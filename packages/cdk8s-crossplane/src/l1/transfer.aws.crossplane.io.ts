// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Server is the Schema for the Servers API
 *
 * @schema Server
 */
export class Server extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Server"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.crossplane.io/v1alpha1',
    kind: 'Server',
  }

  /**
   * Renders a Kubernetes manifest for "Server".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServerProps): any {
    return {
      ...Server.GVK,
      ...toJson_ServerProps(props),
    };
  }

  /**
   * Defines a "Server" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServerProps) {
    super(scope, id, {
      ...Server.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Server.GVK,
      ...toJson_ServerProps(resolved),
    };
  }
}

/**
 * Server is the Schema for the Servers API
 *
 * @schema Server
 */
export interface ServerProps {
  /**
   * @schema Server#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServerSpec defines the desired state of Server
   *
   * @schema Server#spec
   */
  readonly spec: ServerSpec;

}

/**
 * Converts an object of type 'ServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerProps(obj: ServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerSpec defines the desired state of Server
 *
 * @schema ServerSpec
 */
export interface ServerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServerSpecDeletionPolicy;

  /**
   * ServerParameters defines the desired state of Server
   *
   * @schema ServerSpec#forProvider
   */
  readonly forProvider: ServerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServerSpec#managementPolicies
   */
  readonly managementPolicies?: ServerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpec(obj: ServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServerSpecDeletionPolicy
 */
export enum ServerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ServerParameters defines the desired state of Server
 *
 * @schema ServerSpecForProvider
 */
export interface ServerSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. Required when Protocols is set to FTPS.
   * To request a new public certificate, see Request a public certificate (https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the AWS Certificate Manager User Guide.
   * To import an existing certificate into ACM, see Importing certificates into ACM (https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the AWS Certificate Manager User Guide.
   * To request a private certificate to use FTPS through private IP addresses, see Request a private certificate (https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the AWS Certificate Manager User Guide.
   * Certificates with the following cryptographic algorithms and key sizes are supported:
   * * 2048-bit RSA (RSA_2048)
   * * 4096-bit RSA (RSA_4096)
   * * Elliptic Prime Curve 256 bit (EC_prime256v1)
   * * Elliptic Prime Curve 384 bit (EC_secp384r1)
   * * Elliptic Prime Curve 521 bit (EC_secp521r1)
   * The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
   *
   * @schema ServerSpecForProvider#certificate
   */
  readonly certificate?: string;

  /**
   * CertificateRef is a reference to a Certificate.
   *
   * @schema ServerSpecForProvider#certificateRef
   */
  readonly certificateRef?: ServerSpecForProviderCertificateRef;

  /**
   * CertificateSelector selects references to a Certificate.
   *
   * @schema ServerSpecForProvider#certificateSelector
   */
  readonly certificateSelector?: ServerSpecForProviderCertificateSelector;

  /**
   * The domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3.
   * After the server is created, the domain cannot be changed.
   *
   * @schema ServerSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make it accessible only to resources within your VPC, or you can attach Elastic IPs and make it accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
   *
   * @schema ServerSpecForProvider#endpointDetails
   */
  readonly endpointDetails?: ServerSpecForProviderEndpointDetails;

  /**
   * The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.
   * After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC.
   * For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
   * It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
   *
   * @schema ServerSpecForProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * The RSA, ECDSA, or ED25519 private key to use for your SFTP-enabled server. You can add multiple host keys, in case you want to rotate keys, or have a set of active keys that use different algorithms.
   * Use the following command to generate an RSA 2048 bit key with no passphrase:
   * ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key.
   * Use a minimum value of 2048 for the -b option. You can create a stronger key by using 3072 or 4096.
   * Use the following command to generate an ECDSA 256 bit key with no passphrase:
   * ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key.
   * Valid values for the -b option for ECDSA are 256, 384, and 521.
   * Use the following command to generate an ED25519 key with no passphrase:
   * ssh-keygen -t ed25519 -N "" -f my-new-server-key.
   * For all of these commands, you can replace my-new-server-key with a string of your choice.
   * If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive.
   * For more information, see Manage host keys for your SFTP-enabled server (https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Transfer Family User Guide.
   *
   * @schema ServerSpecForProvider#hostKey
   */
  readonly hostKey?: string;

  /**
   * Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE, Amazon Web Services_LAMBDA or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
   *
   * @schema ServerSpecForProvider#identityProviderDetails
   */
  readonly identityProviderDetails?: ServerSpecForProviderIdentityProviderDetails;

  /**
   * The mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer Family service.
   * Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the IdentityProviderDetails parameter.
   * Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the IdentityProviderDetails parameter.
   * Use the AWS_LAMBDA value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the Function parameter for the IdentityProviderDetails data type.
   *
   * @schema ServerSpecForProvider#identityProviderType
   */
  readonly identityProviderType?: string;

  /**
   * Allows the service to write your users' activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
   *
   * @schema ServerSpecForProvider#loggingRole
   */
  readonly loggingRole?: string;

  /**
   * LoggingRoleRef is a reference to a IAM role.
   *
   * @schema ServerSpecForProvider#loggingRoleRef
   */
  readonly loggingRoleRef?: ServerSpecForProviderLoggingRoleRef;

  /**
   * LoggingRoleSelector selects references to a IAM role.
   *
   * @schema ServerSpecForProvider#loggingRoleSelector
   */
  readonly loggingRoleSelector?: ServerSpecForProviderLoggingRoleSelector;

  /**
   * Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.
   * The SFTP protocol does not support post-authentication display banners.
   *
   * @schema ServerSpecForProvider#postAuthenticationLoginBanner
   */
  readonly postAuthenticationLoginBanner?: string;

  /**
   * Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system:
   * This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.
   *
   * @schema ServerSpecForProvider#preAuthenticationLoginBanner
   */
  readonly preAuthenticationLoginBanner?: string;

  /**
   * The protocol settings that are configured for your server.
   * * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
   * * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
   * * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
   * * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
   *
   * @schema ServerSpecForProvider#protocolDetails
   */
  readonly protocolDetails?: ServerSpecForProviderProtocolDetails;

  /**
   * Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
   * * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
   * * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
   * * FTP (File Transfer Protocol): Unencrypted file transfer
   * * AS2 (Applicability Statement 2): used for transporting structured business-to-business data
   * * If you select FTPS, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.
   * * If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be either AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
   * * If Protocol includes FTP, then AddressAllocationIds cannot be associated.
   * * If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set any of the supported identity types: SERVICE_MANAGED, AWS_DIRECTORY_SERVICE, AWS_LAMBDA, or API_GATEWAY.
   * * If Protocol includes AS2, then the EndpointType must be VPC, and domain must be Amazon S3.
   *
   * @schema ServerSpecForProvider#protocols
   */
  readonly protocols?: string[];

  /**
   * Region is which region the Server will be created.
   *
   * @schema ServerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the name of the security policy that is attached to the server.
   *
   * @schema ServerSpecForProvider#securityPolicyName
   */
  readonly securityPolicyName?: string;

  /**
   * Specifies the log groups to which your server logs are sent.
   * To specify a log group, you must provide the ARN for an existing log group. In this case, the format of the log group is as follows:
   * arn:aws:logs:region-name:amazon-account-id:log-group:log-group-name:*
   * For example, arn:aws:logs:us-east-1:111122223333:log-group:mytestgroup:*
   * If you have previously specified a log group for a server, you can clear it, and in effect turn off structured logging, by providing an empty value for this parameter in an update-server call. For example:
   * update-server --server-id s-1234567890abcdef0 --structured-log-destinations
   *
   * @schema ServerSpecForProvider#structuredLogDestinations
   */
  readonly structuredLogDestinations?: string[];

  /**
   * Key-value pairs that can be used to group and search for servers.
   *
   * @schema ServerSpecForProvider#tags
   */
  readonly tags?: ServerSpecForProviderTags[];

  /**
   * Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.
   * In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
   *
   * @schema ServerSpecForProvider#workflowDetails
   */
  readonly workflowDetails?: ServerSpecForProviderWorkflowDetails;

}

/**
 * Converts an object of type 'ServerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProvider(obj: ServerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'certificateRef': toJson_ServerSpecForProviderCertificateRef(obj.certificateRef),
    'certificateSelector': toJson_ServerSpecForProviderCertificateSelector(obj.certificateSelector),
    'domain': obj.domain,
    'endpointDetails': toJson_ServerSpecForProviderEndpointDetails(obj.endpointDetails),
    'endpointType': obj.endpointType,
    'hostKey': obj.hostKey,
    'identityProviderDetails': toJson_ServerSpecForProviderIdentityProviderDetails(obj.identityProviderDetails),
    'identityProviderType': obj.identityProviderType,
    'loggingRole': obj.loggingRole,
    'loggingRoleRef': toJson_ServerSpecForProviderLoggingRoleRef(obj.loggingRoleRef),
    'loggingRoleSelector': toJson_ServerSpecForProviderLoggingRoleSelector(obj.loggingRoleSelector),
    'postAuthenticationLoginBanner': obj.postAuthenticationLoginBanner,
    'preAuthenticationLoginBanner': obj.preAuthenticationLoginBanner,
    'protocolDetails': toJson_ServerSpecForProviderProtocolDetails(obj.protocolDetails),
    'protocols': obj.protocols?.map(y => y),
    'region': obj.region,
    'securityPolicyName': obj.securityPolicyName,
    'structuredLogDestinations': obj.structuredLogDestinations?.map(y => y),
    'tags': obj.tags?.map(y => toJson_ServerSpecForProviderTags(y)),
    'workflowDetails': toJson_ServerSpecForProviderWorkflowDetails(obj.workflowDetails),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServerSpecManagementPolicies
 */
export enum ServerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServerSpecProviderConfigRef
 */
export interface ServerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecProviderConfigRef#policy
   */
  readonly policy?: ServerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecProviderConfigRef(obj: ServerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServerSpecPublishConnectionDetailsTo
 */
export interface ServerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsTo(obj: ServerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServerSpecWriteConnectionSecretToRef
 */
export interface ServerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecWriteConnectionSecretToRef(obj: ServerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateRef is a reference to a Certificate.
 *
 * @schema ServerSpecForProviderCertificateRef
 */
export interface ServerSpecForProviderCertificateRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderCertificateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderCertificateRef#policy
   */
  readonly policy?: ServerSpecForProviderCertificateRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateRef(obj: ServerSpecForProviderCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderCertificateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSelector selects references to a Certificate.
 *
 * @schema ServerSpecForProviderCertificateSelector
 */
export interface ServerSpecForProviderCertificateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderCertificateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderCertificateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderCertificateSelector#policy
   */
  readonly policy?: ServerSpecForProviderCertificateSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateSelector(obj: ServerSpecForProviderCertificateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderCertificateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make it accessible only to resources within your VPC, or you can attach Elastic IPs and make it accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
 *
 * @schema ServerSpecForProviderEndpointDetails
 */
export interface ServerSpecForProviderEndpointDetails {
  /**
   * AddressAllocationIDRefs is a list of references to AddressAllocationID used to set the AddressAllocationIDs.
   *
   * @schema ServerSpecForProviderEndpointDetails#addressAllocationIDRefs
   */
  readonly addressAllocationIdRefs?: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs[];

  /**
   * AddressAllocationIDSelector selects references to AddressAllocationID used to set the AddressAllocationIDs.
   *
   * @schema ServerSpecForProviderEndpointDetails#addressAllocationIDSelector
   */
  readonly addressAllocationIdSelector?: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector;

  /**
   * A list of address allocation IDs that are required to attach an Elastic IP address to your server's endpoint.
   * This property can only be set when EndpointType is set to VPC and it is only valid in the UpdateServer API.
   *
   * @schema ServerSpecForProviderEndpointDetails#addressAllocationIDs
   */
  readonly addressAllocationIDs?: string[];

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ServerSpecForProviderEndpointDetails#securityGroupIDRefs
   */
  readonly securityGroupIdRefs?: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema ServerSpecForProviderEndpointDetails#securityGroupIDSelector
   */
  readonly securityGroupIdSelector?: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector;

  /**
   * A list of security groups IDs that are available to attach to your server's endpoint.
   * This property can only be set when EndpointType is set to VPC.
   * You can edit the SecurityGroupIds property in the UpdateServer (https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html) API only if you are changing the EndpointType from PUBLIC or VPC_ENDPOINT to VPC. To change security groups associated with your server's VPC endpoint after creation, use the Amazon EC2 ModifyVpcEndpoint (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html) API.
   *
   * @schema ServerSpecForProviderEndpointDetails#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema ServerSpecForProviderEndpointDetails#subnetIDRefs
   */
  readonly subnetIdRefs?: ServerSpecForProviderEndpointDetailsSubnetIdRefs[];

  /**
   * SubnetIDSelector selects references to Subnets used to set the SubnetIds.
   *
   * @schema ServerSpecForProviderEndpointDetails#subnetIDSelector
   */
  readonly subnetIdSelector?: ServerSpecForProviderEndpointDetailsSubnetIdSelector;

  /**
   * A list of subnet IDs that are required to host your server endpoint in your VPC.
   * This property can only be set when EndpointType is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#subnetIDs
   */
  readonly subnetIDs?: string[];

  /**
   * The ID of the VPC endpoint.
   * This property can only be set when EndpointType is set to VPC_ENDPOINT.
   * For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcEndpointID
   */
  readonly vpcEndpointId?: string;

  /**
   * VPCEndpointIDRef is a reference to a VPCEndpointID.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcEndpointIDRef
   */
  readonly vpcEndpointIdRef?: ServerSpecForProviderEndpointDetailsVpcEndpointIdRef;

  /**
   * VPCEndpointIDSelector selects references to a VPCEndpointID.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcEndpointIDSelector
   */
  readonly vpcEndpointIdSelector?: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector;

  /**
   * The VPC ID of the VPC in which a server's endpoint will be hosted.
   * This property can only be set when EndpointType is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcID
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef is a reference to a VPCID.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcIDRef
   */
  readonly vpcIdRef?: ServerSpecForProviderEndpointDetailsVpcIdRef;

  /**
   * VPCIDSelector selects references to a VPCID.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcIDSelector
   */
  readonly vpcIdSelector?: ServerSpecForProviderEndpointDetailsVpcIdSelector;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetails(obj: ServerSpecForProviderEndpointDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressAllocationIDRefs': obj.addressAllocationIdRefs?.map(y => toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs(y)),
    'addressAllocationIDSelector': toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector(obj.addressAllocationIdSelector),
    'addressAllocationIDs': obj.addressAllocationIDs?.map(y => y),
    'securityGroupIDRefs': obj.securityGroupIdRefs?.map(y => toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs(y)),
    'securityGroupIDSelector': toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'subnetIDRefs': obj.subnetIdRefs?.map(y => toJson_ServerSpecForProviderEndpointDetailsSubnetIdRefs(y)),
    'subnetIDSelector': toJson_ServerSpecForProviderEndpointDetailsSubnetIdSelector(obj.subnetIdSelector),
    'subnetIDs': obj.subnetIDs?.map(y => y),
    'vpcEndpointID': obj.vpcEndpointId,
    'vpcEndpointIDRef': toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdRef(obj.vpcEndpointIdRef),
    'vpcEndpointIDSelector': toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector(obj.vpcEndpointIdSelector),
    'vpcID': obj.vpcId,
    'vpcIDRef': toJson_ServerSpecForProviderEndpointDetailsVpcIdRef(obj.vpcIdRef),
    'vpcIDSelector': toJson_ServerSpecForProviderEndpointDetailsVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE, Amazon Web Services_LAMBDA or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
 *
 * @schema ServerSpecForProviderIdentityProviderDetails
 */
export interface ServerSpecForProviderIdentityProviderDetails {
  /**
   * @schema ServerSpecForProviderIdentityProviderDetails#directoryID
   */
  readonly directoryId?: string;

  /**
   * @schema ServerSpecForProviderIdentityProviderDetails#function
   */
  readonly function?: string;

  /**
   * @schema ServerSpecForProviderIdentityProviderDetails#invocationRole
   */
  readonly invocationRole?: string;

  /**
   * @schema ServerSpecForProviderIdentityProviderDetails#sftpAuthenticationMethods
   */
  readonly sftpAuthenticationMethods?: string;

  /**
   * @schema ServerSpecForProviderIdentityProviderDetails#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderIdentityProviderDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderIdentityProviderDetails(obj: ServerSpecForProviderIdentityProviderDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryID': obj.directoryId,
    'function': obj.function,
    'invocationRole': obj.invocationRole,
    'sftpAuthenticationMethods': obj.sftpAuthenticationMethods,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingRoleRef is a reference to a IAM role.
 *
 * @schema ServerSpecForProviderLoggingRoleRef
 */
export interface ServerSpecForProviderLoggingRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderLoggingRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderLoggingRoleRef#policy
   */
  readonly policy?: ServerSpecForProviderLoggingRoleRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderLoggingRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderLoggingRoleRef(obj: ServerSpecForProviderLoggingRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderLoggingRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingRoleSelector selects references to a IAM role.
 *
 * @schema ServerSpecForProviderLoggingRoleSelector
 */
export interface ServerSpecForProviderLoggingRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderLoggingRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderLoggingRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderLoggingRoleSelector#policy
   */
  readonly policy?: ServerSpecForProviderLoggingRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderLoggingRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderLoggingRoleSelector(obj: ServerSpecForProviderLoggingRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderLoggingRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The protocol settings that are configured for your server.
 * * To indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
 * * To ignore the error that is generated when the client attempts to use the SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and upload files without needing to make any changes to your SFTP client, set the value to ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a SETSTAT call.
 * * To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode parameter.
 * * As2Transports indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
 *
 * @schema ServerSpecForProviderProtocolDetails
 */
export interface ServerSpecForProviderProtocolDetails {
  /**
   * @schema ServerSpecForProviderProtocolDetails#as2Transports
   */
  readonly as2Transports?: string[];

  /**
   * @schema ServerSpecForProviderProtocolDetails#passiveIP
   */
  readonly passiveIp?: string;

  /**
   * @schema ServerSpecForProviderProtocolDetails#setStatOption
   */
  readonly setStatOption?: string;

  /**
   * @schema ServerSpecForProviderProtocolDetails#tlsSessionResumptionMode
   */
  readonly tlsSessionResumptionMode?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderProtocolDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderProtocolDetails(obj: ServerSpecForProviderProtocolDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as2Transports': obj.as2Transports?.map(y => y),
    'passiveIP': obj.passiveIp,
    'setStatOption': obj.setStatOption,
    'tlsSessionResumptionMode': obj.tlsSessionResumptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderTags
 */
export interface ServerSpecForProviderTags {
  /**
   * @schema ServerSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ServerSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderTags(obj: ServerSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.
 * In addition to a workflow to execute when a file is uploaded completely, WorkflowDetails can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.
 *
 * @schema ServerSpecForProviderWorkflowDetails
 */
export interface ServerSpecForProviderWorkflowDetails {
  /**
   * @schema ServerSpecForProviderWorkflowDetails#onPartialUpload
   */
  readonly onPartialUpload?: ServerSpecForProviderWorkflowDetailsOnPartialUpload[];

  /**
   * @schema ServerSpecForProviderWorkflowDetails#onUpload
   */
  readonly onUpload?: ServerSpecForProviderWorkflowDetailsOnUpload[];

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetails(obj: ServerSpecForProviderWorkflowDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onPartialUpload': obj.onPartialUpload?.map(y => toJson_ServerSpecForProviderWorkflowDetailsOnPartialUpload(y)),
    'onUpload': obj.onUpload?.map(y => toJson_ServerSpecForProviderWorkflowDetailsOnUpload(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecProviderConfigRefPolicy
 */
export interface ServerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecProviderConfigRefPolicy(obj: ServerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRef
 */
export interface ServerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToConfigRef(obj: ServerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServerSpecPublishConnectionDetailsToMetadata
 */
export interface ServerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToMetadata(obj: ServerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderCertificateRefPolicy
 */
export interface ServerSpecForProviderCertificateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderCertificateRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderCertificateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderCertificateRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderCertificateRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateRefPolicy(obj: ServerSpecForProviderCertificateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicy
 */
export interface ServerSpecForProviderCertificateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderCertificateSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderCertificateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderCertificateSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderCertificateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateSelectorPolicy(obj: ServerSpecForProviderCertificateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs
 */
export interface ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs(obj: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddressAllocationIDSelector selects references to AddressAllocationID used to set the AddressAllocationIDs.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector(obj: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs
 */
export interface ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs(obj: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector(obj: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefs
 */
export interface ServerSpecForProviderEndpointDetailsSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefs#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSubnetIdRefs(obj: ServerSpecForProviderEndpointDetailsSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects references to Subnets used to set the SubnetIds.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSubnetIdSelector(obj: ServerSpecForProviderEndpointDetailsSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCEndpointIDRef is a reference to a VPCEndpointID.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRef
 */
export interface ServerSpecForProviderEndpointDetailsVpcEndpointIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRef#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcEndpointIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdRef(obj: ServerSpecForProviderEndpointDetailsVpcEndpointIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCEndpointIDSelector selects references to a VPCEndpointID.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector(obj: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef is a reference to a VPCID.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRef
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRef#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdRef(obj: ServerSpecForProviderEndpointDetailsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects references to a VPCID.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdSelector(obj: ServerSpecForProviderEndpointDetailsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderLoggingRoleRefPolicy
 */
export interface ServerSpecForProviderLoggingRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderLoggingRoleRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderLoggingRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderLoggingRoleRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderLoggingRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderLoggingRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderLoggingRoleRefPolicy(obj: ServerSpecForProviderLoggingRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderLoggingRoleSelectorPolicy
 */
export interface ServerSpecForProviderLoggingRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderLoggingRoleSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderLoggingRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderLoggingRoleSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderLoggingRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderLoggingRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderLoggingRoleSelectorPolicy(obj: ServerSpecForProviderLoggingRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload
 */
export interface ServerSpecForProviderWorkflowDetailsOnPartialUpload {
  /**
   * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload#workflowID
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetailsOnPartialUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetailsOnPartialUpload(obj: ServerSpecForProviderWorkflowDetailsOnPartialUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowID': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderWorkflowDetailsOnUpload
 */
export interface ServerSpecForProviderWorkflowDetailsOnUpload {
  /**
   * @schema ServerSpecForProviderWorkflowDetailsOnUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * @schema ServerSpecForProviderWorkflowDetailsOnUpload#workflowID
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetailsOnUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetailsOnUpload(obj: ServerSpecForProviderWorkflowDetailsOnUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowID': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecProviderConfigRefPolicyResolution
 */
export enum ServerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecProviderConfigRefPolicyResolve
 */
export enum ServerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderCertificateRefPolicyResolution
 */
export enum ServerSpecForProviderCertificateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderCertificateRefPolicyResolve
 */
export enum ServerSpecForProviderCertificateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicyResolution
 */
export enum ServerSpecForProviderCertificateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicyResolve
 */
export enum ServerSpecForProviderCertificateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy
 */
export interface ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy(obj: ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy
 */
export interface ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy(obj: ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy
 */
export interface ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy(obj: ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy(obj: ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdRefPolicy(obj: ServerSpecForProviderEndpointDetailsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderLoggingRoleRefPolicyResolution
 */
export enum ServerSpecForProviderLoggingRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderLoggingRoleRefPolicyResolve
 */
export enum ServerSpecForProviderLoggingRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderLoggingRoleSelectorPolicyResolution
 */
export enum ServerSpecForProviderLoggingRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderLoggingRoleSelectorPolicyResolve
 */
export enum ServerSpecForProviderLoggingRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsAddressAllocationIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsAddressAllocationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcEndpointIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcEndpointIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.crossplane.io/v1alpha1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * UserParameters defines the desired state of User
   *
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserSpec#managementPolicies
   */
  readonly managementPolicies?: UserSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UserParameters defines the desired state of User
 *
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * The landing directory (folder) for a user when they log in to the server using the client.
   * A HomeDirectory example is /bucket_name/home/mydirectory.
   *
   * @schema UserSpecForProvider#homeDirectory
   */
  readonly homeDirectory?: string;

  /**
   * Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Identity and Access Management (IAM) role provides access to paths in Target. This value can be set only when HomeDirectoryType is set to LOGICAL.
   * The following is an Entry and Target pair example.
   * [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]
   * In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the value the user should see for their home directory when they log in.
   * The following is an Entry and Target pair example for chroot.
   * [ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]
   *
   * @schema UserSpecForProvider#homeDirectoryMappings
   */
  readonly homeDirectoryMappings?: UserSpecForProviderHomeDirectoryMappings[];

  /**
   * The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
   *
   * @schema UserSpecForProvider#homeDirectoryType
   */
  readonly homeDirectoryType?: string;

  /**
   * A session policy for your user so that you can use the same Identity and Access Management (IAM) role across multiple users. This policy scopes down a user's access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
   * This policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use session policies.
   * For session policies, Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument.
   * For an example of a session policy, see Example session policy (https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html).
   * For more information, see AssumeRole (https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
   *
   * @schema UserSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
   *
   * @schema UserSpecForProvider#posixProfile
   */
  readonly posixProfile?: UserSpecForProviderPosixProfile;

  /**
   * Region is which region the User will be created.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM role that controls your users' access to your Amazon S3 bucket. The policies attached to this role will determine the level of access you want to provide your users when transferring files into and out of your Amazon S3 bucket or buckets. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
   *
   * @schema UserSpecForProvider#role
   */
  readonly role?: string;

  /**
   * RoleRef is a reference to a IAM role.
   *
   * @schema UserSpecForProvider#roleRef
   */
  readonly roleRef?: UserSpecForProviderRoleRef;

  /**
   * RoleSelector selects references to a IAM role.
   *
   * @schema UserSpecForProvider#roleSelector
   */
  readonly roleSelector?: UserSpecForProviderRoleSelector;

  /**
   * A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
   *
   * @schema UserSpecForProvider#serverID
   */
  readonly serverId?: string;

  /**
   * ServerIDRef is a reference to an server instance.
   *
   * @schema UserSpecForProvider#serverIDRef
   */
  readonly serverIdRef?: UserSpecForProviderServerIdRef;

  /**
   * ServerIDSelector selects references to an server instance.
   *
   * @schema UserSpecForProvider#serverIDSelector
   */
  readonly serverIdSelector?: UserSpecForProviderServerIdSelector;

  /**
   * The public portion of the Secure Shell (SSH) key used to authenticate the user to the server.
   * The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element.
   * Transfer Family accepts RSA, ECDSA, and ED25519 keys.
   * * For RSA keys, the key type is ssh-rsa.
   * * For ED25519 keys, the key type is ssh-ed25519.
   * * For ECDSA keys, the key type is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
   * Deprecated: This property is deprecated in favor of SSHPublicKeys. Changes here will not be reflected in the external resource.
   *
   * @schema UserSpecForProvider#sshPublicKeyBody
   */
  readonly sshPublicKeyBody?: string;

  /**
   * SSHPublicKeys that should be added to the server.
   *
   * @schema UserSpecForProvider#sshPublicKeys
   */
  readonly sshPublicKeys?: UserSpecForProviderSshPublicKeys[];

  /**
   * Key-value pairs that can be used to group and search for users. Tags are metadata attached to users for any purpose.
   *
   * @schema UserSpecForProvider#tags
   */
  readonly tags?: UserSpecForProviderTags[];

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'homeDirectory': obj.homeDirectory,
    'homeDirectoryMappings': obj.homeDirectoryMappings?.map(y => toJson_UserSpecForProviderHomeDirectoryMappings(y)),
    'homeDirectoryType': obj.homeDirectoryType,
    'policy': obj.policy,
    'posixProfile': toJson_UserSpecForProviderPosixProfile(obj.posixProfile),
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_UserSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_UserSpecForProviderRoleSelector(obj.roleSelector),
    'serverID': obj.serverId,
    'serverIDRef': toJson_UserSpecForProviderServerIdRef(obj.serverIdRef),
    'serverIDSelector': toJson_UserSpecForProviderServerIdSelector(obj.serverIdSelector),
    'sshPublicKeyBody': obj.sshPublicKeyBody,
    'sshPublicKeys': obj.sshPublicKeys?.map(y => toJson_UserSpecForProviderSshPublicKeys(y)),
    'tags': obj.tags?.map(y => toJson_UserSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserSpecManagementPolicies
 */
export enum UserSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderHomeDirectoryMappings
 */
export interface UserSpecForProviderHomeDirectoryMappings {
  /**
   * @schema UserSpecForProviderHomeDirectoryMappings#entry
   */
  readonly entry?: string;

  /**
   * @schema UserSpecForProviderHomeDirectoryMappings#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderHomeDirectoryMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderHomeDirectoryMappings(obj: UserSpecForProviderHomeDirectoryMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entry': obj.entry,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
 *
 * @schema UserSpecForProviderPosixProfile
 */
export interface UserSpecForProviderPosixProfile {
  /**
   * @schema UserSpecForProviderPosixProfile#gid
   */
  readonly gid?: number;

  /**
   * @schema UserSpecForProviderPosixProfile#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * @schema UserSpecForProviderPosixProfile#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'UserSpecForProviderPosixProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPosixProfile(obj: UserSpecForProviderPosixProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleRef is a reference to a IAM role.
 *
 * @schema UserSpecForProviderRoleRef
 */
export interface UserSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderRoleRef#policy
   */
  readonly policy?: UserSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleRef(obj: UserSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects references to a IAM role.
 *
 * @schema UserSpecForProviderRoleSelector
 */
export interface UserSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderRoleSelector#policy
   */
  readonly policy?: UserSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleSelector(obj: UserSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerIDRef is a reference to an server instance.
 *
 * @schema UserSpecForProviderServerIdRef
 */
export interface UserSpecForProviderServerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderServerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderServerIdRef#policy
   */
  readonly policy?: UserSpecForProviderServerIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdRef(obj: UserSpecForProviderServerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderServerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerIDSelector selects references to an server instance.
 *
 * @schema UserSpecForProviderServerIdSelector
 */
export interface UserSpecForProviderServerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderServerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderServerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderServerIdSelector#policy
   */
  readonly policy?: UserSpecForProviderServerIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdSelector(obj: UserSpecForProviderServerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderServerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderSshPublicKeys
 */
export interface UserSpecForProviderSshPublicKeys {
  /**
   * Body is the public portion of the Secure Shell (SSH) key used to authenticate the user to the server.
   * The three standard SSH public key format elements are <key type>, <body base64>, and an optional <comment>, with spaces between each element.
   * Transfer Family accepts RSA, ECDSA, and ED25519 keys.
   * * For RSA keys, the key type is ssh-rsa.
   * * For ED25519 keys, the key type is ssh-ed25519.
   * * For ECDSA keys, the key type is either ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521, depending on the size of the key you generated.
   *
   * @schema UserSpecForProviderSshPublicKeys#body
   */
  readonly body: string;

}

/**
 * Converts an object of type 'UserSpecForProviderSshPublicKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderSshPublicKeys(obj: UserSpecForProviderSshPublicKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderTags
 */
export interface UserSpecForProviderTags {
  /**
   * @schema UserSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema UserSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderTags(obj: UserSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderRoleRefPolicy
 */
export interface UserSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleRefPolicy(obj: UserSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderRoleSelectorPolicy
 */
export interface UserSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleSelectorPolicy(obj: UserSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderServerIdRefPolicy
 */
export interface UserSpecForProviderServerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderServerIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderServerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderServerIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderServerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdRefPolicy(obj: UserSpecForProviderServerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicy
 */
export interface UserSpecForProviderServerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderServerIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderServerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderServerIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderServerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdSelectorPolicy(obj: UserSpecForProviderServerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoleRefPolicyResolution
 */
export enum UserSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoleRefPolicyResolve
 */
export enum UserSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoleSelectorPolicyResolution
 */
export enum UserSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoleSelectorPolicyResolve
 */
export enum UserSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderServerIdRefPolicyResolution
 */
export enum UserSpecForProviderServerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderServerIdRefPolicyResolve
 */
export enum UserSpecForProviderServerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicyResolution
 */
export enum UserSpecForProviderServerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicyResolve
 */
export enum UserSpecForProviderServerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

