// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * HTTPNamespace is the Schema for the HTTPNamespaces API
 *
 * @schema HTTPNamespace
 */
export class HttpNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HTTPNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.crossplane.io/v1alpha1',
    kind: 'HTTPNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "HTTPNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HttpNamespaceProps): any {
    return {
      ...HttpNamespace.GVK,
      ...toJson_HttpNamespaceProps(props),
    };
  }

  /**
   * Defines a "HTTPNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HttpNamespaceProps) {
    super(scope, id, {
      ...HttpNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HttpNamespace.GVK,
      ...toJson_HttpNamespaceProps(resolved),
    };
  }
}

/**
 * HTTPNamespace is the Schema for the HTTPNamespaces API
 *
 * @schema HTTPNamespace
 */
export interface HttpNamespaceProps {
  /**
   * @schema HTTPNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HTTPNamespaceSpec defines the desired state of HTTPNamespace
   *
   * @schema HTTPNamespace#spec
   */
  readonly spec: HttpNamespaceSpec;

}

/**
 * Converts an object of type 'HttpNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceProps(obj: HttpNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HttpNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPNamespaceSpec defines the desired state of HTTPNamespace
 *
 * @schema HttpNamespaceSpec
 */
export interface HttpNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HttpNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: HttpNamespaceSpecDeletionPolicy;

  /**
   * HTTPNamespaceParameters defines the desired state of HTTPNamespace
   *
   * @schema HttpNamespaceSpec#forProvider
   */
  readonly forProvider: HttpNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HttpNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: HttpNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HttpNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: HttpNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HttpNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HttpNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HttpNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HttpNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HttpNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpec(obj: HttpNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HttpNamespaceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HttpNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HttpNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HttpNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HttpNamespaceSpecDeletionPolicy
 */
export enum HttpNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * HTTPNamespaceParameters defines the desired state of HTTPNamespace
 *
 * @schema HttpNamespaceSpecForProvider
 */
export interface HttpNamespaceSpecForProvider {
  /**
   * A description for the namespace.
   *
   * @schema HttpNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name that you want to assign to this namespace.
   *
   * @schema HttpNamespaceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the HTTPNamespace will be created.
   *
   * @schema HttpNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
   *
   * @schema HttpNamespaceSpecForProvider#tags
   */
  readonly tags?: HttpNamespaceSpecForProviderTags[];

}

/**
 * Converts an object of type 'HttpNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecForProvider(obj: HttpNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_HttpNamespaceSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HttpNamespaceSpecManagementPolicies
 */
export enum HttpNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HttpNamespaceSpecProviderConfigRef
 */
export interface HttpNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HttpNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HttpNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: HttpNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HttpNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecProviderConfigRef(obj: HttpNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HttpNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsTo
 */
export interface HttpNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HttpNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HttpNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsTo(obj: HttpNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HttpNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HttpNamespaceSpecWriteConnectionSecretToRef
 */
export interface HttpNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HttpNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HttpNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecWriteConnectionSecretToRef(obj: HttpNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpNamespaceSpecForProviderTags
 */
export interface HttpNamespaceSpecForProviderTags {
  /**
   * @schema HttpNamespaceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema HttpNamespaceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecForProviderTags(obj: HttpNamespaceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicy
 */
export interface HttpNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HttpNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HttpNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HttpNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HttpNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HttpNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecProviderConfigRefPolicy(obj: HttpNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRef(obj: HttpNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToMetadata(obj: HttpNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum HttpNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum HttpNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PrivateDNSNamespace is the Schema for the PrivateDNSNamespaces API
 *
 * @schema PrivateDNSNamespace
 */
export class PrivateDnsNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrivateDNSNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.crossplane.io/v1alpha1',
    kind: 'PrivateDNSNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "PrivateDNSNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrivateDnsNamespaceProps): any {
    return {
      ...PrivateDnsNamespace.GVK,
      ...toJson_PrivateDnsNamespaceProps(props),
    };
  }

  /**
   * Defines a "PrivateDNSNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrivateDnsNamespaceProps) {
    super(scope, id, {
      ...PrivateDnsNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrivateDnsNamespace.GVK,
      ...toJson_PrivateDnsNamespaceProps(resolved),
    };
  }
}

/**
 * PrivateDNSNamespace is the Schema for the PrivateDNSNamespaces API
 *
 * @schema PrivateDNSNamespace
 */
export interface PrivateDnsNamespaceProps {
  /**
   * @schema PrivateDNSNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PrivateDNSNamespaceSpec defines the desired state of PrivateDNSNamespace
   *
   * @schema PrivateDNSNamespace#spec
   */
  readonly spec: PrivateDnsNamespaceSpec;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceProps(obj: PrivateDnsNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrivateDnsNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateDNSNamespaceSpec defines the desired state of PrivateDNSNamespace
 *
 * @schema PrivateDnsNamespaceSpec
 */
export interface PrivateDnsNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrivateDnsNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PrivateDnsNamespaceSpecDeletionPolicy;

  /**
   * PrivateDNSNamespaceParameters defines the desired state of PrivateDNSNamespace
   *
   * @schema PrivateDnsNamespaceSpec#forProvider
   */
  readonly forProvider: PrivateDnsNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PrivateDnsNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: PrivateDnsNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PrivateDnsNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PrivateDnsNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PrivateDnsNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PrivateDnsNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PrivateDnsNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PrivateDnsNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpec(obj: PrivateDnsNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PrivateDnsNamespaceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PrivateDnsNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PrivateDnsNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrivateDnsNamespaceSpecDeletionPolicy
 */
export enum PrivateDnsNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * PrivateDNSNamespaceParameters defines the desired state of PrivateDNSNamespace
 *
 * @schema PrivateDnsNamespaceSpecForProvider
 */
export interface PrivateDnsNamespaceSpecForProvider {
  /**
   * A description for the namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Properties for the private DNS namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#properties
   */
  readonly properties?: PrivateDnsNamespaceSpecForProviderProperties;

  /**
   * Region is which region the PrivateDNSNamespace will be created.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#tags
   */
  readonly tags?: PrivateDnsNamespaceSpecForProviderTags[];

  /**
   * VPC of the PrivateDNSNamespace. One if vpc, vpcRef or vpcSelector has to be supplied.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpc
   */
  readonly vpc?: string;

  /**
   * A referencer to retrieve the ID of a VPC
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpcRef
   */
  readonly vpcRef?: PrivateDnsNamespaceSpecForProviderVpcRef;

  /**
   * A selector to select a referencer to retrieve the ID of a VPC.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpcSelector
   */
  readonly vpcSelector?: PrivateDnsNamespaceSpecForProviderVpcSelector;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProvider(obj: PrivateDnsNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'properties': toJson_PrivateDnsNamespaceSpecForProviderProperties(obj.properties),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_PrivateDnsNamespaceSpecForProviderTags(y)),
    'vpc': obj.vpc,
    'vpcRef': toJson_PrivateDnsNamespaceSpecForProviderVpcRef(obj.vpcRef),
    'vpcSelector': toJson_PrivateDnsNamespaceSpecForProviderVpcSelector(obj.vpcSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PrivateDnsNamespaceSpecManagementPolicies
 */
export enum PrivateDnsNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRef
 */
export interface PrivateDnsNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecProviderConfigRef(obj: PrivateDnsNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsTo(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef
 */
export interface PrivateDnsNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecWriteConnectionSecretToRef(obj: PrivateDnsNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Properties for the private DNS namespace.
 *
 * @schema PrivateDnsNamespaceSpecForProviderProperties
 */
export interface PrivateDnsNamespaceSpecForProviderProperties {
  /**
   * DNS properties for the private DNS namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProviderProperties#dnsProperties
   */
  readonly dnsProperties?: PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderProperties(obj: PrivateDnsNamespaceSpecForProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsProperties': toJson_PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties(obj.dnsProperties),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrivateDnsNamespaceSpecForProviderTags
 */
export interface PrivateDnsNamespaceSpecForProviderTags {
  /**
   * @schema PrivateDnsNamespaceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema PrivateDnsNamespaceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderTags(obj: PrivateDnsNamespaceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the ID of a VPC
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRef
 */
export interface PrivateDnsNamespaceSpecForProviderVpcRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecForProviderVpcRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcRef(obj: PrivateDnsNamespaceSpecForProviderVpcRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecForProviderVpcRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the ID of a VPC.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelector
 */
export interface PrivateDnsNamespaceSpecForProviderVpcSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcSelector(obj: PrivateDnsNamespaceSpecForProviderVpcSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy
 */
export interface PrivateDnsNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecProviderConfigRefPolicy(obj: PrivateDnsNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DNS properties for the private DNS namespace.
 *
 * @schema PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties
 */
export interface PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties {
  /**
   * Start of Authority (SOA) properties for a public or private DNS namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties#sOA
   */
  readonly sOa?: PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties(obj: PrivateDnsNamespaceSpecForProviderPropertiesDnsProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sOA': toJson_PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa(obj.sOa),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy
 */
export interface PrivateDnsNamespaceSpecForProviderVpcRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcRefPolicy(obj: PrivateDnsNamespaceSpecForProviderVpcRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy
 */
export interface PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy(obj: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Start of Authority (SOA) properties for a public or private DNS namespace.
 *
 * @schema PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa
 */
export interface PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa {
  /**
   * @schema PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa#tTL
   */
  readonly tTl?: number;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa(obj: PrivateDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tTL': obj.tTl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution
 */
export enum PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve
 */
export enum PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PublicDNSNamespace is the Schema for the PublicDNSNamespaces API
 *
 * @schema PublicDNSNamespace
 */
export class PublicDnsNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PublicDNSNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.crossplane.io/v1alpha1',
    kind: 'PublicDNSNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "PublicDNSNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PublicDnsNamespaceProps): any {
    return {
      ...PublicDnsNamespace.GVK,
      ...toJson_PublicDnsNamespaceProps(props),
    };
  }

  /**
   * Defines a "PublicDNSNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PublicDnsNamespaceProps) {
    super(scope, id, {
      ...PublicDnsNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PublicDnsNamespace.GVK,
      ...toJson_PublicDnsNamespaceProps(resolved),
    };
  }
}

/**
 * PublicDNSNamespace is the Schema for the PublicDNSNamespaces API
 *
 * @schema PublicDNSNamespace
 */
export interface PublicDnsNamespaceProps {
  /**
   * @schema PublicDNSNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PublicDNSNamespaceSpec defines the desired state of PublicDNSNamespace
   *
   * @schema PublicDNSNamespace#spec
   */
  readonly spec: PublicDnsNamespaceSpec;

}

/**
 * Converts an object of type 'PublicDnsNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceProps(obj: PublicDnsNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PublicDnsNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublicDNSNamespaceSpec defines the desired state of PublicDNSNamespace
 *
 * @schema PublicDnsNamespaceSpec
 */
export interface PublicDnsNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PublicDnsNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PublicDnsNamespaceSpecDeletionPolicy;

  /**
   * PublicDNSNamespaceParameters defines the desired state of PublicDNSNamespace
   *
   * @schema PublicDnsNamespaceSpec#forProvider
   */
  readonly forProvider: PublicDnsNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PublicDnsNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: PublicDnsNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PublicDnsNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PublicDnsNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PublicDnsNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PublicDnsNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PublicDnsNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PublicDnsNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpec(obj: PublicDnsNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PublicDnsNamespaceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PublicDnsNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PublicDnsNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PublicDnsNamespaceSpecDeletionPolicy
 */
export enum PublicDnsNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * PublicDNSNamespaceParameters defines the desired state of PublicDNSNamespace
 *
 * @schema PublicDnsNamespaceSpecForProvider
 */
export interface PublicDnsNamespaceSpecForProvider {
  /**
   * A description for the namespace.
   *
   * @schema PublicDnsNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name that you want to assign to this namespace.
   * Do not include sensitive information in the name. The name is publicly available using DNS queries.
   *
   * @schema PublicDnsNamespaceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Properties for the public DNS namespace.
   *
   * @schema PublicDnsNamespaceSpecForProvider#properties
   */
  readonly properties?: PublicDnsNamespaceSpecForProviderProperties;

  /**
   * Region is which region the PublicDNSNamespace will be created.
   *
   * @schema PublicDnsNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
   *
   * @schema PublicDnsNamespaceSpecForProvider#tags
   */
  readonly tags?: PublicDnsNamespaceSpecForProviderTags[];

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProvider(obj: PublicDnsNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'properties': toJson_PublicDnsNamespaceSpecForProviderProperties(obj.properties),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_PublicDnsNamespaceSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PublicDnsNamespaceSpecManagementPolicies
 */
export enum PublicDnsNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRef
 */
export interface PublicDnsNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: PublicDnsNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecProviderConfigRef(obj: PublicDnsNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicDnsNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsTo(obj: PublicDnsNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef
 */
export interface PublicDnsNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecWriteConnectionSecretToRef(obj: PublicDnsNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Properties for the public DNS namespace.
 *
 * @schema PublicDnsNamespaceSpecForProviderProperties
 */
export interface PublicDnsNamespaceSpecForProviderProperties {
  /**
   * DNS properties for the public DNS namespace.
   *
   * @schema PublicDnsNamespaceSpecForProviderProperties#dnsProperties
   */
  readonly dnsProperties?: PublicDnsNamespaceSpecForProviderPropertiesDnsProperties;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProviderProperties(obj: PublicDnsNamespaceSpecForProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsProperties': toJson_PublicDnsNamespaceSpecForProviderPropertiesDnsProperties(obj.dnsProperties),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PublicDnsNamespaceSpecForProviderTags
 */
export interface PublicDnsNamespaceSpecForProviderTags {
  /**
   * @schema PublicDnsNamespaceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema PublicDnsNamespaceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProviderTags(obj: PublicDnsNamespaceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy
 */
export interface PublicDnsNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PublicDnsNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PublicDnsNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecProviderConfigRefPolicy(obj: PublicDnsNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DNS properties for the public DNS namespace.
 *
 * @schema PublicDnsNamespaceSpecForProviderPropertiesDnsProperties
 */
export interface PublicDnsNamespaceSpecForProviderPropertiesDnsProperties {
  /**
   * Start of Authority (SOA) properties for a public or private DNS namespace.
   *
   * @schema PublicDnsNamespaceSpecForProviderPropertiesDnsProperties#sOA
   */
  readonly sOa?: PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProviderPropertiesDnsProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProviderPropertiesDnsProperties(obj: PublicDnsNamespaceSpecForProviderPropertiesDnsProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sOA': toJson_PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa(obj.sOa),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum PublicDnsNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum PublicDnsNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Start of Authority (SOA) properties for a public or private DNS namespace.
 *
 * @schema PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa
 */
export interface PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa {
  /**
   * @schema PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa#tTL
   */
  readonly tTl?: number;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa(obj: PublicDnsNamespaceSpecForProviderPropertiesDnsPropertiesSOa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tTL': obj.tTl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.crossplane.io/v1alpha1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * ServiceParameters defines the desired state of Service
   *
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ServiceParameters defines the desired state of Service
 *
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * A unique string that identifies the request and that allows failed CreateService requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
   *
   * @schema ServiceSpecForProvider#creatorRequestID
   */
  readonly creatorRequestId?: string;

  /**
   * A description for the service.
   *
   * @schema ServiceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you register an instance.
   *
   * @schema ServiceSpecForProvider#dnsConfig
   */
  readonly dnsConfig?: ServiceSpecForProviderDnsConfig;

  /**
   * Public DNS and HTTP namespaces only. A complex type that contains settings for an optional Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the Route 53 DNS records that you specify in DnsConfig.
   * If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
   * For information about the charges for health checks, see Cloud Map Pricing (http://aws.amazon.com/cloud-map/pricing/).
   *
   * @schema ServiceSpecForProvider#healthCheckConfig
   */
  readonly healthCheckConfig?: ServiceSpecForProviderHealthCheckConfig;

  /**
   * A complex type that contains information about an optional custom health check.
   * If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
   * You can't add, update, or delete a HealthCheckCustomConfig configuration from an existing service.
   *
   * @schema ServiceSpecForProvider#healthCheckCustomConfig
   */
  readonly healthCheckCustomConfig?: ServiceSpecForProviderHealthCheckCustomConfig;

  /**
   * The name that you want to assign to the service.
   * Do not include sensitive information in the name if the namespace is discoverable by public DNS queries.
   * If you want Cloud Map to create an SRV record when you register an instance and you're using a system that requires a specific SRV format, such as HAProxy (http://www.haproxy.org/), specify the following for Name:
   * * Start the name with an underscore (_), such as _exampleservice.
   * * End the name with ._protocol, such as ._tcp.
   * When you register an instance, Cloud Map creates an SRV record and assigns a name to the record by concatenating the service name and the namespace name (for example,
   * _exampleservice._tcp.example.com).
   * For services that are accessible by DNS queries, you can't create multiple services with names that differ only by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished. However, if you use a namespace that's only accessible by API calls, then you can create services that with names that differ only by case.
   *
   * @schema ServiceSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it can be specified either here or in the DnsConfig object.
   *
   * @schema ServiceSpecForProvider#namespaceID
   */
  readonly namespaceId?: string;

  /**
   * Region is which region the Service will be created.
   *
   * @schema ServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema ServiceSpecForProvider#serviceName
   */
  readonly serviceName?: string;

  /**
   * ServiceNameRef is a reference to a service used to set the ServiceName.
   *
   * @schema ServiceSpecForProvider#serviceNameRef
   */
  readonly serviceNameRef?: ServiceSpecForProviderServiceNameRef;

  /**
   * ServiceNameSelector selects references to service used to set the ServiceName.
   *
   * @schema ServiceSpecForProvider#serviceNameSelector
   */
  readonly serviceNameSelector?: ServiceSpecForProviderServiceNameSelector;

  /**
   * The tags to add to the service. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
   *
   * @schema ServiceSpecForProvider#tags
   */
  readonly tags?: ServiceSpecForProviderTags[];

  /**
   * If present, specifies that the service instances are only discoverable using the DiscoverInstances API operation. No DNS records is registered for the service instances. The only valid value is HTTP.
   *
   * @schema ServiceSpecForProvider#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creatorRequestID': obj.creatorRequestId,
    'description': obj.description,
    'dnsConfig': toJson_ServiceSpecForProviderDnsConfig(obj.dnsConfig),
    'healthCheckConfig': toJson_ServiceSpecForProviderHealthCheckConfig(obj.healthCheckConfig),
    'healthCheckCustomConfig': toJson_ServiceSpecForProviderHealthCheckCustomConfig(obj.healthCheckCustomConfig),
    'name': obj.name,
    'namespaceID': obj.namespaceId,
    'region': obj.region,
    'serviceName': obj.serviceName,
    'serviceNameRef': toJson_ServiceSpecForProviderServiceNameRef(obj.serviceNameRef),
    'serviceNameSelector': toJson_ServiceSpecForProviderServiceNameSelector(obj.serviceNameSelector),
    'tags': obj.tags?.map(y => toJson_ServiceSpecForProviderTags(y)),
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceSpecManagementPolicies
 */
export enum ServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you register an instance.
 *
 * @schema ServiceSpecForProviderDnsConfig
 */
export interface ServiceSpecForProviderDnsConfig {
  /**
   * @schema ServiceSpecForProviderDnsConfig#dnsRecords
   */
  readonly dnsRecords?: ServiceSpecForProviderDnsConfigDnsRecords[];

  /**
   * @schema ServiceSpecForProviderDnsConfig#namespaceID
   */
  readonly namespaceId?: string;

  /**
   * @schema ServiceSpecForProviderDnsConfig#routingPolicy
   */
  readonly routingPolicy?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfig(obj: ServiceSpecForProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRecords': obj.dnsRecords?.map(y => toJson_ServiceSpecForProviderDnsConfigDnsRecords(y)),
    'namespaceID': obj.namespaceId,
    'routingPolicy': obj.routingPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Public DNS and HTTP namespaces only. A complex type that contains settings for an optional Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the Route 53 DNS records that you specify in DnsConfig.
 * If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
 * For information about the charges for health checks, see Cloud Map Pricing (http://aws.amazon.com/cloud-map/pricing/).
 *
 * @schema ServiceSpecForProviderHealthCheckConfig
 */
export interface ServiceSpecForProviderHealthCheckConfig {
  /**
   * @schema ServiceSpecForProviderHealthCheckConfig#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * @schema ServiceSpecForProviderHealthCheckConfig#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * @schema ServiceSpecForProviderHealthCheckConfig#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderHealthCheckConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderHealthCheckConfig(obj: ServiceSpecForProviderHealthCheckConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'resourcePath': obj.resourcePath,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A complex type that contains information about an optional custom health check.
 * If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
 * You can't add, update, or delete a HealthCheckCustomConfig configuration from an existing service.
 *
 * @schema ServiceSpecForProviderHealthCheckCustomConfig
 */
export interface ServiceSpecForProviderHealthCheckCustomConfig {
  /**
   * @schema ServiceSpecForProviderHealthCheckCustomConfig#failureThreshold
   */
  readonly failureThreshold?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderHealthCheckCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderHealthCheckCustomConfig(obj: ServiceSpecForProviderHealthCheckCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceNameRef is a reference to a service used to set the ServiceName.
 *
 * @schema ServiceSpecForProviderServiceNameRef
 */
export interface ServiceSpecForProviderServiceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderServiceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderServiceNameRef#policy
   */
  readonly policy?: ServiceSpecForProviderServiceNameRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceNameRef(obj: ServiceSpecForProviderServiceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderServiceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceNameSelector selects references to service used to set the ServiceName.
 *
 * @schema ServiceSpecForProviderServiceNameSelector
 */
export interface ServiceSpecForProviderServiceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderServiceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderServiceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderServiceNameSelector#policy
   */
  readonly policy?: ServiceSpecForProviderServiceNameSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceNameSelector(obj: ServiceSpecForProviderServiceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderServiceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTags
 */
export interface ServiceSpecForProviderTags {
  /**
   * @schema ServiceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ServiceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTags(obj: ServiceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderDnsConfigDnsRecords
 */
export interface ServiceSpecForProviderDnsConfigDnsRecords {
  /**
   * @schema ServiceSpecForProviderDnsConfigDnsRecords#tTL
   */
  readonly tTl?: number;

  /**
   * @schema ServiceSpecForProviderDnsConfigDnsRecords#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigDnsRecords' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigDnsRecords(obj: ServiceSpecForProviderDnsConfigDnsRecords | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tTL': obj.tTl,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderServiceNameRefPolicy
 */
export interface ServiceSpecForProviderServiceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderServiceNameRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderServiceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderServiceNameRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderServiceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceNameRefPolicy(obj: ServiceSpecForProviderServiceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderServiceNameSelectorPolicy
 */
export interface ServiceSpecForProviderServiceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderServiceNameSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderServiceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderServiceNameSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderServiceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceNameSelectorPolicy(obj: ServiceSpecForProviderServiceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderServiceNameRefPolicyResolution
 */
export enum ServiceSpecForProviderServiceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderServiceNameRefPolicyResolve
 */
export enum ServiceSpecForProviderServiceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderServiceNameSelectorPolicyResolution
 */
export enum ServiceSpecForProviderServiceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderServiceNameSelectorPolicyResolve
 */
export enum ServiceSpecForProviderServiceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

