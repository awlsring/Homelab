// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * An Bucket is a managed resource that represents an AWS S3 Bucket.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.crossplane.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * An Bucket is a managed resource that represents an AWS S3 Bucket.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec represents the desired state of the Bucket.
   *
   * @schema Bucket#spec
   */
  readonly spec: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec represents the desired state of the Bucket.
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketSpecDeletionPolicy;

  /**
   * BucketParameters are parameters for configuring the calls made to AWS Bucket API.
   *
   * @schema BucketSpec#forProvider
   */
  readonly forProvider: BucketSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketSpec#managementPolicies
   */
  readonly managementPolicies?: BucketSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketSpecDeletionPolicy
 */
export enum BucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * BucketParameters are parameters for configuring the calls made to AWS Bucket API.
 *
 * @schema BucketSpecForProvider
 */
export interface BucketSpecForProvider {
  /**
   * AccelerateConfiguration configures the transfer acceleration state for an Amazon S3 bucket. For more information, see Amazon S3 Transfer Acceleration (https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProvider#accelerateConfiguration
   */
  readonly accelerateConfiguration?: BucketSpecForProviderAccelerateConfiguration;

  /**
   * The canned ACL to apply to the bucket.
   *
   * @schema BucketSpecForProvider#acl
   */
  readonly acl?: BucketSpecForProviderAcl;

  /**
   * Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProvider#corsConfiguration
   */
  readonly corsConfiguration?: BucketSpecForProviderCorsConfiguration;

  /**
   * Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
   *
   * @schema BucketSpecForProvider#grantFullControl
   */
  readonly grantFullControl?: string;

  /**
   * Allows grantee to list the objects in the bucket.
   *
   * @schema BucketSpecForProvider#grantRead
   */
  readonly grantRead?: string;

  /**
   * Allows grantee to read the bucket ACL.
   *
   * @schema BucketSpecForProvider#grantReadAcp
   */
  readonly grantReadAcp?: string;

  /**
   * Allows grantee to create, overwrite, and delete any object in the bucket.
   *
   * @schema BucketSpecForProvider#grantWrite
   */
  readonly grantWrite?: string;

  /**
   * Allows grantee to write the ACL for the applicable bucket.
   *
   * @schema BucketSpecForProvider#grantWriteAcp
   */
  readonly grantWriteAcp?: string;

  /**
   * Creates a new lifecycle configuration for the bucket or replaces an existing lifecycle configuration. For information about lifecycle configuration, see Managing Access Permissions to Your Amazon S3 Resources (https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html).
   *
   * @schema BucketSpecForProvider#lifecycleConfiguration
   */
  readonly lifecycleConfiguration?: BucketSpecForProviderLifecycleConfiguration;

  /**
   * LocationConstraint specifies the Region where the bucket will be created. It is a required field. Due to AWS API limitations lacking on a proper response, when this field is set to a wrong value, or to non-existent region on bucket creation, it's impossible forwarding a meaningful status message to the user about the problem, producing connection errors instead.
   *
   * @schema BucketSpecForProvider#locationConstraint
   */
  readonly locationConstraint: string;

  /**
   * Specifies logging parameters for an Amazon S3 bucket. Set the logging parameters for a bucket and to specify permissions for who can view and modify the logging parameters. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketLogging for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketLogging
   *
   * @schema BucketSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: BucketSpecForProviderLoggingConfiguration;

  /**
   * Enables notifications of specified events for a bucket. For more information about event notifications, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html).
   *
   * @schema BucketSpecForProvider#notificationConfiguration
   */
  readonly notificationConfiguration?: BucketSpecForProviderNotificationConfiguration;

  /**
   * Specifies whether you want S3 Object Lock to be enabled for the new bucket.
   *
   * @schema BucketSpecForProvider#objectLockEnabledForBucket
   */
  readonly objectLockEnabledForBucket?: boolean;

  /**
   * The container element for object ownership for a bucket's ownership controls. BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.
   *
   * @schema BucketSpecForProvider#objectOwnership
   */
  readonly objectOwnership?: BucketSpecForProviderObjectOwnership;

  /**
   * Specifies payer parameters for an Amazon S3 bucket. For more information, see Request Pays buckets (https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProvider#paymentConfiguration
   */
  readonly paymentConfiguration?: BucketSpecForProviderPaymentConfiguration;

  /**
   * Policy is a well defined type which can be parsed into an JSON S3 Bucket Policy.
   * By default, to ensure compatibility with previous APIs, a bucket policy is never deleted from a bucket if this field is set to null. To change this behaviour, see `policyUpdatePolicy`.
   *
   * @schema BucketSpecForProvider#policy
   */
  readonly policy?: BucketSpecForProviderPolicy;

  /**
   * PolicyUpdatePolicy specifies the update behaviour of `policy`.
   *
   * @schema BucketSpecForProvider#policyUpdatePolicy
   */
  readonly policyUpdatePolicy?: BucketSpecForProviderPolicyUpdatePolicy;

  /**
   * PublicAccessBlockConfiguration that you want to apply to this Amazon S3 bucket.
   *
   * @schema BucketSpecForProvider#publicAccessBlockConfiguration
   */
  readonly publicAccessBlockConfiguration?: BucketSpecForProviderPublicAccessBlockConfiguration;

  /**
   * Creates a replication configuration or replaces an existing one. For more information, see Replication (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the Amazon S3 Developer Guide.
   *
   * @schema BucketSpecForProvider#replicationConfiguration
   */
  readonly replicationConfiguration?: BucketSpecForProviderReplicationConfiguration;

  /**
   * Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about the Amazon S3 default encryption feature, see Amazon S3 Default Bucket Encryption (https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProvider#serverSideEncryptionConfiguration
   */
  readonly serverSideEncryptionConfiguration?: BucketSpecForProviderServerSideEncryptionConfiguration;

  /**
   * Sets the tags for a bucket. Use tags to organize your AWS bill to reflect your own cost structure. For more information, see Billing and usage reporting for S3 buckets. (https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketBilling.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProvider#tagging
   */
  readonly tagging?: BucketSpecForProviderTagging;

  /**
   * VersioningConfiguration describes the versioning state of an Amazon S3 bucket. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketVersioning for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketVersioning
   *
   * @schema BucketSpecForProvider#versioningConfiguration
   */
  readonly versioningConfiguration?: BucketSpecForProviderVersioningConfiguration;

  /**
   * Specifies website configuration parameters for an Amazon S3 bucket. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketWebsite for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketWebsite
   *
   * @schema BucketSpecForProvider#websiteConfiguration
   */
  readonly websiteConfiguration?: BucketSpecForProviderWebsiteConfiguration;

}

/**
 * Converts an object of type 'BucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProvider(obj: BucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accelerateConfiguration': toJson_BucketSpecForProviderAccelerateConfiguration(obj.accelerateConfiguration),
    'acl': obj.acl,
    'corsConfiguration': toJson_BucketSpecForProviderCorsConfiguration(obj.corsConfiguration),
    'grantFullControl': obj.grantFullControl,
    'grantRead': obj.grantRead,
    'grantReadAcp': obj.grantReadAcp,
    'grantWrite': obj.grantWrite,
    'grantWriteAcp': obj.grantWriteAcp,
    'lifecycleConfiguration': toJson_BucketSpecForProviderLifecycleConfiguration(obj.lifecycleConfiguration),
    'locationConstraint': obj.locationConstraint,
    'loggingConfiguration': toJson_BucketSpecForProviderLoggingConfiguration(obj.loggingConfiguration),
    'notificationConfiguration': toJson_BucketSpecForProviderNotificationConfiguration(obj.notificationConfiguration),
    'objectLockEnabledForBucket': obj.objectLockEnabledForBucket,
    'objectOwnership': obj.objectOwnership,
    'paymentConfiguration': toJson_BucketSpecForProviderPaymentConfiguration(obj.paymentConfiguration),
    'policy': toJson_BucketSpecForProviderPolicy(obj.policy),
    'policyUpdatePolicy': toJson_BucketSpecForProviderPolicyUpdatePolicy(obj.policyUpdatePolicy),
    'publicAccessBlockConfiguration': toJson_BucketSpecForProviderPublicAccessBlockConfiguration(obj.publicAccessBlockConfiguration),
    'replicationConfiguration': toJson_BucketSpecForProviderReplicationConfiguration(obj.replicationConfiguration),
    'serverSideEncryptionConfiguration': toJson_BucketSpecForProviderServerSideEncryptionConfiguration(obj.serverSideEncryptionConfiguration),
    'tagging': toJson_BucketSpecForProviderTagging(obj.tagging),
    'versioningConfiguration': toJson_BucketSpecForProviderVersioningConfiguration(obj.versioningConfiguration),
    'websiteConfiguration': toJson_BucketSpecForProviderWebsiteConfiguration(obj.websiteConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketSpecManagementPolicies
 */
export enum BucketSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketSpecProviderConfigRef
 */
export interface BucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderConfigRef#policy
   */
  readonly policy?: BucketSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRef(obj: BucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketSpecPublishConnectionDetailsTo
 */
export interface BucketSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsTo(obj: BucketSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketSpecWriteConnectionSecretToRef
 */
export interface BucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWriteConnectionSecretToRef(obj: BucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccelerateConfiguration configures the transfer acceleration state for an Amazon S3 bucket. For more information, see Amazon S3 Transfer Acceleration (https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderAccelerateConfiguration
 */
export interface BucketSpecForProviderAccelerateConfiguration {
  /**
   * Status specifies the transfer acceleration status of the bucket.
   *
   * @schema BucketSpecForProviderAccelerateConfiguration#status
   */
  readonly status: BucketSpecForProviderAccelerateConfigurationStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderAccelerateConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderAccelerateConfiguration(obj: BucketSpecForProviderAccelerateConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The canned ACL to apply to the bucket.
 *
 * @schema BucketSpecForProviderAcl
 */
export enum BucketSpecForProviderAcl {
  /** private */
  PRIVATE = "private",
  /** public-read */
  PUBLIC_HYPHEN_READ = "public-read",
  /** public-read-write */
  PUBLIC_HYPHEN_READ_HYPHEN_WRITE = "public-read-write",
  /** authenticated-read */
  AUTHENTICATED_HYPHEN_READ = "authenticated-read",
  /** aws-exec-read */
  AWS_HYPHEN_EXEC_HYPHEN_READ = "aws-exec-read",
  /** bucket-owner-read */
  BUCKET_HYPHEN_OWNER_HYPHEN_READ = "bucket-owner-read",
  /** bucket-owner-full-control */
  BUCKET_HYPHEN_OWNER_HYPHEN_FULL_HYPHEN_CONTROL = "bucket-owner-full-control",
  /** log-delivery-write */
  LOG_HYPHEN_DELIVERY_HYPHEN_WRITE = "log-delivery-write",
}

/**
 * Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderCorsConfiguration
 */
export interface BucketSpecForProviderCorsConfiguration {
  /**
   * A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
   *
   * @schema BucketSpecForProviderCorsConfiguration#corsRules
   */
  readonly corsRules: BucketSpecForProviderCorsConfigurationCorsRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderCorsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCorsConfiguration(obj: BucketSpecForProviderCorsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsRules': obj.corsRules?.map(y => toJson_BucketSpecForProviderCorsConfigurationCorsRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Creates a new lifecycle configuration for the bucket or replaces an existing lifecycle configuration. For information about lifecycle configuration, see Managing Access Permissions to Your Amazon S3 Resources (https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html).
 *
 * @schema BucketSpecForProviderLifecycleConfiguration
 */
export interface BucketSpecForProviderLifecycleConfiguration {
  /**
   * A lifecycle rule for individual objects in an Amazon S3 bucket.
   * Rules is a required field
   *
   * @schema BucketSpecForProviderLifecycleConfiguration#rules
   */
  readonly rules: BucketSpecForProviderLifecycleConfigurationRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfiguration(obj: BucketSpecForProviderLifecycleConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BucketSpecForProviderLifecycleConfigurationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies logging parameters for an Amazon S3 bucket. Set the logging parameters for a bucket and to specify permissions for who can view and modify the logging parameters. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketLogging for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketLogging
 *
 * @schema BucketSpecForProviderLoggingConfiguration
 */
export interface BucketSpecForProviderLoggingConfiguration {
  /**
   * TargetBucket where logs will be stored, it can be the same bucket. At least one of targetBucket, targetBucketRef or targetBucketSelector is required.
   *
   * @schema BucketSpecForProviderLoggingConfiguration#targetBucket
   */
  readonly targetBucket?: string;

  /**
   * TargetBucketRef references an S3Bucket to retrieve its name
   *
   * @schema BucketSpecForProviderLoggingConfiguration#targetBucketRef
   */
  readonly targetBucketRef?: BucketSpecForProviderLoggingConfigurationTargetBucketRef;

  /**
   * TargetBucketSelector selects a reference to an S3Bucket to retrieve its name
   *
   * @schema BucketSpecForProviderLoggingConfiguration#targetBucketSelector
   */
  readonly targetBucketSelector?: BucketSpecForProviderLoggingConfigurationTargetBucketSelector;

  /**
   * Container for granting information.
   *
   * @schema BucketSpecForProviderLoggingConfiguration#targetGrants
   */
  readonly targetGrants?: BucketSpecForProviderLoggingConfigurationTargetGrants[];

  /**
   * A prefix for all log object keys.
   *
   * @schema BucketSpecForProviderLoggingConfiguration#targetPrefix
   */
  readonly targetPrefix: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfiguration(obj: BucketSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetBucket': obj.targetBucket,
    'targetBucketRef': toJson_BucketSpecForProviderLoggingConfigurationTargetBucketRef(obj.targetBucketRef),
    'targetBucketSelector': toJson_BucketSpecForProviderLoggingConfigurationTargetBucketSelector(obj.targetBucketSelector),
    'targetGrants': obj.targetGrants?.map(y => toJson_BucketSpecForProviderLoggingConfigurationTargetGrants(y)),
    'targetPrefix': obj.targetPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables notifications of specified events for a bucket. For more information about event notifications, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html).
 *
 * @schema BucketSpecForProviderNotificationConfiguration
 */
export interface BucketSpecForProviderNotificationConfiguration {
  /**
   * Describes the AWS Lambda functions to invoke and the events for which to invoke them.
   *
   * @schema BucketSpecForProviderNotificationConfiguration#lambdaFunctionConfigurations
   */
  readonly lambdaFunctionConfigurations?: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations[];

  /**
   * The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
   *
   * @schema BucketSpecForProviderNotificationConfiguration#queueConfigurations
   */
  readonly queueConfigurations?: BucketSpecForProviderNotificationConfigurationQueueConfigurations[];

  /**
   * The topic to which notifications are sent and the events for which notifications are generated.
   *
   * @schema BucketSpecForProviderNotificationConfiguration#topicConfigurations
   */
  readonly topicConfigurations?: BucketSpecForProviderNotificationConfigurationTopicConfigurations[];

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfiguration(obj: BucketSpecForProviderNotificationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaFunctionConfigurations': obj.lambdaFunctionConfigurations?.map(y => toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations(y)),
    'queueConfigurations': obj.queueConfigurations?.map(y => toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurations(y)),
    'topicConfigurations': obj.topicConfigurations?.map(y => toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container element for object ownership for a bucket's ownership controls. BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL. ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL. BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer affect permissions. The bucket owner automatically owns and has full control over every object in the bucket. The bucket only accepts PUT requests that don't specify an ACL or bucket owner full control ACLs, such as the bucket-owner-full-control canned ACL or an equivalent form of this ACL expressed in the XML format.
 *
 * @schema BucketSpecForProviderObjectOwnership
 */
export enum BucketSpecForProviderObjectOwnership {
  /** BucketOwnerPreferred */
  BUCKET_OWNER_PREFERRED = "BucketOwnerPreferred",
  /** ObjectWriter */
  OBJECT_WRITER = "ObjectWriter",
  /** BucketOwnerEnforced */
  BUCKET_OWNER_ENFORCED = "BucketOwnerEnforced",
}

/**
 * Specifies payer parameters for an Amazon S3 bucket. For more information, see Request Pays buckets (https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderPaymentConfiguration
 */
export interface BucketSpecForProviderPaymentConfiguration {
  /**
   * Payer is a required field, detailing who pays Valid values are "Requester" and "BucketOwner"
   *
   * @schema BucketSpecForProviderPaymentConfiguration#payer
   */
  readonly payer: BucketSpecForProviderPaymentConfigurationPayer;

}

/**
 * Converts an object of type 'BucketSpecForProviderPaymentConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPaymentConfiguration(obj: BucketSpecForProviderPaymentConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'payer': obj.payer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy is a well defined type which can be parsed into an JSON S3 Bucket Policy.
 * By default, to ensure compatibility with previous APIs, a bucket policy is never deleted from a bucket if this field is set to null. To change this behaviour, see `policyUpdatePolicy`.
 *
 * @schema BucketSpecForProviderPolicy
 */
export interface BucketSpecForProviderPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema BucketSpecForProviderPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema BucketSpecForProviderPolicy#statements
   */
  readonly statements?: BucketSpecForProviderPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema BucketSpecForProviderPolicy#version
   */
  readonly version: BucketSpecForProviderPolicyVersion;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicy(obj: BucketSpecForProviderPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_BucketSpecForProviderPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyUpdatePolicy specifies the update behaviour of `policy`.
 *
 * @schema BucketSpecForProviderPolicyUpdatePolicy
 */
export interface BucketSpecForProviderPolicyUpdatePolicy {
  /**
   * DeletionPolicy specifies how and if the bucket policy should be deleted from the bucket.
   * * `Never`: The bucket policy is never deleted, but only overwritten. If a change is detected.
   * * `IfNull`: The bucket policy is deleted if the `policy` field is set to null.
   * The default is `Never`.
   *
   * @schema BucketSpecForProviderPolicyUpdatePolicy#deletionPolicy
   */
  readonly deletionPolicy?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyUpdatePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyUpdatePolicy(obj: BucketSpecForProviderPolicyUpdatePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublicAccessBlockConfiguration that you want to apply to this Amazon S3 bucket.
 *
 * @schema BucketSpecForProviderPublicAccessBlockConfiguration
 */
export interface BucketSpecForProviderPublicAccessBlockConfiguration {
  /**
   * Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
   * * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
   * * PUT Object calls fail if the request includes a public ACL.
   * * PUT Bucket calls fail if the request includes a public ACL.
   * Enabling this setting doesn't affect existing policies or ACLs.
   *
   * @schema BucketSpecForProviderPublicAccessBlockConfiguration#blockPublicAcls
   */
  readonly blockPublicAcls?: boolean;

  /**
   * Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
   * Enabling this setting doesn't affect existing bucket policies.
   *
   * @schema BucketSpecForProviderPublicAccessBlockConfiguration#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
   * Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
   *
   * @schema BucketSpecForProviderPublicAccessBlockConfiguration#ignorePublicAcls
   */
  readonly ignorePublicAcls?: boolean;

  /**
   * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
   * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
   *
   * @schema BucketSpecForProviderPublicAccessBlockConfiguration#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderPublicAccessBlockConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPublicAccessBlockConfiguration(obj: BucketSpecForProviderPublicAccessBlockConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicAcls': obj.blockPublicAcls,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicAcls': obj.ignorePublicAcls,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Creates a replication configuration or replaces an existing one. For more information, see Replication (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the Amazon S3 Developer Guide.
 *
 * @schema BucketSpecForProviderReplicationConfiguration
 */
export interface BucketSpecForProviderReplicationConfiguration {
  /**
   * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects. For more information, see How to Set Up Replication (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html) in the Amazon Simple Storage Service Developer Guide.
   * At least one of role, roleRef or roleSelector fields is required.
   *
   * @schema BucketSpecForProviderReplicationConfiguration#role
   */
  readonly role?: string;

  /**
   * RoleRef references an IAMRole to retrieve its Name
   *
   * @schema BucketSpecForProviderReplicationConfiguration#roleRef
   */
  readonly roleRef?: BucketSpecForProviderReplicationConfigurationRoleRef;

  /**
   * RoleSelector selects a reference to an IAMRole to retrieve its Name
   *
   * @schema BucketSpecForProviderReplicationConfiguration#roleSelector
   */
  readonly roleSelector?: BucketSpecForProviderReplicationConfigurationRoleSelector;

  /**
   * A container for one or more replication rules. A replication configuration must have at least one rule and can contain a maximum of 1,000 rules.
   * Rules is a required field
   *
   * @schema BucketSpecForProviderReplicationConfiguration#rules
   */
  readonly rules: BucketSpecForProviderReplicationConfigurationRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfiguration(obj: BucketSpecForProviderReplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'role': obj.role,
    'roleRef': toJson_BucketSpecForProviderReplicationConfigurationRoleRef(obj.roleRef),
    'roleSelector': toJson_BucketSpecForProviderReplicationConfigurationRoleSelector(obj.roleSelector),
    'rules': obj.rules?.map(y => toJson_BucketSpecForProviderReplicationConfigurationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about the Amazon S3 default encryption feature, see Amazon S3 Default Bucket Encryption (https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfiguration
 */
export interface BucketSpecForProviderServerSideEncryptionConfiguration {
  /**
   * Container for information about a particular server-side encryption configuration rule.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfiguration#rules
   */
  readonly rules: BucketSpecForProviderServerSideEncryptionConfigurationRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfiguration(obj: BucketSpecForProviderServerSideEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BucketSpecForProviderServerSideEncryptionConfigurationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sets the tags for a bucket. Use tags to organize your AWS bill to reflect your own cost structure. For more information, see Billing and usage reporting for S3 buckets. (https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketBilling.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderTagging
 */
export interface BucketSpecForProviderTagging {
  /**
   * A collection for a set of tags TagSet is a required field
   *
   * @schema BucketSpecForProviderTagging#tagSet
   */
  readonly tagSet: BucketSpecForProviderTaggingTagSet[];

}

/**
 * Converts an object of type 'BucketSpecForProviderTagging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderTagging(obj: BucketSpecForProviderTagging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tagSet': obj.tagSet?.map(y => toJson_BucketSpecForProviderTaggingTagSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VersioningConfiguration describes the versioning state of an Amazon S3 bucket. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketVersioning for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketVersioning
 *
 * @schema BucketSpecForProviderVersioningConfiguration
 */
export interface BucketSpecForProviderVersioningConfiguration {
  /**
   * MFADelete specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
   *
   * @schema BucketSpecForProviderVersioningConfiguration#mfaDelete
   */
  readonly mfaDelete?: BucketSpecForProviderVersioningConfigurationMfaDelete;

  /**
   * Status is the desired versioning state of the bucket.
   *
   * @schema BucketSpecForProviderVersioningConfiguration#status
   */
  readonly status?: BucketSpecForProviderVersioningConfigurationStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderVersioningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderVersioningConfiguration(obj: BucketSpecForProviderVersioningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mfaDelete': obj.mfaDelete,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies website configuration parameters for an Amazon S3 bucket. See the AWS API reference guide for Amazon Simple Storage Service's API operation PutBucketWebsite for usage and error information. See also, https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PutBucketWebsite
 *
 * @schema BucketSpecForProviderWebsiteConfiguration
 */
export interface BucketSpecForProviderWebsiteConfiguration {
  /**
   * The name of the error document for the website.
   *
   * @schema BucketSpecForProviderWebsiteConfiguration#errorDocument
   */
  readonly errorDocument?: BucketSpecForProviderWebsiteConfigurationErrorDocument;

  /**
   * The name of the index document for the website.
   *
   * @schema BucketSpecForProviderWebsiteConfiguration#indexDocument
   */
  readonly indexDocument?: BucketSpecForProviderWebsiteConfigurationIndexDocument;

  /**
   * The redirect behavior for every request to this bucket's website endpoint. If you specify this property, you can't specify any other property.
   *
   * @schema BucketSpecForProviderWebsiteConfiguration#redirectAllRequestsTo
   */
  readonly redirectAllRequestsTo?: BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo;

  /**
   * Rules that define when a redirect is applied and the redirect behavior.
   *
   * @schema BucketSpecForProviderWebsiteConfiguration#routingRules
   */
  readonly routingRules?: BucketSpecForProviderWebsiteConfigurationRoutingRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfiguration(obj: BucketSpecForProviderWebsiteConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorDocument': toJson_BucketSpecForProviderWebsiteConfigurationErrorDocument(obj.errorDocument),
    'indexDocument': toJson_BucketSpecForProviderWebsiteConfigurationIndexDocument(obj.indexDocument),
    'redirectAllRequestsTo': toJson_BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo(obj.redirectAllRequestsTo),
    'routingRules': obj.routingRules?.map(y => toJson_BucketSpecForProviderWebsiteConfigurationRoutingRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderConfigRefPolicy
 */
export interface BucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRefPolicy(obj: BucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj: BucketSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketSpecPublishConnectionDetailsToMetadata
 */
export interface BucketSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToMetadata(obj: BucketSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Status specifies the transfer acceleration status of the bucket.
 *
 * @schema BucketSpecForProviderAccelerateConfigurationStatus
 */
export enum BucketSpecForProviderAccelerateConfigurationStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Suspended */
  SUSPENDED = "Suspended",
}

/**
 * CORSRule specifies a cross-origin access rule for an Amazon S3 bucket.
 *
 * @schema BucketSpecForProviderCorsConfigurationCorsRules
 */
export interface BucketSpecForProviderCorsConfigurationCorsRules {
  /**
   * Headers that are specified in the Access-Control-Request-Headers header. These headers are allowed in a preflight OPTIONS request. In response to any preflight OPTIONS request, Amazon S3 returns any requested headers that are allowed.
   *
   * @schema BucketSpecForProviderCorsConfigurationCorsRules#allowedHeaders
   */
  readonly allowedHeaders?: string[];

  /**
   * An HTTP method that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
   *
   * @schema BucketSpecForProviderCorsConfigurationCorsRules#allowedMethods
   */
  readonly allowedMethods: string[];

  /**
   * One or more origins you want customers to be able to access the bucket from.
   *
   * @schema BucketSpecForProviderCorsConfigurationCorsRules#allowedOrigins
   */
  readonly allowedOrigins: string[];

  /**
   * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
   *
   * @schema BucketSpecForProviderCorsConfigurationCorsRules#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * The time in seconds that your browser is to cache the preflight response for the specified resource.
   *
   * @schema BucketSpecForProviderCorsConfigurationCorsRules#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderCorsConfigurationCorsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCorsConfigurationCorsRules(obj: BucketSpecForProviderCorsConfigurationCorsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedHeaders': obj.allowedHeaders?.map(y => y),
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'allowedOrigins': obj.allowedOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAgeSeconds': obj.maxAgeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LifecycleRule for individual objects in an Amazon S3 bucket.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRules
 */
export interface BucketSpecForProviderLifecycleConfigurationRules {
  /**
   * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#abortIncompleteMultipartUpload
   */
  readonly abortIncompleteMultipartUpload?: BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload;

  /**
   * Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#expiration
   */
  readonly expiration?: BucketSpecForProviderLifecycleConfigurationRulesExpiration;

  /**
   * The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#filter
   */
  readonly filter?: BucketSpecForProviderLifecycleConfigurationRulesFilter;

  /**
   * Unique identifier for the rule. The value cannot be longer than 255 characters.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#id
   */
  readonly id?: string;

  /**
   * Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#noncurrentVersionExpiration
   */
  readonly noncurrentVersionExpiration?: BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration;

  /**
   * Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#noncurrentVersionTransitions
   */
  readonly noncurrentVersionTransitions?: BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions[];

  /**
   * If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
   * Status is a required field, valid values are Enabled or Disabled
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#status
   */
  readonly status: BucketSpecForProviderLifecycleConfigurationRulesStatus;

  /**
   * Specifies when an Amazon S3 object transitions to a specified storage class.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRules#transitions
   */
  readonly transitions?: BucketSpecForProviderLifecycleConfigurationRulesTransitions[];

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRules(obj: BucketSpecForProviderLifecycleConfigurationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abortIncompleteMultipartUpload': toJson_BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload(obj.abortIncompleteMultipartUpload),
    'expiration': toJson_BucketSpecForProviderLifecycleConfigurationRulesExpiration(obj.expiration),
    'filter': toJson_BucketSpecForProviderLifecycleConfigurationRulesFilter(obj.filter),
    'id': obj.id,
    'noncurrentVersionExpiration': toJson_BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration(obj.noncurrentVersionExpiration),
    'noncurrentVersionTransitions': obj.noncurrentVersionTransitions?.map(y => toJson_BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions(y)),
    'status': obj.status,
    'transitions': obj.transitions?.map(y => toJson_BucketSpecForProviderLifecycleConfigurationRulesTransitions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetBucketRef references an S3Bucket to retrieve its name
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRef
 */
export interface BucketSpecForProviderLoggingConfigurationTargetBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRef#policy
   */
  readonly policy?: BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetBucketRef(obj: BucketSpecForProviderLoggingConfigurationTargetBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetBucketSelector selects a reference to an S3Bucket to retrieve its name
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelector
 */
export interface BucketSpecForProviderLoggingConfigurationTargetBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelector#policy
   */
  readonly policy?: BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetBucketSelector(obj: BucketSpecForProviderLoggingConfigurationTargetBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetGrant is the container for granting information.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetGrants
 */
export interface BucketSpecForProviderLoggingConfigurationTargetGrants {
  /**
   * Logging permissions assigned to the Grantee for the bucket. Valid values are "FULL_CONTROL", "READ", "WRITE"
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrants#bucketLogsPermission
   */
  readonly bucketLogsPermission: BucketSpecForProviderLoggingConfigurationTargetGrantsBucketLogsPermission;

  /**
   * Container for the person being granted permissions.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrants#targetGrantee
   */
  readonly targetGrantee: BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetGrants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetGrants(obj: BucketSpecForProviderLoggingConfigurationTargetGrants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketLogsPermission': obj.bucketLogsPermission,
    'targetGrantee': toJson_BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee(obj.targetGrantee),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LambdaFunctionConfiguration contains the configuration for AWS Lambda notifications.
 *
 * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations
 */
export interface BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations {
  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations#ID
   */
  readonly id?: string;

  /**
   * The Amazon S3 bucket event for which to invoke the AWS Lambda function. For more information, see Supported Event Types (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
   * Events is a required field A full list of valid events can be found in the Amazon S3 Developer guide https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations#events
   */
  readonly events: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations#filter
   */
  readonly filter?: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter;

  /**
   * The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
   * LambdaFunctionArn is a required field
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations#lambdaFunctionArn
   */
  readonly lambdaFunctionArn: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations(obj: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ID': obj.id,
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter(obj.filter),
    'lambdaFunctionArn': obj.lambdaFunctionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfiguration specifies the configuration for publishing messages to an Amazon Simple Queue Service (Amazon SQS) queue when Amazon S3 detects specified events.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurations {
  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#ID
   */
  readonly id?: string;

  /**
   * A collection of bucket events for which to send notifications
   * Events is a required field A full list of valid events can be found in the Amazon S3 Developer guide https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#events
   */
  readonly events: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#filter
   */
  readonly filter?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter;

  /**
   * The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
   * QueueArn is a required field
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#queueArn
   */
  readonly queueArn?: string;

  /**
   * QueueArnRef references an Queue to retrieve its ARN
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#queueArnRef
   */
  readonly queueArnRef?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef;

  /**
   * QueueArnSelector selects a reference to an Queue to retrieve its ARN
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurations#queueArnSelector
   */
  readonly queueArnSelector?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurations(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ID': obj.id,
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter(obj.filter),
    'queueArn': obj.queueArn,
    'queueArnRef': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef(obj.queueArnRef),
    'queueArnSelector': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector(obj.queueArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicConfiguration specifies the configuration for publication of messages to an Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3 detects specified events.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurations {
  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#ID
   */
  readonly id?: string;

  /**
   * The Amazon S3 bucket event about which to send notifications. For more information, see Supported Event Types (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
   * Events is a required field A full list of valid events can be found in the Amazon S3 Developer guide https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#events
   */
  readonly events: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#filter
   */
  readonly filter?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter;

  /**
   * The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type. At least one of topicArn, topicArnRef or topicSelector is required.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#topicArn
   */
  readonly topicArn?: string;

  /**
   * TopicArnRef references an SNS Topic to retrieve its Arn
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#topicRef
   */
  readonly topicRef?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef;

  /**
   * TopicArnSelector selects a reference to an SNS Topic to retrieve its Arn
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurations#topicSelector
   */
  readonly topicSelector?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurations(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ID': obj.id,
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter(obj.filter),
    'topicArn': obj.topicArn,
    'topicRef': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef(obj.topicRef),
    'topicSelector': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Payer is a required field, detailing who pays Valid values are "Requester" and "BucketOwner"
 *
 * @schema BucketSpecForProviderPaymentConfigurationPayer
 */
export enum BucketSpecForProviderPaymentConfigurationPayer {
  /** Requester */
  REQUESTER = "Requester",
  /** BucketOwner */
  BUCKET_OWNER = "BucketOwner",
}

/**
 * BucketPolicyStatement defines an individual statement within the BucketPolicyBody
 *
 * @schema BucketSpecForProviderPolicyStatements
 */
export interface BucketSpecForProviderPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema BucketSpecForProviderPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/AmazonS3/latest/dev/amazon-s3-policy-keys.html
   *
   * @schema BucketSpecForProviderPolicyStatements#condition
   */
  readonly condition?: BucketSpecForProviderPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema BucketSpecForProviderPolicyStatements#effect
   */
  readonly effect: BucketSpecForProviderPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema BucketSpecForProviderPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the S3 policy to specify the users which are not included in this policy
   *
   * @schema BucketSpecForProviderPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: BucketSpecForProviderPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema BucketSpecForProviderPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema BucketSpecForProviderPolicyStatements#principal
   */
  readonly principal?: BucketSpecForProviderPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema BucketSpecForProviderPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema BucketSpecForProviderPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatements(obj: BucketSpecForProviderPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_BucketSpecForProviderPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_BucketSpecForProviderPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_BucketSpecForProviderPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema BucketSpecForProviderPolicyVersion
 */
export enum BucketSpecForProviderPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * RoleRef references an IAMRole to retrieve its Name
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleRef
 */
export interface BucketSpecForProviderReplicationConfigurationRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleRef#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRoleRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRoleRef(obj: BucketSpecForProviderReplicationConfigurationRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects a reference to an IAMRole to retrieve its Name
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleSelector
 */
export interface BucketSpecForProviderReplicationConfigurationRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleSelector#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRoleSelector(obj: BucketSpecForProviderReplicationConfigurationRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationRule specifies which Amazon S3 objects to replicate and where to store the replicas.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRules
 */
export interface BucketSpecForProviderReplicationConfigurationRules {
  /**
   * Specifies whether Amazon S3 replicates the delete markers. If you specify a Filter, you must specify this element. However, in the latest version of replication configuration (when Filter is specified), Amazon S3 doesn't replicate delete markers. Therefore, the DeleteMarkerReplication element can contain only <Status>Disabled</Status>. For an example configuration, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).
   * If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, Amazon S3 handled replication of delete markers differently. For more information, see Backward Compatibility (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#deleteMarkerReplication
   */
  readonly deleteMarkerReplication?: BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication;

  /**
   * A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
   * Destination is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#destination
   */
  readonly destination: BucketSpecForProviderReplicationConfigurationRulesDestination;

  /**
   * Optional configuration to replicate existing source bucket objects. For more information, see Replicating Existing Objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 Developer Guide.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#existingObjectReplication
   */
  readonly existingObjectReplication?: BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication;

  /**
   * A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#filter
   */
  readonly filter?: BucketSpecForProviderReplicationConfigurationRulesFilter;

  /**
   * A unique identifier for the rule. The maximum value is 255 characters.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#id
   */
  readonly id?: string;

  /**
   * The priority associated with the rule. If you specify multiple rules in a replication configuration, Amazon S3 prioritizes the rules to prevent conflicts when filtering. If two or more rules identify the same object based on a specified filter, the rule with higher priority takes precedence. For example:
   * * Same object quality prefix-based filter criteria if prefixes you specified in multiple rules overlap
   * * Same object qualify tag-based filter criteria specified in multiple rules
   * For more information, see Replication (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#priority
   */
  readonly priority?: number;

  /**
   * A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service (SSE-KMS).
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#sourceSelectionCriteria
   */
  readonly sourceSelectionCriteria?: BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria;

  /**
   * Specifies whether the rule is enabled.
   * Status is a required field Valid values are "Enabled" or "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRules#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRules(obj: BucketSpecForProviderReplicationConfigurationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteMarkerReplication': toJson_BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication(obj.deleteMarkerReplication),
    'destination': toJson_BucketSpecForProviderReplicationConfigurationRulesDestination(obj.destination),
    'existingObjectReplication': toJson_BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication(obj.existingObjectReplication),
    'filter': toJson_BucketSpecForProviderReplicationConfigurationRulesFilter(obj.filter),
    'id': obj.id,
    'priority': obj.priority,
    'sourceSelectionCriteria': toJson_BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria(obj.sourceSelectionCriteria),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerSideEncryptionRule Specifies the default server-side encryption configuration.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRules
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRules {
  /**
   * Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRules#applyServerSideEncryptionByDefault
   */
  readonly applyServerSideEncryptionByDefault: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault;

  /**
   * Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled. For more information, see Amazon S3 Bucket Keys (https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRules#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRules(obj: BucketSpecForProviderServerSideEncryptionConfigurationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyServerSideEncryptionByDefault': toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault(obj.applyServerSideEncryptionByDefault),
    'bucketKeyEnabled': obj.bucketKeyEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag is a container for a key value name pair.
 *
 * @schema BucketSpecForProviderTaggingTagSet
 */
export interface BucketSpecForProviderTaggingTagSet {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema BucketSpecForProviderTaggingTagSet#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema BucketSpecForProviderTaggingTagSet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderTaggingTagSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderTaggingTagSet(obj: BucketSpecForProviderTaggingTagSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MFADelete specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
 *
 * @schema BucketSpecForProviderVersioningConfigurationMfaDelete
 */
export enum BucketSpecForProviderVersioningConfigurationMfaDelete {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Status is the desired versioning state of the bucket.
 *
 * @schema BucketSpecForProviderVersioningConfigurationStatus
 */
export enum BucketSpecForProviderVersioningConfigurationStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Suspended */
  SUSPENDED = "Suspended",
}

/**
 * The name of the error document for the website.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationErrorDocument
 */
export interface BucketSpecForProviderWebsiteConfigurationErrorDocument {
  /**
   * The object key name to use when a 4XX class error occurs.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationErrorDocument#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationErrorDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationErrorDocument(obj: BucketSpecForProviderWebsiteConfigurationErrorDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of the index document for the website.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationIndexDocument
 */
export interface BucketSpecForProviderWebsiteConfigurationIndexDocument {
  /**
   * A suffix that is appended to a request that is for a directory on the website endpoint (for example,if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html) The suffix must not be empty and must not include a slash character.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationIndexDocument#suffix
   */
  readonly suffix: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationIndexDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationIndexDocument(obj: BucketSpecForProviderWebsiteConfigurationIndexDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The redirect behavior for every request to this bucket's website endpoint. If you specify this property, you can't specify any other property.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo
 */
export interface BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo {
  /**
   * Name of the host where requests are redirected.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo#hostName
   */
  readonly hostName: string;

  /**
   * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo#protocol
   */
  readonly protocol?: BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsToProtocol;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo(obj: BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostName': obj.hostName,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoutingRule specifies the redirect behavior and when a redirect is applied.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationRoutingRules
 */
export interface BucketSpecForProviderWebsiteConfigurationRoutingRules {
  /**
   * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRules#condition
   */
  readonly condition?: BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition;

  /**
   * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRules#redirect
   */
  readonly redirect: BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationRoutingRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationRoutingRules(obj: BucketSpecForProviderWebsiteConfigurationRoutingRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition(obj.condition),
    'redirect': toJson_BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect(obj.redirect),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolution
 */
export enum BucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolve
 */
export enum BucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload {
  /**
   * Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload#daysAfterInitiation
   */
  readonly daysAfterInitiation: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload(obj: BucketSpecForProviderLifecycleConfigurationRulesAbortIncompleteMultipartUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daysAfterInitiation': obj.daysAfterInitiation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesExpiration
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesExpiration {
  /**
   * Indicates at what date the object is to be moved or deleted.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesExpiration#date
   */
  readonly date?: Date;

  /**
   * Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesExpiration#days
   */
  readonly days?: number;

  /**
   * Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesExpiration#expiredObjectDeleteMarker
   */
  readonly expiredObjectDeleteMarker?: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesExpiration(obj: BucketSpecForProviderLifecycleConfigurationRulesExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date?.toISOString(),
    'days': obj.days,
    'expiredObjectDeleteMarker': obj.expiredObjectDeleteMarker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesFilter
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesFilter {
  /**
   * This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilter#and
   */
  readonly and?: BucketSpecForProviderLifecycleConfigurationRulesFilterAnd;

  /**
   * Prefix identifying one or more objects to which the rule applies.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilter#prefix
   */
  readonly prefix?: string;

  /**
   * This tag must exist in the object's tag set in order for the rule to apply.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilter#tag
   */
  readonly tag?: BucketSpecForProviderLifecycleConfigurationRulesFilterTag;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesFilter(obj: BucketSpecForProviderLifecycleConfigurationRulesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration {
  /**
   * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see How Amazon S3 Calculates When an Object Became Noncurrent (https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration#noncurrentDays
   */
  readonly noncurrentDays?: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration(obj: BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noncurrentDays': obj.noncurrentDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NoncurrentVersionTransition contains the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions {
  /**
   * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see How Amazon S3 Calculates How Long an Object Has Been Noncurrent (https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions#noncurrentDays
   */
  readonly noncurrentDays?: number;

  /**
   * The class of storage used to store the object. Valid values are: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions#storageClass
   */
  readonly storageClass: BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitionsStorageClass;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions(obj: BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noncurrentDays': obj.noncurrentDays,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
 * Status is a required field, valid values are Enabled or Disabled
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesStatus
 */
export enum BucketSpecForProviderLifecycleConfigurationRulesStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Transition specifies when an object transitions to a specified storage class. For more information about Amazon S3 lifecycle configuration rules, see Transitioning Objects Using Amazon S3 Lifecycle (https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesTransitions
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesTransitions {
  /**
   * Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesTransitions#date
   */
  readonly date?: Date;

  /**
   * Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesTransitions#days
   */
  readonly days?: number;

  /**
   * The storage class to which you want the object to transition. Valid values are: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesTransitions#storageClass
   */
  readonly storageClass: BucketSpecForProviderLifecycleConfigurationRulesTransitionsStorageClass;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesTransitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesTransitions(obj: BucketSpecForProviderLifecycleConfigurationRulesTransitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date?.toISOString(),
    'days': obj.days,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy
 */
export interface BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy(obj: BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy
 */
export interface BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy(obj: BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging permissions assigned to the Grantee for the bucket. Valid values are "FULL_CONTROL", "READ", "WRITE"
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsBucketLogsPermission
 */
export enum BucketSpecForProviderLoggingConfigurationTargetGrantsBucketLogsPermission {
  /** FULL_CONTROL */
  FULL_UNDERSCORE_CONTROL = "FULL_CONTROL",
  /** READ */
  READ = "READ",
  /** WRITE */
  WRITE = "WRITE",
}

/**
 * Container for the person being granted permissions.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee
 */
export interface BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee {
  /**
   * The canonical user ID of the grantee.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee#ID
   */
  readonly id?: string;

  /**
   * URI of the grantee group.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee#URI
   */
  readonly uri?: string;

  /**
   * Screen name of the grantee.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee#displayName
   */
  readonly displayName?: string;

  /**
   * Email address of the grantee. For a list of all the Amazon S3 supported Regions and endpoints, see Regions and Endpoints (https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) in the AWS General Reference.
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee#emailAddress
   */
  readonly emailAddress?: string;

  /**
   * Type of grantee Type is a required field
   *
   * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee#type
   */
  readonly type: BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGranteeType;

}

/**
 * Converts an object of type 'BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee(obj: BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGrantee | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ID': obj.id,
    'URI': obj.uri,
    'displayName': obj.displayName,
    'emailAddress': obj.emailAddress,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter
 */
export interface BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter#key
   */
  readonly key?: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter(obj: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter#key
   */
  readonly key?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueArnRef references an Queue to retrieve its ARN
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef#policy
   */
  readonly policy?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueArnSelector selects a reference to an Queue to retrieve its ARN
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector#policy
   */
  readonly policy?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter#key
   */
  readonly key?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicArnRef references an SNS Topic to retrieve its Arn
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef#policy
   */
  readonly policy?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicArnSelector selects a reference to an SNS Topic to retrieve its Arn
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector#policy
   */
  readonly policy?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition represents a set of condition pairs for a bucket policy
 *
 * @schema BucketSpecForProviderPolicyStatementsCondition
 */
export interface BucketSpecForProviderPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema BucketSpecForProviderPolicyStatementsCondition#conditions
   */
  readonly conditions: BucketSpecForProviderPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema BucketSpecForProviderPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsCondition(obj: BucketSpecForProviderPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_BucketSpecForProviderPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema BucketSpecForProviderPolicyStatementsEffect
 */
export enum BucketSpecForProviderPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the S3 policy to specify the users which are not included in this policy
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipal
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipal(obj: BucketSpecForProviderPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipal
 */
export interface BucketSpecForProviderPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipal(obj: BucketSpecForProviderPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleRefPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRoleRefPolicy(obj: BucketSpecForProviderReplicationConfigurationRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy(obj: BucketSpecForProviderReplicationConfigurationRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether Amazon S3 replicates the delete markers. If you specify a Filter, you must specify this element. However, in the latest version of replication configuration (when Filter is specified), Amazon S3 doesn't replicate delete markers. Therefore, the DeleteMarkerReplication element can contain only <Status>Disabled</Status>. For an example configuration, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).
 * If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, Amazon S3 handled replication of delete markers differently. For more information, see Backward Compatibility (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication {
  /**
   * Indicates whether to replicate delete markers. Valid values are "Enabled" or "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplicationStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication(obj: BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
 * Destination is a required field
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestination
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestination {
  /**
   * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#accessControlTranslation
   */
  readonly accessControlTranslation?: BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation;

  /**
   * Destination bucket owner account ID. In a cross-account scenario, if you direct Amazon S3 to change replica ownership to the AWS account that owns the destination bucket by specifying the AccessControlTranslation property, this is the account ID of the destination bucket owner. For more information, see Replication Additional Configuration: Changing the Replica Owner (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-change-owner.html) in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#account
   */
  readonly account?: string;

  /**
   * The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results. At least one of bucket, bucketRef or bucketSelector is required.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#bucket
   */
  readonly bucket?: string;

  /**
   * BucketRef references a Bucket to retrieve its Name
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#bucketRef
   */
  readonly bucketRef?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef;

  /**
   * BucketSelector selects a reference to a Bucket to retrieve its Name
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#bucketSelector
   */
  readonly bucketSelector?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector;

  /**
   * A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#encryptionConfiguration
   */
  readonly encryptionConfiguration?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration;

  /**
   * A container specifying replication metrics-related settings enabling metrics and Amazon S3 events for S3 Replication Time Control (S3 RTC). Must be specified together with a ReplicationTime block.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#metrics
   */
  readonly metrics?: BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics;

  /**
   * A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#replicationTime
   */
  readonly replicationTime?: BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime;

  /**
   * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica. For valid values, see the StorageClass element of the PUT Bucket replication (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the Amazon Simple Storage Service API Reference.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestination#storageClass
   */
  readonly storageClass?: BucketSpecForProviderReplicationConfigurationRulesDestinationStorageClass;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestination(obj: BucketSpecForProviderReplicationConfigurationRulesDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlTranslation': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation(obj.accessControlTranslation),
    'account': obj.account,
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector(obj.bucketSelector),
    'encryptionConfiguration': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration(obj.encryptionConfiguration),
    'metrics': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics(obj.metrics),
    'replicationTime': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime(obj.replicationTime),
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional configuration to replicate existing source bucket objects. For more information, see Replicating Existing Objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 Developer Guide.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication
 */
export interface BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication {
  /**
   * Status is a required field Valid values are "Enabled" and "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplicationStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication(obj: BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesFilter
 */
export interface BucketSpecForProviderReplicationConfigurationRulesFilter {
  /**
   * A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
   * * If you specify both a Prefix and a Tag filter, wrap these filters in an And tag.
   * * If you specify a filter based on multiple tags, wrap the Tag elements in an And tag.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilter#and
   */
  readonly and?: BucketSpecForProviderReplicationConfigurationRulesFilterAnd;

  /**
   * An object key name prefix that identifies the subset of objects to which the rule applies.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container for specifying a tag key and value. The rule applies only to objects that have the tag in their tag set.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilter#tag
   */
  readonly tag?: BucketSpecForProviderReplicationConfigurationRulesFilterTag;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesFilter(obj: BucketSpecForProviderReplicationConfigurationRulesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecForProviderReplicationConfigurationRulesFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecForProviderReplicationConfigurationRulesFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service (SSE-KMS).
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria
 */
export interface BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria {
  /**
   * A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If you include SourceSelectionCriteria in the replication configuration, this element is required.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria#sseKmsEncryptedObjects
   */
  readonly sseKmsEncryptedObjects: BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria(obj: BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sseKmsEncryptedObjects': toJson_BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects(obj.sseKmsEncryptedObjects),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether the rule is enabled.
 * Status is a required field Valid values are "Enabled" or "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault {
  /**
   * AWS Key Management Service (KMS) customer master key ID to use for the default encryption. This parameter is allowed if and only if SSEAlgorithm is set to aws:kms.
   * You can specify the key ID or the Amazon Resource Name (ARN) of the CMK. However, if you are using encryption with cross-account operations, you must use a fully qualified CMK ARN. For more information, see Using encryption for cross-account operations (https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy).
   * For example:
   * * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
   * * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
   * Amazon S3 only supports symmetric CMKs and not asymmetric CMKs. For more information, see Using Symmetric and Asymmetric Keys (https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the AWS Key Management Service Developer Guide.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * KMSMasterKeyIDRef references an KMSKey to retrieve its ID
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault#kmsMasterKeyIdRef
   */
  readonly kmsMasterKeyIdRef?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef;

  /**
   * KMSMasterKeyIDSelector selects a reference to an KMSKey to retrieve its ID
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault#kmsMasterKeyIdSelector
   */
  readonly kmsMasterKeyIdSelector?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector;

  /**
   * Server-side encryption algorithm to use for the default encryption. Options are AES256 or aws:kms
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault#sseAlgorithm
   */
  readonly sseAlgorithm: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault(obj: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'kmsMasterKeyIdRef': toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef(obj.kmsMasterKeyIdRef),
    'kmsMasterKeyIdSelector': toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector(obj.kmsMasterKeyIdSelector),
    'sseAlgorithm': obj.sseAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsToProtocol
 */
export enum BucketSpecForProviderWebsiteConfigurationRedirectAllRequestsToProtocol {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition
 */
export interface BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition {
  /**
   * The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element Condition is specified and sibling KeyPrefixEquals is not specified. If both are specified, then both must be true for the redirect to be applied.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition#httpErrorCodeReturnedEquals
   */
  readonly httpErrorCodeReturnedEquals?: string;

  /**
   * The object key name prefix when the redirect is applied. For example, to redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html. To redirect request for all pages with the prefix docs/, the key prefix will be /docs, which identifies all objects in the docs/ folder. Required when the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals is not specified. If both conditions are specified, both must be true for the redirect to be applied.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition#keyPrefixEquals
   */
  readonly keyPrefixEquals?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition(obj: BucketSpecForProviderWebsiteConfigurationRoutingRulesCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpErrorCodeReturnedEquals': obj.httpErrorCodeReturnedEquals,
    'keyPrefixEquals': obj.keyPrefixEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
 *
 * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect
 */
export interface BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect {
  /**
   * The HTTP redirect code to use on the response. Not required if one of the siblings is present.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect#httpRedirectCode
   */
  readonly httpRedirectCode?: string;

  /**
   * The host name to use in the redirect request.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect#keyPrefixEquals
   */
  readonly keyPrefixEquals?: string;

  /**
   * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect#protocol
   */
  readonly protocol?: string;

  /**
   * The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix docs/ (objects in the docs/ folder) to documents/, you can set a condition block with KeyPrefixEquals set to docs/ and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required if one of the siblings is present. Can be present only if ReplaceKeyWith is not provided.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect#replaceKeyPrefixWith
   */
  readonly replaceKeyPrefixWith?: string;

  /**
   * The specific object key to use in the redirect request. For example, redirect request to error.html. Not required if one of the siblings is present. Can be present only if ReplaceKeyPrefixWith is not provided.
   *
   * @schema BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect#replaceKeyWith
   */
  readonly replaceKeyWith?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect(obj: BucketSpecForProviderWebsiteConfigurationRoutingRulesRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpRedirectCode': obj.httpRedirectCode,
    'keyPrefixEquals': obj.keyPrefixEquals,
    'protocol': obj.protocol,
    'replaceKeyPrefixWith': obj.replaceKeyPrefixWith,
    'replaceKeyWith': obj.replaceKeyWith,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAnd
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesFilterAnd {
  /**
   * Prefix identifying one or more objects to which the rule applies.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * All of these tags must exist in the object's tag set in order for the rule to apply.
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAnd#tags
   */
  readonly tags: BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterAnd(obj: BucketSpecForProviderLifecycleConfigurationRulesFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This tag must exist in the object's tag set in order for the rule to apply.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterTag
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesFilterTag {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterTag#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterTag(obj: BucketSpecForProviderLifecycleConfigurationRulesFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The class of storage used to store the object. Valid values are: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitionsStorageClass
 */
export enum BucketSpecForProviderLifecycleConfigurationRulesNoncurrentVersionTransitionsStorageClass {
  /** GLACIER */
  GLACIER = "GLACIER",
  /** STANDARD_IA */
  STANDARD_UNDERSCORE_IA = "STANDARD_IA",
  /** ONEZONE_IA */
  ONEZONE_UNDERSCORE_IA = "ONEZONE_IA",
  /** INTELLIGENT_TIERING */
  INTELLIGENT_UNDERSCORE_TIERING = "INTELLIGENT_TIERING",
  /** DEEP_ARCHIVE */
  DEEP_UNDERSCORE_ARCHIVE = "DEEP_ARCHIVE",
}

/**
 * The storage class to which you want the object to transition. Valid values are: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesTransitionsStorageClass
 */
export enum BucketSpecForProviderLifecycleConfigurationRulesTransitionsStorageClass {
  /** GLACIER */
  GLACIER = "GLACIER",
  /** STANDARD_IA */
  STANDARD_UNDERSCORE_IA = "STANDARD_IA",
  /** ONEZONE_IA */
  ONEZONE_UNDERSCORE_IA = "ONEZONE_IA",
  /** INTELLIGENT_TIERING */
  INTELLIGENT_UNDERSCORE_TIERING = "INTELLIGENT_TIERING",
  /** DEEP_ARCHIVE */
  DEEP_UNDERSCORE_ARCHIVE = "DEEP_ARCHIVE",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolution
 */
export enum BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolve
 */
export enum BucketSpecForProviderLoggingConfigurationTargetBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolution
 */
export enum BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolve
 */
export enum BucketSpecForProviderLoggingConfigurationTargetBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Type of grantee Type is a required field
 *
 * @schema BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGranteeType
 */
export enum BucketSpecForProviderLoggingConfigurationTargetGrantsTargetGranteeType {
  /** CanonicalUser */
  CANONICAL_USER = "CanonicalUser",
  /** AmazonCustomerByEmail */
  AMAZON_CUSTOMER_BY_EMAIL = "AmazonCustomerByEmail",
  /** Group */
  GROUP = "Group",
}

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey
 */
export interface BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey#filterRules
   */
  readonly filterRules: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey(obj: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey#filterRules
   */
  readonly filterRules: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey#filterRules
   */
  readonly filterRules: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConditionPair represents one condition inside of the set of conditions for a bucket policy
 *
 * @schema BucketSpecForProviderPolicyStatementsConditionConditions
 */
export interface BucketSpecForProviderPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema BucketSpecForProviderPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsConditionConditions(obj: BucketSpecForProviderPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Indicates whether to replicate delete markers. Valid values are "Enabled" or "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplicationStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDeleteMarkerReplicationStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation {
  /**
   * Specifies the replica ownership. For default and valid values, see PUT bucket replication (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon Simple Storage Service API Reference. Owner is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation#ownerOverride
   */
  readonly ownerOverride: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationAccessControlTranslation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ownerOverride': obj.ownerOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketRef references a Bucket to retrieve its Name
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSelector selects a reference to a Bucket to retrieve its Name
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration {
  /**
   * Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket. Amazon S3 uses this key to encrypt replica objects. Amazon S3 only supports symmetric customer managed CMKs. For more information, see Using Symmetric and Asymmetric Keys (https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the AWS Key Management Service Developer Guide.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration#replicaKmsKeyId
   */
  readonly replicaKmsKeyId: string;

  /**
   * ReplicaKmsKeyIDRef references an KMSKey to retrieve its ID
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration#replicaKmsKeyIdRef
   */
  readonly replicaKmsKeyIdRef?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef;

  /**
   * ReplicaKmsKeyIDSelector selects a reference to an KMSKey to retrieve its ID
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration#replicaKmsKeyIdSelector
   */
  readonly replicaKmsKeyIdSelector?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaKmsKeyId': obj.replicaKmsKeyId,
    'replicaKmsKeyIdRef': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef(obj.replicaKmsKeyIdRef),
    'replicaKmsKeyIdSelector': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector(obj.replicaKmsKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying replication metrics-related settings enabling metrics and Amazon S3 events for S3 Replication Time Control (S3 RTC). Must be specified together with a ReplicationTime block.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics {
  /**
   * A container specifying the time threshold for emitting the s3:Replication:OperationMissedThreshold event.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics#eventThreshold
   */
  readonly eventThreshold?: BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold;

  /**
   * Specifies whether the replication metrics are enabled.
   * Status is a required field, valid values are "Enabled" and "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventThreshold': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold(obj.eventThreshold),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime {
  /**
   * Specifies whether the replication time is enabled Status is a required field Valid values are "Enabled" and "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeStatus;

  /**
   * A container specifying the time by which replication should be complete for all objects and operations on objects. Time is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime#time
   */
  readonly time: BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'time': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime(obj.time),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica. For valid values, see the StorageClass element of the PUT Bucket replication (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the Amazon Simple Storage Service API Reference.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationStorageClass
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationStorageClass {
  /** STANDARD */
  STANDARD = "STANDARD",
  /** GLACIER */
  GLACIER = "GLACIER",
  /** STANDARD_IA */
  STANDARD_UNDERSCORE_IA = "STANDARD_IA",
  /** ONEZONE_IA */
  ONEZONE_UNDERSCORE_IA = "ONEZONE_IA",
  /** INTELLIGENT_TIERING */
  INTELLIGENT_UNDERSCORE_TIERING = "INTELLIGENT_TIERING",
  /** DEEP_ARCHIVE */
  DEEP_UNDERSCORE_ARCHIVE = "DEEP_ARCHIVE",
}

/**
 * Status is a required field Valid values are "Enabled" and "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplicationStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesExistingObjectReplicationStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
 * * If you specify both a Prefix and a Tag filter, wrap these filters in an And tag.
 * * If you specify a filter based on multiple tags, wrap the Tag elements in an And tag.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAnd
 */
export interface BucketSpecForProviderReplicationConfigurationRulesFilterAnd {
  /**
   * An object key name prefix that identifies the subset of objects to which the rule applies.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * An array of tags containing key and value pairs.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAnd#tag
   */
  readonly tag?: BucketSpecForProviderReplicationConfigurationRulesFilterAndTag[];

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesFilterAnd(obj: BucketSpecForProviderReplicationConfigurationRulesFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tag': obj.tag?.map(y => toJson_BucketSpecForProviderReplicationConfigurationRulesFilterAndTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying a tag key and value. The rule applies only to objects that have the tag in their tag set.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesFilterTag
 */
export interface BucketSpecForProviderReplicationConfigurationRulesFilterTag {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterTag#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesFilterTag(obj: BucketSpecForProviderReplicationConfigurationRulesFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If you include SourceSelectionCriteria in the replication configuration, this element is required.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects
 */
export interface BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects {
  /**
   * Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
   * Status is a required field Valid values are "Enabled" or "Disabled"
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects#status
   */
  readonly status: BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsStatus;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects(obj: BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSMasterKeyIDRef references an KMSKey to retrieve its ID
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef#policy
   */
  readonly policy?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef(obj: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSMasterKeyIDSelector selects a reference to an KMSKey to retrieve its ID
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#policy
   */
  readonly policy?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector(obj: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag is a container for a key value name pair.
 *
 * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags
 */
export interface BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags(obj: BucketSpecForProviderLifecycleConfigurationRulesFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FilterRule specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules {
  /**
   * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules#name
   */
  readonly name: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRulesName;

  /**
   * The value that the filter searches for in object key names.
   *
   * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules(obj: BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FilterRule specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules {
  /**
   * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules#name
   */
  readonly name: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRulesName;

  /**
   * The value that the filter searches for in object key names.
   *
   * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules(obj: BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolution
 */
export enum BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolve
 */
export enum BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolution
 */
export enum BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolve
 */
export enum BucketSpecForProviderNotificationConfigurationQueueConfigurationsQueueArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * FilterRule specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules {
  /**
   * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules#name
   */
  readonly name: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRulesName;

  /**
   * The value that the filter searches for in object key names.
   *
   * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules(obj: BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolution
 */
export enum BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolve
 */
export enum BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolution
 */
export enum BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolve
 */
export enum BucketSpecForProviderNotificationConfigurationTopicConfigurationsTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaKmsKeyIDRef references an KMSKey to retrieve its ID
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaKmsKeyIDSelector selects a reference to an KMSKey to retrieve its ID
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector#policy
   */
  readonly policy?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying the time threshold for emitting the s3:Replication:OperationMissedThreshold event.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold {
  /**
   * Contains an integer specifying time in minutes.
   * Valid values: 15 minutes.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsEventThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether the replication metrics are enabled.
 * Status is a required field, valid values are "Enabled" and "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationMetricsStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Specifies whether the replication time is enabled Status is a required field Valid values are "Enabled" and "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * A container specifying the time by which replication should be complete for all objects and operations on objects. Time is a required field
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime {
  /**
   * Contains an integer specifying time in minutes.
   * Valid values: 15 minutes.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationReplicationTimeTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag is a container for a key value name pair.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAndTag
 */
export interface BucketSpecForProviderReplicationConfigurationRulesFilterAndTag {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAndTag#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesFilterAndTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesFilterAndTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesFilterAndTag(obj: BucketSpecForProviderReplicationConfigurationRulesFilterAndTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
 * Status is a required field Valid values are "Enabled" or "Disabled"
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsStatus
 */
export enum BucketSpecForProviderReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsStatus {
  /** Enabled */
  ENABLED = "Enabled",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy(obj: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy
 */
export interface BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy(obj: BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
 *
 * @schema BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRulesName
 */
export enum BucketSpecForProviderNotificationConfigurationLambdaFunctionConfigurationsFilterKeyFilterRulesName {
  /** prefix */
  PREFIX = "prefix",
  /** suffix */
  SUFFIX = "suffix",
}

/**
 * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
 *
 * @schema BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRulesName
 */
export enum BucketSpecForProviderNotificationConfigurationQueueConfigurationsFilterKeyFilterRulesName {
  /** prefix */
  PREFIX = "prefix",
  /** suffix */
  SUFFIX = "suffix",
}

/**
 * The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon Simple Storage Service Developer Guide. Valid values are "prefix" or "suffix"
 *
 * @schema BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRulesName
 */
export enum BucketSpecForProviderNotificationConfigurationTopicConfigurationsFilterKeyFilterRulesName {
  /** prefix */
  PREFIX = "prefix",
  /** suffix */
  SUFFIX = "suffix",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy
 */
export interface BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy(obj: BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution
 */
export enum BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve
 */
export enum BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution
 */
export enum BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve
 */
export enum BucketSpecForProviderServerSideEncryptionConfigurationRulesApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum BucketSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolution
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolve
 */
export enum BucketSpecForProviderReplicationConfigurationRulesDestinationEncryptionConfigurationReplicaKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * An BucketPolicy is a managed resource that represents an AWS Bucket policy.
 *
 * @schema BucketPolicy
 */
export class BucketPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.crossplane.io/v1alpha3',
    kind: 'BucketPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BucketPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketPolicyProps): any {
    return {
      ...BucketPolicy.GVK,
      ...toJson_BucketPolicyProps(props),
    };
  }

  /**
   * Defines a "BucketPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketPolicyProps) {
    super(scope, id, {
      ...BucketPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketPolicy.GVK,
      ...toJson_BucketPolicyProps(resolved),
    };
  }
}

/**
 * An BucketPolicy is a managed resource that represents an AWS Bucket policy.
 *
 * @schema BucketPolicy
 */
export interface BucketPolicyProps {
  /**
   * @schema BucketPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An BucketPolicySpec defines the desired state of an BucketPolicy.
   *
   * @schema BucketPolicy#spec
   */
  readonly spec: BucketPolicySpec;

}

/**
 * Converts an object of type 'BucketPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicyProps(obj: BucketPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An BucketPolicySpec defines the desired state of an BucketPolicy.
 *
 * @schema BucketPolicySpec
 */
export interface BucketPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketPolicySpecDeletionPolicy;

  /**
   * BucketPolicyParameters define the desired state of an AWS BucketPolicy.
   *
   * @schema BucketPolicySpec#forProvider
   */
  readonly forProvider: BucketPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketPolicySpec#managementPolicies
   */
  readonly managementPolicies?: BucketPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpec(obj: BucketPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketPolicySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketPolicySpecDeletionPolicy
 */
export enum BucketPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * BucketPolicyParameters define the desired state of an AWS BucketPolicy.
 *
 * @schema BucketPolicySpecForProvider
 */
export interface BucketPolicySpecForProvider {
  /**
   * BucketName presents the name of the bucket.
   *
   * @schema BucketPolicySpecForProvider#bucketName
   */
  readonly bucketName?: string;

  /**
   * BucketNameRef references to an S3Bucket to retrieve its bucketName
   *
   * @schema BucketPolicySpecForProvider#bucketNameRef
   */
  readonly bucketNameRef?: BucketPolicySpecForProviderBucketNameRef;

  /**
   * BucketNameSelector selects a reference to an S3Bucket to retrieve its bucketName
   *
   * @schema BucketPolicySpecForProvider#bucketNameSelector
   */
  readonly bucketNameSelector?: BucketPolicySpecForProviderBucketNameSelector;

  /**
   * Policy is a well defined type which can be parsed into an JSON S3 Bucket Policy either policy or rawPolicy must be specified in the policy
   *
   * @schema BucketPolicySpecForProvider#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicy;

  /**
   * RawPolicy is a stringified version of the S3 Bucket Policy. either policy or rawPolicy must be specified in the policy
   *
   * @schema BucketPolicySpecForProvider#rawPolicy
   */
  readonly rawPolicy?: string;

  /**
   * Region is where the Bucket referenced by this BucketPolicy resides.
   *
   * @schema BucketPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProvider(obj: BucketPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_BucketPolicySpecForProviderBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_BucketPolicySpecForProviderBucketNameSelector(obj.bucketNameSelector),
    'policy': toJson_BucketPolicySpecForProviderPolicy(obj.policy),
    'rawPolicy': obj.rawPolicy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketPolicySpecManagementPolicies
 */
export enum BucketPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketPolicySpecProviderConfigRef
 */
export interface BucketPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecProviderConfigRef#policy
   */
  readonly policy?: BucketPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderConfigRef(obj: BucketPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsTo
 */
export interface BucketPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsTo(obj: BucketPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketPolicySpecWriteConnectionSecretToRef
 */
export interface BucketPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecWriteConnectionSecretToRef(obj: BucketPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketNameRef references to an S3Bucket to retrieve its bucketName
 *
 * @schema BucketPolicySpecForProviderBucketNameRef
 */
export interface BucketPolicySpecForProviderBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderBucketNameRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderBucketNameRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketNameRef(obj: BucketPolicySpecForProviderBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketNameSelector selects a reference to an S3Bucket to retrieve its bucketName
 *
 * @schema BucketPolicySpecForProviderBucketNameSelector
 */
export interface BucketPolicySpecForProviderBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderBucketNameSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketNameSelector(obj: BucketPolicySpecForProviderBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy is a well defined type which can be parsed into an JSON S3 Bucket Policy either policy or rawPolicy must be specified in the policy
 *
 * @schema BucketPolicySpecForProviderPolicy
 */
export interface BucketPolicySpecForProviderPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema BucketPolicySpecForProviderPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema BucketPolicySpecForProviderPolicy#statements
   */
  readonly statements?: BucketPolicySpecForProviderPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema BucketPolicySpecForProviderPolicy#version
   */
  readonly version: BucketPolicySpecForProviderPolicyVersion;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicy(obj: BucketPolicySpecForProviderPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_BucketPolicySpecForProviderPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicy
 */
export interface BucketPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderConfigRefPolicy(obj: BucketPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface BucketPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToConfigRef(obj: BucketPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToMetadata
 */
export interface BucketPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToMetadata(obj: BucketPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderBucketNameRefPolicy
 */
export interface BucketPolicySpecForProviderBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderBucketNameRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderBucketNameRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketNameRefPolicy(obj: BucketPolicySpecForProviderBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderBucketNameSelectorPolicy
 */
export interface BucketPolicySpecForProviderBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketNameSelectorPolicy(obj: BucketPolicySpecForProviderBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketPolicyStatement defines an individual statement within the BucketPolicyBody
 *
 * @schema BucketPolicySpecForProviderPolicyStatements
 */
export interface BucketPolicySpecForProviderPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/AmazonS3/latest/dev/amazon-s3-policy-keys.html
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#condition
   */
  readonly condition?: BucketPolicySpecForProviderPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#effect
   */
  readonly effect: BucketPolicySpecForProviderPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the S3 policy to specify the users which are not included in this policy
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: BucketPolicySpecForProviderPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#principal
   */
  readonly principal?: BucketPolicySpecForProviderPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema BucketPolicySpecForProviderPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatements(obj: BucketPolicySpecForProviderPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_BucketPolicySpecForProviderPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema BucketPolicySpecForProviderPolicyVersion
 */
export enum BucketPolicySpecForProviderPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicyResolution
 */
export enum BucketPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicyResolve
 */
export enum BucketPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderBucketNameRefPolicyResolution
 */
export enum BucketPolicySpecForProviderBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderBucketNameRefPolicyResolve
 */
export enum BucketPolicySpecForProviderBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderBucketNameSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderBucketNameSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Condition represents a set of condition pairs for a bucket policy
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsCondition
 */
export interface BucketPolicySpecForProviderPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsCondition#conditions
   */
  readonly conditions: BucketPolicySpecForProviderPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsCondition(obj: BucketPolicySpecForProviderPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_BucketPolicySpecForProviderPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsEffect
 */
export enum BucketPolicySpecForProviderPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the S3 policy to specify the users which are not included in this policy
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipal
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipal(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipal
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipal(obj: BucketPolicySpecForProviderPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * ConditionPair represents one condition inside of the set of conditions for a bucket policy
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions
 */
export interface BucketPolicySpecForProviderPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsConditionConditions(obj: BucketPolicySpecForProviderPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

