// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alias is the Schema for the Aliases API
 *
 * @schema Alias
 */
export class Alias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.crossplane.io/v1alpha1',
    kind: 'Alias',
  }

  /**
   * Renders a Kubernetes manifest for "Alias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AliasProps): any {
    return {
      ...Alias.GVK,
      ...toJson_AliasProps(props),
    };
  }

  /**
   * Defines a "Alias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AliasProps) {
    super(scope, id, {
      ...Alias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alias.GVK,
      ...toJson_AliasProps(resolved),
    };
  }
}

/**
 * Alias is the Schema for the Aliases API
 *
 * @schema Alias
 */
export interface AliasProps {
  /**
   * @schema Alias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AliasSpec defines the desired state of Alias
   *
   * @schema Alias#spec
   */
  readonly spec: AliasSpec;

}

/**
 * Converts an object of type 'AliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasProps(obj: AliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AliasSpec defines the desired state of Alias
 *
 * @schema AliasSpec
 */
export interface AliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: AliasSpecDeletionPolicy;

  /**
   * AliasParameters defines the desired state of Alias
   *
   * @schema AliasSpec#forProvider
   */
  readonly forProvider: AliasSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AliasSpec#managementPolicies
   */
  readonly managementPolicies?: AliasSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: AliasSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpec(obj: AliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AliasSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AliasSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AliasSpecDeletionPolicy
 */
export enum AliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AliasParameters defines the desired state of Alias
 *
 * @schema AliasSpecForProvider
 */
export interface AliasSpecForProvider {
  /**
   * Region is which region the Alias will be created.
   *
   * @schema AliasSpecForProvider#region
   */
  readonly region: string;

  /**
   * Associates the alias with the specified customer managed CMK (https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk). The CMK must be in the same AWS Region.
   * A valid CMK ID is required. If you supply a null or empty string value, this operation returns an error.
   * For help finding the key ID and ARN, see Finding the Key ID and ARN (https://docs.aws.amazon.com/kms/latest/developerguide/viewing-keys.html#find-cmk-id-arn) in the AWS Key Management Service Developer Guide.
   * Specify the key ID or the Amazon Resource Name (ARN) of the CMK.
   * For example:
   * * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
   * * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
   * To get the key ID and key ARN for a CMK, use ListKeys or DescribeKey.
   *
   * @schema AliasSpecForProvider#targetKeyId
   */
  readonly targetKeyId?: string;

  /**
   * TargetKeyIDRef is a reference to a KMS Key used to set TargetKeyID.
   *
   * @schema AliasSpecForProvider#targetKeyIdRef
   */
  readonly targetKeyIdRef?: AliasSpecForProviderTargetKeyIdRef;

  /**
   * TargetKeyIDSelector selects a reference to a KMS Key used to set TargetKeyID.
   *
   * @schema AliasSpecForProvider#targetKeyIdSelector
   */
  readonly targetKeyIdSelector?: AliasSpecForProviderTargetKeyIdSelector;

}

/**
 * Converts an object of type 'AliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProvider(obj: AliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'targetKeyId': obj.targetKeyId,
    'targetKeyIdRef': toJson_AliasSpecForProviderTargetKeyIdRef(obj.targetKeyIdRef),
    'targetKeyIdSelector': toJson_AliasSpecForProviderTargetKeyIdSelector(obj.targetKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AliasSpecManagementPolicies
 */
export enum AliasSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AliasSpecProviderConfigRef
 */
export interface AliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderConfigRef#policy
   */
  readonly policy?: AliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRef(obj: AliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AliasSpecPublishConnectionDetailsTo
 */
export interface AliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsTo(obj: AliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AliasSpecWriteConnectionSecretToRef
 */
export interface AliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecWriteConnectionSecretToRef(obj: AliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetKeyIDRef is a reference to a KMS Key used to set TargetKeyID.
 *
 * @schema AliasSpecForProviderTargetKeyIdRef
 */
export interface AliasSpecForProviderTargetKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecForProviderTargetKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecForProviderTargetKeyIdRef#policy
   */
  readonly policy?: AliasSpecForProviderTargetKeyIdRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdRef(obj: AliasSpecForProviderTargetKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecForProviderTargetKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetKeyIDSelector selects a reference to a KMS Key used to set TargetKeyID.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelector
 */
export interface AliasSpecForProviderTargetKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#policy
   */
  readonly policy?: AliasSpecForProviderTargetKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdSelector(obj: AliasSpecForProviderTargetKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AliasSpecForProviderTargetKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderConfigRefPolicy
 */
export interface AliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRefPolicy(obj: AliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRef
 */
export interface AliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj: AliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AliasSpecPublishConnectionDetailsToMetadata
 */
export interface AliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToMetadata(obj: AliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicy
 */
export interface AliasSpecForProviderTargetKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderTargetKeyIdRefPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderTargetKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderTargetKeyIdRefPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderTargetKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdRefPolicy(obj: AliasSpecForProviderTargetKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy
 */
export interface AliasSpecForProviderTargetKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderTargetKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderTargetKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdSelectorPolicy(obj: AliasSpecForProviderTargetKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolution
 */
export enum AliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolve
 */
export enum AliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: AliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicyResolution
 */
export enum AliasSpecForProviderTargetKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicyResolve
 */
export enum AliasSpecForProviderTargetKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicyResolution
 */
export enum AliasSpecForProviderTargetKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicyResolve
 */
export enum AliasSpecForProviderTargetKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Grant is the Schema for the Grants API
 *
 * @schema Grant
 */
export class Grant extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Grant"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.crossplane.io/v1alpha1',
    kind: 'Grant',
  }

  /**
   * Renders a Kubernetes manifest for "Grant".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GrantProps): any {
    return {
      ...Grant.GVK,
      ...toJson_GrantProps(props),
    };
  }

  /**
   * Defines a "Grant" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GrantProps) {
    super(scope, id, {
      ...Grant.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Grant.GVK,
      ...toJson_GrantProps(resolved),
    };
  }
}

/**
 * Grant is the Schema for the Grants API
 *
 * @schema Grant
 */
export interface GrantProps {
  /**
   * @schema Grant#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GrantSpec defines the desired state of Grant
   *
   * @schema Grant#spec
   */
  readonly spec: GrantSpec;

}

/**
 * Converts an object of type 'GrantProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantProps(obj: GrantProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GrantSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GrantSpec defines the desired state of Grant
 *
 * @schema GrantSpec
 */
export interface GrantSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GrantSpec#deletionPolicy
   */
  readonly deletionPolicy?: GrantSpecDeletionPolicy;

  /**
   * GrantParameters defines the desired state of Grant
   *
   * @schema GrantSpec#forProvider
   */
  readonly forProvider: GrantSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GrantSpec#managementPolicies
   */
  readonly managementPolicies?: GrantSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GrantSpec#providerConfigRef
   */
  readonly providerConfigRef?: GrantSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GrantSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GrantSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GrantSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GrantSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GrantSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpec(obj: GrantSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GrantSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GrantSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GrantSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GrantSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GrantSpecDeletionPolicy
 */
export enum GrantSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GrantParameters defines the desired state of Grant
 *
 * @schema GrantSpecForProvider
 */
export interface GrantSpecForProvider {
  /**
   * Specifies a grant constraint.
   * Do not include confidential or sensitive information in this field. This field may be displayed in plaintext in CloudTrail logs and other output.
   * KMS supports the EncryptionContextEquals and EncryptionContextSubset grant constraints, which allow the permissions in the grant only when the encryption context in the request matches (EncryptionContextEquals) or includes (EncryptionContextSubset) the encryption context specified in the constraint.
   * The encryption context grant constraints are supported only on grant operations (https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#terms-grant-operations) that include an EncryptionContext parameter, such as cryptographic operations on symmetric encryption KMS keys. Grants with grant constraints can include the DescribeKey and RetireGrant operations, but the constraint doesn't apply to these operations. If a grant with a grant constraint includes the CreateGrant operation, the constraint requires that any grants created with the CreateGrant permission have an equally strict or stricter encryption context constraint.
   * You cannot use an encryption context grant constraint for cryptographic operations with asymmetric KMS keys or HMAC KMS keys. Operations with these keys don't support an encryption context.
   * Each constraint value can include up to 8 encryption context pairs. The encryption context value in each constraint cannot exceed 384 characters. For information about grant constraints, see Using grant constraints (https://docs.aws.amazon.com/kms/latest/developerguide/create-grant-overview.html#grant-constraints) in the Key Management Service Developer Guide. For more information about encryption context, see Encryption context (https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context) in the Key Management Service Developer Guide .
   *
   * @schema GrantSpecForProvider#constraints
   */
  readonly constraints?: GrantSpecForProviderConstraints;

  /**
   * A list of grant tokens.
   * Use a grant token when your permission to call this operation comes from a new grant that has not yet achieved eventual consistency. For more information, see Grant token (https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token) and Using a grant token (https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token) in the Key Management Service Developer Guide.
   *
   * @schema GrantSpecForProvider#grantTokens
   */
  readonly grantTokens?: string[];

  /**
   * The identity that gets the permissions specified in the grant.
   * To specify the grantee principal, use the Amazon Resource Name (ARN) of an Amazon Web Services principal. Valid principals include Amazon Web Services accounts, IAM users, IAM roles, federated users, and assumed role users. For help with the ARN syntax for a principal, see IAM ARNs (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns) in the Identity and Access Management User Guide .
   *
   * @schema GrantSpecForProvider#granteePrincipal
   */
  readonly granteePrincipal: string;

  /**
   * Identifies the KMS key for the grant. The grant gives principals permission to use this KMS key.
   * Specify the key ID or key ARN of the KMS key. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN.
   * For example:
   * * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
   * * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
   * To get the key ID and key ARN for a KMS key, use ListKeys or DescribeKey.
   * KeyID or one of the referencers is a required parameter.
   *
   * @schema GrantSpecForProvider#keyId
   */
  readonly keyId?: string;

  /**
   * KeyIDRef is a reference to a KeyID.
   *
   * @schema GrantSpecForProvider#keyIdRef
   */
  readonly keyIdRef?: GrantSpecForProviderKeyIdRef;

  /**
   * KeyIDSelector selects references to a KeyID.
   *
   * @schema GrantSpecForProvider#keyIdSelector
   */
  readonly keyIdSelector?: GrantSpecForProviderKeyIdSelector;

  /**
   * A friendly name for the grant. Use this value to prevent the unintended creation of duplicate grants when retrying this request.
   * Do not include confidential or sensitive information in this field. This field may be displayed in plaintext in CloudTrail logs and other output.
   * When this value is absent, all CreateGrant requests result in a new grant with a unique GrantId even if all the supplied parameters are identical. This can result in unintended duplicates when you retry the CreateGrant request.
   * When this value is present, you can retry a CreateGrant request with identical parameters; if the grant already exists, the original GrantId is returned without creating a new grant. Note that the returned grant token is unique with every CreateGrant request, even when a duplicate GrantId is returned. All grant tokens for the same grant ID can be used interchangeably.
   *
   * @schema GrantSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A list of operations that the grant permits.
   * This list must include only operations that are permitted in a grant. Also, the operation must be supported on the KMS key. For example, you cannot create a grant for a symmetric encryption KMS key that allows the Sign operation, or a grant for an asymmetric KMS key that allows the GenerateDataKey operation. If you try, KMS returns a ValidationError exception. For details, see Grant operations (https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#terms-grant-operations) in the Key Management Service Developer Guide.
   *
   * @schema GrantSpecForProvider#operations
   */
  readonly operations: string[];

  /**
   * Region is which region the Grant will be created.
   *
   * @schema GrantSpecForProvider#region
   */
  readonly region: string;

  /**
   * The principal that has permission to use the RetireGrant operation to retire the grant.
   * To specify the principal, use the Amazon Resource Name (ARN) (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an Amazon Web Services principal. Valid principals include Amazon Web Services accounts, IAM users, IAM roles, federated users, and assumed role users. For help with the ARN syntax for a principal, see IAM ARNs (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns) in the Identity and Access Management User Guide .
   * The grant determines the retiring principal. Other principals might have permission to retire the grant or revoke the grant. For details, see RevokeGrant and Retiring and revoking grants (https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#grant-delete) in the Key Management Service Developer Guide.
   *
   * @schema GrantSpecForProvider#retiringPrincipal
   */
  readonly retiringPrincipal?: string;

}

/**
 * Converts an object of type 'GrantSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProvider(obj: GrantSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'constraints': toJson_GrantSpecForProviderConstraints(obj.constraints),
    'grantTokens': obj.grantTokens?.map(y => y),
    'granteePrincipal': obj.granteePrincipal,
    'keyId': obj.keyId,
    'keyIdRef': toJson_GrantSpecForProviderKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_GrantSpecForProviderKeyIdSelector(obj.keyIdSelector),
    'name': obj.name,
    'operations': obj.operations?.map(y => y),
    'region': obj.region,
    'retiringPrincipal': obj.retiringPrincipal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GrantSpecManagementPolicies
 */
export enum GrantSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GrantSpecProviderConfigRef
 */
export interface GrantSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecProviderConfigRef#policy
   */
  readonly policy?: GrantSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderConfigRef(obj: GrantSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GrantSpecPublishConnectionDetailsTo
 */
export interface GrantSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GrantSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GrantSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsTo(obj: GrantSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GrantSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GrantSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GrantSpecWriteConnectionSecretToRef
 */
export interface GrantSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GrantSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GrantSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GrantSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecWriteConnectionSecretToRef(obj: GrantSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a grant constraint.
 * Do not include confidential or sensitive information in this field. This field may be displayed in plaintext in CloudTrail logs and other output.
 * KMS supports the EncryptionContextEquals and EncryptionContextSubset grant constraints, which allow the permissions in the grant only when the encryption context in the request matches (EncryptionContextEquals) or includes (EncryptionContextSubset) the encryption context specified in the constraint.
 * The encryption context grant constraints are supported only on grant operations (https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#terms-grant-operations) that include an EncryptionContext parameter, such as cryptographic operations on symmetric encryption KMS keys. Grants with grant constraints can include the DescribeKey and RetireGrant operations, but the constraint doesn't apply to these operations. If a grant with a grant constraint includes the CreateGrant operation, the constraint requires that any grants created with the CreateGrant permission have an equally strict or stricter encryption context constraint.
 * You cannot use an encryption context grant constraint for cryptographic operations with asymmetric KMS keys or HMAC KMS keys. Operations with these keys don't support an encryption context.
 * Each constraint value can include up to 8 encryption context pairs. The encryption context value in each constraint cannot exceed 384 characters. For information about grant constraints, see Using grant constraints (https://docs.aws.amazon.com/kms/latest/developerguide/create-grant-overview.html#grant-constraints) in the Key Management Service Developer Guide. For more information about encryption context, see Encryption context (https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context) in the Key Management Service Developer Guide .
 *
 * @schema GrantSpecForProviderConstraints
 */
export interface GrantSpecForProviderConstraints {
  /**
   * @schema GrantSpecForProviderConstraints#encryptionContextEquals
   */
  readonly encryptionContextEquals?: { [key: string]: string };

  /**
   * @schema GrantSpecForProviderConstraints#encryptionContextSubset
   */
  readonly encryptionContextSubset?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrantSpecForProviderConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderConstraints(obj: GrantSpecForProviderConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionContextEquals': ((obj.encryptionContextEquals) === undefined) ? undefined : (Object.entries(obj.encryptionContextEquals).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'encryptionContextSubset': ((obj.encryptionContextSubset) === undefined) ? undefined : (Object.entries(obj.encryptionContextSubset).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyIDRef is a reference to a KeyID.
 *
 * @schema GrantSpecForProviderKeyIdRef
 */
export interface GrantSpecForProviderKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecForProviderKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecForProviderKeyIdRef#policy
   */
  readonly policy?: GrantSpecForProviderKeyIdRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdRef(obj: GrantSpecForProviderKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecForProviderKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyIDSelector selects references to a KeyID.
 *
 * @schema GrantSpecForProviderKeyIdSelector
 */
export interface GrantSpecForProviderKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GrantSpecForProviderKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GrantSpecForProviderKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GrantSpecForProviderKeyIdSelector#policy
   */
  readonly policy?: GrantSpecForProviderKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdSelector(obj: GrantSpecForProviderKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GrantSpecForProviderKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecProviderConfigRefPolicy
 */
export interface GrantSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GrantSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GrantSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderConfigRefPolicy(obj: GrantSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRef
 */
export interface GrantSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GrantSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToConfigRef(obj: GrantSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GrantSpecPublishConnectionDetailsToMetadata
 */
export interface GrantSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToMetadata(obj: GrantSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicy
 */
export interface GrantSpecForProviderKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderKeyIdRefPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderKeyIdRefPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdRefPolicy(obj: GrantSpecForProviderKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicy
 */
export interface GrantSpecForProviderKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdSelectorPolicy(obj: GrantSpecForProviderKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecProviderConfigRefPolicyResolution
 */
export enum GrantSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecProviderConfigRefPolicyResolve
 */
export enum GrantSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GrantSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToConfigRefPolicy(obj: GrantSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicyResolution
 */
export enum GrantSpecForProviderKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicyResolve
 */
export enum GrantSpecForProviderKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicyResolution
 */
export enum GrantSpecForProviderKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicyResolve
 */
export enum GrantSpecForProviderKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Key is the Schema for the Keys API
 *
 * @schema Key
 */
export class Key extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Key"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.crossplane.io/v1alpha1',
    kind: 'Key',
  }

  /**
   * Renders a Kubernetes manifest for "Key".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyProps): any {
    return {
      ...Key.GVK,
      ...toJson_KeyProps(props),
    };
  }

  /**
   * Defines a "Key" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyProps) {
    super(scope, id, {
      ...Key.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Key.GVK,
      ...toJson_KeyProps(resolved),
    };
  }
}

/**
 * Key is the Schema for the Keys API
 *
 * @schema Key
 */
export interface KeyProps {
  /**
   * @schema Key#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeySpec defines the desired state of Key
   *
   * @schema Key#spec
   */
  readonly spec: KeySpec;

}

/**
 * Converts an object of type 'KeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyProps(obj: KeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeySpec defines the desired state of Key
 *
 * @schema KeySpec
 */
export interface KeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeySpec#deletionPolicy
   */
  readonly deletionPolicy?: KeySpecDeletionPolicy;

  /**
   * KeyParameters defines the desired state of Key
   *
   * @schema KeySpec#forProvider
   */
  readonly forProvider: KeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema KeySpec#managementPolicies
   */
  readonly managementPolicies?: KeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeySpec#providerConfigRef
   */
  readonly providerConfigRef?: KeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpec(obj: KeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_KeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_KeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeySpecDeletionPolicy
 */
export enum KeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * KeyParameters defines the desired state of Key
 *
 * @schema KeySpecForProvider
 */
export interface KeySpecForProvider {
  /**
   * Skips ("bypasses") the key policy lockout safety check. The default value is false.
   * Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately.
   * For more information, see Default key policy (https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#prevent-unmanageable-key) in the Key Management Service Developer Guide.
   * Use this parameter only when you intend to prevent the principal that is making the request from making a subsequent PutKeyPolicy request on the KMS key.
   *
   * @schema KeySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * Creates the KMS key in the specified custom key store (https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html). The ConnectionState of the custom key store must be CONNECTED. To find the CustomKeyStoreID and ConnectionState use the DescribeCustomKeyStores operation.
   * This parameter is valid only for symmetric encryption KMS keys in a single Region. You cannot create any other type of KMS key in a custom key store.
   * When you create a KMS key in an CloudHSM key store, KMS generates a non-exportable 256-bit symmetric key in its associated CloudHSM cluster and associates it with the KMS key. When you create a KMS key in an external key store, you must use the XksKeyId parameter to specify an external key that serves as key material for the KMS key.
   *
   * @schema KeySpecForProvider#customKeyStoreID
   */
  readonly customKeyStoreId?: string;

  /**
   * Instead, use the KeySpec parameter.
   * The KeySpec and CustomerMasterKeySpec parameters work the same way. Only the names differ. We recommend that you use KeySpec parameter in your code. However, to avoid breaking changes, KMS supports both parameters.
   *
   * @schema KeySpecForProvider#customerMasterKeySpec
   */
  readonly customerMasterKeySpec?: string;

  /**
   * A description of the KMS key. Use a description that helps you decide whether the KMS key is appropriate for a task. The default value is an empty string (no description).
   * Do not include confidential or sensitive information in this field. This field may be displayed in plaintext in CloudTrail logs and other output.
   * To set or change the description after the key is created, use UpdateKeyDescription.
   *
   * @schema KeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies if key rotation is enabled for the corresponding key
   *
   * @schema KeySpecForProvider#enableKeyRotation
   */
  readonly enableKeyRotation?: boolean;

  /**
   * Specifies whether the CMK is enabled.
   *
   * @schema KeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Specifies the type of KMS key to create. The default value, SYMMETRIC_DEFAULT, creates a KMS key with a 256-bit AES-GCM key that is used for encryption and decryption, except in China Regions, where it creates a 128-bit symmetric key that uses SM4 encryption. For help choosing a key spec for your KMS key, see Choosing a KMS key type (https://docs.aws.amazon.com/kms/latest/developerguide/key-types.html#symm-asymm-choose) in the Key Management Service Developer Guide .
   * The KeySpec determines whether the KMS key contains a symmetric key or an asymmetric key pair. It also determines the algorithms that the KMS key supports. You can't change the KeySpec after the KMS key is created. To further restrict the algorithms that can be used with the KMS key, use a condition key in its key policy or IAM policy. For more information, see kms:EncryptionAlgorithm (https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-encryption-algorithm), kms:MacAlgorithm (https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-mac-algorithm) or kms:Signing Algorithm (https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-signing-algorithm) in the Key Management Service Developer Guide .
   * Amazon Web Services services that are integrated with KMS (http://aws.amazon.com/kms/features/#AWS_Service_Integration) use symmetric encryption KMS keys to protect your data. These services do not support asymmetric KMS keys or HMAC KMS keys.
   * KMS supports the following key specs for KMS keys:
   * * Symmetric encryption key (default) SYMMETRIC_DEFAULT
   * * HMAC keys (symmetric) HMAC_224 HMAC_256 HMAC_384 HMAC_512
   * * Asymmetric RSA key pairs RSA_2048 RSA_3072 RSA_4096
   * * Asymmetric NIST-recommended elliptic curve key pairs ECC_NIST_P256 (secp256r1) ECC_NIST_P384 (secp384r1) ECC_NIST_P521 (secp521r1)
   * * Other asymmetric elliptic curve key pairs ECC_SECG_P256K1 (secp256k1), commonly used for cryptocurrencies.
   * * SM2 key pairs (China Regions only) SM2
   *
   * @schema KeySpecForProvider#keySpec
   */
  readonly keySpec?: string;

  /**
   * Determines the cryptographic operations (https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) for which you can use the KMS key. The default value is ENCRYPT_DECRYPT. This parameter is optional when you are creating a symmetric encryption KMS key; otherwise, it is required. You can't change the KeyUsage value after the KMS key is created.
   * Select only one valid value.
   * * For symmetric encryption KMS keys, omit the parameter or specify ENCRYPT_DECRYPT.
   * * For HMAC KMS keys (symmetric), specify GENERATE_VERIFY_MAC.
   * * For asymmetric KMS keys with RSA key material, specify ENCRYPT_DECRYPT or SIGN_VERIFY.
   * * For asymmetric KMS keys with ECC key material, specify SIGN_VERIFY.
   * * For asymmetric KMS keys with SM2 key material (China Regions only), specify ENCRYPT_DECRYPT or SIGN_VERIFY.
   *
   * @schema KeySpecForProvider#keyUsage
   */
  readonly keyUsage?: string;

  /**
   * Creates a multi-Region primary key that you can replicate into other Amazon Web Services Regions. You cannot change this value after you create the KMS key.
   * For a multi-Region key, set this parameter to True. For a single-Region KMS key, omit this parameter or set it to False. The default value is False.
   * This operation supports multi-Region keys, an KMS feature that lets you create multiple interoperable KMS keys in different Amazon Web Services Regions. Because these KMS keys have the same key ID, key material, and other metadata, you can use them interchangeably to encrypt data in one Amazon Web Services Region and decrypt it in a different Amazon Web Services Region without re-encrypting the data or making a cross-Region call. For more information about multi-Region keys, see Multi-Region keys in KMS (https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide.
   * This value creates a primary key, not a replica. To create a replica key, use the ReplicateKey operation.
   * You can create a symmetric or asymmetric multi-Region key, and you can create a multi-Region key with imported key material. However, you cannot create a multi-Region key in a custom key store.
   *
   * @schema KeySpecForProvider#multiRegion
   */
  readonly multiRegion?: boolean;

  /**
   * The source of the key material for the KMS key. You cannot change the origin after you create the KMS key. The default is AWS_KMS, which means that KMS creates the key material.
   * To create a KMS key with no key material (https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-create-cmk.html) (for imported key material), set this value to EXTERNAL. For more information about importing key material into KMS, see Importing Key Material (https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html) in the Key Management Service Developer Guide. The EXTERNAL origin value is valid only for symmetric KMS keys.
   * To create a KMS key in an CloudHSM key store (https://docs.aws.amazon.com/kms/latest/developerguide/create-cmk-keystore.html) and create its key material in the associated CloudHSM cluster, set this value to AWS_CLOUDHSM. You must also use the CustomKeyStoreId parameter to identify the CloudHSM key store. The KeySpec value must be SYMMETRIC_DEFAULT.
   * To create a KMS key in an external key store (https://docs.aws.amazon.com/kms/latest/developerguide/create-xks-keys.html), set this value to EXTERNAL_KEY_STORE. You must also use the CustomKeyStoreId parameter to identify the external key store and the XksKeyId parameter to identify the associated external key. The KeySpec value must be SYMMETRIC_DEFAULT.
   *
   * @schema KeySpecForProvider#origin
   */
  readonly origin?: string;

  /**
   * Specifies how many days the Key is retained when scheduled for deletion. Defaults to 30 days.
   *
   * @default 30 days.
   * @schema KeySpecForProvider#pendingWindowInDays
   */
  readonly pendingWindowInDays?: number;

  /**
   * The key policy to attach to the KMS key.
   * If you provide a key policy, it must meet the following criteria:
   * * The key policy must allow the calling principal to make a subsequent PutKeyPolicy request on the KMS key. This reduces the risk that the KMS key becomes unmanageable. For more information, see Default key policy (https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#prevent-unmanageable-key) in the Key Management Service Developer Guide. (To omit this condition, set BypassPolicyLockoutSafetyCheck to true.)
   * * Each statement in the key policy must contain one or more principals. The principals in the key policy must exist and be visible to KMS. When you create a new Amazon Web Services principal, you might need to enforce a delay before including the new principal in a key policy because the new principal might not be immediately visible to KMS. For more information, see Changes that I make are not always immediately visible (https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency) in the Amazon Web Services Identity and Access Management User Guide.
   * If you do not provide a key policy, KMS attaches a default key policy to the KMS key. For more information, see Default key policy (https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default) in the Key Management Service Developer Guide.
   * The key policy size quota is 32 kilobytes (32768 bytes).
   * For help writing and formatting a JSON policy document, see the IAM JSON Policy Reference (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html) in the Identity and Access Management User Guide .
   *
   * @schema KeySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is which region the Key will be created.
   *
   * @schema KeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Assigns one or more tags to the KMS key. Use this parameter to tag the KMS key when it is created. To tag an existing KMS key, use the TagResource operation.
   * Do not include confidential or sensitive information in this field. This field may be displayed in plaintext in CloudTrail logs and other output.
   * Tagging or untagging a KMS key can allow or deny permission to the KMS key. For details, see ABAC for KMS (https://docs.aws.amazon.com/kms/latest/developerguide/abac.html) in the Key Management Service Developer Guide.
   * To use this parameter, you must have kms:TagResource (https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html) permission in an IAM policy.
   * Each tag consists of a tag key and a tag value. Both the tag key and the tag value are required, but the tag value can be an empty (null) string. You cannot have more than one tag on a KMS key with the same tag key. If you specify an existing tag key with a different tag value, KMS replaces the current tag value with the specified one.
   * When you add tags to an Amazon Web Services resource, Amazon Web Services generates a cost allocation report with usage and costs aggregated by tags. Tags can also be used to control access to a KMS key. For details, see Tagging Keys (https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html).
   *
   * @schema KeySpecForProvider#tags
   */
  readonly tags?: KeySpecForProviderTags[];

  /**
   * Identifies the external key (https://docs.aws.amazon.com/kms/latest/developerguide/keystore-external.html#concept-external-key) that serves as key material for the KMS key in an external key store (https://docs.aws.amazon.com/kms/latest/developerguide/keystore-external.html). Specify the ID that the external key store proxy (https://docs.aws.amazon.com/kms/latest/developerguide/keystore-external.html#concept-xks-proxy) uses to refer to the external key. For help, see the documentation for your external key store proxy.
   * This parameter is required for a KMS key with an Origin value of EXTERNAL_KEY_STORE. It is not valid for KMS keys with any other Origin value.
   * The external key must be an existing 256-bit AES symmetric encryption key hosted outside of Amazon Web Services in an external key manager associated with the external key store specified by the CustomKeyStoreId parameter. This key must be enabled and configured to perform encryption and decryption. Each KMS key in an external key store must use a different external key. For details, see Requirements for a KMS key in an external key store (https://docs.aws.amazon.com/create-xks-keys.html#xks-key-requirements) in the Key Management Service Developer Guide.
   * Each KMS key in an external key store is associated two backing keys. One is key material that KMS generates. The other is the external key specified by this parameter. When you use the KMS key in an external key store to encrypt data, the encryption operation is performed first by KMS using the KMS key material, and then by the external key manager using the specified external key, a process known as double encryption. For details, see Double encryption (https://docs.aws.amazon.com/kms/latest/developerguide/keystore-external.html#concept-double-encryption) in the Key Management Service Developer Guide.
   *
   * @schema KeySpecForProvider#xksKeyID
   */
  readonly xksKeyId?: string;

}

/**
 * Converts an object of type 'KeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecForProvider(obj: KeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'customKeyStoreID': obj.customKeyStoreId,
    'customerMasterKeySpec': obj.customerMasterKeySpec,
    'description': obj.description,
    'enableKeyRotation': obj.enableKeyRotation,
    'enabled': obj.enabled,
    'keySpec': obj.keySpec,
    'keyUsage': obj.keyUsage,
    'multiRegion': obj.multiRegion,
    'origin': obj.origin,
    'pendingWindowInDays': obj.pendingWindowInDays,
    'policy': obj.policy,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_KeySpecForProviderTags(y)),
    'xksKeyID': obj.xksKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema KeySpecManagementPolicies
 */
export enum KeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeySpecProviderConfigRef
 */
export interface KeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeySpecProviderConfigRef#policy
   */
  readonly policy?: KeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderConfigRef(obj: KeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeySpecPublishConnectionDetailsTo
 */
export interface KeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsTo(obj: KeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeySpecWriteConnectionSecretToRef
 */
export interface KeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecWriteConnectionSecretToRef(obj: KeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KeySpecForProviderTags
 */
export interface KeySpecForProviderTags {
  /**
   * @schema KeySpecForProviderTags#tagKey
   */
  readonly tagKey?: string;

  /**
   * @schema KeySpecForProviderTags#tagValue
   */
  readonly tagValue?: string;

}

/**
 * Converts an object of type 'KeySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecForProviderTags(obj: KeySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tagKey': obj.tagKey,
    'tagValue': obj.tagValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeySpecProviderConfigRefPolicy
 */
export interface KeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderConfigRefPolicy(obj: KeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRef
 */
export interface KeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToConfigRef(obj: KeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeySpecPublishConnectionDetailsToMetadata
 */
export interface KeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToMetadata(obj: KeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeySpecProviderConfigRefPolicyResolution
 */
export enum KeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeySpecProviderConfigRefPolicyResolve
 */
export enum KeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToConfigRefPolicy(obj: KeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

