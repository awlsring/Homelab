// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.aws.crossplane.io/v1alpha1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * ClusterParameters defines the desired state of Cluster
   *
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClusterParameters defines the desired state of Cluster
 *
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Information about the brokers
   *
   * @schema ClusterSpecForProvider#brokerNodeGroupInfo
   */
  readonly brokerNodeGroupInfo?: ClusterSpecForProviderBrokerNodeGroupInfo;

  /**
   * Includes all client authentication related information.
   *
   * @schema ClusterSpecForProvider#clientAuthentication
   */
  readonly clientAuthentication?: ClusterSpecForProviderClientAuthentication;

  /**
   * The name of the cluster.
   *
   * @schema ClusterSpecForProvider#clusterName
   */
  readonly clusterName: string;

  /**
   * ClusterPolicy of the MSK cluster.
   *
   * @schema ClusterSpecForProvider#clusterPolicy
   */
  readonly clusterPolicy?: ClusterSpecForProviderClusterPolicy;

  /**
   * Represents the configuration that you want MSK to use for the cluster.
   *
   * @schema ClusterSpecForProvider#configurationInfo
   */
  readonly configurationInfo?: ClusterSpecForProviderConfigurationInfo;

  /**
   * Includes all encryption-related information.
   *
   * @schema ClusterSpecForProvider#encryptionInfo
   */
  readonly encryptionInfo?: ClusterSpecForProviderEncryptionInfo;

  /**
   * Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
   *
   * @schema ClusterSpecForProvider#enhancedMonitoring
   */
  readonly enhancedMonitoring?: string;

  /**
   * The version of Apache Kafka.
   *
   * @schema ClusterSpecForProvider#kafkaVersion
   */
  readonly kafkaVersion: string;

  /**
   * LoggingInfo details.
   *
   * @schema ClusterSpecForProvider#loggingInfo
   */
  readonly loggingInfo?: ClusterSpecForProviderLoggingInfo;

  /**
   * The number of Apache Kafka broker nodes in the Amazon MSK cluster.
   *
   * @schema ClusterSpecForProvider#numberOfBrokerNodes
   */
  readonly numberOfBrokerNodes: number;

  /**
   * The settings for open monitoring.
   *
   * @schema ClusterSpecForProvider#openMonitoring
   */
  readonly openMonitoring?: ClusterSpecForProviderOpenMonitoring;

  /**
   * Region is which region the Cluster will be created.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * This controls storage mode for supported storage tiers.
   *
   * @schema ClusterSpecForProvider#storageMode
   */
  readonly storageMode?: string;

  /**
   * Create tags when creating the cluster.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerNodeGroupInfo': toJson_ClusterSpecForProviderBrokerNodeGroupInfo(obj.brokerNodeGroupInfo),
    'clientAuthentication': toJson_ClusterSpecForProviderClientAuthentication(obj.clientAuthentication),
    'clusterName': obj.clusterName,
    'clusterPolicy': toJson_ClusterSpecForProviderClusterPolicy(obj.clusterPolicy),
    'configurationInfo': toJson_ClusterSpecForProviderConfigurationInfo(obj.configurationInfo),
    'encryptionInfo': toJson_ClusterSpecForProviderEncryptionInfo(obj.encryptionInfo),
    'enhancedMonitoring': obj.enhancedMonitoring,
    'kafkaVersion': obj.kafkaVersion,
    'loggingInfo': toJson_ClusterSpecForProviderLoggingInfo(obj.loggingInfo),
    'numberOfBrokerNodes': obj.numberOfBrokerNodes,
    'openMonitoring': toJson_ClusterSpecForProviderOpenMonitoring(obj.openMonitoring),
    'region': obj.region,
    'storageMode': obj.storageMode,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the brokers
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfo {
  /**
   * ClientSubnetRefs is a list of references to Subnets used to set the ClientSubnets.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnetRefs
   */
  readonly clientSubnetRefs?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs[];

  /**
   * ClientSubnetSelector selects references to Subnets used to set the ClientSubnets.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnetSelector
   */
  readonly clientSubnetSelector?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnets
   */
  readonly clientSubnets?: string[];

  /**
   * ConnectivityInfo Information about the broker access configuration.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#connectivityInfo
   */
  readonly connectivityInfo?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#instanceType
   */
  readonly instanceType?: string;

  /**
   * SecurityGroupRefs is a list of references to SecurityGroups used to set the SecurityGroups.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroupRefs
   */
  readonly securityGroupRefs?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs[];

  /**
   * SecurityGroupSelector selects references to SecurityGroup used to set the SecurityGroups.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroupSelector
   */
  readonly securityGroupSelector?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * Contains information about storage volumes attached to MSK broker nodes.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#storageInfo
   */
  readonly storageInfo?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientSubnetRefs': obj.clientSubnetRefs?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs(y)),
    'clientSubnetSelector': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector(obj.clientSubnetSelector),
    'clientSubnets': obj.clientSubnets?.map(y => y),
    'connectivityInfo': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo(obj.connectivityInfo),
    'instanceType': obj.instanceType,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'storageInfo': toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo(obj.storageInfo),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Includes all client authentication related information.
 *
 * @schema ClusterSpecForProviderClientAuthentication
 */
export interface ClusterSpecForProviderClientAuthentication {
  /**
   * @schema ClusterSpecForProviderClientAuthentication#sasl
   */
  readonly sasl?: ClusterSpecForProviderClientAuthenticationSasl;

  /**
   * Details for client authentication using TLS.
   *
   * @schema ClusterSpecForProviderClientAuthentication#tls
   */
  readonly tls?: ClusterSpecForProviderClientAuthenticationTls;

  /**
   * Contains information about unauthenticated traffic to the cluster.
   *
   * @schema ClusterSpecForProviderClientAuthentication#unauthenticated
   */
  readonly unauthenticated?: ClusterSpecForProviderClientAuthenticationUnauthenticated;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthentication(obj: ClusterSpecForProviderClientAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sasl': toJson_ClusterSpecForProviderClientAuthenticationSasl(obj.sasl),
    'tls': toJson_ClusterSpecForProviderClientAuthenticationTls(obj.tls),
    'unauthenticated': toJson_ClusterSpecForProviderClientAuthenticationUnauthenticated(obj.unauthenticated),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterPolicy of the MSK cluster.
 *
 * @schema ClusterSpecForProviderClusterPolicy
 */
export interface ClusterSpecForProviderClusterPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema ClusterSpecForProviderClusterPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema ClusterSpecForProviderClusterPolicy#statements
   */
  readonly statements?: ClusterSpecForProviderClusterPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema ClusterSpecForProviderClusterPolicy#version
   */
  readonly version: ClusterSpecForProviderClusterPolicyVersion;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicy(obj: ClusterSpecForProviderClusterPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_ClusterSpecForProviderClusterPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the configuration that you want MSK to use for the cluster.
 *
 * @schema ClusterSpecForProviderConfigurationInfo
 */
export interface ClusterSpecForProviderConfigurationInfo {
  /**
   * ARN of the configuration to use.
   *
   * @schema ClusterSpecForProviderConfigurationInfo#arn
   */
  readonly arn?: string;

  /**
   * ARNRef is a reference to a Kafka Configuration used to set ARN.
   *
   * @schema ClusterSpecForProviderConfigurationInfo#arnRef
   */
  readonly arnRef?: ClusterSpecForProviderConfigurationInfoArnRef;

  /**
   * ARNSelector selects a reference to a Kafka Configuration used to set ARN.
   *
   * @schema ClusterSpecForProviderConfigurationInfo#arnSelector
   */
  readonly arnSelector?: ClusterSpecForProviderConfigurationInfoArnSelector;

  /**
   * @schema ClusterSpecForProviderConfigurationInfo#revision
   */
  readonly revision?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfo(obj: ClusterSpecForProviderConfigurationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_ClusterSpecForProviderConfigurationInfoArnRef(obj.arnRef),
    'arnSelector': toJson_ClusterSpecForProviderConfigurationInfoArnSelector(obj.arnSelector),
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Includes all encryption-related information.
 *
 * @schema ClusterSpecForProviderEncryptionInfo
 */
export interface ClusterSpecForProviderEncryptionInfo {
  /**
   * The data-volume encryption details.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionAtRest
   */
  readonly encryptionAtRest?: ClusterSpecForProviderEncryptionInfoEncryptionAtRest;

  /**
   * The settings for encrypting data in transit.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionInTransit
   */
  readonly encryptionInTransit?: ClusterSpecForProviderEncryptionInfoEncryptionInTransit;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfo(obj: ClusterSpecForProviderEncryptionInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionAtRest': toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRest(obj.encryptionAtRest),
    'encryptionInTransit': toJson_ClusterSpecForProviderEncryptionInfoEncryptionInTransit(obj.encryptionInTransit),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingInfo details.
 *
 * @schema ClusterSpecForProviderLoggingInfo
 */
export interface ClusterSpecForProviderLoggingInfo {
  /**
   * The broker logs configuration for this MSK cluster.
   *
   * @schema ClusterSpecForProviderLoggingInfo#brokerLogs
   */
  readonly brokerLogs?: ClusterSpecForProviderLoggingInfoBrokerLogs;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfo(obj: ClusterSpecForProviderLoggingInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerLogs': toJson_ClusterSpecForProviderLoggingInfoBrokerLogs(obj.brokerLogs),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The settings for open monitoring.
 *
 * @schema ClusterSpecForProviderOpenMonitoring
 */
export interface ClusterSpecForProviderOpenMonitoring {
  /**
   * Prometheus settings.
   *
   * @schema ClusterSpecForProviderOpenMonitoring#prometheus
   */
  readonly prometheus?: ClusterSpecForProviderOpenMonitoringPrometheus;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoring(obj: ClusterSpecForProviderOpenMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prometheus': toJson_ClusterSpecForProviderOpenMonitoringPrometheus(obj.prometheus),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientSubnetSelector selects references to Subnets used to set the ClientSubnets.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectivityInfo Information about the broker access configuration.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo {
  /**
   * Broker public access control.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo#publicAccess
   */
  readonly publicAccess?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess;

  /**
   * Broker VPC connectivity access control.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo#vpcConnectivity
   */
  readonly vpcConnectivity?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicAccess': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess(obj.publicAccess),
    'vpcConnectivity': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity(obj.vpcConnectivity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupSelector selects references to SecurityGroup used to set the SecurityGroups.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information about storage volumes attached to MSK broker nodes.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo {
  /**
   * Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo#ebsStorageInfo
   */
  readonly ebsStorageInfo?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ebsStorageInfo': toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo(obj.ebsStorageInfo),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthenticationSasl
 */
export interface ClusterSpecForProviderClientAuthenticationSasl {
  /**
   * @schema ClusterSpecForProviderClientAuthenticationSasl#iam
   */
  readonly iam?: ClusterSpecForProviderClientAuthenticationSaslIam;

  /**
   * @schema ClusterSpecForProviderClientAuthenticationSasl#scram
   */
  readonly scram?: ClusterSpecForProviderClientAuthenticationSaslScram;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationSasl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationSasl(obj: ClusterSpecForProviderClientAuthenticationSasl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iam': toJson_ClusterSpecForProviderClientAuthenticationSaslIam(obj.iam),
    'scram': toJson_ClusterSpecForProviderClientAuthenticationSaslScram(obj.scram),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details for client authentication using TLS.
 *
 * @schema ClusterSpecForProviderClientAuthenticationTls
 */
export interface ClusterSpecForProviderClientAuthenticationTls {
  /**
   * @schema ClusterSpecForProviderClientAuthenticationTls#certificateAuthorityARNList
   */
  readonly certificateAuthorityArnList?: string[];

  /**
   * @schema ClusterSpecForProviderClientAuthenticationTls#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationTls(obj: ClusterSpecForProviderClientAuthenticationTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityARNList': obj.certificateAuthorityArnList?.map(y => y),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information about unauthenticated traffic to the cluster.
 *
 * @schema ClusterSpecForProviderClientAuthenticationUnauthenticated
 */
export interface ClusterSpecForProviderClientAuthenticationUnauthenticated {
  /**
   * @schema ClusterSpecForProviderClientAuthenticationUnauthenticated#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationUnauthenticated' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationUnauthenticated(obj: ClusterSpecForProviderClientAuthenticationUnauthenticated | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourcePolicyStatement defines an individual statement within the ResourcePolicyBody
 *
 * @schema ClusterSpecForProviderClusterPolicyStatements
 */
export interface ClusterSpecForProviderClusterPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/Amazonresource/latest/dev/amazon-resource-policy-keys.html
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#condition
   */
  readonly condition?: ClusterSpecForProviderClusterPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#effect
   */
  readonly effect: ClusterSpecForProviderClusterPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the resource policy to specify the users which are not included in this policy
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the resource policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#principal
   */
  readonly principal?: ClusterSpecForProviderClusterPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatements(obj: ClusterSpecForProviderClusterPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_ClusterSpecForProviderClusterPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema ClusterSpecForProviderClusterPolicyVersion
 */
export enum ClusterSpecForProviderClusterPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * ARNRef is a reference to a Kafka Configuration used to set ARN.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnRef
 */
export interface ClusterSpecForProviderConfigurationInfoArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderConfigurationInfoArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfoArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfoArnRef(obj: ClusterSpecForProviderConfigurationInfoArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderConfigurationInfoArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ARNSelector selects a reference to a Kafka Configuration used to set ARN.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnSelector
 */
export interface ClusterSpecForProviderConfigurationInfoArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderConfigurationInfoArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfoArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfoArnSelector(obj: ClusterSpecForProviderConfigurationInfoArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderConfigurationInfoArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The data-volume encryption details.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRest
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionAtRest {
  /**
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRest#dataVolumeKMSKeyID
   */
  readonly dataVolumeKmsKeyId?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionAtRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRest(obj: ClusterSpecForProviderEncryptionInfoEncryptionAtRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataVolumeKMSKeyID': obj.dataVolumeKmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The settings for encrypting data in transit.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionInTransit {
  /**
   * Client-broker encryption in transit setting.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit#clientBroker
   */
  readonly clientBroker?: string;

  /**
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit#inCluster
   */
  readonly inCluster?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionInTransit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionInTransit(obj: ClusterSpecForProviderEncryptionInfoEncryptionInTransit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientBroker': obj.clientBroker,
    'inCluster': obj.inCluster,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The broker logs configuration for this MSK cluster.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogs
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogs {
  /**
   * Details of the CloudWatch Logs destination for broker logs.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#cloudWatchLogs
   */
  readonly cloudWatchLogs?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs;

  /**
   * Firehose details for BrokerLogs.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#firehose
   */
  readonly firehose?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehose;

  /**
   * The details of the Amazon S3 destination for broker logs.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#s3
   */
  readonly s3?: ClusterSpecForProviderLoggingInfoBrokerLogsS3;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogs(obj: ClusterSpecForProviderLoggingInfoBrokerLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchLogs': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs(obj.cloudWatchLogs),
    'firehose': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehose(obj.firehose),
    's3': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3(obj.s3),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Prometheus settings.
 *
 * @schema ClusterSpecForProviderOpenMonitoringPrometheus
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheus {
  /**
   * Indicates whether you want to enable or disable the JMX Exporter.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheus#jmxExporter
   */
  readonly jmxExporter?: ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter;

  /**
   * Indicates whether you want to enable or disable the Node Exporter.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheus#nodeExporter
   */
  readonly nodeExporter?: ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheus(obj: ClusterSpecForProviderOpenMonitoringPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxExporter': toJson_ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter(obj.jmxExporter),
    'nodeExporter': toJson_ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter(obj.nodeExporter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Broker public access control.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess {
  /**
   * Type of the public access control.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Broker VPC connectivity access control.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity#clientAuthentication
   */
  readonly clientAuthentication?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuthentication': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication(obj.clientAuthentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
  /**
   * Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo#provisionedThroughput
   */
  readonly provisionedThroughput?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo#volumeSize
   */
  readonly volumeSize?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provisionedThroughput': toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput(obj.provisionedThroughput),
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthenticationSaslIam
 */
export interface ClusterSpecForProviderClientAuthenticationSaslIam {
  /**
   * @schema ClusterSpecForProviderClientAuthenticationSaslIam#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationSaslIam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationSaslIam(obj: ClusterSpecForProviderClientAuthenticationSaslIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthenticationSaslScram
 */
export interface ClusterSpecForProviderClientAuthenticationSaslScram {
  /**
   * @schema ClusterSpecForProviderClientAuthenticationSaslScram#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationSaslScram' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationSaslScram(obj: ClusterSpecForProviderClientAuthenticationSaslScram | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition represents a set of condition pairs for a resource policy
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsCondition
 */
export interface ClusterSpecForProviderClusterPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsCondition#conditions
   */
  readonly conditions: ClusterSpecForProviderClusterPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsCondition(obj: ClusterSpecForProviderClusterPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_ClusterSpecForProviderClusterPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsEffect
 */
export enum ClusterSpecForProviderClusterPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the resource policy to specify the users which are not included in this policy
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipal
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this resource
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipal(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the resource policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipal
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this resource
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipal(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnRefPolicy
 */
export interface ClusterSpecForProviderConfigurationInfoArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderConfigurationInfoArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderConfigurationInfoArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfoArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfoArnRefPolicy(obj: ClusterSpecForProviderConfigurationInfoArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnSelectorPolicy
 */
export interface ClusterSpecForProviderConfigurationInfoArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderConfigurationInfoArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfoArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfoArnSelectorPolicy(obj: ClusterSpecForProviderConfigurationInfoArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details of the CloudWatch Logs destination for broker logs.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs {
  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs#logGroup
   */
  readonly logGroup?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudWatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroup': obj.logGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Firehose details for BrokerLogs.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehose {
  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#deliveryStream
   */
  readonly deliveryStream?: string;

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehose(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryStream': obj.deliveryStream,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The details of the Amazon S3 destination for broker logs.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3 {
  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'enabled': obj.enabled,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether you want to enable or disable the JMX Exporter.
 *
 * @schema ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter {
  /**
   * @schema ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter#enabledInBroker
   */
  readonly enabledInBroker?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter(obj: ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledInBroker': obj.enabledInBroker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether you want to enable or disable the Node Exporter.
 *
 * @schema ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter {
  /**
   * @schema ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter#enabledInBroker
   */
  readonly enabledInBroker?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter(obj: ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledInBroker': obj.enabledInBroker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication#sasl
   */
  readonly sasl?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication#tls
   */
  readonly tls?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sasl': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl(obj.sasl),
    'tls': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput#volumeThroughput
   */
  readonly volumeThroughput?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'volumeThroughput': obj.volumeThroughput,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConditionPair represents one condition inside of the set of conditions for a resource policy
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions
 */
export interface ClusterSpecForProviderClusterPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsConditionConditions(obj: ClusterSpecForProviderClusterPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnRefPolicyResolution
 */
export enum ClusterSpecForProviderConfigurationInfoArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnRefPolicyResolve
 */
export enum ClusterSpecForProviderConfigurationInfoArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderConfigurationInfoArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl#iam
   */
  readonly iam?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam;

  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl#scram
   */
  readonly scram?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iam': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam(obj.iam),
    'scram': toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram(obj.scram),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram {
  /**
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslScram | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderClusterPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Configuration is the Schema for the Configurations API
 *
 * @schema Configuration
 */
export class Configuration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Configuration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.aws.crossplane.io/v1alpha1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "Configuration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProps): any {
    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(props),
    };
  }

  /**
   * Defines a "Configuration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProps) {
    super(scope, id, {
      ...Configuration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(resolved),
    };
  }
}

/**
 * Configuration is the Schema for the Configurations API
 *
 * @schema Configuration
 */
export interface ConfigurationProps {
  /**
   * @schema Configuration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec defines the desired state of Configuration
   *
   * @schema Configuration#spec
   */
  readonly spec: ConfigurationSpec;

}

/**
 * Converts an object of type 'ConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProps(obj: ConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec defines the desired state of Configuration
 *
 * @schema ConfigurationSpec
 */
export interface ConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSpecDeletionPolicy;

  /**
   * ConfigurationParameters defines the desired state of Configuration
   *
   * @schema ConfigurationSpec#forProvider
   */
  readonly forProvider: ConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: ConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpec(obj: ConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationSpecDeletionPolicy
 */
export enum ConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ConfigurationParameters defines the desired state of Configuration
 *
 * @schema ConfigurationSpecForProvider
 */
export interface ConfigurationSpecForProvider {
  /**
   * The description of the configuration.
   *
   * @schema ConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The versions of Apache Kafka with which you can use this MSK configuration.
   *
   * @schema ConfigurationSpecForProvider#kafkaVersions
   */
  readonly kafkaVersions?: string[];

  /**
   * kafka server configurations
   *
   * @schema ConfigurationSpecForProvider#properties
   */
  readonly properties: string[];

  /**
   * Region is which region the Configuration will be created.
   *
   * @schema ConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecForProvider(obj: ConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kafkaVersions': obj.kafkaVersions?.map(y => y),
    'properties': obj.properties?.map(y => y),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConfigurationSpecManagementPolicies
 */
export enum ConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSpecProviderConfigRef
 */
export interface ConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRef(obj: ConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsTo(obj: ConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecWriteConnectionSecretToRef(obj: ConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicy
 */
export interface ConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRefPolicy(obj: ConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

