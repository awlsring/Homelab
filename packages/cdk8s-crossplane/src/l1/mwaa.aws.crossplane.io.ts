// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Environment is the Schema for the Environments API
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mwaa.aws.crossplane.io/v1alpha1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * EnvironmentParameters defines the desired state of Environment
   *
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EnvironmentSpec#managementPolicies
   */
  readonly managementPolicies?: EnvironmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * EnvironmentParameters defines the desired state of Environment
 *
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * A list of key-value pairs containing the Apache Airflow configuration options you want to attach to your environment. For more information, see Apache Airflow configuration options (https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html).
   *
   * @schema EnvironmentSpecForProvider#airflowConfigurationOptions
   */
  readonly airflowConfigurationOptions?: { [key: string]: string };

  /**
   * The Apache Airflow version for your environment. If no value is specified, it defaults to the latest version. Valid values: 1.10.12, 2.0.2, 2.2.2, 2.4.3, and 2.5.1. For more information, see Apache Airflow versions on Amazon Managed Workflows for Apache Airflow (MWAA) (https://docs.aws.amazon.com/mwaa/latest/userguide/airflow-versions.html).
   *
   * @schema EnvironmentSpecForProvider#airflowVersion
   */
  readonly airflowVersion?: string;

  /**
   * The relative path to the DAGs folder on your Amazon S3 bucket. For example, dags. For more information, see Adding or updating DAGs (https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html).
   *
   * @schema EnvironmentSpecForProvider#dagS3Path
   */
  readonly dagS3Path: string;

  /**
   * The environment class type. Valid values: mw1.small, mw1.medium, mw1.large. For more information, see Amazon MWAA environment class (https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html).
   *
   * @schema EnvironmentSpecForProvider#environmentClass
   */
  readonly environmentClass?: string;

  /**
   * The Amazon Resource Name (ARN) of the execution role for your environment. An execution role is an AWS Identity and Access Management (IAM) role that grants MWAA permission to access AWS services and resources used by your environment. For example, arn:aws:iam::123456789:role/my-execution-role. To learn more, see Amazon MWAA Execution role (https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html).
   * This field or SourceBucketARNRef or SourceBucketARNSelector is required.
   *
   * @schema EnvironmentSpecForProvider#executionRoleARN
   */
  readonly executionRoleArn?: string;

  /**
   * ExecutionRoleARNRef is a reference to the ExecutionRoleARN used to set. the SubnetIDs.
   *
   * @schema EnvironmentSpecForProvider#executionRoleARNRef
   */
  readonly executionRoleArnRef?: EnvironmentSpecForProviderExecutionRoleArnRef;

  /**
   * ExecutionRoleARNSelector selects the reference to the ExecutionRoleARN.
   *
   * @schema EnvironmentSpecForProvider#executionRoleARNSelector
   */
  readonly executionRoleArnSelector?: EnvironmentSpecForProviderExecutionRoleArnSelector;

  /**
   * The AWS Key Management Service (KMS) key to encrypt the data in your environment. You can use an AWS owned CMK, or a Customer managed CMK (advanced). To learn more, see Get started with Amazon Managed Workflows for Apache Airflow (https://docs.aws.amazon.com/mwaa/latest/userguide/get-started.html).
   * This field or KMSKeyRef or KMSKeySelector is required.
   *
   * @schema EnvironmentSpecForProvider#kmsKey
   */
  readonly kmsKey?: string;

  /**
   * KMSKeyRef is a reference to the KMSKey used to set. the SubnetIDs.
   *
   * @schema EnvironmentSpecForProvider#kmsKeyRef
   */
  readonly kmsKeyRef?: EnvironmentSpecForProviderKmsKeyRef;

  /**
   * KMSKeySelector selects the reference to the KMSKey.
   *
   * @schema EnvironmentSpecForProvider#kmsKeySelector
   */
  readonly kmsKeySelector?: EnvironmentSpecForProviderKmsKeySelector;

  /**
   * Defines the Apache Airflow logs to send to CloudWatch Logs.
   *
   * @schema EnvironmentSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: EnvironmentSpecForProviderLoggingConfiguration;

  /**
   * The maximum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. For example, 20. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the one worker that is included with your environment, or the number you specify in MinWorkers.
   *
   * @schema EnvironmentSpecForProvider#maxWorkers
   */
  readonly maxWorkers?: number;

  /**
   * The minimum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the MaxWorkers field. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the worker count you specify in the MinWorkers field. For example, 2.
   *
   * @schema EnvironmentSpecForProvider#minWorkers
   */
  readonly minWorkers?: number;

  /**
   * The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see About networking on Amazon MWAA (https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
   *
   * @schema EnvironmentSpecForProvider#networkConfiguration
   */
  readonly networkConfiguration: EnvironmentSpecForProviderNetworkConfiguration;

  /**
   * The version of the plugins.zip file on your Amazon S3 bucket. You must specify a version each time a plugins.zip file is updated. For more information, see How S3 Versioning works (https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
   *
   * @schema EnvironmentSpecForProvider#pluginsS3ObjectVersion
   */
  readonly pluginsS3ObjectVersion?: string;

  /**
   * The relative path to the plugins.zip file on your Amazon S3 bucket. For example, plugins.zip. If specified, then the plugins.zip version is required. For more information, see Installing custom plugins (https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html).
   *
   * @schema EnvironmentSpecForProvider#pluginsS3Path
   */
  readonly pluginsS3Path?: string;

  /**
   * Region is which region the Environment will be created.
   *
   * @schema EnvironmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * The version of the requirements.txt file on your Amazon S3 bucket. You must specify a version each time a requirements.txt file is updated. For more information, see How S3 Versioning works (https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html).
   *
   * @schema EnvironmentSpecForProvider#requirementsS3ObjectVersion
   */
  readonly requirementsS3ObjectVersion?: string;

  /**
   * The relative path to the requirements.txt file on your Amazon S3 bucket. For example, requirements.txt. If specified, then a version is required. For more information, see Installing Python dependencies (https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html).
   *
   * @schema EnvironmentSpecForProvider#requirementsS3Path
   */
  readonly requirementsS3Path?: string;

  /**
   * The number of Apache Airflow schedulers to run in your environment. Valid values:
   * * v2 - Accepts between 2 to 5. Defaults to 2.
   * * v1 - Accepts 1.
   *
   * @default 2.
   * @schema EnvironmentSpecForProvider#schedulers
   */
  readonly schedulers?: number;

  /**
   * The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, arn:aws:s3:::my-airflow-bucket-unique-name. To learn more, see Create an Amazon S3 bucket for Amazon MWAA (https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html).
   * This field or SourceBucketARNRef or SourceBucketARNSelector is required.
   *
   * @schema EnvironmentSpecForProvider#sourceBucketARN
   */
  readonly sourceBucketArn?: string;

  /**
   * SourceBucketARNRef is a reference to the SourceBucketARN used to set. the SubnetIDs.
   *
   * @schema EnvironmentSpecForProvider#sourceBucketARNRef
   */
  readonly sourceBucketArnRef?: EnvironmentSpecForProviderSourceBucketArnRef;

  /**
   * SourceBucketARNSelector selects the reference to the SourceBucketARN.
   *
   * @schema EnvironmentSpecForProvider#sourceBucketARNSelector
   */
  readonly sourceBucketArnSelector?: EnvironmentSpecForProviderSourceBucketArnSelector;

  /**
   * The version of the startup shell script in your Amazon S3 bucket. You must specify the version ID (https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html) that Amazon S3 assigns to the file every time you update the script.
   * Version IDs are Unicode, UTF-8 encoded, URL-ready, opaque strings that are no more than 1,024 bytes long. The following is an example:
   * 3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo
   * For more information, see Using a startup script (https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
   *
   * @schema EnvironmentSpecForProvider#startupScriptS3ObjectVersion
   */
  readonly startupScriptS3ObjectVersion?: string;

  /**
   * The relative path to the startup shell script in your Amazon S3 bucket. For example, s3://mwaa-environment/startup.sh.
   * Amazon MWAA runs the script as your environment starts, and before running the Apache Airflow process. You can use this script to install dependencies, modify Apache Airflow configuration options, and set environment variables. For more information, see Using a startup script (https://docs.aws.amazon.com/mwaa/latest/userguide/using-startup-script.html).
   *
   * @schema EnvironmentSpecForProvider#startupScriptS3Path
   */
  readonly startupScriptS3Path?: string;

  /**
   * The key-value tag pairs you want to associate to your environment. For example, "Environment": "Staging". For more information, see Tagging Amazon Web Services resources (https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
   *
   * @schema EnvironmentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Apache Airflow Web server access mode. For more information, see Apache Airflow access modes (https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html).
   *
   * @schema EnvironmentSpecForProvider#webserverAccessMode
   */
  readonly webserverAccessMode?: string;

  /**
   * The day and time of the week in Coordinated Universal Time (UTC) 24-hour standard time to start weekly maintenance updates of your environment in the following format: DAY:HH:MM. For example: TUE:03:30. You can specify a start time in 30 minute increments only.
   *
   * @schema EnvironmentSpecForProvider#weeklyMaintenanceWindowStart
   */
  readonly weeklyMaintenanceWindowStart?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'airflowConfigurationOptions': ((obj.airflowConfigurationOptions) === undefined) ? undefined : (Object.entries(obj.airflowConfigurationOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'airflowVersion': obj.airflowVersion,
    'dagS3Path': obj.dagS3Path,
    'environmentClass': obj.environmentClass,
    'executionRoleARN': obj.executionRoleArn,
    'executionRoleARNRef': toJson_EnvironmentSpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleARNSelector': toJson_EnvironmentSpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'kmsKey': obj.kmsKey,
    'kmsKeyRef': toJson_EnvironmentSpecForProviderKmsKeyRef(obj.kmsKeyRef),
    'kmsKeySelector': toJson_EnvironmentSpecForProviderKmsKeySelector(obj.kmsKeySelector),
    'loggingConfiguration': toJson_EnvironmentSpecForProviderLoggingConfiguration(obj.loggingConfiguration),
    'maxWorkers': obj.maxWorkers,
    'minWorkers': obj.minWorkers,
    'networkConfiguration': toJson_EnvironmentSpecForProviderNetworkConfiguration(obj.networkConfiguration),
    'pluginsS3ObjectVersion': obj.pluginsS3ObjectVersion,
    'pluginsS3Path': obj.pluginsS3Path,
    'region': obj.region,
    'requirementsS3ObjectVersion': obj.requirementsS3ObjectVersion,
    'requirementsS3Path': obj.requirementsS3Path,
    'schedulers': obj.schedulers,
    'sourceBucketARN': obj.sourceBucketArn,
    'sourceBucketARNRef': toJson_EnvironmentSpecForProviderSourceBucketArnRef(obj.sourceBucketArnRef),
    'sourceBucketARNSelector': toJson_EnvironmentSpecForProviderSourceBucketArnSelector(obj.sourceBucketArnSelector),
    'startupScriptS3ObjectVersion': obj.startupScriptS3ObjectVersion,
    'startupScriptS3Path': obj.startupScriptS3Path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'webserverAccessMode': obj.webserverAccessMode,
    'weeklyMaintenanceWindowStart': obj.weeklyMaintenanceWindowStart,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EnvironmentSpecManagementPolicies
 */
export enum EnvironmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExecutionRoleARNRef is a reference to the ExecutionRoleARN used to set. the SubnetIDs.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnRef
 */
export interface EnvironmentSpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderExecutionRoleArnRef(obj: EnvironmentSpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExecutionRoleARNSelector selects the reference to the ExecutionRoleARN.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnSelector
 */
export interface EnvironmentSpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderExecutionRoleArnSelector(obj: EnvironmentSpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyRef is a reference to the KMSKey used to set. the SubnetIDs.
 *
 * @schema EnvironmentSpecForProviderKmsKeyRef
 */
export interface EnvironmentSpecForProviderKmsKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderKmsKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderKmsKeyRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderKmsKeyRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderKmsKeyRef(obj: EnvironmentSpecForProviderKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderKmsKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeySelector selects the reference to the KMSKey.
 *
 * @schema EnvironmentSpecForProviderKmsKeySelector
 */
export interface EnvironmentSpecForProviderKmsKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderKmsKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderKmsKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderKmsKeySelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderKmsKeySelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderKmsKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderKmsKeySelector(obj: EnvironmentSpecForProviderKmsKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderKmsKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the Apache Airflow logs to send to CloudWatch Logs.
 *
 * @schema EnvironmentSpecForProviderLoggingConfiguration
 */
export interface EnvironmentSpecForProviderLoggingConfiguration {
  /**
   * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
   *
   * @schema EnvironmentSpecForProviderLoggingConfiguration#dagProcessingLogs
   */
  readonly dagProcessingLogs?: EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs;

  /**
   * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
   *
   * @schema EnvironmentSpecForProviderLoggingConfiguration#schedulerLogs
   */
  readonly schedulerLogs?: EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs;

  /**
   * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
   *
   * @schema EnvironmentSpecForProviderLoggingConfiguration#taskLogs
   */
  readonly taskLogs?: EnvironmentSpecForProviderLoggingConfigurationTaskLogs;

  /**
   * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
   *
   * @schema EnvironmentSpecForProviderLoggingConfiguration#webserverLogs
   */
  readonly webserverLogs?: EnvironmentSpecForProviderLoggingConfigurationWebserverLogs;

  /**
   * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
   *
   * @schema EnvironmentSpecForProviderLoggingConfiguration#workerLogs
   */
  readonly workerLogs?: EnvironmentSpecForProviderLoggingConfigurationWorkerLogs;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfiguration(obj: EnvironmentSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dagProcessingLogs': toJson_EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs(obj.dagProcessingLogs),
    'schedulerLogs': toJson_EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs(obj.schedulerLogs),
    'taskLogs': toJson_EnvironmentSpecForProviderLoggingConfigurationTaskLogs(obj.taskLogs),
    'webserverLogs': toJson_EnvironmentSpecForProviderLoggingConfigurationWebserverLogs(obj.webserverLogs),
    'workerLogs': toJson_EnvironmentSpecForProviderLoggingConfigurationWorkerLogs(obj.workerLogs),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see About networking on Amazon MWAA (https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html).
 *
 * @schema EnvironmentSpecForProviderNetworkConfiguration
 */
export interface EnvironmentSpecForProviderNetworkConfiguration {
  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#subnetIdRefs
   */
  readonly subnetIdRefs?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#subnetIdSelector
   */
  readonly subnetIdSelector?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema EnvironmentSpecForProviderNetworkConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfiguration(obj: EnvironmentSpecForProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs(y)),
    'subnetIdSelector': toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceBucketARNRef is a reference to the SourceBucketARN used to set. the SubnetIDs.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnRef
 */
export interface EnvironmentSpecForProviderSourceBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderSourceBucketArnRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderSourceBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderSourceBucketArnRef(obj: EnvironmentSpecForProviderSourceBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderSourceBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceBucketARNSelector selects the reference to the SourceBucketARN.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnSelector
 */
export interface EnvironmentSpecForProviderSourceBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderSourceBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderSourceBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderSourceBucketArnSelector(obj: EnvironmentSpecForProviderSourceBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderSourceBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnRefPolicy
 */
export interface EnvironmentSpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderExecutionRoleArnRefPolicy(obj: EnvironmentSpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy(obj: EnvironmentSpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderKmsKeyRefPolicy
 */
export interface EnvironmentSpecForProviderKmsKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderKmsKeyRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderKmsKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderKmsKeyRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderKmsKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderKmsKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderKmsKeyRefPolicy(obj: EnvironmentSpecForProviderKmsKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderKmsKeySelectorPolicy
 */
export interface EnvironmentSpecForProviderKmsKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderKmsKeySelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderKmsKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderKmsKeySelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderKmsKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderKmsKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderKmsKeySelectorPolicy(obj: EnvironmentSpecForProviderKmsKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
 *
 * @schema EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs
 */
export interface EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs {
  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs(obj: EnvironmentSpecForProviderLoggingConfigurationDagProcessingLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
 *
 * @schema EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs
 */
export interface EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs {
  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs(obj: EnvironmentSpecForProviderLoggingConfigurationSchedulerLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
 *
 * @schema EnvironmentSpecForProviderLoggingConfigurationTaskLogs
 */
export interface EnvironmentSpecForProviderLoggingConfigurationTaskLogs {
  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationTaskLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationTaskLogs#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfigurationTaskLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfigurationTaskLogs(obj: EnvironmentSpecForProviderLoggingConfigurationTaskLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
 *
 * @schema EnvironmentSpecForProviderLoggingConfigurationWebserverLogs
 */
export interface EnvironmentSpecForProviderLoggingConfigurationWebserverLogs {
  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationWebserverLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationWebserverLogs#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfigurationWebserverLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfigurationWebserverLogs(obj: EnvironmentSpecForProviderLoggingConfigurationWebserverLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables the Apache Airflow log type (e.g. DagProcessingLogs) and defines the log level to send to CloudWatch Logs (e.g. INFO).
 *
 * @schema EnvironmentSpecForProviderLoggingConfigurationWorkerLogs
 */
export interface EnvironmentSpecForProviderLoggingConfigurationWorkerLogs {
  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationWorkerLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EnvironmentSpecForProviderLoggingConfigurationWorkerLogs#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderLoggingConfigurationWorkerLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderLoggingConfigurationWorkerLogs(obj: EnvironmentSpecForProviderLoggingConfigurationWorkerLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs#policy
   */
  readonly policy?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs(obj: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector(obj: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs#policy
   */
  readonly policy?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs(obj: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector(obj: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnRefPolicy
 */
export interface EnvironmentSpecForProviderSourceBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderSourceBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderSourceBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderSourceBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderSourceBucketArnRefPolicy(obj: EnvironmentSpecForProviderSourceBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnSelectorPolicy
 */
export interface EnvironmentSpecForProviderSourceBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderSourceBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderSourceBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderSourceBucketArnSelectorPolicy(obj: EnvironmentSpecForProviderSourceBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum EnvironmentSpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderKmsKeyRefPolicyResolution
 */
export enum EnvironmentSpecForProviderKmsKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderKmsKeyRefPolicyResolve
 */
export enum EnvironmentSpecForProviderKmsKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderKmsKeySelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderKmsKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderKmsKeySelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderKmsKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy(obj: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy(obj: EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy(obj: EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy
 */
export interface EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy(obj: EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnRefPolicyResolution
 */
export enum EnvironmentSpecForProviderSourceBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnRefPolicyResolve
 */
export enum EnvironmentSpecForProviderSourceBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderSourceBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolution
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolve
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolution
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolve
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderNetworkConfigurationSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

