// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LifecyclePolicy is the Schema for the LifecyclePolicies API
 *
 * @schema LifecyclePolicy
 */
export class LifecyclePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LifecyclePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.crossplane.io/v1alpha1',
    kind: 'LifecyclePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "LifecyclePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LifecyclePolicyProps): any {
    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(props),
    };
  }

  /**
   * Defines a "LifecyclePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LifecyclePolicyProps) {
    super(scope, id, {
      ...LifecyclePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(resolved),
    };
  }
}

/**
 * LifecyclePolicy is the Schema for the LifecyclePolicies API
 *
 * @schema LifecyclePolicy
 */
export interface LifecyclePolicyProps {
  /**
   * @schema LifecyclePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LifecyclePolicySpec defines the desired state of LifecyclePolicy
   *
   * @schema LifecyclePolicy#spec
   */
  readonly spec: LifecyclePolicySpec;

}

/**
 * Converts an object of type 'LifecyclePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicyProps(obj: LifecyclePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LifecyclePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LifecyclePolicySpec defines the desired state of LifecyclePolicy
 *
 * @schema LifecyclePolicySpec
 */
export interface LifecyclePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecyclePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: LifecyclePolicySpecDeletionPolicy;

  /**
   * LifecyclePolicyParameters defines the desired state of LifecyclePolicy
   *
   * @schema LifecyclePolicySpec#forProvider
   */
  readonly forProvider: LifecyclePolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LifecyclePolicySpec#managementPolicies
   */
  readonly managementPolicies?: LifecyclePolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LifecyclePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: LifecyclePolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LifecyclePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LifecyclePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LifecyclePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LifecyclePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LifecyclePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpec(obj: LifecyclePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LifecyclePolicySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LifecyclePolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecyclePolicySpecDeletionPolicy
 */
export enum LifecyclePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * LifecyclePolicyParameters defines the desired state of LifecyclePolicy
 *
 * @schema LifecyclePolicySpecForProvider
 */
export interface LifecyclePolicySpecForProvider {
  /**
   * The JSON repository policy text to apply to the repository.
   *
   * @schema LifecyclePolicySpecForProvider#lifecyclePolicyText
   */
  readonly lifecyclePolicyText: string;

  /**
   * Region is which region the LifecyclePolicy will be created.
   *
   * @schema LifecyclePolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
   *
   * @schema LifecyclePolicySpecForProvider#registryID
   */
  readonly registryId?: string;

  /**
   * RepositoryName is the name of the Repository that the policy should attach to
   *
   * @schema LifecyclePolicySpecForProvider#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * RepositoryNameRef is the name of the Repository that the policy should attach to
   *
   * @schema LifecyclePolicySpecForProvider#repositoryNameRef
   */
  readonly repositoryNameRef?: LifecyclePolicySpecForProviderRepositoryNameRef;

  /**
   * RepositoryNameSelector selects a references to the Repository the policy should attach to
   *
   * @schema LifecyclePolicySpecForProvider#repositoryNameSelector
   */
  readonly repositoryNameSelector?: LifecyclePolicySpecForProviderRepositoryNameSelector;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProvider(obj: LifecyclePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lifecyclePolicyText': obj.lifecyclePolicyText,
    'region': obj.region,
    'registryID': obj.registryId,
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_LifecyclePolicySpecForProviderRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_LifecyclePolicySpecForProviderRepositoryNameSelector(obj.repositoryNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LifecyclePolicySpecManagementPolicies
 */
export enum LifecyclePolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LifecyclePolicySpecProviderConfigRef
 */
export interface LifecyclePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRef(obj: LifecyclePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsTo
 */
export interface LifecyclePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LifecyclePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LifecyclePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj: LifecyclePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LifecyclePolicySpecWriteConnectionSecretToRef
 */
export interface LifecyclePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj: LifecyclePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryNameRef is the name of the Repository that the policy should attach to
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameRef
 */
export interface LifecyclePolicySpecForProviderRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameRef#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryNameRef(obj: LifecyclePolicySpecForProviderRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecForProviderRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryNameSelector selects a references to the Repository the policy should attach to
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameSelector
 */
export interface LifecyclePolicySpecForProviderRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameSelector#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryNameSelector(obj: LifecyclePolicySpecForProviderRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicy
 */
export interface LifecyclePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj: LifecyclePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj: LifecyclePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameRefPolicy
 */
export interface LifecyclePolicySpecForProviderRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryNameRefPolicy(obj: LifecyclePolicySpecForProviderRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy
 */
export interface LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy(obj: LifecyclePolicySpecForProviderRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolution
 */
export enum LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolve
 */
export enum LifecyclePolicySpecForProviderRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolution
 */
export enum LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolve
 */
export enum LifecyclePolicySpecForProviderRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Repository is a managed resource that represents an Elastic Container Repository Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema Repository
 */
export class Repository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Repository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.crossplane.io/v1alpha1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "Repository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryProps): any {
    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(props),
    };
  }

  /**
   * Defines a "Repository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryProps) {
    super(scope, id, {
      ...Repository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(resolved),
    };
  }
}

/**
 * A Repository is a managed resource that represents an Elastic Container Repository Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema Repository
 */
export interface RepositoryProps {
  /**
   * @schema Repository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RepositorySpec defines the desired state of a Elastic Container Repository.
   *
   * @schema Repository#spec
   */
  readonly spec: RepositorySpec;

}

/**
 * Converts an object of type 'RepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryProps(obj: RepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RepositorySpec defines the desired state of a Elastic Container Repository.
 *
 * @schema RepositorySpec
 */
export interface RepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositorySpecDeletionPolicy;

  /**
   * RepositoryParameters define the desired state of an AWS Elastic Container Repository
   *
   * @schema RepositorySpec#forProvider
   */
  readonly forProvider: RepositorySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RepositorySpec#managementPolicies
   */
  readonly managementPolicies?: RepositorySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositorySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpec(obj: RepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositorySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RepositorySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositorySpecDeletionPolicy
 */
export enum RepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RepositoryParameters define the desired state of an AWS Elastic Container Repository
 *
 * @schema RepositorySpecForProvider
 */
export interface RepositorySpecForProvider {
  /**
   * If a repository contains images, forces the deletion.
   *
   * @schema RepositorySpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
   *
   * @schema RepositorySpecForProvider#imageScanningConfiguration
   */
  readonly imageScanningConfiguration?: RepositorySpecForProviderImageScanningConfiguration;

  /**
   * The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
   *
   * @schema RepositorySpecForProvider#imageTagMutability
   */
  readonly imageTagMutability?: RepositorySpecForProviderImageTagMutability;

  /**
   * Region is the region you'd like your Repository to be created in.
   *
   * @schema RepositorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Metadata tagging key value pairs
   *
   * @schema RepositorySpecForProvider#tags
   */
  readonly tags?: RepositorySpecForProviderTags[];

}

/**
 * Converts an object of type 'RepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProvider(obj: RepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDelete': obj.forceDelete,
    'imageScanningConfiguration': toJson_RepositorySpecForProviderImageScanningConfiguration(obj.imageScanningConfiguration),
    'imageTagMutability': obj.imageTagMutability,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_RepositorySpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RepositorySpecManagementPolicies
 */
export enum RepositorySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositorySpecProviderConfigRef
 */
export interface RepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderConfigRef#policy
   */
  readonly policy?: RepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRef(obj: RepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositorySpecPublishConnectionDetailsTo
 */
export interface RepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsTo(obj: RepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositorySpecWriteConnectionSecretToRef
 */
export interface RepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecWriteConnectionSecretToRef(obj: RepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
 *
 * @schema RepositorySpecForProviderImageScanningConfiguration
 */
export interface RepositorySpecForProviderImageScanningConfiguration {
  /**
   * The setting that determines whether images are scanned after being pushed to a repository. If set to true, images will be scanned after being pushed. If this parameter is not specified, it will default to false and images will not be scanned unless a scan is manually started with the StartImageScan API.
   *
   * @schema RepositorySpecForProviderImageScanningConfiguration#scanOnPush
   */
  readonly scanOnPush: boolean;

}

/**
 * Converts an object of type 'RepositorySpecForProviderImageScanningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderImageScanningConfiguration(obj: RepositorySpecForProviderImageScanningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scanOnPush': obj.scanOnPush,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
 *
 * @schema RepositorySpecForProviderImageTagMutability
 */
export enum RepositorySpecForProviderImageTagMutability {
  /** MUTABLE */
  MUTABLE = "MUTABLE",
  /** IMMUTABLE */
  IMMUTABLE = "IMMUTABLE",
}

/**
 * Tag defines a tag
 *
 * @schema RepositorySpecForProviderTags
 */
export interface RepositorySpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema RepositorySpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema RepositorySpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderTags(obj: RepositorySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderConfigRefPolicy
 */
export interface RepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRefPolicy(obj: RepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj: RepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToMetadata
 */
export interface RepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj: RepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolution
 */
export enum RepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolve
 */
export enum RepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Repository is a managed resource that represents an Elastic Container Repository
 *
 * @schema RepositoryV1Beta1
 */
export class RepositoryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RepositoryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.crossplane.io/v1beta1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "RepositoryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryV1Beta1Props): any {
    return {
      ...RepositoryV1Beta1.GVK,
      ...toJson_RepositoryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "RepositoryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryV1Beta1Props) {
    super(scope, id, {
      ...RepositoryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RepositoryV1Beta1.GVK,
      ...toJson_RepositoryV1Beta1Props(resolved),
    };
  }
}

/**
 * A Repository is a managed resource that represents an Elastic Container Repository
 *
 * @schema RepositoryV1Beta1
 */
export interface RepositoryV1Beta1Props {
  /**
   * @schema RepositoryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RepositorySpec defines the desired state of a Elastic Container Repository.
   *
   * @schema RepositoryV1Beta1#spec
   */
  readonly spec: RepositoryV1Beta1Spec;

}

/**
 * Converts an object of type 'RepositoryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1Props(obj: RepositoryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositoryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RepositorySpec defines the desired state of a Elastic Container Repository.
 *
 * @schema RepositoryV1Beta1Spec
 */
export interface RepositoryV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositoryV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: RepositoryV1Beta1SpecDeletionPolicy;

  /**
   * RepositoryParameters define the desired state of an AWS Elastic Container Repository
   *
   * @schema RepositoryV1Beta1Spec#forProvider
   */
  readonly forProvider: RepositoryV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RepositoryV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: RepositoryV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositoryV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: RepositoryV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositoryV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositoryV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositoryV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositoryV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositoryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1Spec(obj: RepositoryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositoryV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RepositoryV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RepositoryV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositoryV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositoryV1Beta1SpecDeletionPolicy
 */
export enum RepositoryV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RepositoryParameters define the desired state of an AWS Elastic Container Repository
 *
 * @schema RepositoryV1Beta1SpecForProvider
 */
export interface RepositoryV1Beta1SpecForProvider {
  /**
   * If a repository contains images, forces the deletion.
   *
   * @schema RepositoryV1Beta1SpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
   *
   * @schema RepositoryV1Beta1SpecForProvider#imageScanningConfiguration
   */
  readonly imageScanningConfiguration?: RepositoryV1Beta1SpecForProviderImageScanningConfiguration;

  /**
   * The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
   *
   * @schema RepositoryV1Beta1SpecForProvider#imageTagMutability
   */
  readonly imageTagMutability?: RepositoryV1Beta1SpecForProviderImageTagMutability;

  /**
   * Region is the region you'd like your Repository to be created in.
   *
   * @schema RepositoryV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * Metadata tagging key value pairs
   *
   * @schema RepositoryV1Beta1SpecForProvider#tags
   */
  readonly tags?: RepositoryV1Beta1SpecForProviderTags[];

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecForProvider(obj: RepositoryV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDelete': obj.forceDelete,
    'imageScanningConfiguration': toJson_RepositoryV1Beta1SpecForProviderImageScanningConfiguration(obj.imageScanningConfiguration),
    'imageTagMutability': obj.imageTagMutability,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_RepositoryV1Beta1SpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RepositoryV1Beta1SpecManagementPolicies
 */
export enum RepositoryV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositoryV1Beta1SpecProviderConfigRef
 */
export interface RepositoryV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: RepositoryV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecProviderConfigRef(obj: RepositoryV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsTo
 */
export interface RepositoryV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecPublishConnectionDetailsTo(obj: RepositoryV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositoryV1Beta1SpecWriteConnectionSecretToRef
 */
export interface RepositoryV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositoryV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositoryV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecWriteConnectionSecretToRef(obj: RepositoryV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
 *
 * @schema RepositoryV1Beta1SpecForProviderImageScanningConfiguration
 */
export interface RepositoryV1Beta1SpecForProviderImageScanningConfiguration {
  /**
   * The setting that determines whether images are scanned after being pushed to a repository. If set to true, images will be scanned after being pushed. If this parameter is not specified, it will default to false and images will not be scanned unless a scan is manually started with the StartImageScan API.
   *
   * @schema RepositoryV1Beta1SpecForProviderImageScanningConfiguration#scanOnPush
   */
  readonly scanOnPush: boolean;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecForProviderImageScanningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecForProviderImageScanningConfiguration(obj: RepositoryV1Beta1SpecForProviderImageScanningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scanOnPush': obj.scanOnPush,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
 *
 * @schema RepositoryV1Beta1SpecForProviderImageTagMutability
 */
export enum RepositoryV1Beta1SpecForProviderImageTagMutability {
  /** MUTABLE */
  MUTABLE = "MUTABLE",
  /** IMMUTABLE */
  IMMUTABLE = "IMMUTABLE",
}

/**
 * Tag defines a tag
 *
 * @schema RepositoryV1Beta1SpecForProviderTags
 */
export interface RepositoryV1Beta1SpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema RepositoryV1Beta1SpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema RepositoryV1Beta1SpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecForProviderTags(obj: RepositoryV1Beta1SpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryV1Beta1SpecProviderConfigRefPolicy
 */
export interface RepositoryV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecProviderConfigRefPolicy(obj: RepositoryV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata(obj: RepositoryV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum RepositoryV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum RepositoryV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositoryV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A RepositoryPolicy is a managed resource that represents an Elastic Container Repository Policy Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema RepositoryPolicy
 */
export class RepositoryPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RepositoryPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.crossplane.io/v1alpha1',
    kind: 'RepositoryPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "RepositoryPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryPolicyProps): any {
    return {
      ...RepositoryPolicy.GVK,
      ...toJson_RepositoryPolicyProps(props),
    };
  }

  /**
   * Defines a "RepositoryPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryPolicyProps) {
    super(scope, id, {
      ...RepositoryPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RepositoryPolicy.GVK,
      ...toJson_RepositoryPolicyProps(resolved),
    };
  }
}

/**
 * A RepositoryPolicy is a managed resource that represents an Elastic Container Repository Policy Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema RepositoryPolicy
 */
export interface RepositoryPolicyProps {
  /**
   * @schema RepositoryPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RepositoryPolicySpec defines the desired state of a Elastic Container Repository.
   *
   * @schema RepositoryPolicy#spec
   */
  readonly spec: RepositoryPolicySpec;

}

/**
 * Converts an object of type 'RepositoryPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyProps(obj: RepositoryPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositoryPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RepositoryPolicySpec defines the desired state of a Elastic Container Repository.
 *
 * @schema RepositoryPolicySpec
 */
export interface RepositoryPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositoryPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositoryPolicySpecDeletionPolicy;

  /**
   * RepositoryPolicyParameters define the desired state of an AWS Elastic Container Repository
   *
   * @schema RepositoryPolicySpec#forProvider
   */
  readonly forProvider: RepositoryPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RepositoryPolicySpec#managementPolicies
   */
  readonly managementPolicies?: RepositoryPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositoryPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositoryPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositoryPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositoryPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositoryPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositoryPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositoryPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpec(obj: RepositoryPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositoryPolicySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RepositoryPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RepositoryPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositoryPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositoryPolicySpecDeletionPolicy
 */
export enum RepositoryPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RepositoryPolicyParameters define the desired state of an AWS Elastic Container Repository
 *
 * @schema RepositoryPolicySpecForProvider
 */
export interface RepositoryPolicySpecForProvider {
  /**
   * If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
   *
   * @schema RepositoryPolicySpecForProvider#force
   */
  readonly force?: boolean;

  /**
   * Policy is a well defined type which can be parsed into an JSON Repository Policy either policy or rawPolicy must be specified in the policy
   *
   * @schema RepositoryPolicySpecForProvider#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicy;

  /**
   * Policy stringified version of JSON repository policy either policy or rawPolicy must be specified in the policy
   *
   * @schema RepositoryPolicySpecForProvider#rawPolicy
   */
  readonly rawPolicy?: string;

  /**
   * Region is the region you'd like your RepositoryPolicy to be created in.
   *
   * @schema RepositoryPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
   *
   * @schema RepositoryPolicySpecForProvider#registryId
   */
  readonly registryId?: string;

  /**
   * The name of the repository to receive the policy.
   * One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicySpecForProvider#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * A referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicySpecForProvider#repositoryNameRef
   */
  readonly repositoryNameRef?: RepositoryPolicySpecForProviderRepositoryNameRef;

  /**
   * A selector to select a referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicySpecForProvider#repositoryNameSelector
   */
  readonly repositoryNameSelector?: RepositoryPolicySpecForProviderRepositoryNameSelector;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProvider(obj: RepositoryPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': obj.force,
    'policy': toJson_RepositoryPolicySpecForProviderPolicy(obj.policy),
    'rawPolicy': obj.rawPolicy,
    'region': obj.region,
    'registryId': obj.registryId,
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_RepositoryPolicySpecForProviderRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_RepositoryPolicySpecForProviderRepositoryNameSelector(obj.repositoryNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RepositoryPolicySpecManagementPolicies
 */
export enum RepositoryPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositoryPolicySpecProviderConfigRef
 */
export interface RepositoryPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecProviderConfigRef#policy
   */
  readonly policy?: RepositoryPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderConfigRef(obj: RepositoryPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsTo
 */
export interface RepositoryPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositoryPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositoryPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsTo(obj: RepositoryPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositoryPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositoryPolicySpecWriteConnectionSecretToRef
 */
export interface RepositoryPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositoryPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositoryPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecWriteConnectionSecretToRef(obj: RepositoryPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy is a well defined type which can be parsed into an JSON Repository Policy either policy or rawPolicy must be specified in the policy
 *
 * @schema RepositoryPolicySpecForProviderPolicy
 */
export interface RepositoryPolicySpecForProviderPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema RepositoryPolicySpecForProviderPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema RepositoryPolicySpecForProviderPolicy#statements
   */
  readonly statements?: RepositoryPolicySpecForProviderPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema RepositoryPolicySpecForProviderPolicy#version
   */
  readonly version: RepositoryPolicySpecForProviderPolicyVersion;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicy(obj: RepositoryPolicySpecForProviderPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_RepositoryPolicySpecForProviderPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameRef
 */
export interface RepositoryPolicySpecForProviderRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryNameRef(obj: RepositoryPolicySpecForProviderRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameSelector
 */
export interface RepositoryPolicySpecForProviderRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameSelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryNameSelector(obj: RepositoryPolicySpecForProviderRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicy
 */
export interface RepositoryPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderConfigRefPolicy(obj: RepositoryPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRef(obj: RepositoryPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToMetadata(obj: RepositoryPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryPolicyStatement defines an individual statement within the RepositoryPolicyBody
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatements
 */
export interface RepositoryPolicySpecForProviderPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonelasticcontainerregistry.html#amazonelasticcontainerregistry-policy-keys
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#condition
   */
  readonly condition?: RepositoryPolicySpecForProviderPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#effect
   */
  readonly effect: RepositoryPolicySpecForProviderPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the Repository policy to specify the users which are not included in this policy
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the Repository policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#principal
   */
  readonly principal?: RepositoryPolicySpecForProviderPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatements(obj: RepositoryPolicySpecForProviderPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_RepositoryPolicySpecForProviderPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema RepositoryPolicySpecForProviderPolicyVersion
 */
export enum RepositoryPolicySpecForProviderPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameRefPolicy
 */
export interface RepositoryPolicySpecForProviderRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryNameRefPolicy(obj: RepositoryPolicySpecForProviderRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy
 */
export interface RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy(obj: RepositoryPolicySpecForProviderRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicyResolution
 */
export enum RepositoryPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicyResolve
 */
export enum RepositoryPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition represents a set of condition pairs for a Repository policy
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsCondition
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsCondition#conditions
   */
  readonly conditions: RepositoryPolicySpecForProviderPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsCondition(obj: RepositoryPolicySpecForProviderPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_RepositoryPolicySpecForProviderPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsEffect
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the Repository policy to specify the users which are not included in this policy
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users. Principal: "*"
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * Raw string input can be used for *
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal#raw
   */
  readonly raw?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'raw': obj.raw,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the Repository policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipal
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users. Principal: "*"
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * Raw string input can be used for *
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipal#raw
   */
  readonly raw?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipal(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals(y)),
    'raw': obj.raw,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * ConditionPair represents one condition inside of the set of conditions for a Repository policy
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsConditionConditions(obj: RepositoryPolicySpecForProviderPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A RepositoryPolicy is a managed resource that represents an Elastic Container Repository Policy
 *
 * @schema RepositoryPolicyV1Beta1
 */
export class RepositoryPolicyV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RepositoryPolicyV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.crossplane.io/v1beta1',
    kind: 'RepositoryPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "RepositoryPolicyV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryPolicyV1Beta1Props): any {
    return {
      ...RepositoryPolicyV1Beta1.GVK,
      ...toJson_RepositoryPolicyV1Beta1Props(props),
    };
  }

  /**
   * Defines a "RepositoryPolicyV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryPolicyV1Beta1Props) {
    super(scope, id, {
      ...RepositoryPolicyV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RepositoryPolicyV1Beta1.GVK,
      ...toJson_RepositoryPolicyV1Beta1Props(resolved),
    };
  }
}

/**
 * A RepositoryPolicy is a managed resource that represents an Elastic Container Repository Policy
 *
 * @schema RepositoryPolicyV1Beta1
 */
export interface RepositoryPolicyV1Beta1Props {
  /**
   * @schema RepositoryPolicyV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RepositoryPolicySpec defines the desired state of a Elastic Container Repository.
   *
   * @schema RepositoryPolicyV1Beta1#spec
   */
  readonly spec: RepositoryPolicyV1Beta1Spec;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1Props(obj: RepositoryPolicyV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositoryPolicyV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RepositoryPolicySpec defines the desired state of a Elastic Container Repository.
 *
 * @schema RepositoryPolicyV1Beta1Spec
 */
export interface RepositoryPolicyV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositoryPolicyV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: RepositoryPolicyV1Beta1SpecDeletionPolicy;

  /**
   * RepositoryPolicyParameters define the desired state of an AWS Elastic Container Repository
   *
   * @schema RepositoryPolicyV1Beta1Spec#forProvider
   */
  readonly forProvider: RepositoryPolicyV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RepositoryPolicyV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: RepositoryPolicyV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositoryPolicyV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: RepositoryPolicyV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositoryPolicyV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositoryPolicyV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1Spec(obj: RepositoryPolicyV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositoryPolicyV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RepositoryPolicyV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositoryPolicyV1Beta1SpecDeletionPolicy
 */
export enum RepositoryPolicyV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RepositoryPolicyParameters define the desired state of an AWS Elastic Container Repository
 *
 * @schema RepositoryPolicyV1Beta1SpecForProvider
 */
export interface RepositoryPolicyV1Beta1SpecForProvider {
  /**
   * If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#force
   */
  readonly force?: boolean;

  /**
   * Policy is a well defined type which can be parsed into an JSON Repository Policy either policy or rawPolicy must be specified in the policy
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicy;

  /**
   * Policy stringified version of JSON repository policy either policy or rawPolicy must be specified in the policy
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#rawPolicy
   */
  readonly rawPolicy?: string;

  /**
   * Region is the region you'd like your RepositoryPolicy to be created in.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#registryId
   */
  readonly registryId?: string;

  /**
   * The name of the repository to receive the policy.
   * One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * A referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#repositoryNameRef
   */
  readonly repositoryNameRef?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef;

  /**
   * A selector to select a referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProvider#repositoryNameSelector
   */
  readonly repositoryNameSelector?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProvider(obj: RepositoryPolicyV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': obj.force,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicy(obj.policy),
    'rawPolicy': obj.rawPolicy,
    'region': obj.region,
    'registryId': obj.registryId,
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector(obj.repositoryNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RepositoryPolicyV1Beta1SpecManagementPolicies
 */
export enum RepositoryPolicyV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositoryPolicyV1Beta1SpecProviderConfigRef
 */
export interface RepositoryPolicyV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecProviderConfigRef(obj: RepositoryPolicyV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo
 */
export interface RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo(obj: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef
 */
export interface RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef(obj: RepositoryPolicyV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy is a well defined type which can be parsed into an JSON Repository Policy either policy or rawPolicy must be specified in the policy
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicy#statements
   */
  readonly statements?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicy#version
   */
  readonly version: RepositoryPolicyV1Beta1SpecForProviderPolicyVersion;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef
 */
export interface RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef(obj: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the name of a repository One of RepositoryName, RepositoryNameRef, or RepositoryNameSelector is required.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector
 */
export interface RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector(obj: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy(obj: RepositoryPolicyV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata(obj: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryPolicyStatement defines an individual statement within the RepositoryPolicyBody
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonelasticcontainerregistry.html#amazonelasticcontainerregistry-policy-keys
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#condition
   */
  readonly condition?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#effect
   */
  readonly effect: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the Repository policy to specify the users which are not included in this policy
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the Repository policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#principal
   */
  readonly principal?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatements(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyVersion
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition represents a set of condition pairs for a Repository policy
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition#conditions
   */
  readonly conditions: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsEffect
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the Repository policy to specify the users which are not included in this policy
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users. Principal: "*"
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * Raw string input can be used for *
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal#raw
   */
  readonly raw?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'raw': obj.raw,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the Repository policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users. Principal: "*"
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * Raw string input can be used for *
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal#raw
   */
  readonly raw?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals(y)),
    'raw': obj.raw,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * ConditionPair represents one condition inside of the set of conditions for a Repository policy
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum RepositoryPolicyV1Beta1SpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

