// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export class DbCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'DBCluster',
  }

  /**
   * Renders a Kubernetes manifest for "DBCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbClusterProps): any {
    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(props),
    };
  }

  /**
   * Defines a "DBCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbClusterProps) {
    super(scope, id, {
      ...DbCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(resolved),
    };
  }
}

/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export interface DbClusterProps {
  /**
   * @schema DBCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBClusterSpec defines the desired state of DBCluster
   *
   * @schema DBCluster#spec
   */
  readonly spec: DbClusterSpec;

}

/**
 * Converts an object of type 'DbClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterProps(obj: DbClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterSpec defines the desired state of DBCluster
 *
 * @schema DbClusterSpec
 */
export interface DbClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbClusterSpecDeletionPolicy;

  /**
   * DBClusterParameters defines the desired state of DBCluster
   *
   * @schema DbClusterSpec#forProvider
   */
  readonly forProvider: DbClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbClusterSpec#managementPolicies
   */
  readonly managementPolicies?: DbClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpec(obj: DbClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbClusterSpecDeletionPolicy
 */
export enum DbClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBClusterParameters defines the desired state of DBCluster
 *
 * @schema DbClusterSpecForProvider
 */
export interface DbClusterSpecForProvider {
  /**
   * The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   * This setting is required to create a Multi-AZ DB cluster.
   *
   * @schema DbClusterSpecForProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Specifies whether major version upgrades are allowed.
   * Valid for Cluster Type: Aurora DB clusters only
   * Constraints:
   * * You must allow major version upgrades when specifying a value for the EngineVersion parameter that is a different major version than the DB cluster's current version.
   *
   * @schema DbClusterSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB cluster. If this parameter is disabled, changes to the DB cluster are applied during the next maintenance window.
   * The ApplyImmediately parameter only affects the EnableIAMDatabaseAuthentication, MasterUserPassword values. If the ApplyImmediately parameter is disabled, then changes to the EnableIAMDatabaseAuthentication, MasterUserPassword values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter.
   * By default, this parameter is disabled.
   *
   * @schema DbClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Specifies whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   *
   * @schema DbClusterSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * AutogeneratePassword indicates whether the controller should generate a random password for the master user if one is not provided via MasterUserPasswordSecretRef.
   * If a password is generated, it will be stored as a secret at the location specified by MasterUserPasswordSecretRef.
   *
   * @schema DbClusterSpecForProvider#autogeneratePassword
   */
  readonly autogeneratePassword?: boolean;

  /**
   * A list of Availability Zones (AZs) where DB instances in the DB cluster can be created.
   * For information on Amazon Web Services Regions and Availability Zones, see Choosing the Regions and Availability Zones (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The target backtrack window, in seconds. To disable backtracking, set this value to 0.
   * Valid for Cluster Type: Aurora MySQL DB clusters only
   * Default: 0
   * Constraints:
   * * If specified, this value must be set to a number from 0 to 259,200 (72 hours).
   *
   * @schema DbClusterSpecForProvider#backtrackWindow
   */
  readonly backtrackWindow?: number;

  /**
   * The number of days for which automated backups are retained.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Default: 1
   * Constraints:
   * * Must be a value from 1 to 35.
   *
   * @schema DbClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * The name of the character set (CharacterSet) to associate the DB cluster with.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#characterSetName
   */
  readonly characterSetName?: string;

  /**
   * Specifies whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The name for your database of up to 64 alphanumeric characters. If you don't provide a name, Amazon RDS doesn't create a database in the DB cluster you are creating.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines.
   * For the full list of DB instance classes and availability for your engine, see DB instance class (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide.
   * This setting is required to create a Multi-AZ DB cluster.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   *
   * @schema DbClusterSpecForProvider#dbClusterInstanceClass
   */
  readonly dbClusterInstanceClass?: string;

  /**
   * The name of the DB cluster parameter group to associate with this DB cluster. If you don't specify a value, then the default DB cluster parameter group for the specified DB engine and version is used.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Constraints:
   * * If supplied, must match the name of an existing DB cluster parameter group.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * DBClusterParameterGroupNameRef is a reference to a DBClusterParameterGroup used to set DBClusterParameterGroupName.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupNameRef
   */
  readonly dbClusterParameterGroupNameRef?: DbClusterSpecForProviderDbClusterParameterGroupNameRef;

  /**
   * DBClusterParameterGroupNameSelector selects a reference to a DBClusterParameterGroup used to set DBClusterParameterGroupName.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupNameSelector
   */
  readonly dbClusterParameterGroupNameSelector?: DbClusterSpecForProviderDbClusterParameterGroupNameSelector;

  /**
   * A DB subnet group to associate with this DB cluster.
   * This setting is required to create a Multi-AZ DB cluster.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Constraints:
   * * Must match the name of an existing DB subnet group.
   * * Must not be default.
   * Example: mydbsubnetgroup
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * DBSubnetGroupNameRef is a reference to a DBSubnetGroup used to set DBSubnetGroupName.
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: DbClusterSpecForProviderDbSubnetGroupNameRef;

  /**
   * DBSubnetGroupNameSelector selects a reference to a DBSubnetGroup used to set DBSubnetGroupName.
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: DbClusterSpecForProviderDbSubnetGroupNameSelector;

  /**
   * Reserved for future use.
   *
   * @schema DbClusterSpecForProvider#dbSystemID
   */
  readonly dbSystemId?: string;

  /**
   * Specifies whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * DestinationRegion is used for presigning the request to a given region.
   *
   * @schema DbClusterSpecForProvider#destinationRegion
   */
  readonly destinationRegion?: string;

  /**
   * The Active Directory directory ID to create the DB cluster in.
   * For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster.
   * For more information, see Kerberos authentication (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * The name of the IAM role to use when making API calls to the Directory Service.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#domainIAMRoleName
   */
  readonly domainIamRoleName?: string;

  /**
   * DomainIAMRoleNameRef is a reference to an IAMRole used to set DomainIAMRoleName.
   *
   * @schema DbClusterSpecForProvider#domainIAMRoleNameRef
   */
  readonly domainIamRoleNameRef?: DbClusterSpecForProviderDomainIamRoleNameRef;

  /**
   * DomainIAMRoleNameSelector selects a reference to an IAMRole used to set DomainIAMRoleName.
   *
   * @schema DbClusterSpecForProvider#domainIAMRoleNameSelector
   */
  readonly domainIamRoleNameSelector?: DbClusterSpecForProviderDomainIamRoleNameSelector;

  /**
   * The list of log types that need to be enabled for exporting to CloudWatch Logs.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * The following values are valid for each DB engine:
   * * Aurora MySQL - audit | error | general | slowquery
   * * Aurora PostgreSQL - postgresql
   * * RDS for MySQL - error | general | slowquery
   * * RDS for PostgreSQL - postgresql | upgrade
   * For more information about exporting CloudWatch Logs for Amazon RDS, see Publishing Database Logs to Amazon CloudWatch Logs (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide.
   * For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon Aurora User Guide.
   *
   * @schema DbClusterSpecForProvider#enableCloudwatchLogsExports
   */
  readonly enableCloudwatchLogsExports?: string[];

  /**
   * Specifies whether to enable this DB cluster to forward write operations to the primary cluster of a global cluster (Aurora global database). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database.
   * You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter enabled, a secondary cluster can forward writes to the current primary cluster, and the resulting changes are replicated back to this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is demoted by a global cluster API operation, but it does nothing until then.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#enableGlobalWriteForwarding
   */
  readonly enableGlobalWriteForwarding?: boolean;

  /**
   * Specifies whether to enable the HTTP endpoint for an Aurora Serverless v1 DB cluster. By default, the HTTP endpoint is disabled.
   * When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless v1 DB cluster. You can also query your database from inside the RDS console with the query editor.
   * For more information, see Using the Data API for Aurora Serverless v1 (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#enableHTTPEndpoint
   */
  readonly enableHttpEndpoint?: boolean;

  /**
   * Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled.
   * For more information, see IAM Database Authentication (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#enableIAMDatabaseAuthentication
   */
  readonly enableIamDatabaseAuthentication?: boolean;

  /**
   * Specifies whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances.
   * Valid for: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#enableLocalWriteForwarding
   */
  readonly enableLocalWriteForwarding?: boolean;

  /**
   * Specifies whether to turn on Performance Insights for the DB cluster.
   * For more information, see Using Amazon Performance Insights (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon RDS User Guide.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   *
   * @schema DbClusterSpecForProvider#enablePerformanceInsights
   */
  readonly enablePerformanceInsights?: boolean;

  /**
   * The database engine to use for this DB cluster.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Valid Values: aurora-mysql | aurora-postgresql | mysql | postgres
   *
   * @schema DbClusterSpecForProvider#engine
   */
  readonly engine: string;

  /**
   * The DB engine mode of the DB cluster, either provisioned or serverless.
   * The serverless engine mode only applies for Aurora Serverless v1 DB clusters.
   * For information about limitations and requirements for Serverless DB clusters, see the following sections in the Amazon Aurora User Guide:
   * * Limitations of Aurora Serverless v1 (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations)
   * * Requirements for Aurora Serverless v2 (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html)
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#engineMode
   */
  readonly engineMode?: string;

  /**
   * The version number of the database engine to use.
   * To list all of the available engine versions for MySQL 5.6-compatible Aurora, use the following command:
   * aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"
   * To list all of the available engine versions for MySQL 5.7-compatible and MySQL 8.0-compatible Aurora, use the following command:
   * aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"
   * To list all of the available engine versions for Aurora PostgreSQL, use the following command:
   * aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"
   * To list all of the available engine versions for RDS for MySQL, use the following command:
   * aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"
   * To list all of the available engine versions for RDS for PostgreSQL, use the following command:
   * aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"
   * Aurora MySQL
   * For information, see MySQL on Amazon RDS Versions (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html) in the Amazon Aurora User Guide.
   * Aurora PostgreSQL
   * For information, see Amazon Aurora PostgreSQL releases and engine versions (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html) in the Amazon Aurora User Guide.
   * MySQL
   * For information, see MySQL on Amazon RDS Versions (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the Amazon RDS User Guide.
   * PostgreSQL
   * For information, see Amazon RDS for PostgreSQL versions and extensions (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the Amazon RDS User Guide.
   * Note: Downgrades are not allowed by AWS and attempts to set a lower version will be ignored.
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The DB cluster snapshot identifier of the new DB cluster snapshot created when SkipFinalSnapshot is disabled.
   * Specifying this parameter and also skipping the creation of a final DB cluster snapshot with the SkipFinalShapshot parameter results in an error.
   * Constraints:
   * * Must be 1 to 255 letters, numbers, or hyphens.
   * * First character must be a letter
   * * Can't end with a hyphen or contain two consecutive hyphens
   *
   * @schema DbClusterSpecForProvider#finalDBSnapshotIdentifier
   */
  readonly finalDbSnapshotIdentifier?: string;

  /**
   * The global cluster ID of an Aurora cluster that becomes the primary cluster in the new global database cluster.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.
   * For information about valid IOPS values, see Provisioned IOPS storage (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS) in the Amazon RDS User Guide.
   * This setting is required to create a Multi-AZ DB cluster.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   * Constraints:
   * * Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
   *
   * @schema DbClusterSpecForProvider#iops
   */
  readonly iops?: number;

  /**
   * The Amazon Web Services KMS key identifier for an encrypted DB cluster.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN.
   * When a KMS key isn't specified in KmsKeyId:
   * * If ReplicationSourceIdentifier identifies an encrypted source, then Amazon RDS uses the KMS key used to encrypt the source. Otherwise, Amazon RDS uses your default KMS key.
   * * If the StorageEncrypted parameter is enabled and ReplicationSourceIdentifier isn't specified, then Amazon RDS uses your default KMS key.
   * There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   * If you create a read replica of an encrypted DB cluster in another Amazon Web Services Region, make sure to set KmsKeyId to a KMS key identifier that is valid in the destination Amazon Web Services Region. This KMS key is used to encrypt the read replica in that Amazon Web Services Region.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DbClusterSpecForProvider#kmsKeyIDRef
   */
  readonly kmsKeyIdRef?: DbClusterSpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DbClusterSpecForProvider#kmsKeyIDSelector
   */
  readonly kmsKeyIdSelector?: DbClusterSpecForProviderKmsKeyIdSelector;

  /**
   * Specifies whether to manage the master user password with Amazon Web Services Secrets Manager.
   * For more information, see Password management with Amazon Web Services Secrets Manager (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Constraints:
   * * Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword is specified.
   *
   * @schema DbClusterSpecForProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
   * This parameter will be required in the following scenarios: - The first cluster for a global Aurora cluster - Any cluster as long as it doesn't belong to a global Aurora cluster
   * This parameter is required for creation of a primary cluster. However, it is not required when attaching a secondary regional cluster to an existing global cluster.
   * Constraints: Must contain from 8 to 41 characters.
   *
   * @schema DbClusterSpecForProvider#masterUserPasswordSecretRef
   */
  readonly masterUserPasswordSecretRef?: DbClusterSpecForProviderMasterUserPasswordSecretRef;

  /**
   * The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and managed in Amazon Web Services Secrets Manager.
   * This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets Manager for the DB cluster.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN.
   * If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer managed KMS key.
   * There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#masterUserSecretKMSKeyID
   */
  readonly masterUserSecretKmsKeyId?: string;

  /**
   * The name of the master user for the DB cluster.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Constraints:
   * * Must be 1 to 16 letters or numbers.
   * * First character must be a letter.
   * * Can't be a reserved word for the chosen database engine.
   *
   * @schema DbClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0.
   * If MonitoringRoleArn is specified, also set MonitoringInterval to a value other than 0.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   * Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60
   * Default: 0
   *
   * @schema DbClusterSpecForProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see Setting up and enabling Enhanced Monitoring (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the Amazon RDS User Guide.
   * If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   *
   * @schema DbClusterSpecForProvider#monitoringRoleARN
   */
  readonly monitoringRoleArn?: string;

  /**
   * The network type of the DB cluster.
   * The network type is determined by the DBSubnetGroup specified for the DB cluster. A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6 protocols (DUAL).
   * For more information, see Working with a DB instance in a VPC (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html) in the Amazon Aurora User Guide.
   * Valid for Cluster Type: Aurora DB clusters only
   * Valid Values: IPV4 | DUAL
   *
   * @schema DbClusterSpecForProvider#networkType
   */
  readonly networkType?: string;

  /**
   * The option group to associate the DB cluster with.
   * DB clusters are associated with a default option group that can't be modified.
   *
   * @schema DbClusterSpecForProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
   * If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   *
   * @schema DbClusterSpecForProvider#performanceInsightsKMSKeyID
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * The number of days to retain Performance Insights data.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   * Valid Values:
   * * 7
   * * month * 31, where month is a number of months from 1-23. Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)
   * * 731
   * Default: 7 days
   * If you specify a retention period that isn't valid, such as 94, Amazon RDS issues an error.
   *
   * @schema DbClusterSpecForProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The port number on which the instances in the DB cluster accept connections.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Valid Values: 1150-65535
   * Default:
   * * RDS for MySQL and Aurora MySQL - 3306
   * * RDS for PostgreSQL and Aurora PostgreSQL - 5432
   *
   * @schema DbClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * When you are replicating a DB cluster from one Amazon Web Services GovCloud (US) Region to another, an URL that contains a Signature Version 4 signed request for the CreateDBCluster operation to be called in the source Amazon Web Services Region where the DB cluster is replicated from. Specify PreSignedUrl only when you are performing cross-Region replication from an encrypted DB cluster.
   * The presigned URL must be a valid request for the CreateDBCluster API operation that can run in the source Amazon Web Services Region that contains the encrypted DB cluster to copy.
   * The presigned URL request must contain the following parameter values:
   * * KmsKeyId - The KMS key identifier for the KMS key to use to encrypt the copy of the DB cluster in the destination Amazon Web Services Region. This should refer to the same KMS key for both the CreateDBCluster operation that is called in the destination Amazon Web Services Region, and the operation contained in the presigned URL.
   * * DestinationRegion - The name of the Amazon Web Services Region that Aurora read replica will be created in.
   * * ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an encrypted DB cluster from the us-west-2 Amazon Web Services Region, then your ReplicationSourceIdentifier would look like Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1.
   * To learn how to generate a Signature Version 4 signed request, see Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) (https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html) and Signature Version 4 Signing Process (https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
   * If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#preSignedURL
   */
  readonly preSignedUrl?: string;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. To view the time blocks available, see Backup window (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow) in the Amazon Aurora User Guide.
   * Constraints:
   * * Must be in the format hh24:mi-hh24:mi.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must not conflict with the preferred maintenance window.
   * * Must be at least 30 minutes.
   *
   * @schema DbClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred DB Cluster Maintenance Window (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora) in the Amazon Aurora User Guide.
   * Constraints:
   * * Must be in the format ddd:hh24:mi-ddd:hh24:mi.
   * * Days must be one of Mon | Tue | Wed | Thu | Fri | Sat | Sun.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must be at least 30 minutes.
   *
   * @schema DbClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Specifies whether the DB cluster is publicly accessible.
   * When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it.
   * When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address.
   * Valid for Cluster Type: Multi-AZ DB clusters only
   * Default: The default behavior varies depending on whether DBSubnetGroupName is specified.
   * If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
   * * If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB cluster is private.
   * * If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.
   * If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
   * * If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB cluster is private.
   * * If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
   *
   * @schema DbClusterSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is which region the DBCluster will be created.
   *
   * @schema DbClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#replicationSourceIdentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * RestoreFrom specifies the details of the backup to restore when creating a new DBCluster.
   *
   * @schema DbClusterSpecForProvider#restoreFrom
   */
  readonly restoreFrom?: DbClusterSpecForProviderRestoreFrom;

  /**
   * For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster.
   * Valid for Cluster Type: Aurora DB clusters only
   *
   * @schema DbClusterSpecForProvider#scalingConfiguration
   */
  readonly scalingConfiguration?: DbClusterSpecForProviderScalingConfiguration;

  /**
   * @schema DbClusterSpecForProvider#serverlessV2ScalingConfiguration
   */
  readonly serverlessV2ScalingConfiguration?: DbClusterSpecForProviderServerlessV2ScalingConfiguration;

  /**
   * A value that indicates whether to skip the creation of a final DB cluster snapshot before the DB cluster is deleted. If skip is specified, no DB cluster snapshot is created. If skip isn't specified, a DB cluster snapshot is created before the DB cluster is deleted. By default, skip isn't specified, and the DB cluster snapshot is created. By default, this parameter is disabled.
   * You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is disabled.
   *
   * @schema DbClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * SourceRegion is the source region where the resource exists. This is not sent over the wire and is only used for presigning. This value should always have the same region as the source ARN.
   *
   * @schema DbClusterSpecForProvider#sourceRegion
   */
  readonly sourceRegion?: string;

  /**
   * Specifies whether the DB cluster is encrypted.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The storage type to associate with the DB cluster.
   * For information on storage types for Aurora DB clusters, see Storage configurations for Amazon Aurora DB clusters (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type). For information on storage types for Multi-AZ DB clusters, see Settings for creating Multi-AZ DB clusters (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings).
   * This setting is required to create a Multi-AZ DB cluster.
   * When specified for a Multi-AZ DB cluster, a value for the Iops parameter is required.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   * Valid Values:
   * * Aurora DB clusters - aurora | aurora-iopt1
   * * Multi-AZ DB clusters - io1
   * Default:
   * * Aurora DB clusters - aurora
   * * Multi-AZ DB clusters - io1
   * When you create an Aurora DB cluster with the storage type set to aurora-iopt1, the storage type is returned in the response. The storage type isn't returned when you set it to aurora.
   *
   * @schema DbClusterSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Tags to assign to the DB cluster.
   * Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#tags
   */
  readonly tags?: DbClusterSpecForProviderTags[];

  /**
   * VPCSecurityGroupIDRefs are references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDRefs
   */
  readonly vpcSecurityGroupIdRefs?: DbClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDSelector
   */
  readonly vpcSecurityGroupIdSelector?: DbClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * A list of VPC security groups that the DB cluster will belong to.
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDs
   */
  readonly vpcSecurityGroupIDs?: string[];

}

/**
 * Converts an object of type 'DbClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProvider(obj: DbClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'autogeneratePassword': obj.autogeneratePassword,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backtrackWindow': obj.backtrackWindow,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'characterSetName': obj.characterSetName,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'databaseName': obj.databaseName,
    'dbClusterInstanceClass': obj.dbClusterInstanceClass,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbClusterParameterGroupNameRef': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRef(obj.dbClusterParameterGroupNameRef),
    'dbClusterParameterGroupNameSelector': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelector(obj.dbClusterParameterGroupNameSelector),
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_DbClusterSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_DbClusterSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'dbSystemID': obj.dbSystemId,
    'deletionProtection': obj.deletionProtection,
    'destinationRegion': obj.destinationRegion,
    'domain': obj.domain,
    'domainIAMRoleName': obj.domainIamRoleName,
    'domainIAMRoleNameRef': toJson_DbClusterSpecForProviderDomainIamRoleNameRef(obj.domainIamRoleNameRef),
    'domainIAMRoleNameSelector': toJson_DbClusterSpecForProviderDomainIamRoleNameSelector(obj.domainIamRoleNameSelector),
    'enableCloudwatchLogsExports': obj.enableCloudwatchLogsExports?.map(y => y),
    'enableGlobalWriteForwarding': obj.enableGlobalWriteForwarding,
    'enableHTTPEndpoint': obj.enableHttpEndpoint,
    'enableIAMDatabaseAuthentication': obj.enableIamDatabaseAuthentication,
    'enableLocalWriteForwarding': obj.enableLocalWriteForwarding,
    'enablePerformanceInsights': obj.enablePerformanceInsights,
    'engine': obj.engine,
    'engineMode': obj.engineMode,
    'engineVersion': obj.engineVersion,
    'finalDBSnapshotIdentifier': obj.finalDbSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'iops': obj.iops,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIDRef': toJson_DbClusterSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIDSelector': toJson_DbClusterSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'masterUserPasswordSecretRef': toJson_DbClusterSpecForProviderMasterUserPasswordSecretRef(obj.masterUserPasswordSecretRef),
    'masterUserSecretKMSKeyID': obj.masterUserSecretKmsKeyId,
    'masterUsername': obj.masterUsername,
    'monitoringInterval': obj.monitoringInterval,
    'monitoringRoleARN': obj.monitoringRoleArn,
    'networkType': obj.networkType,
    'optionGroupName': obj.optionGroupName,
    'performanceInsightsKMSKeyID': obj.performanceInsightsKmsKeyId,
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'port': obj.port,
    'preSignedURL': obj.preSignedUrl,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'replicationSourceIdentifier': obj.replicationSourceIdentifier,
    'restoreFrom': toJson_DbClusterSpecForProviderRestoreFrom(obj.restoreFrom),
    'scalingConfiguration': toJson_DbClusterSpecForProviderScalingConfiguration(obj.scalingConfiguration),
    'serverlessV2ScalingConfiguration': toJson_DbClusterSpecForProviderServerlessV2ScalingConfiguration(obj.serverlessV2ScalingConfiguration),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'sourceRegion': obj.sourceRegion,
    'storageEncrypted': obj.storageEncrypted,
    'storageType': obj.storageType,
    'tags': obj.tags?.map(y => toJson_DbClusterSpecForProviderTags(y)),
    'vpcSecurityGroupIDRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_DbClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIDSelector': toJson_DbClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIDs': obj.vpcSecurityGroupIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbClusterSpecManagementPolicies
 */
export enum DbClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbClusterSpecProviderConfigRef
 */
export interface DbClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecProviderConfigRef#policy
   */
  readonly policy?: DbClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRef(obj: DbClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbClusterSpecPublishConnectionDetailsTo
 */
export interface DbClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsTo(obj: DbClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbClusterSpecWriteConnectionSecretToRef
 */
export interface DbClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecWriteConnectionSecretToRef(obj: DbClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterParameterGroupNameRef is a reference to a DBClusterParameterGroup used to set DBClusterParameterGroupName.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef#policy
   */
  readonly policy?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRef(obj: DbClusterSpecForProviderDbClusterParameterGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterParameterGroupNameSelector selects a reference to a DBClusterParameterGroup used to set DBClusterParameterGroupName.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelector(obj: DbClusterSpecForProviderDbClusterParameterGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSubnetGroupNameRef is a reference to a DBSubnetGroup used to set DBSubnetGroupName.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRef
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameRef(obj: DbClusterSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSubnetGroupNameSelector selects a reference to a DBSubnetGroup used to set DBSubnetGroupName.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameSelector(obj: DbClusterSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainIAMRoleNameRef is a reference to an IAMRole used to set DomainIAMRoleName.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameRef
 */
export interface DbClusterSpecForProviderDomainIamRoleNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameRef#policy
   */
  readonly policy?: DbClusterSpecForProviderDomainIamRoleNameRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDomainIamRoleNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDomainIamRoleNameRef(obj: DbClusterSpecForProviderDomainIamRoleNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderDomainIamRoleNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainIAMRoleNameSelector selects a reference to an IAMRole used to set DomainIAMRoleName.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameSelector
 */
export interface DbClusterSpecForProviderDomainIamRoleNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDomainIamRoleNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDomainIamRoleNameSelector(obj: DbClusterSpecForProviderDomainIamRoleNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRef
 */
export interface DbClusterSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DbClusterSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdRef(obj: DbClusterSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelector
 */
export interface DbClusterSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdSelector(obj: DbClusterSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
 * This parameter will be required in the following scenarios: - The first cluster for a global Aurora cluster - Any cluster as long as it doesn't belong to a global Aurora cluster
 * This parameter is required for creation of a primary cluster. However, it is not required when attaching a secondary regional cluster to an existing global cluster.
 * Constraints: Must contain from 8 to 41 characters.
 *
 * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef
 */
export interface DbClusterSpecForProviderMasterUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderMasterUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderMasterUserPasswordSecretRef(obj: DbClusterSpecForProviderMasterUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreFrom specifies the details of the backup to restore when creating a new DBCluster.
 *
 * @schema DbClusterSpecForProviderRestoreFrom
 */
export interface DbClusterSpecForProviderRestoreFrom {
  /**
   * PointInTime specifies the details of the point in time restore.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#pointInTime
   */
  readonly pointInTime?: DbClusterSpecForProviderRestoreFromPointInTime;

  /**
   * S3 specifies the details of the S3 backup to restore from.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#s3
   */
  readonly s3?: DbClusterSpecForProviderRestoreFromS3;

  /**
   * Snapshot specifies the details of the snapshot to restore from.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#snapshot
   */
  readonly snapshot?: DbClusterSpecForProviderRestoreFromSnapshot;

  /**
   * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. S3, Snapshot and PointInTime are supported.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#source
   */
  readonly source: DbClusterSpecForProviderRestoreFromSource;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFrom(obj: DbClusterSpecForProviderRestoreFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pointInTime': toJson_DbClusterSpecForProviderRestoreFromPointInTime(obj.pointInTime),
    's3': toJson_DbClusterSpecForProviderRestoreFromS3(obj.s3),
    'snapshot': toJson_DbClusterSpecForProviderRestoreFromSnapshot(obj.snapshot),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster.
 * Valid for Cluster Type: Aurora DB clusters only
 *
 * @schema DbClusterSpecForProviderScalingConfiguration
 */
export interface DbClusterSpecForProviderScalingConfiguration {
  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#autoPause
   */
  readonly autoPause?: boolean;

  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#secondsBeforeTimeout
   */
  readonly secondsBeforeTimeout?: number;

  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#secondsUntilAutoPause
   */
  readonly secondsUntilAutoPause?: number;

  /**
   * @schema DbClusterSpecForProviderScalingConfiguration#timeoutAction
   */
  readonly timeoutAction?: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderScalingConfiguration(obj: DbClusterSpecForProviderScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoPause': obj.autoPause,
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'secondsBeforeTimeout': obj.secondsBeforeTimeout,
    'secondsUntilAutoPause': obj.secondsUntilAutoPause,
    'timeoutAction': obj.timeoutAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration
 */
export interface DbClusterSpecForProviderServerlessV2ScalingConfiguration {
  /**
   * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderServerlessV2ScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderServerlessV2ScalingConfiguration(obj: DbClusterSpecForProviderServerlessV2ScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterSpecForProviderTags
 */
export interface DbClusterSpecForProviderTags {
  /**
   * @schema DbClusterSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbClusterSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderTags(obj: DbClusterSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIdRefs(obj: DbClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIdSelector(obj: DbClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecProviderConfigRefPolicy
 */
export interface DbClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRefPolicy(obj: DbClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj: DbClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToMetadata
 */
export interface DbClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj: DbClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy(obj: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy(obj: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj: DbClusterSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameRefPolicy
 */
export interface DbClusterSpecForProviderDomainIamRoleNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDomainIamRoleNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDomainIamRoleNameRefPolicy(obj: DbClusterSpecForProviderDomainIamRoleNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy
 */
export interface DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy(obj: DbClusterSpecForProviderDomainIamRoleNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy
 */
export interface DbClusterSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdRefPolicy(obj: DbClusterSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DbClusterSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdSelectorPolicy(obj: DbClusterSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PointInTime specifies the details of the point in time restore.
 *
 * @schema DbClusterSpecForProviderRestoreFromPointInTime
 */
export interface DbClusterSpecForProviderRestoreFromPointInTime {
  /**
   * RestoreTime is the date and time (UTC) to restore from. Must be before the latest restorable time for the DB instance. Can't be specified if the useLatestRestorableTime parameter is enabled. Example: 2011-09-07T23:45:00Z
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#restoreTime
   */
  readonly restoreTime?: Date;

  /**
   * The type of restore to be performed. You can specify one of the following values:
   * * full-copy - The new DB cluster is restored as a full copy of the source DB cluster.
   * * copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
   * Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11.
   * If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster.
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#restoreType
   */
  readonly restoreType?: DbClusterSpecForProviderRestoreFromPointInTimeRestoreType;

  /**
   * SourceDBClusterIdentifier specifies the identifier of the source DB cluster from which to restore. Constraints: Must match the identifier of an existing DB instance.
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#sourceDBClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * SourceDBInstanceAutomatedBackupsArn specifies the Amazon Resource Name (ARN) of the replicated automated backups from which to restore. Example: arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#sourceDBInstanceAutomatedBackupsArn
   */
  readonly sourceDbInstanceAutomatedBackupsArn?: string;

  /**
   * SourceDbiResourceID specifies the resource ID of the source DB instance from which to restore.
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#sourceDbiResourceId
   */
  readonly sourceDbiResourceId?: string;

  /**
   * UseLatestRestorableTime indicates that the DB instance is restored from the latest backup Can't be specified if the restoreTime parameter is provided.
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFromPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFromPointInTime(obj: DbClusterSpecForProviderRestoreFromPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreTime': obj.restoreTime?.toISOString(),
    'restoreType': obj.restoreType,
    'sourceDBClusterIdentifier': obj.sourceDbClusterIdentifier,
    'sourceDBInstanceAutomatedBackupsArn': obj.sourceDbInstanceAutomatedBackupsArn,
    'sourceDbiResourceId': obj.sourceDbiResourceId,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3 specifies the details of the S3 backup to restore from.
 *
 * @schema DbClusterSpecForProviderRestoreFromS3
 */
export interface DbClusterSpecForProviderRestoreFromS3 {
  /**
   * BucketName is the name of the S3 bucket containing the backup to restore.
   *
   * @schema DbClusterSpecForProviderRestoreFromS3#bucketName
   */
  readonly bucketName: string;

  /**
   * IngestionRoleARN is the IAM role RDS can assume that will allow it to access the contents of the S3 bucket.
   *
   * @schema DbClusterSpecForProviderRestoreFromS3#ingestionRoleARN
   */
  readonly ingestionRoleArn: string;

  /**
   * Prefix is the path prefix of the S3 bucket within which the backup to restore is located.
   *
   * @schema DbClusterSpecForProviderRestoreFromS3#prefix
   */
  readonly prefix?: string;

  /**
   * SourceEngine is the engine used to create the backup. Must be "mysql".
   *
   * @schema DbClusterSpecForProviderRestoreFromS3#sourceEngine
   */
  readonly sourceEngine: string;

  /**
   * SourceEngineVersion is the version of the engine used to create the backup. Example: "5.7.30"
   *
   * @schema DbClusterSpecForProviderRestoreFromS3#sourceEngineVersion
   */
  readonly sourceEngineVersion: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFromS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFromS3(obj: DbClusterSpecForProviderRestoreFromS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'ingestionRoleARN': obj.ingestionRoleArn,
    'prefix': obj.prefix,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Snapshot specifies the details of the snapshot to restore from.
 *
 * @schema DbClusterSpecForProviderRestoreFromSnapshot
 */
export interface DbClusterSpecForProviderRestoreFromSnapshot {
  /**
   * SnapshotIdentifier is the identifier of the snapshot to restore.
   *
   * @schema DbClusterSpecForProviderRestoreFromSnapshot#snapshotIdentifier
   */
  readonly snapshotIdentifier: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFromSnapshot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFromSnapshot(obj: DbClusterSpecForProviderRestoreFromSnapshot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'snapshotIdentifier': obj.snapshotIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. S3, Snapshot and PointInTime are supported.
 *
 * @schema DbClusterSpecForProviderRestoreFromSource
 */
export enum DbClusterSpecForProviderRestoreFromSource {
  /** S3 */
  S3 = "S3",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
  /** PointInTime */
  POINT_IN_TIME = "PointInTime",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolution
 */
export enum DbClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolve
 */
export enum DbClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolution
 */
export enum DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolve
 */
export enum DbClusterSpecForProviderDomainIamRoleNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderDomainIamRoleNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DbClusterSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DbClusterSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The type of restore to be performed. You can specify one of the following values:
 * * full-copy - The new DB cluster is restored as a full copy of the source DB cluster.
 * * copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
 * Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11.
 * If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster.
 * Valid for: Aurora DB clusters and Multi-AZ DB clusters
 *
 * @schema DbClusterSpecForProviderRestoreFromPointInTimeRestoreType
 */
export enum DbClusterSpecForProviderRestoreFromPointInTimeRestoreType {
  /** full-copy */
  FULL_HYPHEN_COPY = "full-copy",
  /** copy-on-write */
  COPY_HYPHEN_ON_HYPHEN_WRITE = "copy-on-write",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBClusterParameterGroup is the Schema for the DBClusterParameterGroups API
 *
 * @schema DBClusterParameterGroup
 */
export class DbClusterParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBClusterParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'DBClusterParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "DBClusterParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbClusterParameterGroupProps): any {
    return {
      ...DbClusterParameterGroup.GVK,
      ...toJson_DbClusterParameterGroupProps(props),
    };
  }

  /**
   * Defines a "DBClusterParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbClusterParameterGroupProps) {
    super(scope, id, {
      ...DbClusterParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbClusterParameterGroup.GVK,
      ...toJson_DbClusterParameterGroupProps(resolved),
    };
  }
}

/**
 * DBClusterParameterGroup is the Schema for the DBClusterParameterGroups API
 *
 * @schema DBClusterParameterGroup
 */
export interface DbClusterParameterGroupProps {
  /**
   * @schema DBClusterParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBClusterParameterGroupSpec defines the desired state of DBClusterParameterGroup
   *
   * @schema DBClusterParameterGroup#spec
   */
  readonly spec: DbClusterParameterGroupSpec;

}

/**
 * Converts an object of type 'DbClusterParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupProps(obj: DbClusterParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbClusterParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterParameterGroupSpec defines the desired state of DBClusterParameterGroup
 *
 * @schema DbClusterParameterGroupSpec
 */
export interface DbClusterParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbClusterParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbClusterParameterGroupSpecDeletionPolicy;

  /**
   * DBClusterParameterGroupParameters defines the desired state of DBClusterParameterGroup
   *
   * @schema DbClusterParameterGroupSpec#forProvider
   */
  readonly forProvider: DbClusterParameterGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbClusterParameterGroupSpec#managementPolicies
   */
  readonly managementPolicies?: DbClusterParameterGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbClusterParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbClusterParameterGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbClusterParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbClusterParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbClusterParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbClusterParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpec(obj: DbClusterParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbClusterParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbClusterParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbClusterParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbClusterParameterGroupSpecDeletionPolicy
 */
export enum DbClusterParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBClusterParameterGroupParameters defines the desired state of DBClusterParameterGroup
 *
 * @schema DbClusterParameterGroupSpecForProvider
 */
export interface DbClusterParameterGroupSpecForProvider {
  /**
   * The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a database engine and engine version compatible with that DB cluster parameter group family.
   * Aurora MySQL
   * Example: aurora5.6, aurora-mysql5.7
   * Aurora PostgreSQL
   * Example: aurora-postgresql9.6
   * To list all of the available parameter group families for a DB engine, use the following command:
   * aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine>
   * For example, to list all of the available parameter group families for the Aurora PostgreSQL DB engine, use the following command:
   * aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine aurora-postgresql
   * The output contains duplicates.
   * The following are the valid DB engine values:
   * * aurora (for MySQL 5.6-compatible Aurora)
   * * aurora-mysql (for MySQL 5.7-compatible Aurora)
   * * aurora-postgresql
   * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
   *
   * @schema DbClusterParameterGroupSpecForProvider#dbParameterGroupFamily
   */
  readonly dbParameterGroupFamily?: string;

  /**
   * DBParameterGroupFamilySelector determines DBParameterGroupFamily from the engine and engine version.
   * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
   * Will not be used if DBParameterGroupFamily is already set.
   *
   * @schema DbClusterParameterGroupSpecForProvider#dbParameterGroupFamilySelector
   */
  readonly dbParameterGroupFamilySelector?: DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector;

  /**
   * The description for the DB cluster parameter group.
   *
   * @schema DbClusterParameterGroupSpecForProvider#description
   */
  readonly description: string;

  /**
   * A list of parameters to associate with this DB cluster parameter group. The fields ApplyMethod, ParameterName and ParameterValue are required for every parameter. Note: AWS actually only modifies the ApplyMethod of a parameter, if the ParameterValue changes too.
   *
   * @schema DbClusterParameterGroupSpecForProvider#parameters
   */
  readonly parameters?: DbClusterParameterGroupSpecForProviderParameters[];

  /**
   * Region is which region the DBClusterParameterGroup will be created.
   *
   * @schema DbClusterParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tags to assign to the DB cluster parameter group.
   *
   * @schema DbClusterParameterGroupSpecForProvider#tags
   */
  readonly tags?: DbClusterParameterGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProvider(obj: DbClusterParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbParameterGroupFamily': obj.dbParameterGroupFamily,
    'dbParameterGroupFamilySelector': toJson_DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector(obj.dbParameterGroupFamilySelector),
    'description': obj.description,
    'parameters': obj.parameters?.map(y => toJson_DbClusterParameterGroupSpecForProviderParameters(y)),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_DbClusterParameterGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbClusterParameterGroupSpecManagementPolicies
 */
export enum DbClusterParameterGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRef
 */
export interface DbClusterParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: DbClusterParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecProviderConfigRef(obj: DbClusterParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsTo(obj: DbClusterParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef
 */
export interface DbClusterParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecWriteConnectionSecretToRef(obj: DbClusterParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBParameterGroupFamilySelector determines DBParameterGroupFamily from the engine and engine version.
 * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
 * Will not be used if DBParameterGroupFamily is already set.
 *
 * @schema DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector
 */
export interface DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector {
  /**
   * Engine is the name of the database engine.
   *
   * @schema DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector#engine
   */
  readonly engine: string;

  /**
   * EngineVersion is the version of the database engine. If it is nil, the default engine version given by AWS will be used.
   *
   * @schema DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector#engineVersion
   */
  readonly engineVersion?: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector(obj: DbClusterParameterGroupSpecForProviderDbParameterGroupFamilySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomParameter are custom parameters for the Parameter
 *
 * @schema DbClusterParameterGroupSpecForProviderParameters
 */
export interface DbClusterParameterGroupSpecForProviderParameters {
  /**
   * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#applyMethod
   */
  readonly applyMethod: DbClusterParameterGroupSpecForProviderParametersApplyMethod;

  /**
   * The name of the parameter.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#parameterName
   */
  readonly parameterName: string;

  /**
   * The value of the parameter.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#parameterValue
   */
  readonly parameterValue: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProviderParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProviderParameters(obj: DbClusterParameterGroupSpecForProviderParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterParameterGroupSpecForProviderTags
 */
export interface DbClusterParameterGroupSpecForProviderTags {
  /**
   * @schema DbClusterParameterGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbClusterParameterGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProviderTags(obj: DbClusterParameterGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy
 */
export interface DbClusterParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecProviderConfigRefPolicy(obj: DbClusterParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
 *
 * @schema DbClusterParameterGroupSpecForProviderParametersApplyMethod
 */
export enum DbClusterParameterGroupSpecForProviderParametersApplyMethod {
  /** immediate */
  IMMEDIATE = "immediate",
  /** pending-reboot */
  PENDING_HYPHEN_REBOOT = "pending-reboot",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum DbClusterParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum DbClusterParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBInstance is the Schema for the DBInstances API
 *
 * @schema DBInstance
 */
export class DbInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'DBInstance',
  }

  /**
   * Renders a Kubernetes manifest for "DBInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbInstanceProps): any {
    return {
      ...DbInstance.GVK,
      ...toJson_DbInstanceProps(props),
    };
  }

  /**
   * Defines a "DBInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbInstanceProps) {
    super(scope, id, {
      ...DbInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbInstance.GVK,
      ...toJson_DbInstanceProps(resolved),
    };
  }
}

/**
 * DBInstance is the Schema for the DBInstances API
 *
 * @schema DBInstance
 */
export interface DbInstanceProps {
  /**
   * @schema DBInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBInstanceSpec defines the desired state of DBInstance
   *
   * @schema DBInstance#spec
   */
  readonly spec: DbInstanceSpec;

}

/**
 * Converts an object of type 'DbInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceProps(obj: DbInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceSpec defines the desired state of DBInstance
 *
 * @schema DbInstanceSpec
 */
export interface DbInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbInstanceSpecDeletionPolicy;

  /**
   * DBInstanceParameters defines the desired state of DBInstance
   *
   * @schema DbInstanceSpec#forProvider
   */
  readonly forProvider: DbInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: DbInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpec(obj: DbInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbInstanceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbInstanceSpecDeletionPolicy
 */
export enum DbInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBInstanceParameters defines the desired state of DBInstance
 *
 * @schema DbInstanceSpecForProvider
 */
export interface DbInstanceSpecForProvider {
  /**
   * The amount of storage in gibibytes (GiB) to allocate for the DB instance.
   * This setting doesn't apply to Amazon Aurora DB instances. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.
   * Amazon RDS Custom
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Must be an integer from 40 to 65536 for RDS Custom for Oracle, 16384 for RDS Custom for SQL Server.
   * * Provisioned IOPS storage (io1): Must be an integer from 40 to 65536 for RDS Custom for Oracle, 16384 for RDS Custom for SQL Server.
   * RDS for MariaDB
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.
   * * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
   * * Magnetic storage (standard): Must be an integer from 5 to 3072.
   * RDS for MySQL
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.
   * * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
   * * Magnetic storage (standard): Must be an integer from 5 to 3072.
   * RDS for Oracle
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.
   * * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
   * * Magnetic storage (standard): Must be an integer from 10 to 3072.
   * RDS for PostgreSQL
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.
   * * Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
   * * Magnetic storage (standard): Must be an integer from 5 to 3072.
   * RDS for SQL Server
   * Constraints to the amount of storage for each storage type are the following:
   * * General Purpose (SSD) storage (gp2, gp3): Enterprise and Standard editions: Must be an integer from 20 to 16384. Web and Express editions: Must be an integer from 20 to 16384.
   * * Provisioned IOPS storage (io1): Enterprise and Standard editions: Must be an integer from 100 to 16384. Web and Express editions: Must be an integer from 100 to 16384.
   * * Magnetic storage (standard): Enterprise and Standard editions: Must be an integer from 20 to 1024. Web and Express editions: Must be an integer from 20 to 1024.
   *
   * @schema DbInstanceSpecForProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Specifies whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
   * This setting doesn't apply to RDS Custom DB instances.
   * Constraints:
   * * Major version upgrades must be allowed when specifying a value for the EngineVersion parameter that's a different major version than the DB instance's current version.
   *
   * @schema DbInstanceSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance. By default, this parameter is disabled.
   * If this parameter is disabled, changes to the DB instance are applied during the next maintenance window. Some parameter changes can cause an outage and are applied on the next call to RebootDBInstance, or the next failure reboot. Review the table of parameters in Modifying a DB Instance (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html) in the Amazon RDS User Guide. to see the impact of enabling or disabling ApplyImmediately for each modified parameter and to determine when the changes are applied.
   *
   * @schema DbInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Specifies whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically.
   * If you create an RDS Custom DB instance, you must set AutoMinorVersionUpgrade to false.
   *
   * @schema DbInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * AutogeneratePassword indicates whether the controller should generate a random password for the master user if one is not provided via MasterUserPasswordSecretRef.
   * If a password is generated, it will be stored as a secret at the location specified by MasterUserPasswordSecretRef.
   *
   * @schema DbInstanceSpecForProvider#autogeneratePassword
   */
  readonly autogeneratePassword?: boolean;

  /**
   * The Availability Zone (AZ) where the database will be created. For information on Amazon Web Services Regions and Availability Zones, see Regions and Availability Zones (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html).
   * For Amazon Aurora, each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one.
   * Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region.
   * Constraints:
   * * The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment.
   * * The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.
   * Example: us-east-1d
   *
   * @schema DbInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.
   * This setting doesn't apply to Amazon Aurora DB instances. The retention period for automated backups is managed by the DB cluster.
   * Default: 1
   * Constraints:
   * * Must be a value from 0 to 35.
   * * Can't be set to 0 if the DB instance is a source to read replicas.
   * * Can't be set to 0 for an RDS Custom for Oracle DB instance.
   *
   * @schema DbInstanceSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * The location for storing automated backups and manual snapshots.
   * Valie Values:
   * * outposts (Amazon Web Services Outposts)
   * * region (Amazon Web Services Region)
   * Default: region
   * For more information, see Working with Amazon RDS on Amazon Web Services Outposts (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
   *
   * @schema DbInstanceSpecForProvider#backupTarget
   */
  readonly backupTarget?: string;

  /**
   * The CA certificate identifier to use for the DB instance's server certificate.
   * This setting doesn't apply to RDS Custom DB instances.
   * For more information, see Using SSL/TLS to encrypt a connection to a DB instance (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html) in the Amazon RDS User Guide and Using SSL/TLS to encrypt a connection to a DB cluster (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html) in the Amazon Aurora User Guide.
   *
   * @schema DbInstanceSpecForProvider#caCertificateIdentifier
   */
  readonly caCertificateIdentifier?: string;

  /**
   * For supported engines, the character set (CharacterSet) to associate the DB instance with.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora - The character set is managed by the DB cluster. For more information, see CreateDBCluster.
   * * RDS Custom - However, if you need to change the character set, you can change it on the database itself.
   *
   * @schema DbInstanceSpecForProvider#characterSetName
   */
  readonly characterSetName?: string;

  /**
   * Specifies whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
   * This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
   *
   * @schema DbInstanceSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance.
   * This setting is required for RDS Custom.
   * Constraints:
   * * The profile must exist in your account.
   * * The profile must have an IAM role that Amazon EC2 has permissions to assume.
   * * The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.
   * For the list of permissions required for the IAM role, see Configure IAM and your VPC (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the Amazon RDS User Guide.
   *
   * @schema DbInstanceSpecForProvider#customIAMInstanceProfile
   */
  readonly customIamInstanceProfile?: string;

  /**
   * The identifier of the DB cluster that this DB instance will belong to.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * DBClusterIdentifierRef is a reference to a DBCluster used to set DBClusterIdentifier.
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: DbInstanceSpecForProviderDbClusterIdentifierRef;

  /**
   * DBClusterIdentifierSelector selects a reference to a DBCluster used to set DBClusterIdentifier.
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: DbInstanceSpecForProviderDbClusterIdentifierSelector;

  /**
   * The compute and memory capacity of the DB instance, for example db.m5.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB instance classes (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the Amazon RDS User Guide or Aurora DB instance classes (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.DBInstanceClass.html) in the Amazon Aurora User Guide.
   *
   * @schema DbInstanceSpecForProvider#dbInstanceClass
   */
  readonly dbInstanceClass: string;

  /**
   * The meaning of this parameter differs according to the database engine you use.
   * MySQL
   * The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.
   * Constraints:
   * * Must contain 1 to 64 letters or numbers.
   * * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
   * * Can't be a word reserved by the specified database engine
   * MariaDB
   * The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.
   * Constraints:
   * * Must contain 1 to 64 letters or numbers.
   * * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
   * * Can't be a word reserved by the specified database engine
   * PostgreSQL
   * The name of the database to create when the DB instance is created. If this parameter isn't specified, a database named postgres is created in the DB instance.
   * Constraints:
   * * Must contain 1 to 63 letters, numbers, or underscores.
   * * Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
   * * Can't be a word reserved by the specified database engine
   * Oracle
   * The Oracle System ID (SID) of the created DB instance. If you don't specify a value, the default value is ORCL. You can't specify the string null, or any other reserved word, for DBName.
   * Default: ORCL
   * Constraints:
   * * Can't be longer than 8 characters
   * Amazon RDS Custom for Oracle
   * The Oracle System ID (SID) of the created RDS Custom DB instance. If you don't specify a value, the default value is ORCL for non-CDBs and RDSCDB for CDBs.
   * Default: ORCL
   * Constraints:
   * * It must contain 1 to 8 alphanumeric characters.
   * * It must contain a letter.
   * * It can't be a word reserved by the database engine.
   * Amazon RDS Custom for SQL Server
   * Not applicable. Must be null.
   * SQL Server
   * Not applicable. Must be null.
   * Amazon Aurora MySQL
   * The name of the database to create when the primary DB instance of the Aurora MySQL DB cluster is created. If this parameter isn't specified for an Aurora MySQL DB cluster, no database is created in the DB cluster.
   * Constraints:
   * * It must contain 1 to 64 alphanumeric characters.
   * * It can't be a word reserved by the database engine.
   * Amazon Aurora PostgreSQL
   * The name of the database to create when the primary DB instance of the Aurora PostgreSQL DB cluster is created. If this parameter isn't specified for an Aurora PostgreSQL DB cluster, a database named postgres is created in the DB cluster.
   * Constraints:
   * * It must contain 1 to 63 alphanumeric characters.
   * * It must begin with a letter. Subsequent characters can be letters, underscores, or digits (0 to 9).
   * * It can't be a word reserved by the database engine.
   *
   * @schema DbInstanceSpecForProvider#dbName
   */
  readonly dbName?: string;

  /**
   * The name of the DB parameter group to associate with this DB instance. If you don't specify a value, then Amazon RDS uses the default DB parameter group for the specified DB engine and version.
   * This setting doesn't apply to RDS Custom DB instances.
   * Constraints:
   * * Must be 1 to 255 letters, numbers, or hyphens.
   * * The first character must be a letter.
   * * Can't end with a hyphen or contain two consecutive hyphens.
   *
   * @schema DbInstanceSpecForProvider#dbParameterGroupName
   */
  readonly dbParameterGroupName?: string;

  /**
   * DBParameterGroupNameRef is a reference to a DBParameterGroup used to set DBParameterGroupName.
   *
   * @schema DbInstanceSpecForProvider#dbParameterGroupNameRef
   */
  readonly dbParameterGroupNameRef?: DbInstanceSpecForProviderDbParameterGroupNameRef;

  /**
   * DBParameterGroupNameSelector selects a reference to a DBParameterGroup used to set DBParameterGroupName.
   *
   * @schema DbInstanceSpecForProvider#dbParameterGroupNameSelector
   */
  readonly dbParameterGroupNameSelector?: DbInstanceSpecForProviderDbParameterGroupNameSelector;

  /**
   * A list of database security groups to associate with this DB instance
   *
   * @schema DbInstanceSpecForProvider#dbSecurityGroups
   */
  readonly dbSecurityGroups?: string[];

  /**
   * A DB subnet group to associate with this DB instance.
   * Constraints:
   * * Must match the name of an existing DB subnet group.
   * * Must not be default.
   * Example: mydbsubnetgroup
   *
   * @schema DbInstanceSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * DBSubnetGroupNameRef is a reference to a DBSubnetGroup used to set DBSubnetGroupName.
   *
   * @schema DbInstanceSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: DbInstanceSpecForProviderDbSubnetGroupNameRef;

  /**
   * DBSubnetGroupNameSelector selects a reference to a DBSubnetGroup used to set DBSubnetGroupName.
   *
   * @schema DbInstanceSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: DbInstanceSpecForProviderDbSubnetGroupNameSelector;

  /**
   * The Oracle system identifier (SID), which is the name of the Oracle database instance that manages your database files. In this context, the term "Oracle database instance" refers exclusively to the system global area (SGA) and Oracle background processes. If you don't specify a SID, the value defaults to RDSCDB. The Oracle SID is also the name of your CDB.
   *
   * @schema DbInstanceSpecForProvider#dbSystemID
   */
  readonly dbSystemId?: string;

  /**
   * DeleteAutomatedBackups indicates whether to remove automated backups immediately after the DB instance is deleted. The default is to remove automated backups immediately after the DB instance is deleted.
   *
   * @schema DbInstanceSpecForProvider#deleteAutomatedBackups
   */
  readonly deleteAutomatedBackups?: boolean;

  /**
   * Specifies whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection isn't enabled. For more information, see Deleting a DB Instance (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).
   * This setting doesn't apply to Amazon Aurora DB instances. You can enable or disable deletion protection for the DB cluster. For more information, see CreateDBCluster. DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
   *
   * @schema DbInstanceSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The Active Directory directory ID to create the DB instance in. Currently, only Microsoft SQL Server, MySQL, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
   * For more information, see Kerberos Authentication (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the Amazon RDS User Guide.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (The domain is managed by the DB cluster.)
   * * RDS Custom
   *
   * @schema DbInstanceSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * The ARN for the Secrets Manager secret with the credentials for the user joining the domain.
   * Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
   *
   * @schema DbInstanceSpecForProvider#domainAuthSecretARN
   */
  readonly domainAuthSecretArn?: string;

  /**
   * The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers.
   * Constraints:
   * * Two IP addresses must be provided. If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.
   * Example: 123.124.125.126,234.235.236.237
   *
   * @schema DbInstanceSpecForProvider#domainDNSIPs
   */
  readonly domainDnsiPs?: string[];

  /**
   * The fully qualified domain name (FQDN) of an Active Directory domain.
   * Constraints:
   * * Can't be longer than 64 characters.
   * Example: mymanagedADtest.mymanagedAD.mydomain
   *
   * @schema DbInstanceSpecForProvider#domainFqdn
   */
  readonly domainFqdn?: string;

  /**
   * The name of the IAM role to use when making API calls to the Directory Service.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (The domain is managed by the DB cluster.)
   * * RDS Custom
   *
   * @schema DbInstanceSpecForProvider#domainIAMRoleName
   */
  readonly domainIamRoleName?: string;

  /**
   * DomainIAMRoleNameRef is a reference to an IAMRole used to set DomainIAMRoleName.
   *
   * @schema DbInstanceSpecForProvider#domainIAMRoleNameRef
   */
  readonly domainIamRoleNameRef?: DbInstanceSpecForProviderDomainIamRoleNameRef;

  /**
   * DomainIAMRoleNameSelector selects a reference to an IAMRole used to set DomainIAMRoleName.
   *
   * @schema DbInstanceSpecForProvider#domainIAMRoleNameSelector
   */
  readonly domainIamRoleNameSelector?: DbInstanceSpecForProviderDomainIamRoleNameSelector;

  /**
   * The Active Directory organizational unit for your DB instance to join.
   * Constraints:
   * * Must be in the distinguished name format.
   * * Can't be longer than 64 characters.
   * Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
   *
   * @schema DbInstanceSpecForProvider#domainOu
   */
  readonly domainOu?: string;

  /**
   * The list of log types that need to be enabled for exporting to CloudWatch Logs. For more information, see Publishing Database Logs to Amazon CloudWatch Logs (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the Amazon RDS User Guide.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (CloudWatch Logs exports are managed by the DB cluster.)
   * * RDS Custom
   * The following values are valid for each DB engine:
   * * RDS for MariaDB - audit | error | general | slowquery
   * * RDS for Microsoft SQL Server - agent | error
   * * RDS for MySQL - audit | error | general | slowquery
   * * RDS for Oracle - alert | audit | listener | trace | oemagent
   * * RDS for PostgreSQL - postgresql | upgrade
   *
   * @schema DbInstanceSpecForProvider#enableCloudwatchLogsExports
   */
  readonly enableCloudwatchLogsExports?: string[];

  /**
   * Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.
   * A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network.
   * For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html) in the Amazon RDS User Guide.
   * For more information about CoIPs, see Customer-owned IP addresses (https://docs.aws.amazon.com/outposts/latest/userguide/routing.html#ip-addressing) in the Amazon Web Services Outposts User Guide.
   *
   * @schema DbInstanceSpecForProvider#enableCustomerOwnedIP
   */
  readonly enableCustomerOwnedIp?: boolean;

  /**
   * Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled.
   * For more information, see IAM Database Authentication for MySQL and PostgreSQL (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the Amazon RDS User Guide.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB cluster.)
   * * RDS Custom
   *
   * @schema DbInstanceSpecForProvider#enableIAMDatabaseAuthentication
   */
  readonly enableIamDatabaseAuthentication?: boolean;

  /**
   * Specifies whether to enable Performance Insights for the DB instance. For more information, see Using Amazon Performance Insights (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the Amazon RDS User Guide.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#enablePerformanceInsights
   */
  readonly enablePerformanceInsights?: boolean;

  /**
   * The database engine to use for this DB instance.
   * Not every database engine is available in every Amazon Web Services Region.
   * Valid Values:
   * * aurora-mysql (for Aurora MySQL DB instances)
   * * aurora-postgresql (for Aurora PostgreSQL DB instances)
   * * custom-oracle-ee (for RDS Custom for Oracle DB instances)
   * * custom-oracle-ee-cdb (for RDS Custom for Oracle DB instances)
   * * custom-sqlserver-ee (for RDS Custom for SQL Server DB instances)
   * * custom-sqlserver-se (for RDS Custom for SQL Server DB instances)
   * * custom-sqlserver-web (for RDS Custom for SQL Server DB instances)
   * * mariadb
   * * mysql
   * * oracle-ee
   * * oracle-ee-cdb
   * * oracle-se2
   * * oracle-se2-cdb
   * * postgres
   * * sqlserver-ee
   * * sqlserver-se
   * * sqlserver-ex
   * * sqlserver-web
   *
   * @schema DbInstanceSpecForProvider#engine
   */
  readonly engine: string;

  /**
   * The version number of the database engine to use.
   * For a list of valid engine versions, use the DescribeDBEngineVersions operation.
   * The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every Amazon Web Services Region.
   * Amazon Aurora
   * Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster.
   * Amazon RDS Custom for Oracle
   * A custom engine version (CEV) that you have previously created. This setting is required for RDS Custom for Oracle. The CEV name has the following format: 19.customized_string. A valid CEV name is 19.my_cev1. For more information, see Creating an RDS Custom for Oracle DB instance (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-creating.html#custom-creating.create) in the Amazon RDS User Guide.
   * Amazon RDS Custom for SQL Server
   * See RDS Custom for SQL Server general requirements (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-reqs-limits-MS.html) in the Amazon RDS User Guide.
   * MariaDB
   * For information, see MariaDB on Amazon RDS Versions (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt) in the Amazon RDS User Guide.
   * Microsoft SQL Server
   * For information, see Microsoft SQL Server Versions on Amazon RDS (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport) in the Amazon RDS User Guide.
   * MySQL
   * For information, see MySQL on Amazon RDS Versions (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the Amazon RDS User Guide.
   * Oracle
   * For information, see Oracle Database Engine Release Notes (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html) in the Amazon RDS User Guide.
   * PostgreSQL
   * For information, see Amazon RDS for PostgreSQL versions and extensions (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts) in the Amazon RDS User Guide.
   * Note: Downgrades are not allowed by AWS and attempts to set a lower version will be ignored.
   *
   * @schema DbInstanceSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The DB instance snapshot identifier of the new DB instance snapshot created when SkipFinalSnapshot is disabled.
   * Specifying this parameter and also skipping the creation of a final DB instance snapshot with the SkipFinalShapshot parameter results in an error.
   * Constraints:
   * * Must be 1 to 255 letters, numbers, or hyphens.
   * * First character must be a letter
   * * Can't end with a hyphen or contain two consecutive hyphens
   *
   * @schema DbInstanceSpecForProvider#finalDBSnapshotIdentifier
   */
  readonly finalDbSnapshotIdentifier?: string;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to initially allocate for the DB instance. For information about valid IOPS values, see Amazon RDS DB instance storage (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html) in the Amazon RDS User Guide.
   * This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster.
   * Constraints:
   * * For RDS for MariaDB, MySQL, Oracle, and PostgreSQL - Must be a multiple between .5 and 50 of the storage amount for the DB instance.
   * * For RDS for SQL Server - Must be a multiple between 1 and 50 of the storage amount for the DB instance.
   *
   * @schema DbInstanceSpecForProvider#iops
   */
  readonly iops?: number;

  /**
   * The Amazon Web Services KMS key identifier for an encrypted DB instance.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN.
   * This setting doesn't apply to Amazon Aurora DB instances. The Amazon Web Services KMS key identifier is managed by the DB cluster. For more information, see CreateDBCluster.
   * If StorageEncrypted is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   * For Amazon RDS Custom, a KMS key is required for DB instances. For most RDS engines, if you leave this parameter empty while enabling StorageEncrypted, the engine uses the default KMS key. However, RDS Custom doesn't use the default key when this parameter is empty. You must explicitly specify a key.
   *
   * @schema DbInstanceSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DbInstanceSpecForProvider#kmsKeyIDRef
   */
  readonly kmsKeyIdRef?: DbInstanceSpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DbInstanceSpecForProvider#kmsKeyIDSelector
   */
  readonly kmsKeyIdSelector?: DbInstanceSpecForProviderKmsKeyIdSelector;

  /**
   * The license model information for this DB instance.
   * This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
   * Valid Values:
   * * RDS for MariaDB - general-public-license
   * * RDS for Microsoft SQL Server - license-included
   * * RDS for MySQL - general-public-license
   * * RDS for Oracle - bring-your-own-license | license-included
   * * RDS for PostgreSQL - postgresql-license
   *
   * @schema DbInstanceSpecForProvider#licenseModel
   */
  readonly licenseModel?: string;

  /**
   * Specifies whether to manage the master user password with Amazon Web Services Secrets Manager.
   * For more information, see Password management with Amazon Web Services Secrets Manager (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the Amazon RDS User Guide.
   * Constraints:
   * * Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword is specified.
   *
   * @schema DbInstanceSpecForProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
   * Constraints: Must contain from 8 to 41 characters.
   *
   * @schema DbInstanceSpecForProvider#masterUserPasswordSecretRef
   */
  readonly masterUserPasswordSecretRef?: DbInstanceSpecForProviderMasterUserPasswordSecretRef;

  /**
   * The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and managed in Amazon Web Services Secrets Manager.
   * This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets Manager for the DB instance.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN.
   * If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer managed KMS key.
   * There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   *
   * @schema DbInstanceSpecForProvider#masterUserSecretKMSKeyID
   */
  readonly masterUserSecretKmsKeyId?: string;

  /**
   * The name for the master user.
   * This setting doesn't apply to Amazon Aurora DB instances. The name for the master user is managed by the DB cluster.
   * This setting is required for RDS DB instances.
   * Constraints:
   * * Must be 1 to 16 letters, numbers, or underscores.
   * * First character must be a letter.
   * * Can't be a reserved word for the chosen database engine.
   *
   * @schema DbInstanceSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
   * For more information about this setting, including limitations that apply to it, see Managing capacity automatically with Amazon RDS storage autoscaling (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the Amazon RDS User Guide.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (Storage is managed by the DB cluster.)
   * * RDS Custom
   *
   * @schema DbInstanceSpecForProvider#maxAllocatedStorage
   */
  readonly maxAllocatedStorage?: number;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0.
   * If MonitoringRoleArn is specified, then you must set MonitoringInterval to a value other than 0.
   * This setting doesn't apply to RDS Custom DB instances.
   * Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60
   * Default: 0
   *
   * @schema DbInstanceSpecForProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see Setting Up and Enabling Enhanced Monitoring (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the Amazon RDS User Guide.
   * If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#monitoringRoleARN
   */
  readonly monitoringRoleArn?: string;

  /**
   * MonitoringRoleARNRef is a reference to an IAMRole used to set MonitoringRoleARN.
   *
   * @schema DbInstanceSpecForProvider#monitoringRoleArnRef
   */
  readonly monitoringRoleArnRef?: DbInstanceSpecForProviderMonitoringRoleArnRef;

  /**
   * MonitoringRoleARNSelector selects a reference to an IAMRole used to set MonitoringRoleARN.
   *
   * @schema DbInstanceSpecForProvider#monitoringRoleArnSelector
   */
  readonly monitoringRoleArnSelector?: DbInstanceSpecForProviderMonitoringRoleArnSelector;

  /**
   * Specifies whether the DB instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
   * This setting doesn't apply to the following DB instances:
   * * Amazon Aurora (DB instance Availability Zones (AZs) are managed by the DB cluster.)
   * * RDS Custom
   *
   * @schema DbInstanceSpecForProvider#multiAZ
   */
  readonly multiAz?: boolean;

  /**
   * The name of the NCHAR character set for the Oracle DB instance.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#ncharCharacterSetName
   */
  readonly ncharCharacterSetName?: string;

  /**
   * The network type of the DB instance.
   * The network type is determined by the DBSubnetGroup specified for the DB instance. A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6 protocols (DUAL).
   * For more information, see Working with a DB instance in a VPC (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html) in the Amazon RDS User Guide.
   * Valid Values: IPV4 | DUAL
   *
   * @schema DbInstanceSpecForProvider#networkType
   */
  readonly networkType?: string;

  /**
   * The option group to associate the DB instance with.
   * Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance after it is associated with a DB instance.
   * This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
   * If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#performanceInsightsKMSKeyID
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * The number of days to retain Performance Insights data.
   * This setting doesn't apply to RDS Custom DB instances.
   * Valid Values:
   * * 7
   * * month * 31, where month is a number of months from 1-23. Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)
   * * 731
   * Default: 7 days
   * If you specify a retention period that isn't valid, such as 94, Amazon RDS returns an error.
   *
   * @schema DbInstanceSpecForProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The port number on which the database accepts connections.
   * This setting doesn't apply to Aurora DB instances. The port number is managed by the cluster.
   * Valid Values: 1150-65535
   * Default:
   * * RDS for MariaDB - 3306
   * * RDS for Microsoft SQL Server - 1433
   * * RDS for MySQL - 3306
   * * RDS for Oracle - 1521
   * * RDS for PostgreSQL - 5432
   * Constraints:
   * * For RDS for Microsoft SQL Server, the value can't be 1234, 1434, 3260, 3343, 3389, 47001, or 49152-49156.
   *
   * @schema DbInstanceSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. For more information, see Backup window (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the Amazon RDS User Guide.
   * This setting doesn't apply to Amazon Aurora DB instances. The daily time range for creating automated backups is managed by the DB cluster.
   * Constraints:
   * * Must be in the format hh24:mi-hh24:mi.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must not conflict with the preferred maintenance window.
   * * Must be at least 30 minutes.
   *
   * @schema DbInstanceSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The time range each week during which system maintenance can occur. For more information, see Amazon RDS Maintenance Window (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance) in the Amazon RDS User Guide.
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week.
   * Constraints:
   * * Must be in the format ddd:hh24:mi-ddd:hh24:mi.
   * * The day values must be mon | tue | wed | thu | fri | sat | sun.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must not conflict with the preferred backup window.
   * * Must be at least 30 minutes.
   *
   * @schema DbInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
   * This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#processorFeatures
   */
  readonly processorFeatures?: DbInstanceSpecForProviderProcessorFeatures[];

  /**
   * The order of priority in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see Fault Tolerance for an Aurora DB Cluster (https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.AuroraHighAvailability.html#Aurora.Managing.FaultTolerance) in the Amazon Aurora User Guide.
   * This setting doesn't apply to RDS Custom DB instances.
   * Default: 1
   * Valid Values: 0 - 15
   *
   * @schema DbInstanceSpecForProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Specifies whether the DB instance is publicly accessible.
   * When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it.
   * When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
   * Default: The default behavior varies depending on whether DBSubnetGroupName is specified.
   * If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
   * * If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB instance is private.
   * * If the default VPC in the target Region has an internet gateway attached to it, the DB instance is public.
   * If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
   * * If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB instance is private.
   * * If the subnets are part of a VPC that has an internet gateway attached to it, the DB instance is public.
   *
   * @schema DbInstanceSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is which region the DBInstance will be created.
   *
   * @schema DbInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestoreFrom specifies the details of the backup to restore when creating a new DBInstance.
   *
   * @schema DbInstanceSpecForProvider#restoreFrom
   */
  readonly restoreFrom?: DbInstanceSpecForProviderRestoreFrom;

  /**
   * A value that indicates whether to skip the creation of a final DB instance snapshot before the DB instance is deleted. If skip is specified, no DB instance snapshot is created. If skip isn't specified, a DB instance snapshot is created before the DB instance is deleted. By default, skip isn't specified, and the DB instance snapshot is created. By default, this parameter is disabled.
   * You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is disabled.
   *
   * @schema DbInstanceSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifes whether the DB instance is encrypted. By default, it isn't encrypted.
   * For RDS Custom DB instances, either enable this setting or leave it unset. Otherwise, Amazon RDS reports an error.
   * This setting doesn't apply to Amazon Aurora DB instances. The encryption for DB instances is managed by the DB cluster.
   *
   * @schema DbInstanceSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The storage throughput value for the DB instance.
   * This setting applies only to the gp3 storage type.
   * This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#storageThroughput
   */
  readonly storageThroughput?: number;

  /**
   * The storage type to associate with the DB instance.
   * If you specify io1 or gp3, you must also include a value for the Iops parameter.
   * This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster.
   * Valid Values: gp2 | gp3 | io1 | standard
   * Default: io1, if the Iops parameter is specified. Otherwise, gp2.
   *
   * @schema DbInstanceSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Tags to assign to the DB instance.
   *
   * @schema DbInstanceSpecForProvider#tags
   */
  readonly tags?: DbInstanceSpecForProviderTags[];

  /**
   * The ARN from the key store with which to associate the instance for TDE encryption.
   * This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#tdeCredentialARN
   */
  readonly tdeCredentialArn?: string;

  /**
   * The password for the given ARN from the key store in order to access the device.
   * This setting doesn't apply to RDS Custom DB instances.
   *
   * @schema DbInstanceSpecForProvider#tdeCredentialPassword
   */
  readonly tdeCredentialPassword?: string;

  /**
   * The time zone of the DB instance. The time zone parameter is currently supported only by Microsoft SQL Server (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone).
   *
   * @schema DbInstanceSpecForProvider#timezone
   */
  readonly timezone?: string;

  /**
   * VPCSecurityGroupIDRefs are references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema DbInstanceSpecForProvider#vpcSecurityGroupIDRefs
   */
  readonly vpcSecurityGroupIdRefs?: DbInstanceSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema DbInstanceSpecForProvider#vpcSecurityGroupIDSelector
   */
  readonly vpcSecurityGroupIdSelector?: DbInstanceSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * A list of Amazon EC2 VPC security groups to authorize on this DB instance. This change is asynchronously applied as soon as possible.
   * This setting doesn't apply to RDS Custom.
   * Amazon Aurora Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. For more information, see ModifyDBCluster.
   * Constraints: * If supplied, must match existing VpcSecurityGroupIds.
   *
   * @schema DbInstanceSpecForProvider#vpcSecurityGroupIDs
   */
  readonly vpcSecurityGroupIDs?: string[];

}

/**
 * Converts an object of type 'DbInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProvider(obj: DbInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'autogeneratePassword': obj.autogeneratePassword,
    'availabilityZone': obj.availabilityZone,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'backupTarget': obj.backupTarget,
    'caCertificateIdentifier': obj.caCertificateIdentifier,
    'characterSetName': obj.characterSetName,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'customIAMInstanceProfile': obj.customIamInstanceProfile,
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_DbInstanceSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_DbInstanceSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'dbInstanceClass': obj.dbInstanceClass,
    'dbName': obj.dbName,
    'dbParameterGroupName': obj.dbParameterGroupName,
    'dbParameterGroupNameRef': toJson_DbInstanceSpecForProviderDbParameterGroupNameRef(obj.dbParameterGroupNameRef),
    'dbParameterGroupNameSelector': toJson_DbInstanceSpecForProviderDbParameterGroupNameSelector(obj.dbParameterGroupNameSelector),
    'dbSecurityGroups': obj.dbSecurityGroups?.map(y => y),
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_DbInstanceSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_DbInstanceSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'dbSystemID': obj.dbSystemId,
    'deleteAutomatedBackups': obj.deleteAutomatedBackups,
    'deletionProtection': obj.deletionProtection,
    'domain': obj.domain,
    'domainAuthSecretARN': obj.domainAuthSecretArn,
    'domainDNSIPs': obj.domainDnsiPs?.map(y => y),
    'domainFqdn': obj.domainFqdn,
    'domainIAMRoleName': obj.domainIamRoleName,
    'domainIAMRoleNameRef': toJson_DbInstanceSpecForProviderDomainIamRoleNameRef(obj.domainIamRoleNameRef),
    'domainIAMRoleNameSelector': toJson_DbInstanceSpecForProviderDomainIamRoleNameSelector(obj.domainIamRoleNameSelector),
    'domainOu': obj.domainOu,
    'enableCloudwatchLogsExports': obj.enableCloudwatchLogsExports?.map(y => y),
    'enableCustomerOwnedIP': obj.enableCustomerOwnedIp,
    'enableIAMDatabaseAuthentication': obj.enableIamDatabaseAuthentication,
    'enablePerformanceInsights': obj.enablePerformanceInsights,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalDBSnapshotIdentifier': obj.finalDbSnapshotIdentifier,
    'iops': obj.iops,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIDRef': toJson_DbInstanceSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIDSelector': toJson_DbInstanceSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'licenseModel': obj.licenseModel,
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'masterUserPasswordSecretRef': toJson_DbInstanceSpecForProviderMasterUserPasswordSecretRef(obj.masterUserPasswordSecretRef),
    'masterUserSecretKMSKeyID': obj.masterUserSecretKmsKeyId,
    'masterUsername': obj.masterUsername,
    'maxAllocatedStorage': obj.maxAllocatedStorage,
    'monitoringInterval': obj.monitoringInterval,
    'monitoringRoleARN': obj.monitoringRoleArn,
    'monitoringRoleArnRef': toJson_DbInstanceSpecForProviderMonitoringRoleArnRef(obj.monitoringRoleArnRef),
    'monitoringRoleArnSelector': toJson_DbInstanceSpecForProviderMonitoringRoleArnSelector(obj.monitoringRoleArnSelector),
    'multiAZ': obj.multiAz,
    'ncharCharacterSetName': obj.ncharCharacterSetName,
    'networkType': obj.networkType,
    'optionGroupName': obj.optionGroupName,
    'performanceInsightsKMSKeyID': obj.performanceInsightsKmsKeyId,
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'processorFeatures': obj.processorFeatures?.map(y => toJson_DbInstanceSpecForProviderProcessorFeatures(y)),
    'promotionTier': obj.promotionTier,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'restoreFrom': toJson_DbInstanceSpecForProviderRestoreFrom(obj.restoreFrom),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'storageEncrypted': obj.storageEncrypted,
    'storageThroughput': obj.storageThroughput,
    'storageType': obj.storageType,
    'tags': obj.tags?.map(y => toJson_DbInstanceSpecForProviderTags(y)),
    'tdeCredentialARN': obj.tdeCredentialArn,
    'tdeCredentialPassword': obj.tdeCredentialPassword,
    'timezone': obj.timezone,
    'vpcSecurityGroupIDRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_DbInstanceSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIDSelector': toJson_DbInstanceSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIDs': obj.vpcSecurityGroupIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbInstanceSpecManagementPolicies
 */
export enum DbInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbInstanceSpecProviderConfigRef
 */
export interface DbInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: DbInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecProviderConfigRef(obj: DbInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsTo
 */
export interface DbInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsTo(obj: DbInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbInstanceSpecWriteConnectionSecretToRef
 */
export interface DbInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecWriteConnectionSecretToRef(obj: DbInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterIdentifierRef is a reference to a DBCluster used to set DBClusterIdentifier.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRef
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierRef(obj: DbInstanceSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterIdentifierSelector selects a reference to a DBCluster used to set DBClusterIdentifier.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierSelector(obj: DbInstanceSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBParameterGroupNameRef is a reference to a DBParameterGroup used to set DBParameterGroupName.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameRef
 */
export interface DbInstanceSpecForProviderDbParameterGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbParameterGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbParameterGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbParameterGroupNameRef(obj: DbInstanceSpecForProviderDbParameterGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderDbParameterGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBParameterGroupNameSelector selects a reference to a DBParameterGroup used to set DBParameterGroupName.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameSelector
 */
export interface DbInstanceSpecForProviderDbParameterGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbParameterGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbParameterGroupNameSelector(obj: DbInstanceSpecForProviderDbParameterGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSubnetGroupNameRef is a reference to a DBSubnetGroup used to set DBSubnetGroupName.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameRef
 */
export interface DbInstanceSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbSubnetGroupNameRef(obj: DbInstanceSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSubnetGroupNameSelector selects a reference to a DBSubnetGroup used to set DBSubnetGroupName.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelector
 */
export interface DbInstanceSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbSubnetGroupNameSelector(obj: DbInstanceSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainIAMRoleNameRef is a reference to an IAMRole used to set DomainIAMRoleName.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameRef
 */
export interface DbInstanceSpecForProviderDomainIamRoleNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderDomainIamRoleNameRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDomainIamRoleNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDomainIamRoleNameRef(obj: DbInstanceSpecForProviderDomainIamRoleNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderDomainIamRoleNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainIAMRoleNameSelector selects a reference to an IAMRole used to set DomainIAMRoleName.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameSelector
 */
export interface DbInstanceSpecForProviderDomainIamRoleNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDomainIamRoleNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDomainIamRoleNameSelector(obj: DbInstanceSpecForProviderDomainIamRoleNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdRef
 */
export interface DbInstanceSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderKmsKeyIdRef(obj: DbInstanceSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdSelector
 */
export interface DbInstanceSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderKmsKeyIdSelector(obj: DbInstanceSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
 * Constraints: Must contain from 8 to 41 characters.
 *
 * @schema DbInstanceSpecForProviderMasterUserPasswordSecretRef
 */
export interface DbInstanceSpecForProviderMasterUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DbInstanceSpecForProviderMasterUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DbInstanceSpecForProviderMasterUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbInstanceSpecForProviderMasterUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderMasterUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderMasterUserPasswordSecretRef(obj: DbInstanceSpecForProviderMasterUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MonitoringRoleARNRef is a reference to an IAMRole used to set MonitoringRoleARN.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnRef
 */
export interface DbInstanceSpecForProviderMonitoringRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderMonitoringRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderMonitoringRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderMonitoringRoleArnRef(obj: DbInstanceSpecForProviderMonitoringRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderMonitoringRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MonitoringRoleARNSelector selects a reference to an IAMRole used to set MonitoringRoleARN.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnSelector
 */
export interface DbInstanceSpecForProviderMonitoringRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderMonitoringRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderMonitoringRoleArnSelector(obj: DbInstanceSpecForProviderMonitoringRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbInstanceSpecForProviderProcessorFeatures
 */
export interface DbInstanceSpecForProviderProcessorFeatures {
  /**
   * @schema DbInstanceSpecForProviderProcessorFeatures#name
   */
  readonly name?: string;

  /**
   * @schema DbInstanceSpecForProviderProcessorFeatures#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderProcessorFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderProcessorFeatures(obj: DbInstanceSpecForProviderProcessorFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreFrom specifies the details of the backup to restore when creating a new DBInstance.
 *
 * @schema DbInstanceSpecForProviderRestoreFrom
 */
export interface DbInstanceSpecForProviderRestoreFrom {
  /**
   * PointInTime specifies the details of the point in time restore.
   *
   * @schema DbInstanceSpecForProviderRestoreFrom#pointInTime
   */
  readonly pointInTime?: DbInstanceSpecForProviderRestoreFromPointInTime;

  /**
   * S3 specifies the details of the S3 backup to restore from.
   *
   * @schema DbInstanceSpecForProviderRestoreFrom#s3
   */
  readonly s3?: DbInstanceSpecForProviderRestoreFromS3;

  /**
   * Snapshot specifies the details of the snapshot to restore from.
   *
   * @schema DbInstanceSpecForProviderRestoreFrom#snapshot
   */
  readonly snapshot?: DbInstanceSpecForProviderRestoreFromSnapshot;

  /**
   * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. S3, Snapshot and PointInTime are supported.
   *
   * @schema DbInstanceSpecForProviderRestoreFrom#source
   */
  readonly source: DbInstanceSpecForProviderRestoreFromSource;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderRestoreFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderRestoreFrom(obj: DbInstanceSpecForProviderRestoreFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pointInTime': toJson_DbInstanceSpecForProviderRestoreFromPointInTime(obj.pointInTime),
    's3': toJson_DbInstanceSpecForProviderRestoreFromS3(obj.s3),
    'snapshot': toJson_DbInstanceSpecForProviderRestoreFromSnapshot(obj.snapshot),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbInstanceSpecForProviderTags
 */
export interface DbInstanceSpecForProviderTags {
  /**
   * @schema DbInstanceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbInstanceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderTags(obj: DbInstanceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefs
 */
export interface DbInstanceSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderVpcSecurityGroupIdRefs(obj: DbInstanceSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelector
 */
export interface DbInstanceSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderVpcSecurityGroupIdSelector(obj: DbInstanceSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicy
 */
export interface DbInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecProviderConfigRefPolicy(obj: DbInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface DbInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToConfigRef(obj: DbInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface DbInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToMetadata(obj: DbInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierRefPolicy(obj: DbInstanceSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy(obj: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameRefPolicy
 */
export interface DbInstanceSpecForProviderDbParameterGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbParameterGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbParameterGroupNameRefPolicy(obj: DbInstanceSpecForProviderDbParameterGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy
 */
export interface DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy(obj: DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj: DbInstanceSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameRefPolicy
 */
export interface DbInstanceSpecForProviderDomainIamRoleNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDomainIamRoleNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDomainIamRoleNameRefPolicy(obj: DbInstanceSpecForProviderDomainIamRoleNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy
 */
export interface DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy(obj: DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdRefPolicy
 */
export interface DbInstanceSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderKmsKeyIdRefPolicy(obj: DbInstanceSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DbInstanceSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderKmsKeyIdSelectorPolicy(obj: DbInstanceSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnRefPolicy
 */
export interface DbInstanceSpecForProviderMonitoringRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderMonitoringRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderMonitoringRoleArnRefPolicy(obj: DbInstanceSpecForProviderMonitoringRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy
 */
export interface DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj: DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PointInTime specifies the details of the point in time restore.
 *
 * @schema DbInstanceSpecForProviderRestoreFromPointInTime
 */
export interface DbInstanceSpecForProviderRestoreFromPointInTime {
  /**
   * RestoreTime is the date and time (UTC) to restore from. Must be before the latest restorable time for the DB instance. Can't be specified if the useLatestRestorableTime parameter is enabled. Example: 2011-09-07T23:45:00Z
   *
   * @schema DbInstanceSpecForProviderRestoreFromPointInTime#restoreTime
   */
  readonly restoreTime?: Date;

  /**
   * SourceDBInstanceAutomatedBackupsArn specifies the Amazon Resource Name (ARN) of the replicated automated backups from which to restore. Example: arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE
   *
   * @schema DbInstanceSpecForProviderRestoreFromPointInTime#sourceDBInstanceAutomatedBackupsArn
   */
  readonly sourceDbInstanceAutomatedBackupsArn?: string;

  /**
   * SourceDBInstanceIdentifier specifies the identifier of the source DB instance from which to restore. Constraints: Must match the identifier of an existing DB instance.
   *
   * @schema DbInstanceSpecForProviderRestoreFromPointInTime#sourceDBInstanceIdentifier
   */
  readonly sourceDbInstanceIdentifier?: string;

  /**
   * SourceDbiResourceID specifies the resource ID of the source DB instance from which to restore.
   *
   * @schema DbInstanceSpecForProviderRestoreFromPointInTime#sourceDbiResourceId
   */
  readonly sourceDbiResourceId?: string;

  /**
   * UseLatestRestorableTime indicates that the DB instance is restored from the latest backup Can't be specified if the restoreTime parameter is provided.
   *
   * @schema DbInstanceSpecForProviderRestoreFromPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderRestoreFromPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderRestoreFromPointInTime(obj: DbInstanceSpecForProviderRestoreFromPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreTime': obj.restoreTime?.toISOString(),
    'sourceDBInstanceAutomatedBackupsArn': obj.sourceDbInstanceAutomatedBackupsArn,
    'sourceDBInstanceIdentifier': obj.sourceDbInstanceIdentifier,
    'sourceDbiResourceId': obj.sourceDbiResourceId,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3 specifies the details of the S3 backup to restore from.
 *
 * @schema DbInstanceSpecForProviderRestoreFromS3
 */
export interface DbInstanceSpecForProviderRestoreFromS3 {
  /**
   * BucketName is the name of the S3 bucket containing the backup to restore.
   *
   * @schema DbInstanceSpecForProviderRestoreFromS3#bucketName
   */
  readonly bucketName: string;

  /**
   * IngestionRoleARN is the IAM role RDS can assume that will allow it to access the contents of the S3 bucket.
   *
   * @schema DbInstanceSpecForProviderRestoreFromS3#ingestionRoleARN
   */
  readonly ingestionRoleArn: string;

  /**
   * Prefix is the path prefix of the S3 bucket within which the backup to restore is located.
   *
   * @schema DbInstanceSpecForProviderRestoreFromS3#prefix
   */
  readonly prefix?: string;

  /**
   * SourceEngine is the engine used to create the backup. Must be "mysql".
   *
   * @schema DbInstanceSpecForProviderRestoreFromS3#sourceEngine
   */
  readonly sourceEngine: string;

  /**
   * SourceEngineVersion is the version of the engine used to create the backup. Example: "5.7.30"
   *
   * @schema DbInstanceSpecForProviderRestoreFromS3#sourceEngineVersion
   */
  readonly sourceEngineVersion: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderRestoreFromS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderRestoreFromS3(obj: DbInstanceSpecForProviderRestoreFromS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'ingestionRoleARN': obj.ingestionRoleArn,
    'prefix': obj.prefix,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Snapshot specifies the details of the snapshot to restore from.
 *
 * @schema DbInstanceSpecForProviderRestoreFromSnapshot
 */
export interface DbInstanceSpecForProviderRestoreFromSnapshot {
  /**
   * SnapshotIdentifier is the identifier of the snapshot to restore.
   *
   * @schema DbInstanceSpecForProviderRestoreFromSnapshot#snapshotIdentifier
   */
  readonly snapshotIdentifier: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderRestoreFromSnapshot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderRestoreFromSnapshot(obj: DbInstanceSpecForProviderRestoreFromSnapshot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'snapshotIdentifier': obj.snapshotIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. S3, Snapshot and PointInTime are supported.
 *
 * @schema DbInstanceSpecForProviderRestoreFromSource
 */
export enum DbInstanceSpecForProviderRestoreFromSource {
  /** S3 */
  S3 = "S3",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
  /** PointInTime */
  POINT_IN_TIME = "PointInTime",
}

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicyResolution
 */
export enum DbInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicyResolve
 */
export enum DbInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolution
 */
export enum DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolve
 */
export enum DbInstanceSpecForProviderDbParameterGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderDbParameterGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum DbInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolution
 */
export enum DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolve
 */
export enum DbInstanceSpecForProviderDomainIamRoleNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderDomainIamRoleNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DbInstanceSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DbInstanceSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution
 */
export enum DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve
 */
export enum DbInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum DbInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBInstanceRoleAssociation is the Schema for the DBInstanceRoleAssociations API
 *
 * @schema DBInstanceRoleAssociation
 */
export class DbInstanceRoleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBInstanceRoleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'DBInstanceRoleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "DBInstanceRoleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbInstanceRoleAssociationProps): any {
    return {
      ...DbInstanceRoleAssociation.GVK,
      ...toJson_DbInstanceRoleAssociationProps(props),
    };
  }

  /**
   * Defines a "DBInstanceRoleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbInstanceRoleAssociationProps) {
    super(scope, id, {
      ...DbInstanceRoleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbInstanceRoleAssociation.GVK,
      ...toJson_DbInstanceRoleAssociationProps(resolved),
    };
  }
}

/**
 * DBInstanceRoleAssociation is the Schema for the DBInstanceRoleAssociations API
 *
 * @schema DBInstanceRoleAssociation
 */
export interface DbInstanceRoleAssociationProps {
  /**
   * @schema DBInstanceRoleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBInstanceRoleAssociationSpec defines the desired state of DBInstanceRoleAssociation
   *
   * @schema DBInstanceRoleAssociation#spec
   */
  readonly spec: DbInstanceRoleAssociationSpec;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationProps(obj: DbInstanceRoleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbInstanceRoleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceRoleAssociationSpec defines the desired state of DBInstanceRoleAssociation
 *
 * @schema DbInstanceRoleAssociationSpec
 */
export interface DbInstanceRoleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbInstanceRoleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbInstanceRoleAssociationSpecDeletionPolicy;

  /**
   * DBInstanceRoleAssociationParameters defines the desired state of DBInstanceRoleAssociation
   *
   * @schema DbInstanceRoleAssociationSpec#forProvider
   */
  readonly forProvider: DbInstanceRoleAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbInstanceRoleAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: DbInstanceRoleAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbInstanceRoleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbInstanceRoleAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbInstanceRoleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbInstanceRoleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbInstanceRoleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbInstanceRoleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpec(obj: DbInstanceRoleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbInstanceRoleAssociationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbInstanceRoleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbInstanceRoleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbInstanceRoleAssociationSpecDeletionPolicy
 */
export enum DbInstanceRoleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBInstanceRoleAssociationParameters defines the desired state of DBInstanceRoleAssociation
 *
 * @schema DbInstanceRoleAssociationSpecForProvider
 */
export interface DbInstanceRoleAssociationSpecForProvider {
  /**
   * The name of the DB instance to associate the IAM role with.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#dbInstanceIdentifier
   */
  readonly dbInstanceIdentifier?: string;

  /**
   * DBInstanceIdentifierRef is a reference to a DBInstance used to set the DBInstanceIdentifier.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#dbInstanceIdentifierRef
   */
  readonly dbInstanceIdentifierRef?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef;

  /**
   * DBInstanceIdentifierSelector selects references to a DBInstance used to set the DBInstanceIdentifier.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#dbInstanceIdentifierSelector
   */
  readonly dbInstanceIdentifierSelector?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector;

  /**
   * The name of the feature for the DB instance that the IAM role is to be associated with. For information about supported feature names, see DBEngineVersion.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#featureName
   */
  readonly featureName: string;

  /**
   * Region is which region the DBInstanceRoleAssociation will be created.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the IAM role to associate with the DB instance, for example arn:aws:iam::123456789012:role/AccessRole.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * RoleARNRef is a reference to a IAM Role used to set RoleARN.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: DbInstanceRoleAssociationSpecForProviderRoleArnRef;

  /**
   * RoleARNSelector selects a reference to a IAM Role used to set RoleARN.
   *
   * @schema DbInstanceRoleAssociationSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: DbInstanceRoleAssociationSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProvider(obj: DbInstanceRoleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbInstanceIdentifier': obj.dbInstanceIdentifier,
    'dbInstanceIdentifierRef': toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef(obj.dbInstanceIdentifierRef),
    'dbInstanceIdentifierSelector': toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector(obj.dbInstanceIdentifierSelector),
    'featureName': obj.featureName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DbInstanceRoleAssociationSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DbInstanceRoleAssociationSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbInstanceRoleAssociationSpecManagementPolicies
 */
export enum DbInstanceRoleAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbInstanceRoleAssociationSpecProviderConfigRef
 */
export interface DbInstanceRoleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceRoleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceRoleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecProviderConfigRef(obj: DbInstanceRoleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceRoleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsTo
 */
export interface DbInstanceRoleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsTo(obj: DbInstanceRoleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbInstanceRoleAssociationSpecWriteConnectionSecretToRef
 */
export interface DbInstanceRoleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbInstanceRoleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbInstanceRoleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecWriteConnectionSecretToRef(obj: DbInstanceRoleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceIdentifierRef is a reference to a DBInstance used to set the DBInstanceIdentifier.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef
 */
export interface DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef(obj: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceIdentifierSelector selects references to a DBInstance used to set the DBInstanceIdentifier.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector
 */
export interface DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector(obj: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleARNRef is a reference to a IAM Role used to set RoleARN.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRef
 */
export interface DbInstanceRoleAssociationSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRef#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderRoleArnRef(obj: DbInstanceRoleAssociationSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleARNSelector selects a reference to a IAM Role used to set RoleARN.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelector
 */
export interface DbInstanceRoleAssociationSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderRoleArnSelector(obj: DbInstanceRoleAssociationSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceRoleAssociationSpecProviderConfigRefPolicy
 */
export interface DbInstanceRoleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecProviderConfigRefPolicy(obj: DbInstanceRoleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata(obj: DbInstanceRoleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy
 */
export interface DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy(obj: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy
 */
export interface DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy(obj: DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy
 */
export interface DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy(obj: DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy
 */
export interface DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj: DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbInstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBParameterGroup is the Schema for the DBParameterGroups API
 *
 * @schema DBParameterGroup
 */
export class DbParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'DBParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "DBParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbParameterGroupProps): any {
    return {
      ...DbParameterGroup.GVK,
      ...toJson_DbParameterGroupProps(props),
    };
  }

  /**
   * Defines a "DBParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbParameterGroupProps) {
    super(scope, id, {
      ...DbParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbParameterGroup.GVK,
      ...toJson_DbParameterGroupProps(resolved),
    };
  }
}

/**
 * DBParameterGroup is the Schema for the DBParameterGroups API
 *
 * @schema DBParameterGroup
 */
export interface DbParameterGroupProps {
  /**
   * @schema DBParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBParameterGroupSpec defines the desired state of DBParameterGroup
   *
   * @schema DBParameterGroup#spec
   */
  readonly spec: DbParameterGroupSpec;

}

/**
 * Converts an object of type 'DbParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupProps(obj: DbParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBParameterGroupSpec defines the desired state of DBParameterGroup
 *
 * @schema DbParameterGroupSpec
 */
export interface DbParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbParameterGroupSpecDeletionPolicy;

  /**
   * DBParameterGroupParameters defines the desired state of DBParameterGroup
   *
   * @schema DbParameterGroupSpec#forProvider
   */
  readonly forProvider: DbParameterGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbParameterGroupSpec#managementPolicies
   */
  readonly managementPolicies?: DbParameterGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbParameterGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpec(obj: DbParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbParameterGroupSpecDeletionPolicy
 */
export enum DbParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBParameterGroupParameters defines the desired state of DBParameterGroup
 *
 * @schema DbParameterGroupSpecForProvider
 */
export interface DbParameterGroupSpecForProvider {
  /**
   * The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a database engine and engine version compatible with that DB parameter group family.
   * To list all of the available parameter group families for a DB engine, use the following command:
   * aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine>
   * For example, to list all of the available parameter group families for the MySQL DB engine, use the following command:
   * aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine mysql
   * The output contains duplicates.
   * The following are the valid DB engine values:
   * * aurora (for MySQL 5.6-compatible Aurora)
   * * aurora-mysql (for MySQL 5.7-compatible Aurora)
   * * aurora-postgresql
   * * mariadb
   * * mysql
   * * oracle-ee
   * * oracle-ee-cdb
   * * oracle-se2
   * * oracle-se2-cdb
   * * postgres
   * * sqlserver-ee
   * * sqlserver-se
   * * sqlserver-ex
   * * sqlserver-web
   * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
   *
   * @schema DbParameterGroupSpecForProvider#dbParameterGroupFamily
   */
  readonly dbParameterGroupFamily?: string;

  /**
   * DBParameterGroupFamilySelector determines DBParameterGroupFamily from the engine and engine version.
   * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
   * Will not be used if DBParameterGroupFamily is already set.
   *
   * @schema DbParameterGroupSpecForProvider#dbParameterGroupFamilySelector
   */
  readonly dbParameterGroupFamilySelector?: DbParameterGroupSpecForProviderDbParameterGroupFamilySelector;

  /**
   * The description for the DB parameter group.
   *
   * @schema DbParameterGroupSpecForProvider#description
   */
  readonly description: string;

  /**
   * A list of parameters to associate with this DB parameter group. The fields ApplyMethod, ParameterName and ParameterValue are required for every parameter. Note: AWS actually only modifies the ApplyMethod of a parameter, if the ParameterValue changes too.
   *
   * @schema DbParameterGroupSpecForProvider#parameters
   */
  readonly parameters?: DbParameterGroupSpecForProviderParameters[];

  /**
   * Region is which region the DBParameterGroup will be created.
   *
   * @schema DbParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tags to assign to the DB parameter group.
   *
   * @schema DbParameterGroupSpecForProvider#tags
   */
  readonly tags?: DbParameterGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'DbParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecForProvider(obj: DbParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbParameterGroupFamily': obj.dbParameterGroupFamily,
    'dbParameterGroupFamilySelector': toJson_DbParameterGroupSpecForProviderDbParameterGroupFamilySelector(obj.dbParameterGroupFamilySelector),
    'description': obj.description,
    'parameters': obj.parameters?.map(y => toJson_DbParameterGroupSpecForProviderParameters(y)),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_DbParameterGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbParameterGroupSpecManagementPolicies
 */
export enum DbParameterGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbParameterGroupSpecProviderConfigRef
 */
export interface DbParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: DbParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecProviderConfigRef(obj: DbParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsTo
 */
export interface DbParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecPublishConnectionDetailsTo(obj: DbParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbParameterGroupSpecWriteConnectionSecretToRef
 */
export interface DbParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecWriteConnectionSecretToRef(obj: DbParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBParameterGroupFamilySelector determines DBParameterGroupFamily from the engine and engine version.
 * One of DBParameterGroupFamily or DBParameterGroupFamilySelector is required.
 * Will not be used if DBParameterGroupFamily is already set.
 *
 * @schema DbParameterGroupSpecForProviderDbParameterGroupFamilySelector
 */
export interface DbParameterGroupSpecForProviderDbParameterGroupFamilySelector {
  /**
   * Engine is the name of the database engine.
   *
   * @schema DbParameterGroupSpecForProviderDbParameterGroupFamilySelector#engine
   */
  readonly engine: string;

  /**
   * EngineVersion is the version of the database engine. If it is nil, the default engine version given by AWS will be used.
   *
   * @schema DbParameterGroupSpecForProviderDbParameterGroupFamilySelector#engineVersion
   */
  readonly engineVersion?: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecForProviderDbParameterGroupFamilySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecForProviderDbParameterGroupFamilySelector(obj: DbParameterGroupSpecForProviderDbParameterGroupFamilySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomParameter are custom parameters for the Parameter
 *
 * @schema DbParameterGroupSpecForProviderParameters
 */
export interface DbParameterGroupSpecForProviderParameters {
  /**
   * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
   *
   * @schema DbParameterGroupSpecForProviderParameters#applyMethod
   */
  readonly applyMethod: DbParameterGroupSpecForProviderParametersApplyMethod;

  /**
   * The name of the parameter.
   *
   * @schema DbParameterGroupSpecForProviderParameters#parameterName
   */
  readonly parameterName: string;

  /**
   * The value of the parameter.
   *
   * @schema DbParameterGroupSpecForProviderParameters#parameterValue
   */
  readonly parameterValue: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecForProviderParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecForProviderParameters(obj: DbParameterGroupSpecForProviderParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbParameterGroupSpecForProviderTags
 */
export interface DbParameterGroupSpecForProviderTags {
  /**
   * @schema DbParameterGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbParameterGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecForProviderTags(obj: DbParameterGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbParameterGroupSpecProviderConfigRefPolicy
 */
export interface DbParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecProviderConfigRefPolicy(obj: DbParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface DbParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: DbParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface DbParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecPublishConnectionDetailsToMetadata(obj: DbParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
 *
 * @schema DbParameterGroupSpecForProviderParametersApplyMethod
 */
export enum DbParameterGroupSpecForProviderParametersApplyMethod {
  /** immediate */
  IMMEDIATE = "immediate",
  /** pending-reboot */
  PENDING_HYPHEN_REBOOT = "pending-reboot",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum DbParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum DbParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalCluster is the Schema for the GlobalClusters API
 *
 * @schema GlobalCluster
 */
export class GlobalCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'GlobalCluster',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalClusterProps): any {
    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(props),
    };
  }

  /**
   * Defines a "GlobalCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalClusterProps) {
    super(scope, id, {
      ...GlobalCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(resolved),
    };
  }
}

/**
 * GlobalCluster is the Schema for the GlobalClusters API
 *
 * @schema GlobalCluster
 */
export interface GlobalClusterProps {
  /**
   * @schema GlobalCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalClusterSpec defines the desired state of GlobalCluster
   *
   * @schema GlobalCluster#spec
   */
  readonly spec: GlobalClusterSpec;

}

/**
 * Converts an object of type 'GlobalClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterProps(obj: GlobalClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalClusterSpec defines the desired state of GlobalCluster
 *
 * @schema GlobalClusterSpec
 */
export interface GlobalClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalClusterSpecDeletionPolicy;

  /**
   * GlobalClusterParameters defines the desired state of GlobalCluster
   *
   * @schema GlobalClusterSpec#forProvider
   */
  readonly forProvider: GlobalClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GlobalClusterSpec#managementPolicies
   */
  readonly managementPolicies?: GlobalClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpec(obj: GlobalClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GlobalClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalClusterSpecDeletionPolicy
 */
export enum GlobalClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GlobalClusterParameters defines the desired state of GlobalCluster
 *
 * @schema GlobalClusterSpecForProvider
 */
export interface GlobalClusterSpecForProvider {
  /**
   * The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster.
   * Constraints:
   * * Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.
   *
   * @schema GlobalClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.
   *
   * @schema GlobalClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The database engine to use for this global database cluster.
   * Valid Values: aurora-mysql | aurora-postgresql
   * Constraints:
   * * Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.
   *
   * @schema GlobalClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The engine version to use for this global database cluster.
   * Constraints:
   * * Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.
   *
   * @schema GlobalClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Region is which region the GlobalCluster will be created.
   *
   * @schema GlobalClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) to use as the primary cluster of the global database.
   * If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:
   * * DatabaseName
   * * Engine
   * * EngineVersion
   * * StorageEncrypted
   *
   * @schema GlobalClusterSpecForProvider#sourceDBClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * SourceDBClusterIdentifierRef is a reference to a DBCluster used to set SourceDBClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDBClusterIdentifierRef
   */
  readonly sourceDbClusterIdentifierRef?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef;

  /**
   * SourceDBClusterIdentifierSelector selects a reference to a DBCluster used to set SourceDBClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDBClusterIdentifierSelector
   */
  readonly sourceDbClusterIdentifierSelector?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector;

  /**
   * Specifies whether to enable storage encryption for the new global database cluster.
   * Constraints:
   * * Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.
   *
   * @schema GlobalClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProvider(obj: GlobalClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'deletionProtection': obj.deletionProtection,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'region': obj.region,
    'sourceDBClusterIdentifier': obj.sourceDbClusterIdentifier,
    'sourceDBClusterIdentifierRef': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj.sourceDbClusterIdentifierRef),
    'sourceDBClusterIdentifierSelector': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj.sourceDbClusterIdentifierSelector),
    'storageEncrypted': obj.storageEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GlobalClusterSpecManagementPolicies
 */
export enum GlobalClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalClusterSpecProviderConfigRef
 */
export interface GlobalClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRef(obj: GlobalClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsTo
 */
export interface GlobalClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj: GlobalClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalClusterSpecWriteConnectionSecretToRef
 */
export interface GlobalClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj: GlobalClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceDBClusterIdentifierRef is a reference to a DBCluster used to set SourceDBClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceDBClusterIdentifierSelector selects a reference to a DBCluster used to set SourceDBClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicy
 */
export interface GlobalClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRefPolicy(obj: GlobalClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj: GlobalClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolution
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolve
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OptionGroup is the Schema for the OptionGroups API
 *
 * @schema OptionGroup
 */
export class OptionGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OptionGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.crossplane.io/v1alpha1',
    kind: 'OptionGroup',
  }

  /**
   * Renders a Kubernetes manifest for "OptionGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OptionGroupProps): any {
    return {
      ...OptionGroup.GVK,
      ...toJson_OptionGroupProps(props),
    };
  }

  /**
   * Defines a "OptionGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OptionGroupProps) {
    super(scope, id, {
      ...OptionGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OptionGroup.GVK,
      ...toJson_OptionGroupProps(resolved),
    };
  }
}

/**
 * OptionGroup is the Schema for the OptionGroups API
 *
 * @schema OptionGroup
 */
export interface OptionGroupProps {
  /**
   * @schema OptionGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OptionGroupSpec defines the desired state of OptionGroup
   *
   * @schema OptionGroup#spec
   */
  readonly spec: OptionGroupSpec;

}

/**
 * Converts an object of type 'OptionGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupProps(obj: OptionGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OptionGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OptionGroupSpec defines the desired state of OptionGroup
 *
 * @schema OptionGroupSpec
 */
export interface OptionGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OptionGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: OptionGroupSpecDeletionPolicy;

  /**
   * OptionGroupParameters defines the desired state of OptionGroup
   *
   * @schema OptionGroupSpec#forProvider
   */
  readonly forProvider: OptionGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OptionGroupSpec#managementPolicies
   */
  readonly managementPolicies?: OptionGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OptionGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: OptionGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OptionGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OptionGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OptionGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OptionGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OptionGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpec(obj: OptionGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OptionGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OptionGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OptionGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OptionGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OptionGroupSpecDeletionPolicy
 */
export enum OptionGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * OptionGroupParameters defines the desired state of OptionGroup
 *
 * @schema OptionGroupSpecForProvider
 */
export interface OptionGroupSpecForProvider {
  /**
   * A value that indicates whether to apply the change immediately or during the next maintenance window for each instance associated with the option group.
   *
   * @schema OptionGroupSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Specifies the name of the engine that this option group should be associated with.
   * Valid Values:
   * * mariadb
   * * mysql
   * * oracle-ee
   * * oracle-ee-cdb
   * * oracle-se2
   * * oracle-se2-cdb
   * * postgres
   * * sqlserver-ee
   * * sqlserver-se
   * * sqlserver-ex
   * * sqlserver-web
   *
   * @schema OptionGroupSpecForProvider#engineName
   */
  readonly engineName: string;

  /**
   * Specifies the major version of the engine that this option group should be associated with.
   *
   * @schema OptionGroupSpecForProvider#majorEngineVersion
   */
  readonly majorEngineVersion: string;

  /**
   * Option in this list are added to the option group or, if already present, the specified configuration is used to update the existing configuration.
   *
   * @schema OptionGroupSpecForProvider#option
   */
  readonly option?: OptionGroupSpecForProviderOption[];

  /**
   * The description of the option group.
   *
   * @schema OptionGroupSpecForProvider#optionGroupDescription
   */
  readonly optionGroupDescription: string;

  /**
   * Region is which region the OptionGroup will be created.
   *
   * @schema OptionGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tags to assign to the option group.
   *
   * @schema OptionGroupSpecForProvider#tags
   */
  readonly tags?: OptionGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'OptionGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProvider(obj: OptionGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'engineName': obj.engineName,
    'majorEngineVersion': obj.majorEngineVersion,
    'option': obj.option?.map(y => toJson_OptionGroupSpecForProviderOption(y)),
    'optionGroupDescription': obj.optionGroupDescription,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_OptionGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OptionGroupSpecManagementPolicies
 */
export enum OptionGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OptionGroupSpecProviderConfigRef
 */
export interface OptionGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OptionGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OptionGroupSpecProviderConfigRef#policy
   */
  readonly policy?: OptionGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OptionGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecProviderConfigRef(obj: OptionGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OptionGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsTo
 */
export interface OptionGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OptionGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OptionGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsTo(obj: OptionGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OptionGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OptionGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OptionGroupSpecWriteConnectionSecretToRef
 */
export interface OptionGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OptionGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OptionGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OptionGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecWriteConnectionSecretToRef(obj: OptionGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomOptionConfiguration are custom parameters for the OptionConfiguration
 *
 * @schema OptionGroupSpecForProviderOption
 */
export interface OptionGroupSpecForProviderOption {
  /**
   * @schema OptionGroupSpecForProviderOption#dbSecurityGroupMemberships
   */
  readonly dbSecurityGroupMemberships?: string[];

  /**
   * @schema OptionGroupSpecForProviderOption#optionName
   */
  readonly optionName?: string;

  /**
   * @schema OptionGroupSpecForProviderOption#optionSettings
   */
  readonly optionSettings?: OptionGroupSpecForProviderOptionOptionSettings[];

  /**
   * @schema OptionGroupSpecForProviderOption#optionVersion
   */
  readonly optionVersion?: string;

  /**
   * @schema OptionGroupSpecForProviderOption#port
   */
  readonly port?: number;

  /**
   * @schema OptionGroupSpecForProviderOption#vpcSecurityGroupMemberships
   */
  readonly vpcSecurityGroupMemberships?: string[];

}

/**
 * Converts an object of type 'OptionGroupSpecForProviderOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProviderOption(obj: OptionGroupSpecForProviderOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbSecurityGroupMemberships': obj.dbSecurityGroupMemberships?.map(y => y),
    'optionName': obj.optionName,
    'optionSettings': obj.optionSettings?.map(y => toJson_OptionGroupSpecForProviderOptionOptionSettings(y)),
    'optionVersion': obj.optionVersion,
    'port': obj.port,
    'vpcSecurityGroupMemberships': obj.vpcSecurityGroupMemberships?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OptionGroupSpecForProviderTags
 */
export interface OptionGroupSpecForProviderTags {
  /**
   * @schema OptionGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema OptionGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProviderTags(obj: OptionGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicy
 */
export interface OptionGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OptionGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OptionGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OptionGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OptionGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OptionGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecProviderConfigRefPolicy(obj: OptionGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface OptionGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToConfigRef(obj: OptionGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToMetadata
 */
export interface OptionGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToMetadata(obj: OptionGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomOptionGroupOptionSetting are custom parameters for the OptionGroupOptionSetting
 *
 * @schema OptionGroupSpecForProviderOptionOptionSettings
 */
export interface OptionGroupSpecForProviderOptionOptionSettings {
  /**
   * @schema OptionGroupSpecForProviderOptionOptionSettings#name
   */
  readonly name?: string;

  /**
   * @schema OptionGroupSpecForProviderOptionOptionSettings#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecForProviderOptionOptionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProviderOptionOptionSettings(obj: OptionGroupSpecForProviderOptionOptionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicyResolution
 */
export enum OptionGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicyResolve
 */
export enum OptionGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

