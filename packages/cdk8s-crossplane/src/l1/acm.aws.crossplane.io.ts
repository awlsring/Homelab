// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Certificate is a managed resource that represents an AWS Certificate Manager. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acm.aws.crossplane.io/v1alpha1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is a managed resource that represents an AWS Certificate Manager. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * CertificateParameters defines the desired state of an AWS Certificate.
   *
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateParameters defines the desired state of an AWS Certificate.
 *
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the private certificate authority (CA)that will be used to issue the certificate.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityARN
   */
  readonly certificateAuthorityArn?: string;

  /**
   * CertificateAuthorityARNRef references an AWS ACMPCA CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateSpecForProvider#certificateAuthorityARNRef
   */
  readonly certificateAuthorityArnRef?: CertificateSpecForProviderCertificateAuthorityArnRef;

  /**
   * CertificateAuthorityARNSelector selects a reference to an AWS ACMPCA CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateSpecForProvider#certificateAuthorityARNSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateSpecForProviderCertificateAuthorityArnSelector;

  /**
   * Parameter add the certificate to a certificate transparency log.
   *
   * @schema CertificateSpecForProvider#certificateTransparencyLoggingPreference
   */
  readonly certificateTransparencyLoggingPreference?: CertificateSpecForProviderCertificateTransparencyLoggingPreference;

  /**
   * Fully qualified domain name (FQDN),that to secure with an ACM certificate.
   *
   * @schema CertificateSpecForProvider#domainName
   */
  readonly domainName: string;

  /**
   * The domain name that you want ACM to use to send you emails so that you can validate domain ownership.
   *
   * @schema CertificateSpecForProvider#domainValidationOptions
   */
  readonly domainValidationOptions?: CertificateSpecForProviderDomainValidationOptions[];

  /**
   * Region is the region you'd like your Certificate to be created in.
   *
   * @schema CertificateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Flag to renew the certificate
   *
   * @schema CertificateSpecForProvider#renewCertificate
   */
  readonly renewCertificate?: boolean;

  /**
   * Subject Alternative Name extension of the ACM certificate.
   *
   * @schema CertificateSpecForProvider#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: string[];

  /**
   * One or more resource tags to associate with the certificate.
   *
   * @schema CertificateSpecForProvider#tags
   */
  readonly tags: CertificateSpecForProviderTags[];

  /**
   * Method to validate certificate.
   *
   * @schema CertificateSpecForProvider#validationMethod
   */
  readonly validationMethod?: CertificateSpecForProviderValidationMethod;

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityARN': obj.certificateAuthorityArn,
    'certificateAuthorityARNRef': toJson_CertificateSpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityARNSelector': toJson_CertificateSpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'certificateTransparencyLoggingPreference': obj.certificateTransparencyLoggingPreference,
    'domainName': obj.domainName,
    'domainValidationOptions': obj.domainValidationOptions?.map(y => toJson_CertificateSpecForProviderDomainValidationOptions(y)),
    'region': obj.region,
    'renewCertificate': obj.renewCertificate,
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => y),
    'tags': obj.tags?.map(y => toJson_CertificateSpecForProviderTags(y)),
    'validationMethod': obj.validationMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateSpecManagementPolicies
 */
export enum CertificateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNRef references an AWS ACMPCA CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateSpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnRef(obj: CertificateSpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNSelector selects a reference to an AWS ACMPCA CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateSpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnSelector(obj: CertificateSpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameter add the certificate to a certificate transparency log.
 *
 * @schema CertificateSpecForProviderCertificateTransparencyLoggingPreference
 */
export enum CertificateSpecForProviderCertificateTransparencyLoggingPreference {
  /** ENABLED */
  ENABLED = "ENABLED",
  /** DISABLED */
  DISABLED = "DISABLED",
}

/**
 * DomainValidationOption validate domain ownership.
 *
 * @schema CertificateSpecForProviderDomainValidationOptions
 */
export interface CertificateSpecForProviderDomainValidationOptions {
  /**
   * Additional Fully qualified domain name (FQDN), that to secure with an ACM certificate.
   *
   * @schema CertificateSpecForProviderDomainValidationOptions#domainName
   */
  readonly domainName: string;

  /**
   * Method to validate certificate
   *
   * @schema CertificateSpecForProviderDomainValidationOptions#validationDomain
   */
  readonly validationDomain: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderDomainValidationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderDomainValidationOptions(obj: CertificateSpecForProviderDomainValidationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'validationDomain': obj.validationDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag represents user-provided metadata that can be associated
 *
 * @schema CertificateSpecForProviderTags
 */
export interface CertificateSpecForProviderTags {
  /**
   * The key name that can be used to look up or retrieve the associated value.
   *
   * @schema CertificateSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value associated with this tag.
   *
   * @schema CertificateSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderTags(obj: CertificateSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method to validate certificate.
 *
 * @schema CertificateSpecForProviderValidationMethod
 */
export enum CertificateSpecForProviderValidationMethod {
  /** DNS */
  DNS = "DNS",
  /** EMAIL */
  EMAIL = "EMAIL",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateSpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Certificate is a managed resource that represents an AWS Certificate Manager.
 *
 * @schema CertificateV1Beta1
 */
export class CertificateV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acm.aws.crossplane.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateV1Beta1Props): any {
    return {
      ...CertificateV1Beta1.GVK,
      ...toJson_CertificateV1Beta1Props(props),
    };
  }

  /**
   * Defines a "CertificateV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateV1Beta1Props) {
    super(scope, id, {
      ...CertificateV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateV1Beta1.GVK,
      ...toJson_CertificateV1Beta1Props(resolved),
    };
  }
}

/**
 * Certificate is a managed resource that represents an AWS Certificate Manager.
 *
 * @schema CertificateV1Beta1
 */
export interface CertificateV1Beta1Props {
  /**
   * @schema CertificateV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema CertificateV1Beta1#spec
   */
  readonly spec: CertificateV1Beta1Spec;

}

/**
 * Converts an object of type 'CertificateV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1Props(obj: CertificateV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateV1Beta1Spec
 */
export interface CertificateV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateV1Beta1SpecDeletionPolicy;

  /**
   * CertificateParameters defines the desired state of an AWS Certificate.
   *
   * @schema CertificateV1Beta1Spec#forProvider
   */
  readonly forProvider: CertificateV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: CertificateV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1Spec(obj: CertificateV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateV1Beta1SpecDeletionPolicy
 */
export enum CertificateV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateParameters defines the desired state of an AWS Certificate.
 *
 * @schema CertificateV1Beta1SpecForProvider
 */
export interface CertificateV1Beta1SpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the private certificate authority (CA)that will be used to issue the certificate.
   *
   * @schema CertificateV1Beta1SpecForProvider#certificateAuthorityARN
   */
  readonly certificateAuthorityArn?: string;

  /**
   * CertificateAuthorityARNRef references an AWS ACMPCA CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateV1Beta1SpecForProvider#certificateAuthorityARNRef
   */
  readonly certificateAuthorityArnRef?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef;

  /**
   * CertificateAuthorityARNSelector selects a reference to an AWS ACMPCA CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateV1Beta1SpecForProvider#certificateAuthorityARNSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector;

  /**
   * Fully qualified domain name (FQDN),that to secure with an ACM certificate.
   *
   * @schema CertificateV1Beta1SpecForProvider#domainName
   */
  readonly domainName: string;

  /**
   * The domain name that you want ACM to use to send you emails so that you can validate domain ownership.
   *
   * @schema CertificateV1Beta1SpecForProvider#domainValidationOptions
   */
  readonly domainValidationOptions?: CertificateV1Beta1SpecForProviderDomainValidationOptions[];

  /**
   * Specifies the algorithm of the public and private key pair that your certificate uses to encrypt data. RSA is the default key algorithm for ACM certificates. Elliptic Curve Digital Signature Algorithm (ECDSA) keys are smaller, offering security comparable to RSA keys but with greater computing efficiency. However, ECDSA is not supported by all network clients. Some AWS services may require RSA keys, or only support ECDSA keys of a particular size, while others allow the use of either RSA and ECDSA keys to ensure that compatibility is not broken. Check the requirements for the AWS service where you plan to deploy your certificate. Default: RSA_2048 Note: ACM can request the issue of new certificates using the following algorithms: "RSA_2048", "EC_prime256v1" and "EC_secp384r1". The remaining algorithms are supported only for imported certificates. See also AWS docs: https://docs.aws.amazon.com/acm/latest/userguide/acm-certificate.html#algorithms.title
   *
   * @schema CertificateV1Beta1SpecForProvider#keyAlgorithm
   */
  readonly keyAlgorithm?: string;

  /**
   * Currently, you can use this parameter to specify whether to add the certificate to a certificate transparency log. Certificate transparency makes it possible to detect SSL/TLS certificates that have been mistakenly or maliciously issued. Certificates that have not been logged typically produce an error message in a browser. For more information, see Opting Out of Certificate Transparency Logging (https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency).
   *
   * @schema CertificateV1Beta1SpecForProvider#options
   */
  readonly options?: CertificateV1Beta1SpecForProviderOptions;

  /**
   * Region is the region you'd like your Certificate to be created in.
   *
   * @schema CertificateV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * Subject Alternative Name extension of the ACM certificate.
   *
   * @schema CertificateV1Beta1SpecForProvider#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: string[];

  /**
   * One or more resource tags to associate with the certificate.
   *
   * @schema CertificateV1Beta1SpecForProvider#tags
   */
  readonly tags: CertificateV1Beta1SpecForProviderTags[];

  /**
   * Method to validate certificate.
   *
   * @schema CertificateV1Beta1SpecForProvider#validationMethod
   */
  readonly validationMethod?: CertificateV1Beta1SpecForProviderValidationMethod;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProvider(obj: CertificateV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityARN': obj.certificateAuthorityArn,
    'certificateAuthorityARNRef': toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityARNSelector': toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'domainName': obj.domainName,
    'domainValidationOptions': obj.domainValidationOptions?.map(y => toJson_CertificateV1Beta1SpecForProviderDomainValidationOptions(y)),
    'keyAlgorithm': obj.keyAlgorithm,
    'options': toJson_CertificateV1Beta1SpecForProviderOptions(obj.options),
    'region': obj.region,
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => y),
    'tags': obj.tags?.map(y => toJson_CertificateV1Beta1SpecForProviderTags(y)),
    'validationMethod': obj.validationMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateV1Beta1SpecManagementPolicies
 */
export enum CertificateV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateV1Beta1SpecProviderConfigRef
 */
export interface CertificateV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: CertificateV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecProviderConfigRef(obj: CertificateV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsTo
 */
export interface CertificateV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecPublishConnectionDetailsTo(obj: CertificateV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateV1Beta1SpecWriteConnectionSecretToRef
 */
export interface CertificateV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecWriteConnectionSecretToRef(obj: CertificateV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNRef references an AWS ACMPCA CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef(obj: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNSelector selects a reference to an AWS ACMPCA CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector(obj: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainValidationOption validate domain ownership.
 *
 * @schema CertificateV1Beta1SpecForProviderDomainValidationOptions
 */
export interface CertificateV1Beta1SpecForProviderDomainValidationOptions {
  /**
   * Additional Fully qualified domain name (FQDN), that to secure with an ACM certificate.
   *
   * @schema CertificateV1Beta1SpecForProviderDomainValidationOptions#domainName
   */
  readonly domainName: string;

  /**
   * Method to validate certificate
   *
   * @schema CertificateV1Beta1SpecForProviderDomainValidationOptions#validationDomain
   */
  readonly validationDomain: string;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderDomainValidationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderDomainValidationOptions(obj: CertificateV1Beta1SpecForProviderDomainValidationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'validationDomain': obj.validationDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Currently, you can use this parameter to specify whether to add the certificate to a certificate transparency log. Certificate transparency makes it possible to detect SSL/TLS certificates that have been mistakenly or maliciously issued. Certificates that have not been logged typically produce an error message in a browser. For more information, see Opting Out of Certificate Transparency Logging (https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-transparency).
 *
 * @schema CertificateV1Beta1SpecForProviderOptions
 */
export interface CertificateV1Beta1SpecForProviderOptions {
  /**
   * You can opt out of certificate transparency logging by specifying the DISABLED option. Opt in by specifying ENABLED.
   *
   * @schema CertificateV1Beta1SpecForProviderOptions#certificateTransparencyLoggingPreference
   */
  readonly certificateTransparencyLoggingPreference: CertificateV1Beta1SpecForProviderOptionsCertificateTransparencyLoggingPreference;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderOptions(obj: CertificateV1Beta1SpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateTransparencyLoggingPreference': obj.certificateTransparencyLoggingPreference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag represents user-provided metadata that can be associated
 *
 * @schema CertificateV1Beta1SpecForProviderTags
 */
export interface CertificateV1Beta1SpecForProviderTags {
  /**
   * The key name that can be used to look up or retrieve the associated value.
   *
   * @schema CertificateV1Beta1SpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value associated with this tag.
   *
   * @schema CertificateV1Beta1SpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderTags(obj: CertificateV1Beta1SpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method to validate certificate.
 *
 * @schema CertificateV1Beta1SpecForProviderValidationMethod
 */
export enum CertificateV1Beta1SpecForProviderValidationMethod {
  /** DNS */
  DNS = "DNS",
  /** EMAIL */
  EMAIL = "EMAIL",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateV1Beta1SpecProviderConfigRefPolicy
 */
export interface CertificateV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecProviderConfigRefPolicy(obj: CertificateV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface CertificateV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecPublishConnectionDetailsToMetadata(obj: CertificateV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * You can opt out of certificate transparency logging by specifying the DISABLED option. Opt in by specifying ENABLED.
 *
 * @schema CertificateV1Beta1SpecForProviderOptionsCertificateTransparencyLoggingPreference
 */
export enum CertificateV1Beta1SpecForProviderOptionsCertificateTransparencyLoggingPreference {
  /** ENABLED */
  ENABLED = "ENABLED",
  /** DISABLED */
  DISABLED = "DISABLED",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum CertificateV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum CertificateV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

