// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export class DbCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.crossplane.io/v1alpha1',
    kind: 'DBCluster',
  }

  /**
   * Renders a Kubernetes manifest for "DBCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbClusterProps): any {
    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(props),
    };
  }

  /**
   * Defines a "DBCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbClusterProps) {
    super(scope, id, {
      ...DbCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(resolved),
    };
  }
}

/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export interface DbClusterProps {
  /**
   * @schema DBCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBClusterSpec defines the desired state of DBCluster
   *
   * @schema DBCluster#spec
   */
  readonly spec: DbClusterSpec;

}

/**
 * Converts an object of type 'DbClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterProps(obj: DbClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterSpec defines the desired state of DBCluster
 *
 * @schema DbClusterSpec
 */
export interface DbClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbClusterSpecDeletionPolicy;

  /**
   * DBClusterParameters defines the desired state of DBCluster
   *
   * @schema DbClusterSpec#forProvider
   */
  readonly forProvider: DbClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbClusterSpec#managementPolicies
   */
  readonly managementPolicies?: DbClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpec(obj: DbClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbClusterSpecDeletionPolicy
 */
export enum DbClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBClusterParameters defines the desired state of DBCluster
 *
 * @schema DbClusterSpecForProvider
 */
export interface DbClusterSpecForProvider {
  /**
   * The ApplyImmediately parameter only affects the NewDBClusterIdentifier and MasterUserPassword values. If you set the ApplyImmediately parameter value to false, then changes to the NewDBClusterIdentifier and MasterUserPassword values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter.
   * Default: false
   *
   * @schema DbClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * A list of EC2 Availability Zones that instances in the DB cluster can be created in.
   *
   * @schema DbClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The number of days for which automated backups are retained. You must specify a minimum value of 1.
   * Default: 1
   * Constraints:
   * * Must be a value from 1 to 35
   *
   * @schema DbClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * (Not supported by Neptune)
   *
   * @schema DbClusterSpecForProvider#characterSetName
   */
  readonly characterSetName?: string;

  /**
   * If set to true, tags are copied to any snapshot of the DB cluster that is created.
   *
   * @schema DbClusterSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon Neptune will not create a database in the DB cluster you are creating.
   *
   * @schema DbClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, the default is used.
   * Constraints:
   * * If supplied, must match the name of an existing DBClusterParameterGroup.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * A DB subnet group to associate with this DB cluster.
   * Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.
   * Example: mySubnetgroup
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is enabled.
   *
   * @schema DbClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * DestinationRegion is used for presigning the request to a given region.
   *
   * @schema DbClusterSpecForProvider#destinationRegion
   */
  readonly destinationRegion?: string;

  /**
   * The list of log types that need to be enabled for exporting to CloudWatch Logs.
   *
   * @schema DbClusterSpecForProvider#enableCloudwatchLogsExports
   */
  readonly enableCloudwatchLogsExports?: string[];

  /**
   * If set to true, enables Amazon Identity and Access Management (IAM) authentication for the entire DB cluster (this cannot be set at an instance level).
   * Default: false.
   *
   * @schema DbClusterSpecForProvider#enableIAMDatabaseAuthentication
   */
  readonly enableIamDatabaseAuthentication?: boolean;

  /**
   * The name of the database engine to be used for this DB cluster.
   * Valid Values: neptune
   *
   * @schema DbClusterSpecForProvider#engine
   */
  readonly engine: string;

  /**
   * The version number of the database engine to use for the new DB cluster.
   * Example: 1.0.2.1
   *
   * @schema DbClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The ID of the Neptune global database to which this new DB cluster should be added.
   *
   * @schema DbClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * The Amazon KMS key identifier for an encrypted DB cluster.
   * The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a DB cluster with the same Amazon account that owns the KMS encryption key used to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the KMS encryption key.
   * If an encryption key is not specified in KmsKeyId:
   * * If ReplicationSourceIdentifier identifies an encrypted source, then Amazon Neptune will use the encryption key used to encrypt the source. Otherwise, Amazon Neptune will use your default encryption key.
   * * If the StorageEncrypted parameter is true and ReplicationSourceIdentifier is not specified, then Amazon Neptune will use your default encryption key.
   * Amazon KMS creates the default encryption key for your Amazon account. Your Amazon account has a different default encryption key for each Amazon Region.
   * If you create a Read Replica of an encrypted DB cluster in another Amazon Region, you must set KmsKeyId to a KMS key ID that is valid in the destination Amazon Region. This key is used to encrypt the Read Replica in that Amazon Region.
   *
   * @schema DbClusterSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * Not supported by Neptune.
   *
   * @schema DbClusterSpecForProvider#masterUserPassword
   */
  readonly masterUserPassword?: string;

  /**
   * Not supported by Neptune.
   *
   * @schema DbClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * (Not supported by Neptune)
   *
   * @schema DbClusterSpecForProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * The port number on which the instances in the DB cluster accept connections.
   * Default: 8182
   *
   * @schema DbClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * This parameter is not currently supported.
   *
   * @schema DbClusterSpecForProvider#preSignedURL
   */
  readonly preSignedUrl?: string;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Region. To see the time blocks available, see Adjusting the Preferred Maintenance Window (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html) in the Amazon Neptune User Guide.
   * Constraints:
   * * Must be in the format hh24:mi-hh24:mi.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must not conflict with the preferred maintenance window.
   * * Must be at least 30 minutes.
   *
   * @schema DbClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
   * Format: ddd:hh24:mi-ddd:hh24:mi
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred Maintenance Window (https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html) in the Amazon Neptune User Guide.
   * Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
   * Constraints: Minimum 30-minute window.
   *
   * @schema DbClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Region is which region the DBCluster will be created.
   *
   * @schema DbClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a Read Replica.
   *
   * @schema DbClusterSpecForProvider#replicationSourceIdentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * @schema DbClusterSpecForProvider#serverlessV2ScalingConfiguration
   */
  readonly serverlessV2ScalingConfiguration?: DbClusterSpecForProviderServerlessV2ScalingConfiguration;

  /**
   * Determines whether a final DB cluster snapshot is created before the DB cluster is deleted. If true is specified, no DB cluster snapshot is created. If false is specified, a DB cluster snapshot is created before the DB cluster is deleted.
   * You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is false.
   * Default: false
   *
   * @schema DbClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * SourceRegion is the source region where the resource exists. This is not sent over the wire and is only used for presigning. This value should always have the same region as the source ARN.
   *
   * @schema DbClusterSpecForProvider#sourceRegion
   */
  readonly sourceRegion?: string;

  /**
   * Specifies whether the DB cluster is encrypted.
   *
   * @schema DbClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The tags to assign to the new DB cluster.
   *
   * @schema DbClusterSpecForProvider#tags
   */
  readonly tags?: DbClusterSpecForProviderTags[];

  /**
   * A list of EC2 VPC security groups to associate with this DB cluster.
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDs
   */
  readonly vpcSecurityGroupIDs?: string[];

}

/**
 * Converts an object of type 'DbClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProvider(obj: DbClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'characterSetName': obj.characterSetName,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'databaseName': obj.databaseName,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'deletionProtection': obj.deletionProtection,
    'destinationRegion': obj.destinationRegion,
    'enableCloudwatchLogsExports': obj.enableCloudwatchLogsExports?.map(y => y),
    'enableIAMDatabaseAuthentication': obj.enableIamDatabaseAuthentication,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'kmsKeyID': obj.kmsKeyId,
    'masterUserPassword': obj.masterUserPassword,
    'masterUsername': obj.masterUsername,
    'optionGroupName': obj.optionGroupName,
    'port': obj.port,
    'preSignedURL': obj.preSignedUrl,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'region': obj.region,
    'replicationSourceIdentifier': obj.replicationSourceIdentifier,
    'serverlessV2ScalingConfiguration': toJson_DbClusterSpecForProviderServerlessV2ScalingConfiguration(obj.serverlessV2ScalingConfiguration),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'sourceRegion': obj.sourceRegion,
    'storageEncrypted': obj.storageEncrypted,
    'tags': obj.tags?.map(y => toJson_DbClusterSpecForProviderTags(y)),
    'vpcSecurityGroupIDs': obj.vpcSecurityGroupIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbClusterSpecManagementPolicies
 */
export enum DbClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbClusterSpecProviderConfigRef
 */
export interface DbClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecProviderConfigRef#policy
   */
  readonly policy?: DbClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRef(obj: DbClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbClusterSpecPublishConnectionDetailsTo
 */
export interface DbClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsTo(obj: DbClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbClusterSpecWriteConnectionSecretToRef
 */
export interface DbClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecWriteConnectionSecretToRef(obj: DbClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration
 */
export interface DbClusterSpecForProviderServerlessV2ScalingConfiguration {
  /**
   * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * @schema DbClusterSpecForProviderServerlessV2ScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderServerlessV2ScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderServerlessV2ScalingConfiguration(obj: DbClusterSpecForProviderServerlessV2ScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterSpecForProviderTags
 */
export interface DbClusterSpecForProviderTags {
  /**
   * @schema DbClusterSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbClusterSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderTags(obj: DbClusterSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecProviderConfigRefPolicy
 */
export interface DbClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRefPolicy(obj: DbClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj: DbClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToMetadata
 */
export interface DbClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj: DbClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolution
 */
export enum DbClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolve
 */
export enum DbClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

