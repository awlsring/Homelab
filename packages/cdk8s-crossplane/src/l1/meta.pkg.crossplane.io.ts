// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Configuration is the description of a Crossplane Configuration package.
 *
 * @schema Configuration
 */
export class Configuration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Configuration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'meta.pkg.crossplane.io/v1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "Configuration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProps): any {
    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(props),
    };
  }

  /**
   * Defines a "Configuration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProps) {
    super(scope, id, {
      ...Configuration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(resolved),
    };
  }
}

/**
 * A Configuration is the description of a Crossplane Configuration package.
 *
 * @schema Configuration
 */
export interface ConfigurationProps {
  /**
   * @schema Configuration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec specifies the configuration of a Configuration.
   *
   * @schema Configuration#spec
   */
  readonly spec: ConfigurationSpec;

}

/**
 * Converts an object of type 'ConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProps(obj: ConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec specifies the configuration of a Configuration.
 *
 * @schema ConfigurationSpec
 */
export interface ConfigurationSpec {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ConfigurationSpec#crossplane
   */
  readonly crossplane?: ConfigurationSpecCrossplane;

  /**
   * Dependencies on other packages.
   *
   * @schema ConfigurationSpec#dependsOn
   */
  readonly dependsOn?: ConfigurationSpecDependsOn[];

}

/**
 * Converts an object of type 'ConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpec(obj: ConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossplane': toJson_ConfigurationSpecCrossplane(obj.crossplane),
    'dependsOn': obj.dependsOn?.map(y => toJson_ConfigurationSpecDependsOn(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Semantic version constraints of Crossplane that package is compatible with.
 *
 * @schema ConfigurationSpecCrossplane
 */
export interface ConfigurationSpecCrossplane {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ConfigurationSpecCrossplane#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ConfigurationSpecCrossplane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecCrossplane(obj: ConfigurationSpecCrossplane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dependency is a dependency on another package. One of Provider or Configuration may be supplied.
 *
 * @schema ConfigurationSpecDependsOn
 */
export interface ConfigurationSpecDependsOn {
  /**
   * Configuration is the name of a Configuration package image.
   *
   * @schema ConfigurationSpecDependsOn#configuration
   */
  readonly configuration?: string;

  /**
   * Function is the name of a Function package image.
   *
   * @schema ConfigurationSpecDependsOn#function
   */
  readonly function?: string;

  /**
   * Provider is the name of a Provider package image.
   *
   * @schema ConfigurationSpecDependsOn#provider
   */
  readonly provider?: string;

  /**
   * Version is the semantic version constraints of the dependency image.
   *
   * @schema ConfigurationSpecDependsOn#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ConfigurationSpecDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecDependsOn(obj: ConfigurationSpecDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'function': obj.function,
    'provider': obj.provider,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Configuration is the description of a Crossplane Configuration package.
 *
 * @schema ConfigurationV1Alpha1
 */
export class ConfigurationV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'meta.pkg.crossplane.io/v1alpha1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationV1Alpha1Props): any {
    return {
      ...ConfigurationV1Alpha1.GVK,
      ...toJson_ConfigurationV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "ConfigurationV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationV1Alpha1Props) {
    super(scope, id, {
      ...ConfigurationV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationV1Alpha1.GVK,
      ...toJson_ConfigurationV1Alpha1Props(resolved),
    };
  }
}

/**
 * A Configuration is the description of a Crossplane Configuration package.
 *
 * @schema ConfigurationV1Alpha1
 */
export interface ConfigurationV1Alpha1Props {
  /**
   * @schema ConfigurationV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec specifies the configuration of a Configuration.
   *
   * @schema ConfigurationV1Alpha1#spec
   */
  readonly spec: ConfigurationV1Alpha1Spec;

}

/**
 * Converts an object of type 'ConfigurationV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationV1Alpha1Props(obj: ConfigurationV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec specifies the configuration of a Configuration.
 *
 * @schema ConfigurationV1Alpha1Spec
 */
export interface ConfigurationV1Alpha1Spec {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ConfigurationV1Alpha1Spec#crossplane
   */
  readonly crossplane?: ConfigurationV1Alpha1SpecCrossplane;

  /**
   * Dependencies on other packages.
   *
   * @schema ConfigurationV1Alpha1Spec#dependsOn
   */
  readonly dependsOn?: ConfigurationV1Alpha1SpecDependsOn[];

}

/**
 * Converts an object of type 'ConfigurationV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationV1Alpha1Spec(obj: ConfigurationV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossplane': toJson_ConfigurationV1Alpha1SpecCrossplane(obj.crossplane),
    'dependsOn': obj.dependsOn?.map(y => toJson_ConfigurationV1Alpha1SpecDependsOn(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Semantic version constraints of Crossplane that package is compatible with.
 *
 * @schema ConfigurationV1Alpha1SpecCrossplane
 */
export interface ConfigurationV1Alpha1SpecCrossplane {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ConfigurationV1Alpha1SpecCrossplane#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ConfigurationV1Alpha1SpecCrossplane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationV1Alpha1SpecCrossplane(obj: ConfigurationV1Alpha1SpecCrossplane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dependency is a dependency on another package. One of Provider or Configuration may be supplied.
 *
 * @schema ConfigurationV1Alpha1SpecDependsOn
 */
export interface ConfigurationV1Alpha1SpecDependsOn {
  /**
   * Configuration is the name of a Configuration package image.
   *
   * @schema ConfigurationV1Alpha1SpecDependsOn#configuration
   */
  readonly configuration?: string;

  /**
   * Function is the name of a Function package image.
   *
   * @schema ConfigurationV1Alpha1SpecDependsOn#function
   */
  readonly function?: string;

  /**
   * Provider is the name of a Provider package image.
   *
   * @schema ConfigurationV1Alpha1SpecDependsOn#provider
   */
  readonly provider?: string;

  /**
   * Version is the semantic version constraints of the dependency image.
   *
   * @schema ConfigurationV1Alpha1SpecDependsOn#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ConfigurationV1Alpha1SpecDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationV1Alpha1SpecDependsOn(obj: ConfigurationV1Alpha1SpecDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'function': obj.function,
    'provider': obj.provider,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Function is the description of a Crossplane Function package.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'meta.pkg.crossplane.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * A Function is the description of a Crossplane Function package.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec specifies the configuration of a Function.
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec specifies the configuration of a Function.
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema FunctionSpec#crossplane
   */
  readonly crossplane?: FunctionSpecCrossplane;

  /**
   * Dependencies on other packages.
   *
   * @schema FunctionSpec#dependsOn
   */
  readonly dependsOn?: FunctionSpecDependsOn[];

  /**
   * Image is the packaged Function image.
   *
   * @schema FunctionSpec#image
   */
  readonly image?: string;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossplane': toJson_FunctionSpecCrossplane(obj.crossplane),
    'dependsOn': obj.dependsOn?.map(y => toJson_FunctionSpecDependsOn(y)),
    'image': obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Semantic version constraints of Crossplane that package is compatible with.
 *
 * @schema FunctionSpecCrossplane
 */
export interface FunctionSpecCrossplane {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema FunctionSpecCrossplane#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'FunctionSpecCrossplane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecCrossplane(obj: FunctionSpecCrossplane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dependency is a dependency on another package. One of Provider or Configuration may be supplied.
 *
 * @schema FunctionSpecDependsOn
 */
export interface FunctionSpecDependsOn {
  /**
   * Configuration is the name of a Configuration package image.
   *
   * @schema FunctionSpecDependsOn#configuration
   */
  readonly configuration?: string;

  /**
   * Function is the name of a Function package image.
   *
   * @schema FunctionSpecDependsOn#function
   */
  readonly function?: string;

  /**
   * Provider is the name of a Provider package image.
   *
   * @schema FunctionSpecDependsOn#provider
   */
  readonly provider?: string;

  /**
   * Version is the semantic version constraints of the dependency image.
   *
   * @schema FunctionSpecDependsOn#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'FunctionSpecDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecDependsOn(obj: FunctionSpecDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'function': obj.function,
    'provider': obj.provider,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Provider is the description of a Crossplane Provider package.
 *
 * @schema Provider
 */
export class Provider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Provider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'meta.pkg.crossplane.io/v1',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "Provider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderProps): any {
    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(props),
    };
  }

  /**
   * Defines a "Provider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderProps) {
    super(scope, id, {
      ...Provider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(resolved),
    };
  }
}

/**
 * A Provider is the description of a Crossplane Provider package.
 *
 * @schema Provider
 */
export interface ProviderProps {
  /**
   * @schema Provider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec specifies the configuration of a Provider.
   *
   * @schema Provider#spec
   */
  readonly spec: ProviderSpec;

}

/**
 * Converts an object of type 'ProviderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderProps(obj: ProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderSpec specifies the configuration of a Provider.
 *
 * @schema ProviderSpec
 */
export interface ProviderSpec {
  /**
   * Configuration for the packaged Provider's controller.
   *
   * @schema ProviderSpec#controller
   */
  readonly controller: ProviderSpecController;

  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ProviderSpec#crossplane
   */
  readonly crossplane?: ProviderSpecCrossplane;

  /**
   * Dependencies on other packages.
   *
   * @schema ProviderSpec#dependsOn
   */
  readonly dependsOn?: ProviderSpecDependsOn[];

}

/**
 * Converts an object of type 'ProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpec(obj: ProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controller': toJson_ProviderSpecController(obj.controller),
    'crossplane': toJson_ProviderSpecCrossplane(obj.crossplane),
    'dependsOn': obj.dependsOn?.map(y => toJson_ProviderSpecDependsOn(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for the packaged Provider's controller.
 *
 * @schema ProviderSpecController
 */
export interface ProviderSpecController {
  /**
   * Image is the packaged Provider controller image.
   *
   * @schema ProviderSpecController#image
   */
  readonly image?: string;

  /**
   * PermissionRequests for RBAC rules required for this provider's controller
   * to function. The RBAC manager is responsible for assessing the requested
   * permissions.
   *
   * @schema ProviderSpecController#permissionRequests
   */
  readonly permissionRequests?: ProviderSpecControllerPermissionRequests[];

}

/**
 * Converts an object of type 'ProviderSpecController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecController(obj: ProviderSpecController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'permissionRequests': obj.permissionRequests?.map(y => toJson_ProviderSpecControllerPermissionRequests(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Semantic version constraints of Crossplane that package is compatible with.
 *
 * @schema ProviderSpecCrossplane
 */
export interface ProviderSpecCrossplane {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ProviderSpecCrossplane#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ProviderSpecCrossplane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecCrossplane(obj: ProviderSpecCrossplane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dependency is a dependency on another package. One of Provider or Configuration may be supplied.
 *
 * @schema ProviderSpecDependsOn
 */
export interface ProviderSpecDependsOn {
  /**
   * Configuration is the name of a Configuration package image.
   *
   * @schema ProviderSpecDependsOn#configuration
   */
  readonly configuration?: string;

  /**
   * Function is the name of a Function package image.
   *
   * @schema ProviderSpecDependsOn#function
   */
  readonly function?: string;

  /**
   * Provider is the name of a Provider package image.
   *
   * @schema ProviderSpecDependsOn#provider
   */
  readonly provider?: string;

  /**
   * Version is the semantic version constraints of the dependency image.
   *
   * @schema ProviderSpecDependsOn#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ProviderSpecDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecDependsOn(obj: ProviderSpecDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'function': obj.function,
    'provider': obj.provider,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyRule holds information that describes a policy rule, but does not contain information
 * about who the rule applies to or which namespace the rule applies to.
 *
 * @schema ProviderSpecControllerPermissionRequests
 */
export interface ProviderSpecControllerPermissionRequests {
  /**
   * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
   * the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
   *
   * @schema ProviderSpecControllerPermissionRequests#apiGroups
   */
  readonly apiGroups?: string[];

  /**
   * NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
   * Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
   * Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
   *
   * @schema ProviderSpecControllerPermissionRequests#nonResourceURLs
   */
  readonly nonResourceUrLs?: string[];

  /**
   * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
   *
   * @schema ProviderSpecControllerPermissionRequests#resourceNames
   */
  readonly resourceNames?: string[];

  /**
   * Resources is a list of resources this rule applies to. '*' represents all resources.
   *
   * @schema ProviderSpecControllerPermissionRequests#resources
   */
  readonly resources?: string[];

  /**
   * Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
   *
   * @schema ProviderSpecControllerPermissionRequests#verbs
   */
  readonly verbs: string[];

}

/**
 * Converts an object of type 'ProviderSpecControllerPermissionRequests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecControllerPermissionRequests(obj: ProviderSpecControllerPermissionRequests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroups': obj.apiGroups?.map(y => y),
    'nonResourceURLs': obj.nonResourceUrLs?.map(y => y),
    'resourceNames': obj.resourceNames?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'verbs': obj.verbs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Provider is the description of a Crossplane Provider package.
 *
 * @schema ProviderV1Alpha1
 */
export class ProviderV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'meta.pkg.crossplane.io/v1alpha1',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderV1Alpha1Props): any {
    return {
      ...ProviderV1Alpha1.GVK,
      ...toJson_ProviderV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "ProviderV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderV1Alpha1Props) {
    super(scope, id, {
      ...ProviderV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderV1Alpha1.GVK,
      ...toJson_ProviderV1Alpha1Props(resolved),
    };
  }
}

/**
 * A Provider is the description of a Crossplane Provider package.
 *
 * @schema ProviderV1Alpha1
 */
export interface ProviderV1Alpha1Props {
  /**
   * @schema ProviderV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec specifies the configuration of a Provider.
   *
   * @schema ProviderV1Alpha1#spec
   */
  readonly spec: ProviderV1Alpha1Spec;

}

/**
 * Converts an object of type 'ProviderV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1Props(obj: ProviderV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderSpec specifies the configuration of a Provider.
 *
 * @schema ProviderV1Alpha1Spec
 */
export interface ProviderV1Alpha1Spec {
  /**
   * Configuration for the packaged Provider's controller.
   *
   * @schema ProviderV1Alpha1Spec#controller
   */
  readonly controller: ProviderV1Alpha1SpecController;

  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ProviderV1Alpha1Spec#crossplane
   */
  readonly crossplane?: ProviderV1Alpha1SpecCrossplane;

  /**
   * Dependencies on other packages.
   *
   * @schema ProviderV1Alpha1Spec#dependsOn
   */
  readonly dependsOn?: ProviderV1Alpha1SpecDependsOn[];

}

/**
 * Converts an object of type 'ProviderV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1Spec(obj: ProviderV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controller': toJson_ProviderV1Alpha1SpecController(obj.controller),
    'crossplane': toJson_ProviderV1Alpha1SpecCrossplane(obj.crossplane),
    'dependsOn': obj.dependsOn?.map(y => toJson_ProviderV1Alpha1SpecDependsOn(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for the packaged Provider's controller.
 *
 * @schema ProviderV1Alpha1SpecController
 */
export interface ProviderV1Alpha1SpecController {
  /**
   * Image is the packaged Provider controller image.
   *
   * @schema ProviderV1Alpha1SpecController#image
   */
  readonly image?: string;

  /**
   * PermissionRequests for RBAC rules required for this provider's controller
   * to function. The RBAC manager is responsible for assessing the requested
   * permissions.
   *
   * @schema ProviderV1Alpha1SpecController#permissionRequests
   */
  readonly permissionRequests?: ProviderV1Alpha1SpecControllerPermissionRequests[];

}

/**
 * Converts an object of type 'ProviderV1Alpha1SpecController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1SpecController(obj: ProviderV1Alpha1SpecController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'permissionRequests': obj.permissionRequests?.map(y => toJson_ProviderV1Alpha1SpecControllerPermissionRequests(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Semantic version constraints of Crossplane that package is compatible with.
 *
 * @schema ProviderV1Alpha1SpecCrossplane
 */
export interface ProviderV1Alpha1SpecCrossplane {
  /**
   * Semantic version constraints of Crossplane that package is compatible with.
   *
   * @schema ProviderV1Alpha1SpecCrossplane#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ProviderV1Alpha1SpecCrossplane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1SpecCrossplane(obj: ProviderV1Alpha1SpecCrossplane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dependency is a dependency on another package. One of Provider or Configuration may be supplied.
 *
 * @schema ProviderV1Alpha1SpecDependsOn
 */
export interface ProviderV1Alpha1SpecDependsOn {
  /**
   * Configuration is the name of a Configuration package image.
   *
   * @schema ProviderV1Alpha1SpecDependsOn#configuration
   */
  readonly configuration?: string;

  /**
   * Function is the name of a Function package image.
   *
   * @schema ProviderV1Alpha1SpecDependsOn#function
   */
  readonly function?: string;

  /**
   * Provider is the name of a Provider package image.
   *
   * @schema ProviderV1Alpha1SpecDependsOn#provider
   */
  readonly provider?: string;

  /**
   * Version is the semantic version constraints of the dependency image.
   *
   * @schema ProviderV1Alpha1SpecDependsOn#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ProviderV1Alpha1SpecDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1SpecDependsOn(obj: ProviderV1Alpha1SpecDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'function': obj.function,
    'provider': obj.provider,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyRule holds information that describes a policy rule, but does not contain information
 * about who the rule applies to or which namespace the rule applies to.
 *
 * @schema ProviderV1Alpha1SpecControllerPermissionRequests
 */
export interface ProviderV1Alpha1SpecControllerPermissionRequests {
  /**
   * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
   * the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
   *
   * @schema ProviderV1Alpha1SpecControllerPermissionRequests#apiGroups
   */
  readonly apiGroups?: string[];

  /**
   * NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
   * Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
   * Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
   *
   * @schema ProviderV1Alpha1SpecControllerPermissionRequests#nonResourceURLs
   */
  readonly nonResourceUrLs?: string[];

  /**
   * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
   *
   * @schema ProviderV1Alpha1SpecControllerPermissionRequests#resourceNames
   */
  readonly resourceNames?: string[];

  /**
   * Resources is a list of resources this rule applies to. '*' represents all resources.
   *
   * @schema ProviderV1Alpha1SpecControllerPermissionRequests#resources
   */
  readonly resources?: string[];

  /**
   * Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
   *
   * @schema ProviderV1Alpha1SpecControllerPermissionRequests#verbs
   */
  readonly verbs: string[];

}

/**
 * Converts an object of type 'ProviderV1Alpha1SpecControllerPermissionRequests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Alpha1SpecControllerPermissionRequests(obj: ProviderV1Alpha1SpecControllerPermissionRequests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroups': obj.apiGroups?.map(y => y),
    'nonResourceURLs': obj.nonResourceUrLs?.map(y => y),
    'resourceNames': obj.resourceNames?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'verbs': obj.verbs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

