// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export class DbCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.crossplane.io/v1alpha1',
    kind: 'DBCluster',
  }

  /**
   * Renders a Kubernetes manifest for "DBCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbClusterProps): any {
    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(props),
    };
  }

  /**
   * Defines a "DBCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbClusterProps) {
    super(scope, id, {
      ...DbCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbCluster.GVK,
      ...toJson_DbClusterProps(resolved),
    };
  }
}

/**
 * DBCluster is the Schema for the DBClusters API
 *
 * @schema DBCluster
 */
export interface DbClusterProps {
  /**
   * @schema DBCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBClusterSpec defines the desired state of DBCluster
   *
   * @schema DBCluster#spec
   */
  readonly spec: DbClusterSpec;

}

/**
 * Converts an object of type 'DbClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterProps(obj: DbClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterSpec defines the desired state of DBCluster
 *
 * @schema DbClusterSpec
 */
export interface DbClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbClusterSpecDeletionPolicy;

  /**
   * DBClusterParameters defines the desired state of DBCluster
   *
   * @schema DbClusterSpec#forProvider
   */
  readonly forProvider: DbClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbClusterSpec#managementPolicies
   */
  readonly managementPolicies?: DbClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpec(obj: DbClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbClusterSpecDeletionPolicy
 */
export enum DbClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBClusterParameters defines the desired state of DBCluster
 *
 * @schema DbClusterSpecForProvider
 */
export interface DbClusterSpecForProvider {
  /**
   * A value that specifies whether the changes in this request and any pending changes are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the cluster. If this parameter is set to false, changes to the cluster are applied during the next maintenance window.
   * The ApplyImmediately parameter affects only the NewDBClusterIdentifier and MasterUserPassword values. If you set this parameter value to false, the changes to the NewDBClusterIdentifier and MasterUserPassword values are applied during the next maintenance window. All other changes are applied immediately, regardless of the value of the ApplyImmediately parameter.
   * Default: false
   *
   * @schema DbClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * AutogeneratePassword indicates whether the controller should generate a random password for the master user if one is not provided via MasterUserPasswordSecretRef.
   * If a password is generated, it will be stored as a secret at the location specified by MasterUserPasswordSecretRef.
   *
   * @schema DbClusterSpecForProvider#autogeneratePassword
   */
  readonly autogeneratePassword?: boolean;

  /**
   * A list of Amazon EC2 Availability Zones that instances in the cluster can be created in.
   *
   * @schema DbClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The number of days for which automated backups are retained. You must specify a minimum value of 1.
   * Default: 1
   * Constraints:
   * * Must be a value from 1 to 35.
   *
   * @schema DbClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * The name of the cluster parameter group to associate with this cluster.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * A Reference to a named object.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupNameRef
   */
  readonly dbClusterParameterGroupNameRef?: DbClusterSpecForProviderDbClusterParameterGroupNameRef;

  /**
   * A Selector selects an object.
   *
   * @schema DbClusterSpecForProvider#dbClusterParameterGroupNameSelector
   */
  readonly dbClusterParameterGroupNameSelector?: DbClusterSpecForProviderDbClusterParameterGroupNameSelector;

  /**
   * A subnet group to associate with this cluster.
   * Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.
   * Example: mySubnetgroup
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * A Reference to a named object.
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: DbClusterSpecForProviderDbSubnetGroupNameRef;

  /**
   * A Selector selects an object.
   *
   * @schema DbClusterSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: DbClusterSpecForProviderDbSubnetGroupNameSelector;

  /**
   * Specifies whether this cluster can be deleted. If DeletionProtection is enabled, the cluster cannot be deleted unless it is modified and DeletionProtection is disabled. DeletionProtection protects clusters from being accidentally deleted.
   *
   * @schema DbClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * DestinationRegion is used for presigning the request to a given region.
   *
   * @schema DbClusterSpecForProvider#destinationRegion
   */
  readonly destinationRegion?: string;

  /**
   * A list of log types that need to be enabled for exporting to Amazon CloudWatch Logs. You can enable audit logs or profiler logs. For more information, see Auditing Amazon DocumentDB Events (https://docs.aws.amazon.com/documentdb/latest/developerguide/event-auditing.html) and Profiling Amazon DocumentDB Operations (https://docs.aws.amazon.com/documentdb/latest/developerguide/profiling.html).
   *
   * @schema DbClusterSpecForProvider#enableCloudwatchLogsExports
   */
  readonly enableCloudwatchLogsExports?: string[];

  /**
   * The name of the database engine to be used for this cluster.
   * Valid values: docdb
   *
   * @schema DbClusterSpecForProvider#engine
   */
  readonly engine: string;

  /**
   * The version number of the database engine to use. The --engine-version will default to the latest major engine version. For production workloads, we recommend explicitly declaring this parameter with the intended major engine version.
   *
   * @schema DbClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The cluster snapshot identifier of the new cluster snapshot created when SkipFinalSnapshot is set to false.
   * Specifying this parameter and also setting the SkipFinalShapshot parameter to true results in an error.
   * Constraints:
   * * Must be from 1 to 255 letters, numbers, or hyphens.
   * * The first character must be a letter.
   * * Cannot end with a hyphen or contain two consecutive hyphens.
   *
   * @schema DbClusterSpecForProvider#finalDBSnapshotIdentifier
   */
  readonly finalDbSnapshotIdentifier?: string;

  /**
   * The cluster identifier of the new global cluster.
   *
   * @schema DbClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * The KMS key identifier for an encrypted cluster.
   * The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a cluster using the same Amazon Web Services account that owns the KMS encryption key that is used to encrypt the new cluster, you can use the KMS key alias instead of the ARN for the KMS encryption key.
   * If an encryption key is not specified in KmsKeyId:
   * * If the StorageEncrypted parameter is true, Amazon DocumentDB uses your default encryption key.
   * KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Regions.
   *
   * @schema DbClusterSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to kmsKeyIdRef
   *
   * @schema DbClusterSpecForProvider#kmsKeyIDRef
   */
  readonly kmsKeyIdRef?: DbClusterSpecForProviderKmsKeyIdRef;

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to kmsKeyIdSelector
   *
   * @schema DbClusterSpecForProvider#kmsKeyIDSelector
   */
  readonly kmsKeyIdSelector?: DbClusterSpecForProviderKmsKeyIdSelector;

  /**
   * MasterUserPasswordSecretRef references the secret that contains the password for the master database user. This password can contain any printable ASCII character except forward slash (/), double quote ("), or the "at" symbol (@).
   * Constraints: Must contain from 8 to 100 characters.
   *
   * @schema DbClusterSpecForProvider#masterUserPasswordSecretRef
   */
  readonly masterUserPasswordSecretRef?: DbClusterSpecForProviderMasterUserPasswordSecretRef;

  /**
   * The name of the master user for the cluster.
   * Constraints:
   * * Must be from 1 to 63 letters or numbers.
   * * The first character must be a letter.
   * * Cannot be a reserved word for the chosen database engine.
   *
   * @schema DbClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The port number on which the instances in the cluster accept connections.
   *
   * @schema DbClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * Not currently supported.
   *
   * @schema DbClusterSpecForProvider#preSignedURL
   */
  readonly preSignedUrl?: string;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region.
   * Constraints:
   * * Must be in the format hh24:mi-hh24:mi.
   * * Must be in Universal Coordinated Time (UTC).
   * * Must not conflict with the preferred maintenance window.
   * * Must be at least 30 minutes.
   *
   * @schema DbClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
   * Format: ddd:hh24:mi-ddd:hh24:mi
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week.
   * Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun
   * Constraints: Minimum 30-minute window.
   *
   * @schema DbClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Region is which region the DBCluster will be created.
   *
   * @schema DbClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestoreFrom specifies the details of the backup to restore when creating a new DBCluster.
   *
   * @schema DbClusterSpecForProvider#restoreFrom
   */
  readonly restoreFrom?: DbClusterSpecForProviderRestoreFrom;

  /**
   * Determines whether a final cluster snapshot is created before the cluster is deleted. If true is specified, no cluster snapshot is created. If false is specified, a cluster snapshot is created before the DB cluster is deleted.
   * If SkipFinalSnapshot is false, you must specify a FinalDBSnapshotIdentifier parameter.
   * Default: false
   *
   * @schema DbClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * SourceRegion is the source region where the resource exists. This is not sent over the wire and is only used for presigning. This value should always have the same region as the source ARN.
   *
   * @schema DbClusterSpecForProvider#sourceRegion
   */
  readonly sourceRegion?: string;

  /**
   * Specifies whether the cluster is encrypted.
   *
   * @schema DbClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The tags to be assigned to the cluster.
   *
   * @schema DbClusterSpecForProvider#tags
   */
  readonly tags?: DbClusterSpecForProviderTags[];

  /**
   * A list of EC2 VPC security groups to associate with this cluster.
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDs
   */
  readonly vpcSecurityGroupIDs?: string[];

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to vpcSecurityGroupIdRefs
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDsRefs
   */
  readonly vpcSecurityGroupIDsRefs?: DbClusterSpecForProviderVpcSecurityGroupIDsRefs[];

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to vpcSecurityGroupIdSelector
   *
   * @schema DbClusterSpecForProvider#vpcSecurityGroupIDsSelector
   */
  readonly vpcSecurityGroupIDsSelector?: DbClusterSpecForProviderVpcSecurityGroupIDsSelector;

}

/**
 * Converts an object of type 'DbClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProvider(obj: DbClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autogeneratePassword': obj.autogeneratePassword,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbClusterParameterGroupNameRef': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRef(obj.dbClusterParameterGroupNameRef),
    'dbClusterParameterGroupNameSelector': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelector(obj.dbClusterParameterGroupNameSelector),
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_DbClusterSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_DbClusterSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'deletionProtection': obj.deletionProtection,
    'destinationRegion': obj.destinationRegion,
    'enableCloudwatchLogsExports': obj.enableCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalDBSnapshotIdentifier': obj.finalDbSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIDRef': toJson_DbClusterSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIDSelector': toJson_DbClusterSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'masterUserPasswordSecretRef': toJson_DbClusterSpecForProviderMasterUserPasswordSecretRef(obj.masterUserPasswordSecretRef),
    'masterUsername': obj.masterUsername,
    'port': obj.port,
    'preSignedURL': obj.preSignedUrl,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'region': obj.region,
    'restoreFrom': toJson_DbClusterSpecForProviderRestoreFrom(obj.restoreFrom),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'sourceRegion': obj.sourceRegion,
    'storageEncrypted': obj.storageEncrypted,
    'tags': obj.tags?.map(y => toJson_DbClusterSpecForProviderTags(y)),
    'vpcSecurityGroupIDs': obj.vpcSecurityGroupIDs?.map(y => y),
    'vpcSecurityGroupIDsRefs': obj.vpcSecurityGroupIDsRefs?.map(y => toJson_DbClusterSpecForProviderVpcSecurityGroupIDsRefs(y)),
    'vpcSecurityGroupIDsSelector': toJson_DbClusterSpecForProviderVpcSecurityGroupIDsSelector(obj.vpcSecurityGroupIDsSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbClusterSpecManagementPolicies
 */
export enum DbClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbClusterSpecProviderConfigRef
 */
export interface DbClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecProviderConfigRef#policy
   */
  readonly policy?: DbClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRef(obj: DbClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbClusterSpecPublishConnectionDetailsTo
 */
export interface DbClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsTo(obj: DbClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbClusterSpecWriteConnectionSecretToRef
 */
export interface DbClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecWriteConnectionSecretToRef(obj: DbClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRef#policy
   */
  readonly policy?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRef(obj: DbClusterSpecForProviderDbClusterParameterGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelector(obj: DbClusterSpecForProviderDbClusterParameterGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRef
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameRef(obj: DbClusterSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameSelector(obj: DbClusterSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TODO(haarchri): when resource is bumped to beta we will convert this field to kmsKeyIdRef
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRef
 */
export interface DbClusterSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DbClusterSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdRef(obj: DbClusterSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TODO(haarchri): when resource is bumped to beta we will convert this field to kmsKeyIdSelector
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelector
 */
export interface DbClusterSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdSelector(obj: DbClusterSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MasterUserPasswordSecretRef references the secret that contains the password for the master database user. This password can contain any printable ASCII character except forward slash (/), double quote ("), or the "at" symbol (@).
 * Constraints: Must contain from 8 to 100 characters.
 *
 * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef
 */
export interface DbClusterSpecForProviderMasterUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterSpecForProviderMasterUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderMasterUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderMasterUserPasswordSecretRef(obj: DbClusterSpecForProviderMasterUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreFrom specifies the details of the backup to restore when creating a new DBCluster.
 *
 * @schema DbClusterSpecForProviderRestoreFrom
 */
export interface DbClusterSpecForProviderRestoreFrom {
  /**
   * PointInTime specifies the details of the point in time restore.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#pointInTime
   */
  readonly pointInTime?: DbClusterSpecForProviderRestoreFromPointInTime;

  /**
   * Snapshot specifies the details of the snapshot to restore from.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#snapshot
   */
  readonly snapshot?: DbClusterSpecForProviderRestoreFromSnapshot;

  /**
   * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. Snapshot and PointInTime are supported.
   *
   * @schema DbClusterSpecForProviderRestoreFrom#source
   */
  readonly source: DbClusterSpecForProviderRestoreFromSource;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFrom(obj: DbClusterSpecForProviderRestoreFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pointInTime': toJson_DbClusterSpecForProviderRestoreFromPointInTime(obj.pointInTime),
    'snapshot': toJson_DbClusterSpecForProviderRestoreFromSnapshot(obj.snapshot),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterSpecForProviderTags
 */
export interface DbClusterSpecForProviderTags {
  /**
   * @schema DbClusterSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbClusterSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderTags(obj: DbClusterSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefs
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIDsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefs#policy
   */
  readonly policy?: DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIDsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIDsRefs(obj: DbClusterSpecForProviderVpcSecurityGroupIDsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TODO(haarchri): when resource is bumped to beta we will convert this field to vpcSecurityGroupIdSelector
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelector
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIDsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelector#policy
   */
  readonly policy?: DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIDsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIDsSelector(obj: DbClusterSpecForProviderVpcSecurityGroupIDsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecProviderConfigRefPolicy
 */
export interface DbClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecProviderConfigRefPolicy(obj: DbClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRef(obj: DbClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToMetadata
 */
export interface DbClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToMetadata(obj: DbClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy(obj: DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy
 */
export interface DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy(obj: DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj: DbClusterSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy
 */
export interface DbClusterSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdRefPolicy(obj: DbClusterSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DbClusterSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderKmsKeyIdSelectorPolicy(obj: DbClusterSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PointInTime specifies the details of the point in time restore.
 *
 * @schema DbClusterSpecForProviderRestoreFromPointInTime
 */
export interface DbClusterSpecForProviderRestoreFromPointInTime {
  /**
   * RestoreTime is the date and time (UTC) to restore from. Must be before the latest restorable time for the DB instance. Can't be specified if the useLatestRestorableTime parameter is enabled. Example: 2011-09-07T23:45:00Z
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#restoreTime
   */
  readonly restoreTime?: Date;

  /**
   * The type of restore to be performed. You can specify one of the following values:
   * * full-copy - The new DB cluster is restored as a full copy of the source DB cluster.
   * * copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
   * Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11.
   * If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster.
   * Valid for: Aurora DB clusters and Multi-AZ DB clusters
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#restoreType
   */
  readonly restoreType?: DbClusterSpecForProviderRestoreFromPointInTimeRestoreType;

  /**
   * SourceDBClusterIdentifier specifies the identifier of the source DB cluster from which to restore. Constraints: Must match the identifier of an existing DB instance.
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#sourceDBClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * UseLatestRestorableTime indicates that the DB instance is restored from the latest backup Can't be specified if the restoreTime parameter is provided.
   *
   * @schema DbClusterSpecForProviderRestoreFromPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFromPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFromPointInTime(obj: DbClusterSpecForProviderRestoreFromPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreTime': obj.restoreTime?.toISOString(),
    'restoreType': obj.restoreType,
    'sourceDBClusterIdentifier': obj.sourceDbClusterIdentifier,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Snapshot specifies the details of the snapshot to restore from.
 *
 * @schema DbClusterSpecForProviderRestoreFromSnapshot
 */
export interface DbClusterSpecForProviderRestoreFromSnapshot {
  /**
   * SnapshotIdentifier is the identifier of the snapshot to restore.
   *
   * @schema DbClusterSpecForProviderRestoreFromSnapshot#snapshotIdentifier
   */
  readonly snapshotIdentifier: string;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderRestoreFromSnapshot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderRestoreFromSnapshot(obj: DbClusterSpecForProviderRestoreFromSnapshot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'snapshotIdentifier': obj.snapshotIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source is the type of the backup to restore when creating a new  DBCluster or DBInstance. Snapshot and PointInTime are supported.
 *
 * @schema DbClusterSpecForProviderRestoreFromSource
 */
export enum DbClusterSpecForProviderRestoreFromSource {
  /** Snapshot */
  SNAPSHOT = "Snapshot",
  /** PointInTime */
  POINT_IN_TIME = "PointInTime",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy(obj: DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy
 */
export interface DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy#resolution
   */
  readonly resolution?: DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy#resolve
   */
  readonly resolve?: DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy(obj: DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolution
 */
export enum DbClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecProviderConfigRefPolicyResolve
 */
export enum DbClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderDbClusterParameterGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DbClusterSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DbClusterSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The type of restore to be performed. You can specify one of the following values:
 * * full-copy - The new DB cluster is restored as a full copy of the source DB cluster.
 * * copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
 * Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11.
 * If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster.
 * Valid for: Aurora DB clusters and Multi-AZ DB clusters
 *
 * @schema DbClusterSpecForProviderRestoreFromPointInTimeRestoreType
 */
export enum DbClusterSpecForProviderRestoreFromPointInTimeRestoreType {
  /** full-copy */
  FULL_HYPHEN_COPY = "full-copy",
  /** copy-on-write */
  COPY_HYPHEN_ON_HYPHEN_WRITE = "copy-on-write",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolution
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolve
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIDsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolution
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolve
 */
export enum DbClusterSpecForProviderVpcSecurityGroupIDsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBClusterParameterGroup is the Schema for the DBClusterParameterGroups API
 *
 * @schema DBClusterParameterGroup
 */
export class DbClusterParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBClusterParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.crossplane.io/v1alpha1',
    kind: 'DBClusterParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "DBClusterParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbClusterParameterGroupProps): any {
    return {
      ...DbClusterParameterGroup.GVK,
      ...toJson_DbClusterParameterGroupProps(props),
    };
  }

  /**
   * Defines a "DBClusterParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbClusterParameterGroupProps) {
    super(scope, id, {
      ...DbClusterParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbClusterParameterGroup.GVK,
      ...toJson_DbClusterParameterGroupProps(resolved),
    };
  }
}

/**
 * DBClusterParameterGroup is the Schema for the DBClusterParameterGroups API
 *
 * @schema DBClusterParameterGroup
 */
export interface DbClusterParameterGroupProps {
  /**
   * @schema DBClusterParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBClusterParameterGroupSpec defines the desired state of DBClusterParameterGroup
   *
   * @schema DBClusterParameterGroup#spec
   */
  readonly spec: DbClusterParameterGroupSpec;

}

/**
 * Converts an object of type 'DbClusterParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupProps(obj: DbClusterParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbClusterParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBClusterParameterGroupSpec defines the desired state of DBClusterParameterGroup
 *
 * @schema DbClusterParameterGroupSpec
 */
export interface DbClusterParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbClusterParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbClusterParameterGroupSpecDeletionPolicy;

  /**
   * DBClusterParameterGroupParameters defines the desired state of DBClusterParameterGroup
   *
   * @schema DbClusterParameterGroupSpec#forProvider
   */
  readonly forProvider: DbClusterParameterGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbClusterParameterGroupSpec#managementPolicies
   */
  readonly managementPolicies?: DbClusterParameterGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbClusterParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbClusterParameterGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbClusterParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbClusterParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbClusterParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbClusterParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpec(obj: DbClusterParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbClusterParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbClusterParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbClusterParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbClusterParameterGroupSpecDeletionPolicy
 */
export enum DbClusterParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBClusterParameterGroupParameters defines the desired state of DBClusterParameterGroup
 *
 * @schema DbClusterParameterGroupSpecForProvider
 */
export interface DbClusterParameterGroupSpecForProvider {
  /**
   * The cluster parameter group family name.
   *
   * @schema DbClusterParameterGroupSpecForProvider#dbParameterGroupFamily
   */
  readonly dbParameterGroupFamily: string;

  /**
   * The description for the cluster parameter group.
   *
   * @schema DbClusterParameterGroupSpecForProvider#description
   */
  readonly description: string;

  /**
   * A list of parameters to associate with this DB parameter group. The fields ApplyMethod, ParameterName and ParameterValue are required for every parameter. Note: AWS actually only modifies the ApplyMethod of a parameter, if the ParameterValue changes too.
   *
   * @schema DbClusterParameterGroupSpecForProvider#parameters
   */
  readonly parameters?: DbClusterParameterGroupSpecForProviderParameters[];

  /**
   * Region is which region the DBClusterParameterGroup will be created.
   *
   * @schema DbClusterParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to be assigned to the cluster parameter group.
   *
   * @schema DbClusterParameterGroupSpecForProvider#tags
   */
  readonly tags?: DbClusterParameterGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProvider(obj: DbClusterParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbParameterGroupFamily': obj.dbParameterGroupFamily,
    'description': obj.description,
    'parameters': obj.parameters?.map(y => toJson_DbClusterParameterGroupSpecForProviderParameters(y)),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_DbClusterParameterGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbClusterParameterGroupSpecManagementPolicies
 */
export enum DbClusterParameterGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRef
 */
export interface DbClusterParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: DbClusterParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecProviderConfigRef(obj: DbClusterParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsTo(obj: DbClusterParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef
 */
export interface DbClusterParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbClusterParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecWriteConnectionSecretToRef(obj: DbClusterParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomParameter are custom parameters for the Parameter
 *
 * @schema DbClusterParameterGroupSpecForProviderParameters
 */
export interface DbClusterParameterGroupSpecForProviderParameters {
  /**
   * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#applyMethod
   */
  readonly applyMethod: DbClusterParameterGroupSpecForProviderParametersApplyMethod;

  /**
   * The name of the parameter.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#parameterName
   */
  readonly parameterName: string;

  /**
   * The value of the parameter.
   *
   * @schema DbClusterParameterGroupSpecForProviderParameters#parameterValue
   */
  readonly parameterValue: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProviderParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProviderParameters(obj: DbClusterParameterGroupSpecForProviderParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbClusterParameterGroupSpecForProviderTags
 */
export interface DbClusterParameterGroupSpecForProviderTags {
  /**
   * @schema DbClusterParameterGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbClusterParameterGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecForProviderTags(obj: DbClusterParameterGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy
 */
export interface DbClusterParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecProviderConfigRefPolicy(obj: DbClusterParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The apply method of the parameter. AWS actually only modifies to value set here, if the parameter value changes too.
 *
 * @schema DbClusterParameterGroupSpecForProviderParametersApplyMethod
 */
export enum DbClusterParameterGroupSpecForProviderParametersApplyMethod {
  /** immediate */
  IMMEDIATE = "immediate",
  /** pending-reboot */
  PENDING_HYPHEN_REBOOT = "pending-reboot",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum DbClusterParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum DbClusterParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBInstance is the Schema for the DBInstances API
 *
 * @schema DBInstance
 */
export class DbInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.crossplane.io/v1alpha1',
    kind: 'DBInstance',
  }

  /**
   * Renders a Kubernetes manifest for "DBInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbInstanceProps): any {
    return {
      ...DbInstance.GVK,
      ...toJson_DbInstanceProps(props),
    };
  }

  /**
   * Defines a "DBInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbInstanceProps) {
    super(scope, id, {
      ...DbInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbInstance.GVK,
      ...toJson_DbInstanceProps(resolved),
    };
  }
}

/**
 * DBInstance is the Schema for the DBInstances API
 *
 * @schema DBInstance
 */
export interface DbInstanceProps {
  /**
   * @schema DBInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBInstanceSpec defines the desired state of DBInstance
   *
   * @schema DBInstance#spec
   */
  readonly spec: DbInstanceSpec;

}

/**
 * Converts an object of type 'DbInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceProps(obj: DbInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceSpec defines the desired state of DBInstance
 *
 * @schema DbInstanceSpec
 */
export interface DbInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbInstanceSpecDeletionPolicy;

  /**
   * DBInstanceParameters defines the desired state of DBInstance
   *
   * @schema DbInstanceSpec#forProvider
   */
  readonly forProvider: DbInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: DbInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpec(obj: DbInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbInstanceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbInstanceSpecDeletionPolicy
 */
export enum DbInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBInstanceParameters defines the desired state of DBInstance
 *
 * @schema DbInstanceSpecForProvider
 */
export interface DbInstanceSpecForProvider {
  /**
   * Specifies whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the instance.
   * If this parameter is set to false, changes to the instance are applied during the next maintenance window. Some parameter changes can cause an outage and are applied on the next reboot.
   * Default: false
   *
   * @schema DbInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * This parameter does not apply to Amazon DocumentDB. Amazon DocumentDB does not perform minor version upgrades regardless of the value set.
   * Default: false
   *
   * @schema DbInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The Amazon EC2 Availability Zone that the instance is created in.
   * Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region.
   * Example: us-east-1d
   *
   * @schema DbInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The identifier of the CA certificate for this DB instance.
   *
   * @schema DbInstanceSpecForProvider#caCertificateIdentifier
   */
  readonly caCertificateIdentifier?: string;

  /**
   * A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
   *
   * @schema DbInstanceSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The identifier of the cluster this instance will belong to
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * A Reference to a named object.
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: DbInstanceSpecForProviderDbClusterIdentifierRef;

  /**
   * A Selector selects an object.
   *
   * @schema DbInstanceSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: DbInstanceSpecForProviderDbClusterIdentifierSelector;

  /**
   * The compute and memory capacity of the instance; for example, db.r5.large.
   *
   * @schema DbInstanceSpecForProvider#dbInstanceClass
   */
  readonly dbInstanceClass: string;

  /**
   * A value that indicates whether to enable Performance Insights for the DB Instance. For more information, see Using Amazon Performance Insights (https://docs.aws.amazon.com/documentdb/latest/developerguide/performance-insights.html).
   *
   * @schema DbInstanceSpecForProvider#enablePerformanceInsights
   */
  readonly enablePerformanceInsights?: boolean;

  /**
   * The name of the database engine to be used for this instance.
   * Valid value: docdb
   *
   * @schema DbInstanceSpecForProvider#engine
   */
  readonly engine: string;

  /**
   * The KMS key identifier for encryption of Performance Insights data.
   * The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
   * If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon DocumentDB uses your default KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services region.
   *
   * @schema DbInstanceSpecForProvider#performanceInsightsKMSKeyID
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * The time range each week during which system maintenance can occur, in Universal Coordinated Time (UTC).
   * Format: ddd:hh24:mi-ddd:hh24:mi
   * The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week.
   * Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun
   * Constraints: Minimum 30-minute window.
   *
   * @schema DbInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * A value that specifies the order in which an Amazon DocumentDB replica is promoted to the primary instance after a failure of the existing primary instance.
   * Default: 1
   * Valid values: 0-15
   *
   * @schema DbInstanceSpecForProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Region is which region the DBInstance will be created.
   *
   * @schema DbInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to be assigned to the instance. You can assign up to 10 tags to an instance.
   *
   * @schema DbInstanceSpecForProvider#tags
   */
  readonly tags?: DbInstanceSpecForProviderTags[];

}

/**
 * Converts an object of type 'DbInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProvider(obj: DbInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'caCertificateIdentifier': obj.caCertificateIdentifier,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_DbInstanceSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_DbInstanceSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'dbInstanceClass': obj.dbInstanceClass,
    'enablePerformanceInsights': obj.enablePerformanceInsights,
    'engine': obj.engine,
    'performanceInsightsKMSKeyID': obj.performanceInsightsKmsKeyId,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'promotionTier': obj.promotionTier,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_DbInstanceSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbInstanceSpecManagementPolicies
 */
export enum DbInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbInstanceSpecProviderConfigRef
 */
export interface DbInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: DbInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecProviderConfigRef(obj: DbInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsTo
 */
export interface DbInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsTo(obj: DbInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbInstanceSpecWriteConnectionSecretToRef
 */
export interface DbInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecWriteConnectionSecretToRef(obj: DbInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRef
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierRef(obj: DbInstanceSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierSelector(obj: DbInstanceSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbInstanceSpecForProviderTags
 */
export interface DbInstanceSpecForProviderTags {
  /**
   * @schema DbInstanceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbInstanceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderTags(obj: DbInstanceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicy
 */
export interface DbInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecProviderConfigRefPolicy(obj: DbInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface DbInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToConfigRef(obj: DbInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface DbInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToMetadata(obj: DbInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierRefPolicy(obj: DbInstanceSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy(obj: DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicyResolution
 */
export enum DbInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecProviderConfigRefPolicyResolve
 */
export enum DbInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum DbInstanceSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBSubnetGroup is the Schema for the DBSubnetGroups API
 *
 * @schema DBSubnetGroup
 */
export class DbSubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBSubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.crossplane.io/v1alpha1',
    kind: 'DBSubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "DBSubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbSubnetGroupProps): any {
    return {
      ...DbSubnetGroup.GVK,
      ...toJson_DbSubnetGroupProps(props),
    };
  }

  /**
   * Defines a "DBSubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbSubnetGroupProps) {
    super(scope, id, {
      ...DbSubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbSubnetGroup.GVK,
      ...toJson_DbSubnetGroupProps(resolved),
    };
  }
}

/**
 * DBSubnetGroup is the Schema for the DBSubnetGroups API
 *
 * @schema DBSubnetGroup
 */
export interface DbSubnetGroupProps {
  /**
   * @schema DBSubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBSubnetGroupSpec defines the desired state of DBSubnetGroup
   *
   * @schema DBSubnetGroup#spec
   */
  readonly spec: DbSubnetGroupSpec;

}

/**
 * Converts an object of type 'DbSubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupProps(obj: DbSubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbSubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSubnetGroupSpec defines the desired state of DBSubnetGroup
 *
 * @schema DbSubnetGroupSpec
 */
export interface DbSubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbSubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbSubnetGroupSpecDeletionPolicy;

  /**
   * DBSubnetGroupParameters defines the desired state of DBSubnetGroup
   *
   * @schema DbSubnetGroupSpec#forProvider
   */
  readonly forProvider: DbSubnetGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbSubnetGroupSpec#managementPolicies
   */
  readonly managementPolicies?: DbSubnetGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbSubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbSubnetGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbSubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbSubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbSubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbSubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbSubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpec(obj: DbSubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbSubnetGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbSubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbSubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbSubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbSubnetGroupSpecDeletionPolicy
 */
export enum DbSubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DBSubnetGroupParameters defines the desired state of DBSubnetGroup
 *
 * @schema DbSubnetGroupSpecForProvider
 */
export interface DbSubnetGroupSpecForProvider {
  /**
   * The description for the subnet group.
   *
   * @schema DbSubnetGroupSpecForProvider#dbSubnetGroupDescription
   */
  readonly dbSubnetGroupDescription: string;

  /**
   * Region is which region the DBSubnetGroup will be created.
   *
   * @schema DbSubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema DbSubnetGroupSpecForProvider#subnetIDs
   */
  readonly subnetIDs?: string[];

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to subnetIdRefs
   *
   * @schema DbSubnetGroupSpecForProvider#subnetIDsRefs
   */
  readonly subnetIDsRefs?: DbSubnetGroupSpecForProviderSubnetIDsRefs[];

  /**
   * TODO(haarchri): when resource is bumped to beta we will convert this field to subnetIdSelector
   *
   * @schema DbSubnetGroupSpecForProvider#subnetIDsSelector
   */
  readonly subnetIDsSelector?: DbSubnetGroupSpecForProviderSubnetIDsSelector;

  /**
   * The tags to be assigned to the subnet group.
   *
   * @schema DbSubnetGroupSpecForProvider#tags
   */
  readonly tags?: DbSubnetGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProvider(obj: DbSubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbSubnetGroupDescription': obj.dbSubnetGroupDescription,
    'region': obj.region,
    'subnetIDs': obj.subnetIDs?.map(y => y),
    'subnetIDsRefs': obj.subnetIDsRefs?.map(y => toJson_DbSubnetGroupSpecForProviderSubnetIDsRefs(y)),
    'subnetIDsSelector': toJson_DbSubnetGroupSpecForProviderSubnetIDsSelector(obj.subnetIDsSelector),
    'tags': obj.tags?.map(y => toJson_DbSubnetGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbSubnetGroupSpecManagementPolicies
 */
export enum DbSubnetGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbSubnetGroupSpecProviderConfigRef
 */
export interface DbSubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: DbSubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecProviderConfigRef(obj: DbSubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsTo
 */
export interface DbSubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbSubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbSubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecPublishConnectionDetailsTo(obj: DbSubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbSubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbSubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbSubnetGroupSpecWriteConnectionSecretToRef
 */
export interface DbSubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbSubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbSubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecWriteConnectionSecretToRef(obj: DbSubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsRefs
 */
export interface DbSubnetGroupSpecForProviderSubnetIDsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsRefs#policy
   */
  readonly policy?: DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProviderSubnetIDsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProviderSubnetIDsRefs(obj: DbSubnetGroupSpecForProviderSubnetIDsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TODO(haarchri): when resource is bumped to beta we will convert this field to subnetIdSelector
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsSelector
 */
export interface DbSubnetGroupSpecForProviderSubnetIDsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsSelector#policy
   */
  readonly policy?: DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProviderSubnetIDsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProviderSubnetIDsSelector(obj: DbSubnetGroupSpecForProviderSubnetIDsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DbSubnetGroupSpecForProviderTags
 */
export interface DbSubnetGroupSpecForProviderTags {
  /**
   * @schema DbSubnetGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema DbSubnetGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProviderTags(obj: DbSubnetGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbSubnetGroupSpecProviderConfigRefPolicy
 */
export interface DbSubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbSubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbSubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecProviderConfigRefPolicy(obj: DbSubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface DbSubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: DbSubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface DbSubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecPublishConnectionDetailsToMetadata(obj: DbSubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy
 */
export interface DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy#resolution
   */
  readonly resolution?: DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy#resolve
   */
  readonly resolve?: DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolve;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy(obj: DbSubnetGroupSpecForProviderSubnetIDsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy
 */
export interface DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy#resolution
   */
  readonly resolution?: DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy#resolve
   */
  readonly resolve?: DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy(obj: DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum DbSubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum DbSubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolution
 */
export enum DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolve
 */
export enum DbSubnetGroupSpecForProviderSubnetIDsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolution
 */
export enum DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolve
 */
export enum DbSubnetGroupSpecForProviderSubnetIDsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

