// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Classifier is the Schema for the Classifiers API
 *
 * @schema Classifier
 */
export class Classifier extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Classifier"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'Classifier',
  }

  /**
   * Renders a Kubernetes manifest for "Classifier".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClassifierProps): any {
    return {
      ...Classifier.GVK,
      ...toJson_ClassifierProps(props),
    };
  }

  /**
   * Defines a "Classifier" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClassifierProps) {
    super(scope, id, {
      ...Classifier.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Classifier.GVK,
      ...toJson_ClassifierProps(resolved),
    };
  }
}

/**
 * Classifier is the Schema for the Classifiers API
 *
 * @schema Classifier
 */
export interface ClassifierProps {
  /**
   * @schema Classifier#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClassifierSpec defines the desired state of Classifier
   *
   * @schema Classifier#spec
   */
  readonly spec: ClassifierSpec;

}

/**
 * Converts an object of type 'ClassifierProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierProps(obj: ClassifierProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClassifierSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClassifierSpec defines the desired state of Classifier
 *
 * @schema ClassifierSpec
 */
export interface ClassifierSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClassifierSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClassifierSpecDeletionPolicy;

  /**
   * ClassifierParameters defines the desired state of Classifier
   *
   * @schema ClassifierSpec#forProvider
   */
  readonly forProvider: ClassifierSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClassifierSpec#managementPolicies
   */
  readonly managementPolicies?: ClassifierSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClassifierSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClassifierSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClassifierSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClassifierSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClassifierSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClassifierSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClassifierSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpec(obj: ClassifierSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClassifierSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClassifierSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClassifierSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClassifierSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClassifierSpecDeletionPolicy
 */
export enum ClassifierSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClassifierParameters defines the desired state of Classifier
 *
 * @schema ClassifierSpecForProvider
 */
export interface ClassifierSpecForProvider {
  /**
   * A CSVClassifier object specifying the classifier to create.
   *
   * @schema ClassifierSpecForProvider#csvClassifier
   */
  readonly csvClassifier?: ClassifierSpecForProviderCsvClassifier;

  /**
   * A GrokClassifier object specifying the classifier to create.
   *
   * @schema ClassifierSpecForProvider#grokClassifier
   */
  readonly grokClassifier?: ClassifierSpecForProviderGrokClassifier;

  /**
   * A JsonClassifier object specifying the classifier to create.
   *
   * @schema ClassifierSpecForProvider#jsonClassifier
   */
  readonly jsonClassifier?: ClassifierSpecForProviderJsonClassifier;

  /**
   * Region is which region the Classifier will be created.
   *
   * @schema ClassifierSpecForProvider#region
   */
  readonly region: string;

  /**
   * A XMLClassifier object specifying the classifier to create.
   *
   * @schema ClassifierSpecForProvider#xmlClassifier
   */
  readonly xmlClassifier?: ClassifierSpecForProviderXmlClassifier;

}

/**
 * Converts an object of type 'ClassifierSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProvider(obj: ClassifierSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvClassifier': toJson_ClassifierSpecForProviderCsvClassifier(obj.csvClassifier),
    'grokClassifier': toJson_ClassifierSpecForProviderGrokClassifier(obj.grokClassifier),
    'jsonClassifier': toJson_ClassifierSpecForProviderJsonClassifier(obj.jsonClassifier),
    'region': obj.region,
    'xmlClassifier': toJson_ClassifierSpecForProviderXmlClassifier(obj.xmlClassifier),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClassifierSpecManagementPolicies
 */
export enum ClassifierSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClassifierSpecProviderConfigRef
 */
export interface ClassifierSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassifierSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassifierSpecProviderConfigRef#policy
   */
  readonly policy?: ClassifierSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassifierSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecProviderConfigRef(obj: ClassifierSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassifierSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClassifierSpecPublishConnectionDetailsTo
 */
export interface ClassifierSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClassifierSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClassifierSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsTo(obj: ClassifierSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClassifierSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClassifierSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClassifierSpecWriteConnectionSecretToRef
 */
export interface ClassifierSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClassifierSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClassifierSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClassifierSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecWriteConnectionSecretToRef(obj: ClassifierSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CSVClassifier object specifying the classifier to create.
 *
 * @schema ClassifierSpecForProviderCsvClassifier
 */
export interface ClassifierSpecForProviderCsvClassifier {
  /**
   * Enables the processing of files that contain only one column.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#allowSingleColumn
   */
  readonly allowSingleColumn?: boolean;

  /**
   * Indicates whether the CSV file contains a header. UNKNOWN = "Detect headings" PRESENT = "Has headings" ABSENT = "No headings"
   *
   * @schema ClassifierSpecForProviderCsvClassifier#containsHeader
   */
  readonly containsHeader?: ClassifierSpecForProviderCsvClassifierContainsHeader;

  /**
   * A custom symbol to denote what separates each column entry in the row.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#delimiter
   */
  readonly delimiter?: string;

  /**
   * Specifies not to trim values before identifying the type of column values. The default value is true.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#disableValueTrimming
   */
  readonly disableValueTrimming?: boolean;

  /**
   * A list of strings representing column names.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#header
   */
  readonly header?: string[];

  /**
   * A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#quoteSymbol
   */
  readonly quoteSymbol?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderCsvClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderCsvClassifier(obj: ClassifierSpecForProviderCsvClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSingleColumn': obj.allowSingleColumn,
    'containsHeader': obj.containsHeader,
    'delimiter': obj.delimiter,
    'disableValueTrimming': obj.disableValueTrimming,
    'header': obj.header?.map(y => y),
    'quoteSymbol': obj.quoteSymbol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A GrokClassifier object specifying the classifier to create.
 *
 * @schema ClassifierSpecForProviderGrokClassifier
 */
export interface ClassifierSpecForProviderGrokClassifier {
  /**
   * An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#classification
   */
  readonly classification: string;

  /**
   * Optional custom grok patterns used by this classifier.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#customPatterns
   */
  readonly customPatterns?: string;

  /**
   * The grok pattern used by this classifier.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#grokPattern
   */
  readonly grokPattern: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderGrokClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderGrokClassifier(obj: ClassifierSpecForProviderGrokClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'customPatterns': obj.customPatterns,
    'grokPattern': obj.grokPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A JsonClassifier object specifying the classifier to create.
 *
 * @schema ClassifierSpecForProviderJsonClassifier
 */
export interface ClassifierSpecForProviderJsonClassifier {
  /**
   * A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers (https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
   *
   * @schema ClassifierSpecForProviderJsonClassifier#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderJsonClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderJsonClassifier(obj: ClassifierSpecForProviderJsonClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A XMLClassifier object specifying the classifier to create.
 *
 * @schema ClassifierSpecForProviderXmlClassifier
 */
export interface ClassifierSpecForProviderXmlClassifier {
  /**
   * An identifier of the data format that the classifier matches. Classification is a required field
   *
   * @schema ClassifierSpecForProviderXmlClassifier#classification
   */
  readonly classification: string;

  /**
   * The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <row item_a="A" item_b="B"></row> is okay, but <row item_a="A" item_b="B" /> is not).
   *
   * @schema ClassifierSpecForProviderXmlClassifier#rowTag
   */
  readonly rowTag?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderXmlClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderXmlClassifier(obj: ClassifierSpecForProviderXmlClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'rowTag': obj.rowTag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClassifierSpecProviderConfigRefPolicy
 */
export interface ClassifierSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassifierSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClassifierSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassifierSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClassifierSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassifierSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecProviderConfigRefPolicy(obj: ClassifierSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRef
 */
export interface ClassifierSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToConfigRef(obj: ClassifierSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassifierSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToMetadata
 */
export interface ClassifierSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToMetadata(obj: ClassifierSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the CSV file contains a header. UNKNOWN = "Detect headings" PRESENT = "Has headings" ABSENT = "No headings"
 *
 * @schema ClassifierSpecForProviderCsvClassifierContainsHeader
 */
export enum ClassifierSpecForProviderCsvClassifierContainsHeader {
  /** UNKNOWN */
  UNKNOWN = "UNKNOWN",
  /** PRESENT */
  PRESENT = "PRESENT",
  /** ABSENT */
  ABSENT = "ABSENT",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassifierSpecProviderConfigRefPolicyResolution
 */
export enum ClassifierSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassifierSpecProviderConfigRefPolicyResolve
 */
export enum ClassifierSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClassifierSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClassifierSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * ConnectionParameters defines the desired state of Connection
   *
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ConnectionParameters defines the desired state of Connection
 *
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services account ID is used by default.
   *
   * @schema ConnectionSpecForProvider#catalogID
   */
  readonly catalogId?: string;

  /**
   * A ConnectionInput object defining the connection to create.
   *
   * @schema ConnectionSpecForProvider#connectionInput
   */
  readonly connectionInput: ConnectionSpecForProviderConnectionInput;

  /**
   * Region is which region the Connection will be created.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags you assign to the connection.
   *
   * @schema ConnectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogID': obj.catalogId,
    'connectionInput': toJson_ConnectionSpecForProviderConnectionInput(obj.connectionInput),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectionSpecManagementPolicies
 */
export enum ConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ConnectionInput object defining the connection to create.
 *
 * @schema ConnectionSpecForProviderConnectionInput
 */
export interface ConnectionSpecForProviderConnectionInput {
  /**
   * These key-value pairs define parameters for the connection. Possible keys for connection properties: "HOST"|"PORT"|"USERNAME"|"PASSWORD"|"ENCRYPTED_PASSWORD"|"JDBC_DRIVER_JAR_URI" "JDBC_DRIVER_CLASS_NAME"|"JDBC_ENGINE"|"JDBC_ENGINE_VERSION"|"CONFIG_FILES" "INSTANCE_ID"|"JDBC_CONNECTION_URL"|"JDBC_ENFORCE_SSL"|"CUSTOM_JDBC_CERT" "SKIP_CUSTOM_JDBC_CERT_VALIDATION"|"CUSTOM_JDBC_CERT_STRING"|"CONNECTION_URL" "KAFKA_BOOTSTRAP_SERVERS"|"KAFKA_SSL_ENABLED"|"KAFKA_CUSTOM_CERT" "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"|"KAFKA_CLIENT_KEYSTORE" "KAFKA_CLIENT_KEYSTORE_PASSWORD"|"KAFKA_CLIENT_KEY_PASSWORD" "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"|"ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD" "SECRET_ID"|"CONNECTOR_URL"|"CONNECTOR_TYPE"|"CONNECTOR_CLASS_NAME"
   * ConnectionProperties is a required field
   *
   * @schema ConnectionSpecForProviderConnectionInput#connectionProperties
   */
  readonly connectionProperties: { [key: string]: string };

  /**
   * The type of the connection. Currently, these types are supported:
   * * JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).
   * * KAFKA - Designates a connection to an Apache Kafka streaming platform.
   * * MONGODB - Designates a connection to a MongoDB document database.
   * * NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).
   * * MARKETPLACE - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.
   * * CUSTOM - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.
   * SFTP is not supported.
   * ConnectionType is a required field
   *
   * @schema ConnectionSpecForProviderConnectionInput#connectionType
   */
  readonly connectionType: ConnectionSpecForProviderConnectionInputConnectionType;

  /**
   * The description of the connection.
   *
   * @schema ConnectionSpecForProviderConnectionInput#description
   */
  readonly description?: string;

  /**
   * A list of criteria that can be used in selecting this connection.
   *
   * @schema ConnectionSpecForProviderConnectionInput#matchCriteria
   */
  readonly matchCriteria?: string[];

  /**
   * Specifies the physical requirements for a connection.
   *
   * @schema ConnectionSpecForProviderConnectionInput#physicalConnectionRequirements
   */
  readonly physicalConnectionRequirements?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInput(obj: ConnectionSpecForProviderConnectionInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionProperties': ((obj.connectionProperties) === undefined) ? undefined : (Object.entries(obj.connectionProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'connectionType': obj.connectionType,
    'description': obj.description,
    'matchCriteria': obj.matchCriteria?.map(y => y),
    'physicalConnectionRequirements': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements(obj.physicalConnectionRequirements),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of the connection. Currently, these types are supported:
 * * JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).
 * * KAFKA - Designates a connection to an Apache Kafka streaming platform.
 * * MONGODB - Designates a connection to a MongoDB document database.
 * * NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).
 * * MARKETPLACE - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.
 * * CUSTOM - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.
 * SFTP is not supported.
 * ConnectionType is a required field
 *
 * @schema ConnectionSpecForProviderConnectionInputConnectionType
 */
export enum ConnectionSpecForProviderConnectionInputConnectionType {
  /** JDBC */
  JDBC = "JDBC",
  /** KAFKA */
  KAFKA = "KAFKA",
  /** MONGODB */
  MONGODB = "MONGODB",
  /** NETWORK */
  NETWORK = "NETWORK",
  /** MARKETPLACE */
  MARKETPLACE = "MARKETPLACE",
  /** CUSTOM */
  CUSTOM = "CUSTOM",
}

/**
 * Specifies the physical requirements for a connection.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements {
  /**
   * The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be removed in the future.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The security group ID list used by the connection.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#securityGroupIdList
   */
  readonly securityGroupIdList?: string[];

  /**
   * SecurityGroupIDRefs are references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector;

  /**
   * The subnet ID used by the connection.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#subnetId
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRef is a reference to SubnetID used to set the SubnetID.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#subnetIdRef
   */
  readonly subnetIdRef?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef;

  /**
   * SubnetIDSelector selects a reference to SubnetID used to set the SubnetID.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements#subnetIdSelector
   */
  readonly subnetIdSelector?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZone': obj.availabilityZone,
    'securityGroupIdList': obj.securityGroupIdList?.map(y => y),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDRef is a reference to SubnetID used to set the SubnetID.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects a reference to SubnetID used to set the SubnetID.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy
 */
export interface ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy(obj: ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolution
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolve
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderConnectionInputPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Crawler is the Schema for the Crawlers API
 *
 * @schema Crawler
 */
export class Crawler extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Crawler"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'Crawler',
  }

  /**
   * Renders a Kubernetes manifest for "Crawler".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CrawlerProps): any {
    return {
      ...Crawler.GVK,
      ...toJson_CrawlerProps(props),
    };
  }

  /**
   * Defines a "Crawler" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CrawlerProps) {
    super(scope, id, {
      ...Crawler.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Crawler.GVK,
      ...toJson_CrawlerProps(resolved),
    };
  }
}

/**
 * Crawler is the Schema for the Crawlers API
 *
 * @schema Crawler
 */
export interface CrawlerProps {
  /**
   * @schema Crawler#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CrawlerSpec defines the desired state of Crawler
   *
   * @schema Crawler#spec
   */
  readonly spec: CrawlerSpec;

}

/**
 * Converts an object of type 'CrawlerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerProps(obj: CrawlerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CrawlerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrawlerSpec defines the desired state of Crawler
 *
 * @schema CrawlerSpec
 */
export interface CrawlerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CrawlerSpec#deletionPolicy
   */
  readonly deletionPolicy?: CrawlerSpecDeletionPolicy;

  /**
   * CrawlerParameters defines the desired state of Crawler
   *
   * @schema CrawlerSpec#forProvider
   */
  readonly forProvider: CrawlerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CrawlerSpec#managementPolicies
   */
  readonly managementPolicies?: CrawlerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CrawlerSpec#providerConfigRef
   */
  readonly providerConfigRef?: CrawlerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CrawlerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CrawlerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CrawlerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CrawlerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CrawlerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpec(obj: CrawlerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CrawlerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CrawlerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CrawlerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CrawlerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CrawlerSpecDeletionPolicy
 */
export enum CrawlerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CrawlerParameters defines the desired state of Crawler
 *
 * @schema CrawlerSpecForProvider
 */
export interface CrawlerSpecForProvider {
  /**
   * ClassifierRefs is a list of references to Classifiers used to set the Classifiers.
   *
   * @schema CrawlerSpecForProvider#classifierRefs
   */
  readonly classifierRefs?: CrawlerSpecForProviderClassifierRefs[];

  /**
   * ClassifiersSelector selects references to Classifiers used to set the Classifiers.
   *
   * @schema CrawlerSpecForProvider#classifierSelector
   */
  readonly classifierSelector?: CrawlerSpecForProviderClassifierSelector;

  /**
   * A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
   *
   * @schema CrawlerSpecForProvider#classifiers
   */
  readonly classifiers?: string[];

  /**
   * Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options (https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
   *
   * @schema CrawlerSpecForProvider#configuration
   */
  readonly configuration?: string;

  /**
   * The name of the SecurityConfiguration structure to be used by this crawler.
   *
   * @schema CrawlerSpecForProvider#crawlerSecurityConfiguration
   */
  readonly crawlerSecurityConfiguration?: string;

  /**
   * CrawlerSecurityConfigurationRef is a reference to an SecurityConfiguration used to set the CrawlerSecurityConfiguration.
   *
   * @schema CrawlerSpecForProvider#crawlerSecurityConfigurationRef
   */
  readonly crawlerSecurityConfigurationRef?: CrawlerSpecForProviderCrawlerSecurityConfigurationRef;

  /**
   * CrawlerSecurityConfigurationSelector selects references to SecurityConfiguration used to set the CrawlerSecurityConfiguration.
   *
   * @schema CrawlerSpecForProvider#crawlerSecurityConfigurationSelector
   */
  readonly crawlerSecurityConfigurationSelector?: CrawlerSpecForProviderCrawlerSecurityConfigurationSelector;

  /**
   * The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
   *
   * @schema CrawlerSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * DatabaseNameRef is a reference to an Database used to set the DatabaseName.
   *
   * @schema CrawlerSpecForProvider#databaseNameRef
   */
  readonly databaseNameRef?: CrawlerSpecForProviderDatabaseNameRef;

  /**
   * DatabaseNamesSelector selects references to Database used to set the DatabaseName.
   *
   * @schema CrawlerSpecForProvider#databaseNameSelector
   */
  readonly databaseNameSelector?: CrawlerSpecForProviderDatabaseNameSelector;

  /**
   * A description of the new crawler.
   *
   * @schema CrawlerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies Lake Formation configuration settings for the crawler.
   *
   * @schema CrawlerSpecForProvider#lakeFormationConfiguration
   */
  readonly lakeFormationConfiguration?: CrawlerSpecForProviderLakeFormationConfiguration;

  /**
   * Specifies data lineage configuration settings for the crawler.
   *
   * @schema CrawlerSpecForProvider#lineageConfiguration
   */
  readonly lineageConfiguration?: CrawlerSpecForProviderLineageConfiguration;

  /**
   * A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
   *
   * @schema CrawlerSpecForProvider#recrawlPolicy
   */
  readonly recrawlPolicy?: CrawlerSpecForProviderRecrawlPolicy;

  /**
   * Region is which region the Crawler will be created.
   *
   * @schema CrawlerSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources. AWS API seems to give just name of the role back (not ARN)
   *
   * @schema CrawlerSpecForProvider#role
   */
  readonly role?: string;

  /**
   * RoleRef is a reference to an IAMRole used to set the Role.
   *
   * @schema CrawlerSpecForProvider#roleRef
   */
  readonly roleRef?: CrawlerSpecForProviderRoleRef;

  /**
   * RoleSelector selects references to IAMRole used to set the Role.
   *
   * @schema CrawlerSpecForProvider#roleSelector
   */
  readonly roleSelector?: CrawlerSpecForProviderRoleSelector;

  /**
   * A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers (https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
   *
   * @schema CrawlerSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * The policy for the crawler's update and deletion behavior.
   *
   * @schema CrawlerSpecForProvider#schemaChangePolicy
   */
  readonly schemaChangePolicy?: CrawlerSpecForProviderSchemaChangePolicy;

  /**
   * The table prefix used for catalog tables that are created.
   *
   * @schema CrawlerSpecForProvider#tablePrefix
   */
  readonly tablePrefix?: string;

  /**
   * The tags to use with this crawler request. You may use tags to limit access to the crawler. For more information about tags in Glue, see Amazon Web Services Tags in Glue (https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
   *
   * @schema CrawlerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * A list of collection of targets to crawl.
   * Targets is a required field
   *
   * @schema CrawlerSpecForProvider#targets
   */
  readonly targets: CrawlerSpecForProviderTargets;

}

/**
 * Converts an object of type 'CrawlerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProvider(obj: CrawlerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classifierRefs': obj.classifierRefs?.map(y => toJson_CrawlerSpecForProviderClassifierRefs(y)),
    'classifierSelector': toJson_CrawlerSpecForProviderClassifierSelector(obj.classifierSelector),
    'classifiers': obj.classifiers?.map(y => y),
    'configuration': obj.configuration,
    'crawlerSecurityConfiguration': obj.crawlerSecurityConfiguration,
    'crawlerSecurityConfigurationRef': toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationRef(obj.crawlerSecurityConfigurationRef),
    'crawlerSecurityConfigurationSelector': toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationSelector(obj.crawlerSecurityConfigurationSelector),
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_CrawlerSpecForProviderDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_CrawlerSpecForProviderDatabaseNameSelector(obj.databaseNameSelector),
    'description': obj.description,
    'lakeFormationConfiguration': toJson_CrawlerSpecForProviderLakeFormationConfiguration(obj.lakeFormationConfiguration),
    'lineageConfiguration': toJson_CrawlerSpecForProviderLineageConfiguration(obj.lineageConfiguration),
    'recrawlPolicy': toJson_CrawlerSpecForProviderRecrawlPolicy(obj.recrawlPolicy),
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_CrawlerSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_CrawlerSpecForProviderRoleSelector(obj.roleSelector),
    'schedule': obj.schedule,
    'schemaChangePolicy': toJson_CrawlerSpecForProviderSchemaChangePolicy(obj.schemaChangePolicy),
    'tablePrefix': obj.tablePrefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targets': toJson_CrawlerSpecForProviderTargets(obj.targets),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CrawlerSpecManagementPolicies
 */
export enum CrawlerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CrawlerSpecProviderConfigRef
 */
export interface CrawlerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecProviderConfigRef#policy
   */
  readonly policy?: CrawlerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecProviderConfigRef(obj: CrawlerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CrawlerSpecPublishConnectionDetailsTo
 */
export interface CrawlerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CrawlerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CrawlerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsTo(obj: CrawlerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CrawlerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CrawlerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CrawlerSpecWriteConnectionSecretToRef
 */
export interface CrawlerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CrawlerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CrawlerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CrawlerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecWriteConnectionSecretToRef(obj: CrawlerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema CrawlerSpecForProviderClassifierRefs
 */
export interface CrawlerSpecForProviderClassifierRefs {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderClassifierRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderClassifierRefs#policy
   */
  readonly policy?: CrawlerSpecForProviderClassifierRefsPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderClassifierRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderClassifierRefs(obj: CrawlerSpecForProviderClassifierRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderClassifierRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClassifiersSelector selects references to Classifiers used to set the Classifiers.
 *
 * @schema CrawlerSpecForProviderClassifierSelector
 */
export interface CrawlerSpecForProviderClassifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderClassifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderClassifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderClassifierSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderClassifierSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderClassifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderClassifierSelector(obj: CrawlerSpecForProviderClassifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderClassifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrawlerSecurityConfigurationRef is a reference to an SecurityConfiguration used to set the CrawlerSecurityConfiguration.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRef
 */
export interface CrawlerSpecForProviderCrawlerSecurityConfigurationRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRef#policy
   */
  readonly policy?: CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCrawlerSecurityConfigurationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationRef(obj: CrawlerSpecForProviderCrawlerSecurityConfigurationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrawlerSecurityConfigurationSelector selects references to SecurityConfiguration used to set the CrawlerSecurityConfiguration.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelector
 */
export interface CrawlerSpecForProviderCrawlerSecurityConfigurationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCrawlerSecurityConfigurationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationSelector(obj: CrawlerSpecForProviderCrawlerSecurityConfigurationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseNameRef is a reference to an Database used to set the DatabaseName.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRef
 */
export interface CrawlerSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameRef(obj: CrawlerSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseNamesSelector selects references to Database used to set the DatabaseName.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelector
 */
export interface CrawlerSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameSelector(obj: CrawlerSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies Lake Formation configuration settings for the crawler.
 *
 * @schema CrawlerSpecForProviderLakeFormationConfiguration
 */
export interface CrawlerSpecForProviderLakeFormationConfiguration {
  /**
   * @schema CrawlerSpecForProviderLakeFormationConfiguration#accountID
   */
  readonly accountId?: string;

  /**
   * @schema CrawlerSpecForProviderLakeFormationConfiguration#useLakeFormationCredentials
   */
  readonly useLakeFormationCredentials?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderLakeFormationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderLakeFormationConfiguration(obj: CrawlerSpecForProviderLakeFormationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountID': obj.accountId,
    'useLakeFormationCredentials': obj.useLakeFormationCredentials,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies data lineage configuration settings for the crawler.
 *
 * @schema CrawlerSpecForProviderLineageConfiguration
 */
export interface CrawlerSpecForProviderLineageConfiguration {
  /**
   * @schema CrawlerSpecForProviderLineageConfiguration#crawlerLineageSettings
   */
  readonly crawlerLineageSettings?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderLineageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderLineageConfiguration(obj: CrawlerSpecForProviderLineageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crawlerLineageSettings': obj.crawlerLineageSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
 *
 * @schema CrawlerSpecForProviderRecrawlPolicy
 */
export interface CrawlerSpecForProviderRecrawlPolicy {
  /**
   * @schema CrawlerSpecForProviderRecrawlPolicy#recrawlBehavior
   */
  readonly recrawlBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRecrawlPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRecrawlPolicy(obj: CrawlerSpecForProviderRecrawlPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recrawlBehavior': obj.recrawlBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleRef is a reference to an IAMRole used to set the Role.
 *
 * @schema CrawlerSpecForProviderRoleRef
 */
export interface CrawlerSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderRoleRef#policy
   */
  readonly policy?: CrawlerSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleRef(obj: CrawlerSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects references to IAMRole used to set the Role.
 *
 * @schema CrawlerSpecForProviderRoleSelector
 */
export interface CrawlerSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderRoleSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleSelector(obj: CrawlerSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for the crawler's update and deletion behavior.
 *
 * @schema CrawlerSpecForProviderSchemaChangePolicy
 */
export interface CrawlerSpecForProviderSchemaChangePolicy {
  /**
   * @schema CrawlerSpecForProviderSchemaChangePolicy#deleteBehavior
   */
  readonly deleteBehavior?: string;

  /**
   * @schema CrawlerSpecForProviderSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderSchemaChangePolicy(obj: CrawlerSpecForProviderSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteBehavior': obj.deleteBehavior,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of collection of targets to crawl.
 * Targets is a required field
 *
 * @schema CrawlerSpecForProviderTargets
 */
export interface CrawlerSpecForProviderTargets {
  /**
   * Specifies Glue Data Catalog targets.
   *
   * @schema CrawlerSpecForProviderTargets#catalogTargets
   */
  readonly catalogTargets?: CrawlerSpecForProviderTargetsCatalogTargets[];

  /**
   * Specifies Amazon DynamoDB targets.
   *
   * @schema CrawlerSpecForProviderTargets#dynamoDBTargets
   */
  readonly dynamoDbTargets?: CrawlerSpecForProviderTargetsDynamoDbTargets[];

  /**
   * Specifies JDBC targets.
   *
   * @schema CrawlerSpecForProviderTargets#jdbcTargets
   */
  readonly jdbcTargets?: CrawlerSpecForProviderTargetsJdbcTargets[];

  /**
   * Specifies Amazon DocumentDB or MongoDB targets.
   *
   * @schema CrawlerSpecForProviderTargets#mongoDBTargets
   */
  readonly mongoDbTargets?: CrawlerSpecForProviderTargetsMongoDbTargets[];

  /**
   * Specifies Amazon Simple Storage Service (Amazon S3) targets.
   *
   * @schema CrawlerSpecForProviderTargets#s3Targets
   */
  readonly s3Targets?: CrawlerSpecForProviderTargetsS3Targets[];

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargets(obj: CrawlerSpecForProviderTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogTargets': obj.catalogTargets?.map(y => toJson_CrawlerSpecForProviderTargetsCatalogTargets(y)),
    'dynamoDBTargets': obj.dynamoDbTargets?.map(y => toJson_CrawlerSpecForProviderTargetsDynamoDbTargets(y)),
    'jdbcTargets': obj.jdbcTargets?.map(y => toJson_CrawlerSpecForProviderTargetsJdbcTargets(y)),
    'mongoDBTargets': obj.mongoDbTargets?.map(y => toJson_CrawlerSpecForProviderTargetsMongoDbTargets(y)),
    's3Targets': obj.s3Targets?.map(y => toJson_CrawlerSpecForProviderTargetsS3Targets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecProviderConfigRefPolicy
 */
export interface CrawlerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecProviderConfigRefPolicy(obj: CrawlerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRef
 */
export interface CrawlerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToConfigRef(obj: CrawlerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToMetadata
 */
export interface CrawlerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToMetadata(obj: CrawlerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderClassifierRefsPolicy
 */
export interface CrawlerSpecForProviderClassifierRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderClassifierRefsPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderClassifierRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderClassifierRefsPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderClassifierRefsPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderClassifierRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderClassifierRefsPolicy(obj: CrawlerSpecForProviderClassifierRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderClassifierSelectorPolicy
 */
export interface CrawlerSpecForProviderClassifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderClassifierSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderClassifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderClassifierSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderClassifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderClassifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderClassifierSelectorPolicy(obj: CrawlerSpecForProviderClassifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy
 */
export interface CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy(obj: CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy
 */
export interface CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy(obj: CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicy
 */
export interface CrawlerSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameRefPolicy(obj: CrawlerSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy
 */
export interface CrawlerSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameSelectorPolicy(obj: CrawlerSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicy
 */
export interface CrawlerSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleRefPolicy(obj: CrawlerSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicy
 */
export interface CrawlerSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleSelectorPolicy(obj: CrawlerSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomCatalogTarget contains the additional fields for CatalogTarget
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargets
 */
export interface CrawlerSpecForProviderTargetsCatalogTargets {
  /**
   * The name of the database to be synchronized.
   * DatabaseName is a required field
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargets#databaseName
   */
  readonly databaseName?: string;

  /**
   * DatabaseNameRef is a reference to an Database used to set the DatabaseName.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargets#databaseNameRef
   */
  readonly databaseNameRef?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef;

  /**
   * DatabaseNamesSelector selects references to Database used to set the DatabaseName.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargets#databaseNameSelector
   */
  readonly databaseNameSelector?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector;

  /**
   * A list of the tables to be synchronized.
   * Tables is a required field
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargets#tables
   */
  readonly tables: string[];

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsCatalogTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsCatalogTargets(obj: CrawlerSpecForProviderTargetsCatalogTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector(obj.databaseNameSelector),
    'tables': obj.tables?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderTargetsDynamoDbTargets
 */
export interface CrawlerSpecForProviderTargetsDynamoDbTargets {
  /**
   * @schema CrawlerSpecForProviderTargetsDynamoDbTargets#path
   */
  readonly path?: string;

  /**
   * @schema CrawlerSpecForProviderTargetsDynamoDbTargets#scanAll
   */
  readonly scanAll?: boolean;

  /**
   * @schema CrawlerSpecForProviderTargetsDynamoDbTargets#scanRate
   */
  readonly scanRate?: number;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsDynamoDbTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsDynamoDbTargets(obj: CrawlerSpecForProviderTargetsDynamoDbTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'scanAll': obj.scanAll,
    'scanRate': obj.scanRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomJDBCTarget contains the additional fields for JdbcTarget
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargets
 */
export interface CrawlerSpecForProviderTargetsJdbcTargets {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargets#connectionName
   */
  readonly connectionName?: string;

  /**
   * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargets#connectionNameRef
   */
  readonly connectionNameRef?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef;

  /**
   * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargets#connectionNameSelector
   */
  readonly connectionNameSelector?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector;

  /**
   * A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler (https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargets#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The path of the JDBC target.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargets#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsJdbcTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsJdbcTargets(obj: CrawlerSpecForProviderTargetsJdbcTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionNameRef': toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef(obj.connectionNameRef),
    'connectionNameSelector': toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector(obj.connectionNameSelector),
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomMongoDBTarget contains the additional fields for MongoDBTarget
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargets
 */
export interface CrawlerSpecForProviderTargetsMongoDbTargets {
  /**
   * The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargets#connectionName
   */
  readonly connectionName?: string;

  /**
   * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargets#connectionNameRef
   */
  readonly connectionNameRef?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef;

  /**
   * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargets#connectionNameSelector
   */
  readonly connectionNameSelector?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector;

  /**
   * The path of the Amazon DocumentDB or MongoDB target (database/collection).
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargets#path
   */
  readonly path?: string;

  /**
   * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.
   * A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargets#scanAll
   */
  readonly scanAll?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsMongoDbTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsMongoDbTargets(obj: CrawlerSpecForProviderTargetsMongoDbTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionNameRef': toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef(obj.connectionNameRef),
    'connectionNameSelector': toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector(obj.connectionNameSelector),
    'path': obj.path,
    'scanAll': obj.scanAll,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomS3Target contains the additional fields for S3Target
 *
 * @schema CrawlerSpecForProviderTargetsS3Targets
 */
export interface CrawlerSpecForProviderTargetsS3Targets {
  /**
   * The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#connectionName
   */
  readonly connectionName?: string;

  /**
   * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#connectionNameRef
   */
  readonly connectionNameRef?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef;

  /**
   * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#connectionNameSelector
   */
  readonly connectionNameSelector?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector;

  /**
   * A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#dlqEventQueueArn
   */
  readonly dlqEventQueueArn?: string;

  /**
   * DlqEventQueueARNRef is a reference to an SQSEventQueue used to set the DlqEventQueueARN.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#dlqEventQueueArnRef
   */
  readonly dlqEventQueueArnRef?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef;

  /**
   * DlqEventQueueARNSelector selects references to SQSEventQueue used to set the DlqEventQueueARN.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#dlqEventQueueArnSelector
   */
  readonly dlqEventQueueArnSelector?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector;

  /**
   * A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#eventQueueArn
   */
  readonly eventQueueArn?: string;

  /**
   * EventQueueARNRef is a reference to an SQSEventQueue used to set the EventQueueARN.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#eventQueueArnRef
   */
  readonly eventQueueArnRef?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef;

  /**
   * EventQueueARNSelector selects references to SQSEventQueue used to set the EventQueueARN.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#eventQueueArnSelector
   */
  readonly eventQueueArnSelector?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector;

  /**
   * A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler (https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The path to the Amazon S3 target.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#path
   */
  readonly path?: string;

  /**
   * Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
   *
   * @schema CrawlerSpecForProviderTargetsS3Targets#sampleSize
   */
  readonly sampleSize?: number;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3Targets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3Targets(obj: CrawlerSpecForProviderTargetsS3Targets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionNameRef': toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef(obj.connectionNameRef),
    'connectionNameSelector': toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector(obj.connectionNameSelector),
    'dlqEventQueueArn': obj.dlqEventQueueArn,
    'dlqEventQueueArnRef': toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef(obj.dlqEventQueueArnRef),
    'dlqEventQueueArnSelector': toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector(obj.dlqEventQueueArnSelector),
    'eventQueueArn': obj.eventQueueArn,
    'eventQueueArnRef': toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef(obj.eventQueueArnRef),
    'eventQueueArnSelector': toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector(obj.eventQueueArnSelector),
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
    'sampleSize': obj.sampleSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecProviderConfigRefPolicyResolution
 */
export enum CrawlerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecProviderConfigRefPolicyResolve
 */
export enum CrawlerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CrawlerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToConfigRefPolicy(obj: CrawlerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderClassifierRefsPolicyResolution
 */
export enum CrawlerSpecForProviderClassifierRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderClassifierRefsPolicyResolve
 */
export enum CrawlerSpecForProviderClassifierRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderClassifierSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderClassifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderClassifierSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderClassifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolution
 */
export enum CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolve
 */
export enum CrawlerSpecForProviderCrawlerSecurityConfigurationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderCrawlerSecurityConfigurationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicyResolution
 */
export enum CrawlerSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicyResolve
 */
export enum CrawlerSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * DatabaseNameRef is a reference to an Database used to set the DatabaseName.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef
 */
export interface CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef(obj: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseNamesSelector selects references to Database used to set the DatabaseName.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector
 */
export interface CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector(obj: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef
 */
export interface CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef(obj: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector
 */
export interface CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector(obj: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef
 */
export interface CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef(obj: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector
 */
export interface CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector(obj: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNameRef is a reference to an Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef
 */
export interface CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef(obj: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionNamesSelector selects references to Connection used to set the ConnectionName.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector
 */
export interface CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector(obj: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DlqEventQueueARNRef is a reference to an SQSEventQueue used to set the DlqEventQueueARN.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef
 */
export interface CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef(obj: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DlqEventQueueARNSelector selects references to SQSEventQueue used to set the DlqEventQueueARN.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector
 */
export interface CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector(obj: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventQueueARNRef is a reference to an SQSEventQueue used to set the EventQueueARN.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef
 */
export interface CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef(obj: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventQueueARNSelector selects references to SQSEventQueue used to set the EventQueueARN.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector
 */
export interface CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector(obj: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy
 */
export interface CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy(obj: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy(obj: CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy
 */
export interface CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy(obj: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy(obj: CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy
 */
export interface CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy(obj: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy(obj: CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy
 */
export interface CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy(obj: CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsCatalogTargetsDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsJdbcTargetsConnectionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsMongoDbTargetsConnectionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsConnectionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsConnectionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsDlqEventQueueArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsEventQueueArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderTargetsS3TargetsEventQueueArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Database is the Schema for the Databases API
 *
 * @schema Database
 */
export class Database extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Database"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'Database',
  }

  /**
   * Renders a Kubernetes manifest for "Database".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatabaseProps): any {
    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(props),
    };
  }

  /**
   * Defines a "Database" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatabaseProps) {
    super(scope, id, {
      ...Database.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(resolved),
    };
  }
}

/**
 * Database is the Schema for the Databases API
 *
 * @schema Database
 */
export interface DatabaseProps {
  /**
   * @schema Database#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatabaseSpec defines the desired state of Database
   *
   * @schema Database#spec
   */
  readonly spec: DatabaseSpec;

}

/**
 * Converts an object of type 'DatabaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseProps(obj: DatabaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatabaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseSpec defines the desired state of Database
 *
 * @schema DatabaseSpec
 */
export interface DatabaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatabaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatabaseSpecDeletionPolicy;

  /**
   * DatabaseParameters defines the desired state of Database
   *
   * @schema DatabaseSpec#forProvider
   */
  readonly forProvider: DatabaseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DatabaseSpec#managementPolicies
   */
  readonly managementPolicies?: DatabaseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatabaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatabaseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatabaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatabaseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatabaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatabaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatabaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpec(obj: DatabaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatabaseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DatabaseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DatabaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatabaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatabaseSpecDeletionPolicy
 */
export enum DatabaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DatabaseParameters defines the desired state of Database
 *
 * @schema DatabaseSpecForProvider
 */
export interface DatabaseSpecForProvider {
  /**
   * The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services account ID is used by default.
   *
   * @schema DatabaseSpecForProvider#catalogID
   */
  readonly catalogId?: string;

  /**
   * The metadata for the database.
   *
   * @schema DatabaseSpecForProvider#databaseInput
   */
  readonly databaseInput?: DatabaseSpecForProviderDatabaseInput;

  /**
   * Region is which region the Database will be created.
   *
   * @schema DatabaseSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags you assign to the database.
   *
   * @schema DatabaseSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatabaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProvider(obj: DatabaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogID': obj.catalogId,
    'databaseInput': toJson_DatabaseSpecForProviderDatabaseInput(obj.databaseInput),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DatabaseSpecManagementPolicies
 */
export enum DatabaseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatabaseSpecProviderConfigRef
 */
export interface DatabaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderConfigRef#policy
   */
  readonly policy?: DatabaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRef(obj: DatabaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatabaseSpecPublishConnectionDetailsTo
 */
export interface DatabaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatabaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatabaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsTo(obj: DatabaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatabaseSpecWriteConnectionSecretToRef
 */
export interface DatabaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecWriteConnectionSecretToRef(obj: DatabaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The metadata for the database.
 *
 * @schema DatabaseSpecForProviderDatabaseInput
 */
export interface DatabaseSpecForProviderDatabaseInput {
  /**
   * Creates a set of default permissions on the table for principals. If left empty on creation, AWS defaults it to [Permissions: ["All"], Principal: DataLake Prinicpal Identifier : "IAM_ALLOWED_PRINCIPALS"]
   *
   * @schema DatabaseSpecForProviderDatabaseInput#createTableDefaultPermissions
   */
  readonly createTableDefaultPermissions?: DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions[];

  /**
   * A description of the database.
   *
   * @schema DatabaseSpecForProviderDatabaseInput#description
   */
  readonly description?: string;

  /**
   * The location of the database (for example, an HDFS path).
   *
   * @schema DatabaseSpecForProviderDatabaseInput#locationURI
   */
  readonly locationUri?: string;

  /**
   * These key-value pairs define parameters and properties of the database.
   *
   * @schema DatabaseSpecForProviderDatabaseInput#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * A structure that describes a target database for resource linking.
   *
   * @schema DatabaseSpecForProviderDatabaseInput#targetDatabase
   */
  readonly targetDatabase?: DatabaseSpecForProviderDatabaseInputTargetDatabase;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderDatabaseInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderDatabaseInput(obj: DatabaseSpecForProviderDatabaseInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createTableDefaultPermissions': obj.createTableDefaultPermissions?.map(y => toJson_DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions(y)),
    'description': obj.description,
    'locationURI': obj.locationUri,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetDatabase': toJson_DatabaseSpecForProviderDatabaseInputTargetDatabase(obj.targetDatabase),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderConfigRefPolicy
 */
export interface DatabaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRefPolicy(obj: DatabaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRef
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj: DatabaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToMetadata
 */
export interface DatabaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj: DatabaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions
 */
export interface DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions {
  /**
   * @schema DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions#permissions
   */
  readonly permissions?: string[];

  /**
   * The Lake Formation principal.
   *
   * @schema DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions#principal
   */
  readonly principal?: DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions(obj: DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': toJson_DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal(obj.principal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A structure that describes a target database for resource linking.
 *
 * @schema DatabaseSpecForProviderDatabaseInputTargetDatabase
 */
export interface DatabaseSpecForProviderDatabaseInputTargetDatabase {
  /**
   * @schema DatabaseSpecForProviderDatabaseInputTargetDatabase#catalogID
   */
  readonly catalogId?: string;

  /**
   * @schema DatabaseSpecForProviderDatabaseInputTargetDatabase#databaseName
   */
  readonly databaseName?: string;

  /**
   * @schema DatabaseSpecForProviderDatabaseInputTargetDatabase#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderDatabaseInputTargetDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderDatabaseInputTargetDatabase(obj: DatabaseSpecForProviderDatabaseInputTargetDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogID': obj.catalogId,
    'databaseName': obj.databaseName,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolution
 */
export enum DatabaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolve
 */
export enum DatabaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Lake Formation principal.
 *
 * @schema DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal
 */
export interface DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal {
  /**
   * @schema DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal#dataLakePrincipalIdentifier
   */
  readonly dataLakePrincipalIdentifier?: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal(obj: DatabaseSpecForProviderDatabaseInputCreateTableDefaultPermissionsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLakePrincipalIdentifier': obj.dataLakePrincipalIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Job is the Schema for the Jobs API
 *
 * @schema Job
 */
export class Job extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Job"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'Job',
  }

  /**
   * Renders a Kubernetes manifest for "Job".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JobProps): any {
    return {
      ...Job.GVK,
      ...toJson_JobProps(props),
    };
  }

  /**
   * Defines a "Job" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JobProps) {
    super(scope, id, {
      ...Job.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Job.GVK,
      ...toJson_JobProps(resolved),
    };
  }
}

/**
 * Job is the Schema for the Jobs API
 *
 * @schema Job
 */
export interface JobProps {
  /**
   * @schema Job#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JobSpec defines the desired state of Job
   *
   * @schema Job#spec
   */
  readonly spec: JobSpec;

}

/**
 * Converts an object of type 'JobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobProps(obj: JobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JobSpec defines the desired state of Job
 *
 * @schema JobSpec
 */
export interface JobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema JobSpec#deletionPolicy
   */
  readonly deletionPolicy?: JobSpecDeletionPolicy;

  /**
   * JobParameters defines the desired state of Job
   *
   * @schema JobSpec#forProvider
   */
  readonly forProvider: JobSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema JobSpec#managementPolicies
   */
  readonly managementPolicies?: JobSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JobSpec#providerConfigRef
   */
  readonly providerConfigRef?: JobSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpec(obj: JobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JobSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_JobSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_JobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema JobSpecDeletionPolicy
 */
export enum JobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * JobParameters defines the desired state of Job
 *
 * @schema JobSpecForProvider
 */
export interface JobSpecForProvider {
  /**
   * This parameter is deprecated. Use MaxCapacity instead.
   * The number of Glue data processing units (DPUs) to allocate to this Job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page (https://aws.amazon.com/glue/pricing/).
   *
   * @schema JobSpecForProvider#allocatedCapacity
   */
  readonly allocatedCapacity?: number;

  /**
   * The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
   *
   * @schema JobSpecForProvider#codeGenConfigurationNodes
   */
  readonly codeGenConfigurationNodes?: { [key: string]: JobSpecForProviderCodeGenConfigurationNodes };

  /**
   * The JobCommand that runs this job.
   *
   * @schema JobSpecForProvider#command
   */
  readonly command: JobSpecForProviderCommand;

  /**
   * ConnectionRefs is a list of references to Connections used to set the Connections.
   *
   * @schema JobSpecForProvider#connectionRefs
   */
  readonly connectionRefs?: JobSpecForProviderConnectionRefs[];

  /**
   * ConnectionsSelector selects references to Connections used to set the Connections.
   *
   * @schema JobSpecForProvider#connectionSelector
   */
  readonly connectionSelector?: JobSpecForProviderConnectionSelector;

  /**
   * The connections used for this job.
   *
   * @schema JobSpecForProvider#connections
   */
  readonly connections?: string[];

  /**
   * The default arguments for every run of this job, specified as name-value pairs.
   * You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.
   * Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.
   * For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python (https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide.
   * For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue (https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide.
   * For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs (https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
   *
   * @schema JobSpecForProvider#defaultArguments
   */
  readonly defaultArguments?: { [key: string]: string };

  /**
   * Description of the job being defined.
   *
   * @schema JobSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.
   * The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.
   * Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
   *
   * @schema JobSpecForProvider#executionClass
   */
  readonly executionClass?: string;

  /**
   * An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
   *
   * @schema JobSpecForProvider#executionProperty
   */
  readonly executionProperty?: JobSpecForProviderExecutionProperty;

  /**
   * In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.
   * Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command.
   * For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version (https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide.
   * Jobs that are created without specifying a Glue version default to Glue 0.9.
   *
   * @schema JobSpecForProvider#glueVersion
   */
  readonly glueVersion?: string;

  /**
   * This field is reserved for future use.
   *
   * @schema JobSpecForProvider#logURI
   */
  readonly logUri?: string;

  /**
   * For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page (https://aws.amazon.com/glue/pricing/).
   * For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers.
   * Do not set MaxCapacity if using WorkerType and NumberOfWorkers.
   * The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
   * * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
   * * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
   *
   * @schema JobSpecForProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * The maximum number of times to retry this job if it fails.
   *
   * @schema JobSpecForProvider#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
   *
   * @schema JobSpecForProvider#nonOverridableArguments
   */
  readonly nonOverridableArguments?: { [key: string]: string };

  /**
   * Specifies configuration properties of a job notification.
   *
   * @schema JobSpecForProvider#notificationProperty
   */
  readonly notificationProperty?: JobSpecForProviderNotificationProperty;

  /**
   * The number of workers of a defined workerType that are allocated when a job runs.
   *
   * @schema JobSpecForProvider#numberOfWorkers
   */
  readonly numberOfWorkers?: number;

  /**
   * Region is which region the Job will be created.
   *
   * @schema JobSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name or Amazon Resource Name (ARN) of the IAM role associated with this job. Role is a required field
   *
   * @schema JobSpecForProvider#role
   */
  readonly role?: string;

  /**
   * RoleRef is a reference to an IAMRole used to set the Role.
   *
   * @schema JobSpecForProvider#roleRef
   */
  readonly roleRef?: JobSpecForProviderRoleRef;

  /**
   * RoleSelector selects references to IAMRole used to set the Role.
   *
   * @schema JobSpecForProvider#roleSelector
   */
  readonly roleSelector?: JobSpecForProviderRoleSelector;

  /**
   * The name of the SecurityConfiguration structure to be used with this job.
   *
   * @schema JobSpecForProvider#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * SecurityConfigurationRef is a reference to an SecurityConfiguration used to set the SecurityConfiguration.
   *
   * @schema JobSpecForProvider#securityConfigurationRef
   */
  readonly securityConfigurationRef?: JobSpecForProviderSecurityConfigurationRef;

  /**
   * SecurityConfigurationSelector selects references to SecurityConfiguration used to set the SecurityConfiguration.
   *
   * @schema JobSpecForProvider#securityConfigurationSelector
   */
  readonly securityConfigurationSelector?: JobSpecForProviderSecurityConfigurationSelector;

  /**
   * The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
   *
   * @schema JobSpecForProvider#sourceControlDetails
   */
  readonly sourceControlDetails?: JobSpecForProviderSourceControlDetails;

  /**
   * The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see Amazon Web Services Tags in Glue (https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
   *
   * @schema JobSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
   *
   * @schema JobSpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
   * * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
   * * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
   * * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
   * * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
   * * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
   * * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
   *
   * @schema JobSpecForProvider#workerType
   */
  readonly workerType?: string;

}

/**
 * Converts an object of type 'JobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProvider(obj: JobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedCapacity': obj.allocatedCapacity,
    'codeGenConfigurationNodes': ((obj.codeGenConfigurationNodes) === undefined) ? undefined : (Object.entries(obj.codeGenConfigurationNodes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_JobSpecForProviderCodeGenConfigurationNodes(i[1]) }), {})),
    'command': toJson_JobSpecForProviderCommand(obj.command),
    'connectionRefs': obj.connectionRefs?.map(y => toJson_JobSpecForProviderConnectionRefs(y)),
    'connectionSelector': toJson_JobSpecForProviderConnectionSelector(obj.connectionSelector),
    'connections': obj.connections?.map(y => y),
    'defaultArguments': ((obj.defaultArguments) === undefined) ? undefined : (Object.entries(obj.defaultArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'executionClass': obj.executionClass,
    'executionProperty': toJson_JobSpecForProviderExecutionProperty(obj.executionProperty),
    'glueVersion': obj.glueVersion,
    'logURI': obj.logUri,
    'maxCapacity': obj.maxCapacity,
    'maxRetries': obj.maxRetries,
    'nonOverridableArguments': ((obj.nonOverridableArguments) === undefined) ? undefined : (Object.entries(obj.nonOverridableArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'notificationProperty': toJson_JobSpecForProviderNotificationProperty(obj.notificationProperty),
    'numberOfWorkers': obj.numberOfWorkers,
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_JobSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_JobSpecForProviderRoleSelector(obj.roleSelector),
    'securityConfiguration': obj.securityConfiguration,
    'securityConfigurationRef': toJson_JobSpecForProviderSecurityConfigurationRef(obj.securityConfigurationRef),
    'securityConfigurationSelector': toJson_JobSpecForProviderSecurityConfigurationSelector(obj.securityConfigurationSelector),
    'sourceControlDetails': toJson_JobSpecForProviderSourceControlDetails(obj.sourceControlDetails),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'workerType': obj.workerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema JobSpecManagementPolicies
 */
export enum JobSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JobSpecProviderConfigRef
 */
export interface JobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecProviderConfigRef#policy
   */
  readonly policy?: JobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRef(obj: JobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JobSpecPublishConnectionDetailsTo
 */
export interface JobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsTo(obj: JobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JobSpecWriteConnectionSecretToRef
 */
export interface JobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecWriteConnectionSecretToRef(obj: JobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodes
 */
export interface JobSpecForProviderCodeGenConfigurationNodes {
  /**
   * Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#aggregate
   */
  readonly aggregate?: JobSpecForProviderCodeGenConfigurationNodesAggregate;

  /**
   * Specifies an Amazon Redshift source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#amazonRedshiftSource
   */
  readonly amazonRedshiftSource?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource;

  /**
   * Specifies an Amazon Redshift target.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#amazonRedshiftTarget
   */
  readonly amazonRedshiftTarget?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget;

  /**
   * Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#applyMapping
   */
  readonly applyMapping?: JobSpecForProviderCodeGenConfigurationNodesApplyMapping;

  /**
   * Specifies a connector to an Amazon Athena data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#athenaConnectorSource
   */
  readonly athenaConnectorSource?: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource;

  /**
   * Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogDeltaSource
   */
  readonly catalogDeltaSource?: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource;

  /**
   * Specifies a Hudi data source that is registered in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogHudiSource
   */
  readonly catalogHudiSource?: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource;

  /**
   * Specifies an Apache Kafka data store in the Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogKafkaSource
   */
  readonly catalogKafkaSource?: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource;

  /**
   * Specifies a Kinesis data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogKinesisSource
   */
  readonly catalogKinesisSource?: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource;

  /**
   * Specifies a data store in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogSource
   */
  readonly catalogSource?: JobSpecForProviderCodeGenConfigurationNodesCatalogSource;

  /**
   * Specifies a target that uses a Glue Data Catalog table.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#catalogTarget
   */
  readonly catalogTarget?: JobSpecForProviderCodeGenConfigurationNodesCatalogTarget;

  /**
   * Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#customCode
   */
  readonly customCode?: JobSpecForProviderCodeGenConfigurationNodesCustomCode;

  /**
   * Specifies the direct JDBC source connection.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#directJDBCSource
   */
  readonly directJdbcSource?: JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource;

  /**
   * Specifies an Apache Kafka data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#directKafkaSource
   */
  readonly directKafkaSource?: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource;

  /**
   * Specifies a direct Amazon Kinesis data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#directKinesisSource
   */
  readonly directKinesisSource?: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource;

  /**
   * Specifies a transform that removes rows of repeating data from a data set.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#dropDuplicates
   */
  readonly dropDuplicates?: JobSpecForProviderCodeGenConfigurationNodesDropDuplicates;

  /**
   * Specifies a transform that chooses the data property keys that you want to drop.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#dropFields
   */
  readonly dropFields?: JobSpecForProviderCodeGenConfigurationNodesDropFields;

  /**
   * Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#dropNullFields
   */
  readonly dropNullFields?: JobSpecForProviderCodeGenConfigurationNodesDropNullFields;

  /**
   * Specifies the set of parameters needed to perform the dynamic transform.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#dynamicTransform
   */
  readonly dynamicTransform?: JobSpecForProviderCodeGenConfigurationNodesDynamicTransform;

  /**
   * Specifies a DynamoDB data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#dynamoDBCatalogSource
   */
  readonly dynamoDbCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource;

  /**
   * Specifies your data quality evaluation criteria.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#evaluateDataQuality
   */
  readonly evaluateDataQuality?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality;

  /**
   * Specifies your data quality evaluation criteria.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#evaluateDataQualityMultiFrame
   */
  readonly evaluateDataQualityMultiFrame?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame;

  /**
   * Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#fillMissingValues
   */
  readonly fillMissingValues?: JobSpecForProviderCodeGenConfigurationNodesFillMissingValues;

  /**
   * Specifies a transform that splits a dataset into two, based on a filter condition.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#filter
   */
  readonly filter?: JobSpecForProviderCodeGenConfigurationNodesFilter;

  /**
   * Specifies the data store in the governed Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#governedCatalogSource
   */
  readonly governedCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource;

  /**
   * Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#governedCatalogTarget
   */
  readonly governedCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget;

  /**
   * Specifies a connector to a JDBC data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#jDBCConnectorSource
   */
  readonly jDbcConnectorSource?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource;

  /**
   * Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#jDBCConnectorTarget
   */
  readonly jDbcConnectorTarget?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget;

  /**
   * Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#join
   */
  readonly join?: JobSpecForProviderCodeGenConfigurationNodesJoin;

  /**
   * Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#merge
   */
  readonly merge?: JobSpecForProviderCodeGenConfigurationNodesMerge;

  /**
   * Specifies a Microsoft SQL server data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#microsoftSQLServerCatalogSource
   */
  readonly microsoftSqlServerCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource;

  /**
   * Specifies a target that uses Microsoft SQL.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#microsoftSQLServerCatalogTarget
   */
  readonly microsoftSqlServerCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget;

  /**
   * Specifies a MySQL data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#mySQLCatalogSource
   */
  readonly mySqlCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource;

  /**
   * Specifies a target that uses MySQL.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#mySQLCatalogTarget
   */
  readonly mySqlCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget;

  /**
   * Specifies an Oracle data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#oracleSQLCatalogSource
   */
  readonly oracleSqlCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource;

  /**
   * Specifies a target that uses Oracle SQL.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#oracleSQLCatalogTarget
   */
  readonly oracleSqlCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget;

  /**
   * Specifies a transform that identifies, removes or masks PII data.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#pIIDetection
   */
  readonly pIiDetection?: JobSpecForProviderCodeGenConfigurationNodesPIiDetection;

  /**
   * Specifies a PostgresSQL data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#postgreSQLCatalogSource
   */
  readonly postgreSqlCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource;

  /**
   * Specifies a target that uses Postgres SQL.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#postgreSQLCatalogTarget
   */
  readonly postgreSqlCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget;

  /**
   * A Glue Studio node that uses a Glue DataBrew recipe in Glue jobs.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#recipe
   */
  readonly recipe?: JobSpecForProviderCodeGenConfigurationNodesRecipe;

  /**
   * Specifies an Amazon Redshift data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#redshiftSource
   */
  readonly redshiftSource?: JobSpecForProviderCodeGenConfigurationNodesRedshiftSource;

  /**
   * Specifies a target that uses Amazon Redshift.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#redshiftTarget
   */
  readonly redshiftTarget?: JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget;

  /**
   * Specifies a Relational database data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#relationalCatalogSource
   */
  readonly relationalCatalogSource?: JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource;

  /**
   * Specifies a transform that renames a single data property key.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#renameField
   */
  readonly renameField?: JobSpecForProviderCodeGenConfigurationNodesRenameField;

  /**
   * Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3CatalogDeltaSource
   */
  readonly s3CatalogDeltaSource?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource;

  /**
   * Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3CatalogHudiSource
   */
  readonly s3CatalogHudiSource?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource;

  /**
   * Specifies an Amazon S3 data store in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3CatalogSource
   */
  readonly s3CatalogSource?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource;

  /**
   * Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3CatalogTarget
   */
  readonly s3CatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget;

  /**
   * Specifies a command-separated value (CSV) data store stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3CsvSource
   */
  readonly s3CsvSource?: JobSpecForProviderCodeGenConfigurationNodesS3CsvSource;

  /**
   * Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3DeltaCatalogTarget
   */
  readonly s3DeltaCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget;

  /**
   * Specifies a target that writes to a Delta Lake data source in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3DeltaDirectTarget
   */
  readonly s3DeltaDirectTarget?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget;

  /**
   * Specifies a Delta Lake data source stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3DeltaSource
   */
  readonly s3DeltaSource?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource;

  /**
   * Specifies a data target that writes to Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3DirectTarget
   */
  readonly s3DirectTarget?: JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget;

  /**
   * Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3GlueParquetTarget
   */
  readonly s3GlueParquetTarget?: JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget;

  /**
   * Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3HudiCatalogTarget
   */
  readonly s3HudiCatalogTarget?: JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget;

  /**
   * Specifies a target that writes to a Hudi data source in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3HudiDirectTarget
   */
  readonly s3HudiDirectTarget?: JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget;

  /**
   * Specifies a Hudi data source stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3HudiSource
   */
  readonly s3HudiSource?: JobSpecForProviderCodeGenConfigurationNodesS3HudiSource;

  /**
   * Specifies a JSON data store stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3JSONSource
   */
  readonly s3JsonSource?: JobSpecForProviderCodeGenConfigurationNodesS3JsonSource;

  /**
   * Specifies an Apache Parquet data store stored in Amazon S3.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#s3ParquetSource
   */
  readonly s3ParquetSource?: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource;

  /**
   * Specifies a transform that chooses the data property keys that you want to keep.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#selectFields
   */
  readonly selectFields?: JobSpecForProviderCodeGenConfigurationNodesSelectFields;

  /**
   * Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames. The output is the selected DynamicFrame
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#selectFromCollection
   */
  readonly selectFromCollection?: JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection;

  /**
   * Specifies a Snowflake data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#snowflakeSource
   */
  readonly snowflakeSource?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource;

  /**
   * Specifies a Snowflake target.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#snowflakeTarget
   */
  readonly snowflakeTarget?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget;

  /**
   * Specifies a connector to an Apache Spark data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#sparkConnectorSource
   */
  readonly sparkConnectorSource?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource;

  /**
   * Specifies a target that uses an Apache Spark connector.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#sparkConnectorTarget
   */
  readonly sparkConnectorTarget?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget;

  /**
   * Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single DynamicFrame.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#sparkSQL
   */
  readonly sparkSql?: JobSpecForProviderCodeGenConfigurationNodesSparkSql;

  /**
   * Specifies a transform that writes samples of the data to an Amazon S3 bucket.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#spigot
   */
  readonly spigot?: JobSpecForProviderCodeGenConfigurationNodesSpigot;

  /**
   * Specifies a transform that splits data property keys into two DynamicFrames. The output is a collection of DynamicFrames: one with selected data property keys, and one with the remaining data property keys.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#splitFields
   */
  readonly splitFields?: JobSpecForProviderCodeGenConfigurationNodesSplitFields;

  /**
   * Specifies a transform that combines the rows from two or more datasets into a single result.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodes#union
   */
  readonly union?: JobSpecForProviderCodeGenConfigurationNodesUnion;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodes(obj: JobSpecForProviderCodeGenConfigurationNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregate': toJson_JobSpecForProviderCodeGenConfigurationNodesAggregate(obj.aggregate),
    'amazonRedshiftSource': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource(obj.amazonRedshiftSource),
    'amazonRedshiftTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget(obj.amazonRedshiftTarget),
    'applyMapping': toJson_JobSpecForProviderCodeGenConfigurationNodesApplyMapping(obj.applyMapping),
    'athenaConnectorSource': toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource(obj.athenaConnectorSource),
    'catalogDeltaSource': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource(obj.catalogDeltaSource),
    'catalogHudiSource': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource(obj.catalogHudiSource),
    'catalogKafkaSource': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource(obj.catalogKafkaSource),
    'catalogKinesisSource': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource(obj.catalogKinesisSource),
    'catalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogSource(obj.catalogSource),
    'catalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogTarget(obj.catalogTarget),
    'customCode': toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCode(obj.customCode),
    'directJDBCSource': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource(obj.directJdbcSource),
    'directKafkaSource': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource(obj.directKafkaSource),
    'directKinesisSource': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource(obj.directKinesisSource),
    'dropDuplicates': toJson_JobSpecForProviderCodeGenConfigurationNodesDropDuplicates(obj.dropDuplicates),
    'dropFields': toJson_JobSpecForProviderCodeGenConfigurationNodesDropFields(obj.dropFields),
    'dropNullFields': toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFields(obj.dropNullFields),
    'dynamicTransform': toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransform(obj.dynamicTransform),
    'dynamoDBCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource(obj.dynamoDbCatalogSource),
    'evaluateDataQuality': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality(obj.evaluateDataQuality),
    'evaluateDataQualityMultiFrame': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame(obj.evaluateDataQualityMultiFrame),
    'fillMissingValues': toJson_JobSpecForProviderCodeGenConfigurationNodesFillMissingValues(obj.fillMissingValues),
    'filter': toJson_JobSpecForProviderCodeGenConfigurationNodesFilter(obj.filter),
    'governedCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource(obj.governedCatalogSource),
    'governedCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget(obj.governedCatalogTarget),
    'jDBCConnectorSource': toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource(obj.jDbcConnectorSource),
    'jDBCConnectorTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget(obj.jDbcConnectorTarget),
    'join': toJson_JobSpecForProviderCodeGenConfigurationNodesJoin(obj.join),
    'merge': toJson_JobSpecForProviderCodeGenConfigurationNodesMerge(obj.merge),
    'microsoftSQLServerCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource(obj.microsoftSqlServerCatalogSource),
    'microsoftSQLServerCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget(obj.microsoftSqlServerCatalogTarget),
    'mySQLCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource(obj.mySqlCatalogSource),
    'mySQLCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget(obj.mySqlCatalogTarget),
    'oracleSQLCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource(obj.oracleSqlCatalogSource),
    'oracleSQLCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget(obj.oracleSqlCatalogTarget),
    'pIIDetection': toJson_JobSpecForProviderCodeGenConfigurationNodesPIiDetection(obj.pIiDetection),
    'postgreSQLCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource(obj.postgreSqlCatalogSource),
    'postgreSQLCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget(obj.postgreSqlCatalogTarget),
    'recipe': toJson_JobSpecForProviderCodeGenConfigurationNodesRecipe(obj.recipe),
    'redshiftSource': toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftSource(obj.redshiftSource),
    'redshiftTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget(obj.redshiftTarget),
    'relationalCatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource(obj.relationalCatalogSource),
    'renameField': toJson_JobSpecForProviderCodeGenConfigurationNodesRenameField(obj.renameField),
    's3CatalogDeltaSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource(obj.s3CatalogDeltaSource),
    's3CatalogHudiSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource(obj.s3CatalogHudiSource),
    's3CatalogSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource(obj.s3CatalogSource),
    's3CatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget(obj.s3CatalogTarget),
    's3CsvSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSource(obj.s3CsvSource),
    's3DeltaCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget(obj.s3DeltaCatalogTarget),
    's3DeltaDirectTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget(obj.s3DeltaDirectTarget),
    's3DeltaSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource(obj.s3DeltaSource),
    's3DirectTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget(obj.s3DirectTarget),
    's3GlueParquetTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget(obj.s3GlueParquetTarget),
    's3HudiCatalogTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget(obj.s3HudiCatalogTarget),
    's3HudiDirectTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget(obj.s3HudiDirectTarget),
    's3HudiSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSource(obj.s3HudiSource),
    's3JSONSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSource(obj.s3JsonSource),
    's3ParquetSource': toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource(obj.s3ParquetSource),
    'selectFields': toJson_JobSpecForProviderCodeGenConfigurationNodesSelectFields(obj.selectFields),
    'selectFromCollection': toJson_JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection(obj.selectFromCollection),
    'snowflakeSource': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource(obj.snowflakeSource),
    'snowflakeTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget(obj.snowflakeTarget),
    'sparkConnectorSource': toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource(obj.sparkConnectorSource),
    'sparkConnectorTarget': toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget(obj.sparkConnectorTarget),
    'sparkSQL': toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSql(obj.sparkSql),
    'spigot': toJson_JobSpecForProviderCodeGenConfigurationNodesSpigot(obj.spigot),
    'splitFields': toJson_JobSpecForProviderCodeGenConfigurationNodesSplitFields(obj.splitFields),
    'union': toJson_JobSpecForProviderCodeGenConfigurationNodesUnion(obj.union),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The JobCommand that runs this job.
 *
 * @schema JobSpecForProviderCommand
 */
export interface JobSpecForProviderCommand {
  /**
   * @schema JobSpecForProviderCommand#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCommand#pythonVersion
   */
  readonly pythonVersion?: string;

  /**
   * @schema JobSpecForProviderCommand#runtime
   */
  readonly runtime?: string;

  /**
   * @schema JobSpecForProviderCommand#scriptLocation
   */
  readonly scriptLocation?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCommand' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCommand(obj: JobSpecForProviderCommand | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'pythonVersion': obj.pythonVersion,
    'runtime': obj.runtime,
    'scriptLocation': obj.scriptLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema JobSpecForProviderConnectionRefs
 */
export interface JobSpecForProviderConnectionRefs {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderConnectionRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderConnectionRefs#policy
   */
  readonly policy?: JobSpecForProviderConnectionRefsPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderConnectionRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderConnectionRefs(obj: JobSpecForProviderConnectionRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderConnectionRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionsSelector selects references to Connections used to set the Connections.
 *
 * @schema JobSpecForProviderConnectionSelector
 */
export interface JobSpecForProviderConnectionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderConnectionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderConnectionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderConnectionSelector#policy
   */
  readonly policy?: JobSpecForProviderConnectionSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderConnectionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderConnectionSelector(obj: JobSpecForProviderConnectionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderConnectionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
 *
 * @schema JobSpecForProviderExecutionProperty
 */
export interface JobSpecForProviderExecutionProperty {
  /**
   * @schema JobSpecForProviderExecutionProperty#maxConcurrentRuns
   */
  readonly maxConcurrentRuns?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderExecutionProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExecutionProperty(obj: JobSpecForProviderExecutionProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentRuns': obj.maxConcurrentRuns,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies configuration properties of a job notification.
 *
 * @schema JobSpecForProviderNotificationProperty
 */
export interface JobSpecForProviderNotificationProperty {
  /**
   * @schema JobSpecForProviderNotificationProperty#notifyDelayAfter
   */
  readonly notifyDelayAfter?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderNotificationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderNotificationProperty(obj: JobSpecForProviderNotificationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notifyDelayAfter': obj.notifyDelayAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleRef is a reference to an IAMRole used to set the Role.
 *
 * @schema JobSpecForProviderRoleRef
 */
export interface JobSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderRoleRef#policy
   */
  readonly policy?: JobSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleRef(obj: JobSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects references to IAMRole used to set the Role.
 *
 * @schema JobSpecForProviderRoleSelector
 */
export interface JobSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderRoleSelector#policy
   */
  readonly policy?: JobSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleSelector(obj: JobSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityConfigurationRef is a reference to an SecurityConfiguration used to set the SecurityConfiguration.
 *
 * @schema JobSpecForProviderSecurityConfigurationRef
 */
export interface JobSpecForProviderSecurityConfigurationRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderSecurityConfigurationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderSecurityConfigurationRef#policy
   */
  readonly policy?: JobSpecForProviderSecurityConfigurationRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderSecurityConfigurationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderSecurityConfigurationRef(obj: JobSpecForProviderSecurityConfigurationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderSecurityConfigurationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityConfigurationSelector selects references to SecurityConfiguration used to set the SecurityConfiguration.
 *
 * @schema JobSpecForProviderSecurityConfigurationSelector
 */
export interface JobSpecForProviderSecurityConfigurationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderSecurityConfigurationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderSecurityConfigurationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderSecurityConfigurationSelector#policy
   */
  readonly policy?: JobSpecForProviderSecurityConfigurationSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderSecurityConfigurationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderSecurityConfigurationSelector(obj: JobSpecForProviderSecurityConfigurationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderSecurityConfigurationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
 *
 * @schema JobSpecForProviderSourceControlDetails
 */
export interface JobSpecForProviderSourceControlDetails {
  /**
   * @schema JobSpecForProviderSourceControlDetails#authStrategy
   */
  readonly authStrategy?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#authToken
   */
  readonly authToken?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#branch
   */
  readonly branch?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#folder
   */
  readonly folder?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#lastCommitID
   */
  readonly lastCommitId?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#owner
   */
  readonly owner?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#provider
   */
  readonly provider?: string;

  /**
   * @schema JobSpecForProviderSourceControlDetails#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderSourceControlDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderSourceControlDetails(obj: JobSpecForProviderSourceControlDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authStrategy': obj.authStrategy,
    'authToken': obj.authToken,
    'branch': obj.branch,
    'folder': obj.folder,
    'lastCommitID': obj.lastCommitId,
    'owner': obj.owner,
    'provider': obj.provider,
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecProviderConfigRefPolicy
 */
export interface JobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRefPolicy(obj: JobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRef
 */
export interface JobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRef(obj: JobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JobSpecPublishConnectionDetailsToMetadata
 */
export interface JobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToMetadata(obj: JobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAggregate
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAggregate {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregate#aggs
   */
  readonly aggs?: JobSpecForProviderCodeGenConfigurationNodesAggregateAggs[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregate#groups
   */
  readonly groups?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregate#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregate#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAggregate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAggregate(obj: JobSpecForProviderCodeGenConfigurationNodesAggregate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggs': obj.aggs?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAggregateAggs(y)),
    'groups': obj.groups?.map(y => y?.map(y => y)),
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon Redshift source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource {
  /**
   * Specifies an Amazon Redshift node.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource#data
   */
  readonly data?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData(obj.data),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon Redshift target.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget {
  /**
   * Specifies an Amazon Redshift node.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget#data
   */
  readonly data?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData(obj.data),
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMapping
 */
export interface JobSpecForProviderCodeGenConfigurationNodesApplyMapping {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMapping#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMapping#mapping
   */
  readonly mapping?: JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMapping#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesApplyMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesApplyMapping(obj: JobSpecForProviderCodeGenConfigurationNodesApplyMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'mapping': obj.mapping?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a connector to an Amazon Athena data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#connectionTable
   */
  readonly connectionTable?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#connectorName
   */
  readonly connectorName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource#schemaName
   */
  readonly schemaName?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource(obj: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionTable': obj.connectionTable,
    'connectionType': obj.connectionType,
    'connectorName': obj.connectorName,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas(y)),
    'schemaName': obj.schemaName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource#additionalDeltaOptions
   */
  readonly additionalDeltaOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalDeltaOptions': ((obj.additionalDeltaOptions) === undefined) ? undefined : (Object.entries(obj.additionalDeltaOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas(y)),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Hudi data source that is registered in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource#additionalHudiOptions
   */
  readonly additionalHudiOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalHudiOptions': ((obj.additionalHudiOptions) === undefined) ? undefined : (Object.entries(obj.additionalHudiOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas(y)),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Apache Kafka data store in the Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource {
  /**
   * Specifies options related to data preview for viewing a sample of your data.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#dataPreviewOptions
   */
  readonly dataPreviewOptions?: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#detectSchema
   */
  readonly detectSchema?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#name
   */
  readonly name?: string;

  /**
   * Additional options for streaming.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#streamingOptions
   */
  readonly streamingOptions?: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource#windowSize
   */
  readonly windowSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataPreviewOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions(obj.dataPreviewOptions),
    'database': obj.database,
    'detectSchema': obj.detectSchema,
    'name': obj.name,
    'streamingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions(obj.streamingOptions),
    'table': obj.table,
    'windowSize': obj.windowSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Kinesis data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource {
  /**
   * Specifies options related to data preview for viewing a sample of your data.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#dataPreviewOptions
   */
  readonly dataPreviewOptions?: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#detectSchema
   */
  readonly detectSchema?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#name
   */
  readonly name?: string;

  /**
   * Additional options for the Amazon Kinesis streaming data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#streamingOptions
   */
  readonly streamingOptions?: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource#windowSize
   */
  readonly windowSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataPreviewOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions(obj.dataPreviewOptions),
    'database': obj.database,
    'detectSchema': obj.detectSchema,
    'name': obj.name,
    'streamingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions(obj.streamingOptions),
    'table': obj.table,
    'windowSize': obj.windowSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data store in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses a Glue Data Catalog table.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCustomCode {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode#className
   */
  readonly className?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode#code
   */
  readonly code?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCode#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCustomCode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCode(obj: JobSpecForProviderCodeGenConfigurationNodesCustomCode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'className': obj.className,
    'code': obj.code,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the direct JDBC source connection.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#redshiftTmpDir
   */
  readonly redshiftTmpDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource(obj: JobSpecForProviderCodeGenConfigurationNodesDirectJdbcSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionType': obj.connectionType,
    'database': obj.database,
    'name': obj.name,
    'redshiftTmpDir': obj.redshiftTmpDir,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Apache Kafka data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource {
  /**
   * Specifies options related to data preview for viewing a sample of your data.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource#dataPreviewOptions
   */
  readonly dataPreviewOptions?: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource#detectSchema
   */
  readonly detectSchema?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource#name
   */
  readonly name?: string;

  /**
   * Additional options for streaming.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource#streamingOptions
   */
  readonly streamingOptions?: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource#windowSize
   */
  readonly windowSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataPreviewOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions(obj.dataPreviewOptions),
    'detectSchema': obj.detectSchema,
    'name': obj.name,
    'streamingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions(obj.streamingOptions),
    'windowSize': obj.windowSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a direct Amazon Kinesis data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource {
  /**
   * Specifies options related to data preview for viewing a sample of your data.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource#dataPreviewOptions
   */
  readonly dataPreviewOptions?: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource#detectSchema
   */
  readonly detectSchema?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource#name
   */
  readonly name?: string;

  /**
   * Additional options for the Amazon Kinesis streaming data source.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource#streamingOptions
   */
  readonly streamingOptions?: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource#windowSize
   */
  readonly windowSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataPreviewOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions(obj.dataPreviewOptions),
    'detectSchema': obj.detectSchema,
    'name': obj.name,
    'streamingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions(obj.streamingOptions),
    'windowSize': obj.windowSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that removes rows of repeating data from a data set.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropDuplicates
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropDuplicates {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropDuplicates#columns
   */
  readonly columns?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropDuplicates#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropDuplicates#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropDuplicates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropDuplicates(obj: JobSpecForProviderCodeGenConfigurationNodesDropDuplicates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => y?.map(y => y)),
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that chooses the data property keys that you want to drop.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropFields
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropFields {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropFields#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropFields#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropFields#paths
   */
  readonly paths?: string[][];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropFields(obj: JobSpecForProviderCodeGenConfigurationNodesDropFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'paths': obj.paths?.map(y => y?.map(y => y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFields
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropNullFields {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFields#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFields#name
   */
  readonly name?: string;

  /**
   * Represents whether certain values are recognized as null values for removal.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFields#nullCheckBoxList
   */
  readonly nullCheckBoxList?: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFields#nullTextList
   */
  readonly nullTextList?: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropNullFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFields(obj: JobSpecForProviderCodeGenConfigurationNodesDropNullFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'nullCheckBoxList': toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList(obj.nullCheckBoxList),
    'nullTextList': obj.nullTextList?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the set of parameters needed to perform the dynamic transform.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDynamicTransform {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#functionName
   */
  readonly functionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#parameters
   */
  readonly parameters?: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#path
   */
  readonly path?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#transformName
   */
  readonly transformName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransform#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDynamicTransform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransform(obj: JobSpecForProviderCodeGenConfigurationNodesDynamicTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionName': obj.functionName,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas(y)),
    'parameters': obj.parameters?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters(y)),
    'path': obj.path,
    'transformName': obj.transformName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a DynamoDB data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesDynamoDbCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies your data quality evaluation criteria.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#output
   */
  readonly output?: string;

  /**
   * Options to configure how your data quality evaluation results are published.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#publishingOptions
   */
  readonly publishingOptions?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#ruleset
   */
  readonly ruleset?: string;

  /**
   * Options to configure how your job will stop if your data quality evaluation fails.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality#stopJobOnFailureOptions
   */
  readonly stopJobOnFailureOptions?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQuality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'output': obj.output,
    'publishingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions(obj.publishingOptions),
    'ruleset': obj.ruleset,
    'stopJobOnFailureOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions(obj.stopJobOnFailureOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies your data quality evaluation criteria.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#additionalDataSources
   */
  readonly additionalDataSources?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#name
   */
  readonly name?: string;

  /**
   * Options to configure how your data quality evaluation results are published.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#publishingOptions
   */
  readonly publishingOptions?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#ruleset
   */
  readonly ruleset?: string;

  /**
   * Options to configure how your job will stop if your data quality evaluation fails.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame#stopJobOnFailureOptions
   */
  readonly stopJobOnFailureOptions?: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrame | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalDataSources': ((obj.additionalDataSources) === undefined) ? undefined : (Object.entries(obj.additionalDataSources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'publishingOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions(obj.publishingOptions),
    'ruleset': obj.ruleset,
    'stopJobOnFailureOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions(obj.stopJobOnFailureOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesFillMissingValues
 */
export interface JobSpecForProviderCodeGenConfigurationNodesFillMissingValues {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFillMissingValues#filledPath
   */
  readonly filledPath?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFillMissingValues#imputedPath
   */
  readonly imputedPath?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFillMissingValues#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFillMissingValues#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesFillMissingValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesFillMissingValues(obj: JobSpecForProviderCodeGenConfigurationNodesFillMissingValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filledPath': obj.filledPath,
    'imputedPath': obj.imputedPath,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that splits a dataset into two, based on a filter condition.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesFilter
 */
export interface JobSpecForProviderCodeGenConfigurationNodesFilter {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilter#filters
   */
  readonly filters?: JobSpecForProviderCodeGenConfigurationNodesFilterFilters[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilter#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilter#logicalOperator
   */
  readonly logicalOperator?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesFilter(obj: JobSpecForProviderCodeGenConfigurationNodesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filters': obj.filters?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesFilterFilters(y)),
    'inputs': obj.inputs?.map(y => y),
    'logicalOperator': obj.logicalOperator,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the data store in the governed Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource {
  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource#partitionPredicate
   */
  readonly partitionPredicate?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions(obj.additionalOptions),
    'database': obj.database,
    'name': obj.name,
    'partitionPredicate': obj.partitionPredicate,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy(obj.schemaChangePolicy),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a connector to a JDBC data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource {
  /**
   * Additional connection options for the connector.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#connectionTable
   */
  readonly connectionTable?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#connectorName
   */
  readonly connectorName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource#query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions(obj.additionalOptions),
    'connectionName': obj.connectionName,
    'connectionTable': obj.connectionTable,
    'connectionType': obj.connectionType,
    'connectorName': obj.connectorName,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas(y)),
    'query': obj.query,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#connectionTable
   */
  readonly connectionTable?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#connectorName
   */
  readonly connectorName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'connectionName': obj.connectionName,
    'connectionTable': obj.connectionTable,
    'connectionType': obj.connectionType,
    'connectorName': obj.connectorName,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesJoin
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJoin {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoin#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesJoinColumns[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoin#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoin#joinType
   */
  readonly joinType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoin#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJoin(obj: JobSpecForProviderCodeGenConfigurationNodesJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesJoinColumns(y)),
    'inputs': obj.inputs?.map(y => y),
    'joinType': obj.joinType,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesMerge
 */
export interface JobSpecForProviderCodeGenConfigurationNodesMerge {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMerge#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMerge#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMerge#primaryKeys
   */
  readonly primaryKeys?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMerge#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesMerge' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesMerge(obj: JobSpecForProviderCodeGenConfigurationNodesMerge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'primaryKeys': obj.primaryKeys?.map(y => y?.map(y => y)),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Microsoft SQL server data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses Microsoft SQL.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesMicrosoftSqlServerCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a MySQL data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses MySQL.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesMySqlCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Oracle data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses Oracle SQL.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesOracleSqlCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that identifies, removes or masks PII data.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesPIiDetection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#entityTypesToDetect
   */
  readonly entityTypesToDetect?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#maskValue
   */
  readonly maskValue?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#outputColumnName
   */
  readonly outputColumnName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#piiType
   */
  readonly piiType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#sampleFraction
   */
  readonly sampleFraction?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPIiDetection#thresholdFraction
   */
  readonly thresholdFraction?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesPIiDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesPIiDetection(obj: JobSpecForProviderCodeGenConfigurationNodesPIiDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityTypesToDetect': obj.entityTypesToDetect?.map(y => y),
    'inputs': obj.inputs?.map(y => y),
    'maskValue': obj.maskValue,
    'name': obj.name,
    'outputColumnName': obj.outputColumnName,
    'piiType': obj.piiType,
    'sampleFraction': obj.sampleFraction,
    'thresholdFraction': obj.thresholdFraction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a PostgresSQL data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses Postgres SQL.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesPostgreSqlCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Glue Studio node that uses a Glue DataBrew recipe in Glue jobs.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRecipe
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRecipe {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRecipe#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRecipe#name
   */
  readonly name?: string;

  /**
   * A reference to a Glue DataBrew recipe.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesRecipe#recipeReference
   */
  readonly recipeReference?: JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRecipe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRecipe(obj: JobSpecForProviderCodeGenConfigurationNodesRecipe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'recipeReference': toJson_JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference(obj.recipeReference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon Redshift data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRedshiftSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource#redshiftTmpDir
   */
  readonly redshiftTmpDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftSource#tmpDirIAMRole
   */
  readonly tmpDirIamRole?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRedshiftSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftSource(obj: JobSpecForProviderCodeGenConfigurationNodesRedshiftSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'redshiftTmpDir': obj.redshiftTmpDir,
    'table': obj.table,
    'tmpDirIAMRole': obj.tmpDirIamRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses Amazon Redshift.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#redshiftTmpDir
   */
  readonly redshiftTmpDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#tmpDirIAMRole
   */
  readonly tmpDirIamRole?: string;

  /**
   * The options to configure an upsert operation when writing to a Redshift target .
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget#upsertRedshiftOptions
   */
  readonly upsertRedshiftOptions?: JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget(obj: JobSpecForProviderCodeGenConfigurationNodesRedshiftTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'redshiftTmpDir': obj.redshiftTmpDir,
    'table': obj.table,
    'tmpDirIAMRole': obj.tmpDirIamRole,
    'upsertRedshiftOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions(obj.upsertRedshiftOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Relational database data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesRelationalCatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'name': obj.name,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that renames a single data property key.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRenameField
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRenameField {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRenameField#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRenameField#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRenameField#sourcePath
   */
  readonly sourcePath?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRenameField#targetPath
   */
  readonly targetPath?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRenameField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRenameField(obj: JobSpecForProviderCodeGenConfigurationNodesRenameField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'sourcePath': obj.sourcePath?.map(y => y),
    'targetPath': obj.targetPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource#additionalDeltaOptions
   */
  readonly additionalDeltaOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalDeltaOptions': ((obj.additionalDeltaOptions) === undefined) ? undefined : (Object.entries(obj.additionalDeltaOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas(y)),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource#additionalHudiOptions
   */
  readonly additionalHudiOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalHudiOptions': ((obj.additionalHudiOptions) === undefined) ? undefined : (Object.entries(obj.additionalHudiOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas(y)),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon S3 data store in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource {
  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource#partitionPredicate
   */
  readonly partitionPredicate?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions(obj.additionalOptions),
    'database': obj.database,
    'name': obj.name,
    'partitionPredicate': obj.partitionPredicate,
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy(obj.schemaChangePolicy),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a command-separated value (CSV) data store stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CsvSource {
  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#compressionType
   */
  readonly compressionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#escaper
   */
  readonly escaper?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#exclusions
   */
  readonly exclusions?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#groupFiles
   */
  readonly groupFiles?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#groupSize
   */
  readonly groupSize?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#maxBand
   */
  readonly maxBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#maxFilesInBand
   */
  readonly maxFilesInBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#multiline
   */
  readonly multiline?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#optimizePerformance
   */
  readonly optimizePerformance?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#paths
   */
  readonly paths?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#quoteChar
   */
  readonly quoteChar?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#recurse
   */
  readonly recurse?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#separator
   */
  readonly separator?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#skipFirst
   */
  readonly skipFirst?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#withHeader
   */
  readonly withHeader?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSource#writeHeader
   */
  readonly writeHeader?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CsvSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3CsvSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions(obj.additionalOptions),
    'compressionType': obj.compressionType,
    'escaper': obj.escaper,
    'exclusions': obj.exclusions?.map(y => y),
    'groupFiles': obj.groupFiles,
    'groupSize': obj.groupSize,
    'maxBand': obj.maxBand,
    'maxFilesInBand': obj.maxFilesInBand,
    'multiline': obj.multiline,
    'name': obj.name,
    'optimizePerformance': obj.optimizePerformance,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas(y)),
    'paths': obj.paths?.map(y => y),
    'quoteChar': obj.quoteChar,
    'recurse': obj.recurse,
    'separator': obj.separator,
    'skipFirst': obj.skipFirst,
    'withHeader': obj.withHeader,
    'writeHeader': obj.writeHeader,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy(obj.schemaChangePolicy),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that writes to a Delta Lake data source in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#compression
   */
  readonly compression?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#format
   */
  readonly format?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#path
   */
  readonly path?: string;

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'compression': obj.compression,
    'format': obj.format,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'path': obj.path,
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy(obj.schemaChangePolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Delta Lake data source stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource#additionalDeltaOptions
   */
  readonly additionalDeltaOptions?: { [key: string]: string };

  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource#paths
   */
  readonly paths?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalDeltaOptions': ((obj.additionalDeltaOptions) === undefined) ? undefined : (Object.entries(obj.additionalDeltaOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions(obj.additionalOptions),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas(y)),
    'paths': obj.paths?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data target that writes to Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#compression
   */
  readonly compression?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#format
   */
  readonly format?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#path
   */
  readonly path?: string;

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3DirectTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': obj.compression,
    'format': obj.format,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'path': obj.path,
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy(obj.schemaChangePolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#compression
   */
  readonly compression?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#path
   */
  readonly path?: string;

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': obj.compression,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'path': obj.path,
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy(obj.schemaChangePolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget#table
   */
  readonly table?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'database': obj.database,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy(obj.schemaChangePolicy),
    'table': obj.table,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that writes to a Hudi data source in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#compression
   */
  readonly compression?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#format
   */
  readonly format?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#partitionKeys
   */
  readonly partitionKeys?: string[][];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#path
   */
  readonly path?: string;

  /**
   * A policy that specifies update behavior for the crawler.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget#schemaChangePolicy
   */
  readonly schemaChangePolicy?: JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'compression': obj.compression,
    'format': obj.format,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'partitionKeys': obj.partitionKeys?.map(y => y?.map(y => y)),
    'path': obj.path,
    'schemaChangePolicy': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy(obj.schemaChangePolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Hudi data source stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource#additionalHudiOptions
   */
  readonly additionalHudiOptions?: { [key: string]: string };

  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSource#paths
   */
  readonly paths?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalHudiOptions': ((obj.additionalHudiOptions) === undefined) ? undefined : (Object.entries(obj.additionalHudiOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions(obj.additionalOptions),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas(y)),
    'paths': obj.paths?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a JSON data store stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3JsonSource {
  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#compressionType
   */
  readonly compressionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#exclusions
   */
  readonly exclusions?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#groupFiles
   */
  readonly groupFiles?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#groupSize
   */
  readonly groupSize?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#jsonPath
   */
  readonly jsonPath?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#maxBand
   */
  readonly maxBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#maxFilesInBand
   */
  readonly maxFilesInBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#multiline
   */
  readonly multiline?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#paths
   */
  readonly paths?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSource#recurse
   */
  readonly recurse?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3JsonSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3JsonSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions(obj.additionalOptions),
    'compressionType': obj.compressionType,
    'exclusions': obj.exclusions?.map(y => y),
    'groupFiles': obj.groupFiles,
    'groupSize': obj.groupSize,
    'jsonPath': obj.jsonPath,
    'maxBand': obj.maxBand,
    'maxFilesInBand': obj.maxFilesInBand,
    'multiline': obj.multiline,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas(y)),
    'paths': obj.paths?.map(y => y),
    'recurse': obj.recurse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Apache Parquet data store stored in Amazon S3.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource {
  /**
   * Specifies additional connection options for the Amazon S3 data store.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#additionalOptions
   */
  readonly additionalOptions?: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#compressionType
   */
  readonly compressionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#exclusions
   */
  readonly exclusions?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#groupFiles
   */
  readonly groupFiles?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#groupSize
   */
  readonly groupSize?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#maxBand
   */
  readonly maxBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#maxFilesInBand
   */
  readonly maxFilesInBand?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#paths
   */
  readonly paths?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource#recurse
   */
  readonly recurse?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource(obj: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions(obj.additionalOptions),
    'compressionType': obj.compressionType,
    'exclusions': obj.exclusions?.map(y => y),
    'groupFiles': obj.groupFiles,
    'groupSize': obj.groupSize,
    'maxBand': obj.maxBand,
    'maxFilesInBand': obj.maxFilesInBand,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas(y)),
    'paths': obj.paths?.map(y => y),
    'recurse': obj.recurse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that chooses the data property keys that you want to keep.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFields
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSelectFields {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFields#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFields#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFields#paths
   */
  readonly paths?: string[][];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSelectFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSelectFields(obj: JobSpecForProviderCodeGenConfigurationNodesSelectFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'paths': obj.paths?.map(y => y?.map(y => y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames. The output is the selected DynamicFrame
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection#index
   */
  readonly index?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection(obj: JobSpecForProviderCodeGenConfigurationNodesSelectFromCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'index': obj.index,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Snowflake data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource {
  /**
   * Specifies configuration for Snowflake nodes in Glue Studio.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource#data
   */
  readonly data?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData(obj.data),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a Snowflake target.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget {
  /**
   * Specifies configuration for Snowflake nodes in Glue Studio.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget#data
   */
  readonly data?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData(obj.data),
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a connector to an Apache Spark data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#connectorName
   */
  readonly connectorName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'connectionName': obj.connectionName,
    'connectionType': obj.connectionType,
    'connectorName': obj.connectorName,
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a target that uses an Apache Spark connector.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#connectorName
   */
  readonly connectorName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'connectionName': obj.connectionName,
    'connectionType': obj.connectionType,
    'connectorName': obj.connectorName,
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single DynamicFrame.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkSql {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql#outputSchemas
   */
  readonly outputSchemas?: JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql#sqlAliases
   */
  readonly sqlAliases?: JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSql#sqlQuery
   */
  readonly sqlQuery?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkSql' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSql(obj: JobSpecForProviderCodeGenConfigurationNodesSparkSql | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'outputSchemas': obj.outputSchemas?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas(y)),
    'sqlAliases': obj.sqlAliases?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases(y)),
    'sqlQuery': obj.sqlQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that writes samples of the data to an Amazon S3 bucket.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSpigot {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot#path
   */
  readonly path?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot#prob
   */
  readonly prob?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSpigot#topk
   */
  readonly topk?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSpigot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSpigot(obj: JobSpecForProviderCodeGenConfigurationNodesSpigot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'path': obj.path,
    'prob': obj.prob,
    'topk': obj.topk,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that splits data property keys into two DynamicFrames. The output is a collection of DynamicFrames: one with selected data property keys, and one with the remaining data property keys.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSplitFields
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSplitFields {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSplitFields#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSplitFields#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSplitFields#paths
   */
  readonly paths?: string[][];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSplitFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSplitFields(obj: JobSpecForProviderCodeGenConfigurationNodesSplitFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'paths': obj.paths?.map(y => y?.map(y => y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a transform that combines the rows from two or more datasets into a single result.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesUnion
 */
export interface JobSpecForProviderCodeGenConfigurationNodesUnion {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesUnion#inputs
   */
  readonly inputs?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesUnion#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesUnion#unionType
   */
  readonly unionType?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesUnion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesUnion(obj: JobSpecForProviderCodeGenConfigurationNodesUnion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputs': obj.inputs?.map(y => y),
    'name': obj.name,
    'unionType': obj.unionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderConnectionRefsPolicy
 */
export interface JobSpecForProviderConnectionRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderConnectionRefsPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderConnectionRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderConnectionRefsPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderConnectionRefsPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderConnectionRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderConnectionRefsPolicy(obj: JobSpecForProviderConnectionRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderConnectionSelectorPolicy
 */
export interface JobSpecForProviderConnectionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderConnectionSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderConnectionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderConnectionSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderConnectionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderConnectionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderConnectionSelectorPolicy(obj: JobSpecForProviderConnectionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderRoleRefPolicy
 */
export interface JobSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleRefPolicy(obj: JobSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderRoleSelectorPolicy
 */
export interface JobSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleSelectorPolicy(obj: JobSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderSecurityConfigurationRefPolicy
 */
export interface JobSpecForProviderSecurityConfigurationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderSecurityConfigurationRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderSecurityConfigurationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderSecurityConfigurationRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderSecurityConfigurationRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderSecurityConfigurationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderSecurityConfigurationRefPolicy(obj: JobSpecForProviderSecurityConfigurationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderSecurityConfigurationSelectorPolicy
 */
export interface JobSpecForProviderSecurityConfigurationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderSecurityConfigurationSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderSecurityConfigurationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderSecurityConfigurationSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderSecurityConfigurationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderSecurityConfigurationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderSecurityConfigurationSelectorPolicy(obj: JobSpecForProviderSecurityConfigurationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecProviderConfigRefPolicyResolution
 */
export enum JobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecProviderConfigRefPolicyResolve
 */
export enum JobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj: JobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAggregateAggs
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAggregateAggs {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregateAggs#aggFunc
   */
  readonly aggFunc?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAggregateAggs#column
   */
  readonly column?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAggregateAggs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAggregateAggs(obj: JobSpecForProviderCodeGenConfigurationNodesAggregateAggs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggFunc': obj.aggFunc,
    'column': obj.column?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon Redshift node.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#accessType
   */
  readonly accessType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#action
   */
  readonly action?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#advancedOptions
   */
  readonly advancedOptions?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions[];

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#catalogDatabase
   */
  readonly catalogDatabase?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#catalogRedshiftSchema
   */
  readonly catalogRedshiftSchema?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#catalogRedshiftTable
   */
  readonly catalogRedshiftTable?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#catalogTable
   */
  readonly catalogTable?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#connection
   */
  readonly connection?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#crawlerConnection
   */
  readonly crawlerConnection?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#iamRole
   */
  readonly iamRole?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#mergeAction
   */
  readonly mergeAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#mergeClause
   */
  readonly mergeClause?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#mergeWhenMatched
   */
  readonly mergeWhenMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#mergeWhenNotMatched
   */
  readonly mergeWhenNotMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#postAction
   */
  readonly postAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#preAction
   */
  readonly preAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#sampleQuery
   */
  readonly sampleQuery?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#schema
   */
  readonly schema?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#selectedColumns
   */
  readonly selectedColumns?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#sourceType
   */
  readonly sourceType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#stagingTable
   */
  readonly stagingTable?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#table
   */
  readonly table?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#tablePrefix
   */
  readonly tablePrefix?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#tableSchema
   */
  readonly tableSchema?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#tempDir
   */
  readonly tempDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData#upsert
   */
  readonly upsert?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessType': obj.accessType,
    'action': obj.action,
    'advancedOptions': obj.advancedOptions?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions(y)),
    'catalogDatabase': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase(obj.catalogDatabase),
    'catalogRedshiftSchema': obj.catalogRedshiftSchema,
    'catalogRedshiftTable': obj.catalogRedshiftTable,
    'catalogTable': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable(obj.catalogTable),
    'connection': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection(obj.connection),
    'crawlerConnection': obj.crawlerConnection,
    'iamRole': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole(obj.iamRole),
    'mergeAction': obj.mergeAction,
    'mergeClause': obj.mergeClause,
    'mergeWhenMatched': obj.mergeWhenMatched,
    'mergeWhenNotMatched': obj.mergeWhenNotMatched,
    'postAction': obj.postAction,
    'preAction': obj.preAction,
    'sampleQuery': obj.sampleQuery,
    'schema': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema(obj.schema),
    'selectedColumns': obj.selectedColumns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns(y)),
    'sourceType': obj.sourceType,
    'stagingTable': obj.stagingTable,
    'table': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable(obj.table),
    'tablePrefix': obj.tablePrefix,
    'tableSchema': obj.tableSchema?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema(y)),
    'tempDir': obj.tempDir,
    'upsert': obj.upsert,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an Amazon Redshift node.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#accessType
   */
  readonly accessType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#action
   */
  readonly action?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#advancedOptions
   */
  readonly advancedOptions?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions[];

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#catalogDatabase
   */
  readonly catalogDatabase?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#catalogRedshiftSchema
   */
  readonly catalogRedshiftSchema?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#catalogRedshiftTable
   */
  readonly catalogRedshiftTable?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#catalogTable
   */
  readonly catalogTable?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#connection
   */
  readonly connection?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#crawlerConnection
   */
  readonly crawlerConnection?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#iamRole
   */
  readonly iamRole?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#mergeAction
   */
  readonly mergeAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#mergeClause
   */
  readonly mergeClause?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#mergeWhenMatched
   */
  readonly mergeWhenMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#mergeWhenNotMatched
   */
  readonly mergeWhenNotMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#postAction
   */
  readonly postAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#preAction
   */
  readonly preAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#sampleQuery
   */
  readonly sampleQuery?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#schema
   */
  readonly schema?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#selectedColumns
   */
  readonly selectedColumns?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#sourceType
   */
  readonly sourceType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#stagingTable
   */
  readonly stagingTable?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#table
   */
  readonly table?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#tablePrefix
   */
  readonly tablePrefix?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#tableSchema
   */
  readonly tableSchema?: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#tempDir
   */
  readonly tempDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData#upsert
   */
  readonly upsert?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessType': obj.accessType,
    'action': obj.action,
    'advancedOptions': obj.advancedOptions?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions(y)),
    'catalogDatabase': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase(obj.catalogDatabase),
    'catalogRedshiftSchema': obj.catalogRedshiftSchema,
    'catalogRedshiftTable': obj.catalogRedshiftTable,
    'catalogTable': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable(obj.catalogTable),
    'connection': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection(obj.connection),
    'crawlerConnection': obj.crawlerConnection,
    'iamRole': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole(obj.iamRole),
    'mergeAction': obj.mergeAction,
    'mergeClause': obj.mergeClause,
    'mergeWhenMatched': obj.mergeWhenMatched,
    'mergeWhenNotMatched': obj.mergeWhenNotMatched,
    'postAction': obj.postAction,
    'preAction': obj.preAction,
    'sampleQuery': obj.sampleQuery,
    'schema': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema(obj.schema),
    'selectedColumns': obj.selectedColumns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns(y)),
    'sourceType': obj.sourceType,
    'stagingTable': obj.stagingTable,
    'table': toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable(obj.table),
    'tablePrefix': obj.tablePrefix,
    'tableSchema': obj.tableSchema?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema(y)),
    'tempDir': obj.tempDir,
    'upsert': obj.upsert,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping
 */
export interface JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping#dropped
   */
  readonly dropped?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping#fromPath
   */
  readonly fromPath?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping#fromType
   */
  readonly fromType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping#toKey
   */
  readonly toKey?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping#toType
   */
  readonly toType?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping(obj: JobSpecForProviderCodeGenConfigurationNodesApplyMappingMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dropped': obj.dropped,
    'fromPath': obj.fromPath?.map(y => y),
    'fromType': obj.fromType,
    'toKey': obj.toKey,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies options related to data preview for viewing a sample of your data.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions#pollingTime
   */
  readonly pollingTime?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions#recordPollingLimit
   */
  readonly recordPollingLimit?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceDataPreviewOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pollingTime': obj.pollingTime,
    'recordPollingLimit': obj.recordPollingLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional options for streaming.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#addRecordTimestamp
   */
  readonly addRecordTimestamp?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#assign
   */
  readonly assign?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#bootstrapServers
   */
  readonly bootstrapServers?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#classification
   */
  readonly classification?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#emitConsumerLagMetrics
   */
  readonly emitConsumerLagMetrics?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#endingOffsets
   */
  readonly endingOffsets?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#includeHeaders
   */
  readonly includeHeaders?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#maxOffsetsPerTrigger
   */
  readonly maxOffsetsPerTrigger?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#minPartitions
   */
  readonly minPartitions?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#numRetries
   */
  readonly numRetries?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#pollTimeoutMs
   */
  readonly pollTimeoutMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#retryIntervalMs
   */
  readonly retryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#securityProtocol
   */
  readonly securityProtocol?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#startingOffsets
   */
  readonly startingOffsets?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#startingTimestamp
   */
  readonly startingTimestamp?: Date;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#subscribePattern
   */
  readonly subscribePattern?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions#topicName
   */
  readonly topicName?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKafkaSourceStreamingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addRecordTimestamp': obj.addRecordTimestamp,
    'assign': obj.assign,
    'bootstrapServers': obj.bootstrapServers,
    'classification': obj.classification,
    'connectionName': obj.connectionName,
    'delimiter': obj.delimiter,
    'emitConsumerLagMetrics': obj.emitConsumerLagMetrics,
    'endingOffsets': obj.endingOffsets,
    'includeHeaders': obj.includeHeaders,
    'maxOffsetsPerTrigger': obj.maxOffsetsPerTrigger,
    'minPartitions': obj.minPartitions,
    'numRetries': obj.numRetries,
    'pollTimeoutMs': obj.pollTimeoutMs,
    'retryIntervalMs': obj.retryIntervalMs,
    'securityProtocol': obj.securityProtocol,
    'startingOffsets': obj.startingOffsets,
    'startingTimestamp': obj.startingTimestamp?.toISOString(),
    'subscribePattern': obj.subscribePattern,
    'topicName': obj.topicName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies options related to data preview for viewing a sample of your data.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions#pollingTime
   */
  readonly pollingTime?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions#recordPollingLimit
   */
  readonly recordPollingLimit?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceDataPreviewOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pollingTime': obj.pollingTime,
    'recordPollingLimit': obj.recordPollingLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional options for the Amazon Kinesis streaming data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#addIdleTimeBetweenReads
   */
  readonly addIdleTimeBetweenReads?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#addRecordTimestamp
   */
  readonly addRecordTimestamp?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#avoidEmptyBatches
   */
  readonly avoidEmptyBatches?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#classification
   */
  readonly classification?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#describeShardInterval
   */
  readonly describeShardInterval?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#emitConsumerLagMetrics
   */
  readonly emitConsumerLagMetrics?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#idleTimeBetweenReadsInMs
   */
  readonly idleTimeBetweenReadsInMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#maxFetchRecordsPerShard
   */
  readonly maxFetchRecordsPerShard?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#maxFetchTimeInMs
   */
  readonly maxFetchTimeInMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#maxRecordPerRead
   */
  readonly maxRecordPerRead?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#maxRetryIntervalMs
   */
  readonly maxRetryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#numRetries
   */
  readonly numRetries?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#retryIntervalMs
   */
  readonly retryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#roleARN
   */
  readonly roleArn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#roleSessionName
   */
  readonly roleSessionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#startingPosition
   */
  readonly startingPosition?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#startingTimestamp
   */
  readonly startingTimestamp?: Date;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#streamARN
   */
  readonly streamArn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogKinesisSourceStreamingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addIdleTimeBetweenReads': obj.addIdleTimeBetweenReads,
    'addRecordTimestamp': obj.addRecordTimestamp,
    'avoidEmptyBatches': obj.avoidEmptyBatches,
    'classification': obj.classification,
    'delimiter': obj.delimiter,
    'describeShardInterval': obj.describeShardInterval,
    'emitConsumerLagMetrics': obj.emitConsumerLagMetrics,
    'endpointURL': obj.endpointUrl,
    'idleTimeBetweenReadsInMs': obj.idleTimeBetweenReadsInMs,
    'maxFetchRecordsPerShard': obj.maxFetchRecordsPerShard,
    'maxFetchTimeInMs': obj.maxFetchTimeInMs,
    'maxRecordPerRead': obj.maxRecordPerRead,
    'maxRetryIntervalMs': obj.maxRetryIntervalMs,
    'numRetries': obj.numRetries,
    'retryIntervalMs': obj.retryIntervalMs,
    'roleARN': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
    'startingPosition': obj.startingPosition,
    'startingTimestamp': obj.startingTimestamp?.toISOString(),
    'streamARN': obj.streamArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies options related to data preview for viewing a sample of your data.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions#pollingTime
   */
  readonly pollingTime?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions#recordPollingLimit
   */
  readonly recordPollingLimit?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceDataPreviewOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pollingTime': obj.pollingTime,
    'recordPollingLimit': obj.recordPollingLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional options for streaming.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#addRecordTimestamp
   */
  readonly addRecordTimestamp?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#assign
   */
  readonly assign?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#bootstrapServers
   */
  readonly bootstrapServers?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#classification
   */
  readonly classification?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#emitConsumerLagMetrics
   */
  readonly emitConsumerLagMetrics?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#endingOffsets
   */
  readonly endingOffsets?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#includeHeaders
   */
  readonly includeHeaders?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#maxOffsetsPerTrigger
   */
  readonly maxOffsetsPerTrigger?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#minPartitions
   */
  readonly minPartitions?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#numRetries
   */
  readonly numRetries?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#pollTimeoutMs
   */
  readonly pollTimeoutMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#retryIntervalMs
   */
  readonly retryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#securityProtocol
   */
  readonly securityProtocol?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#startingOffsets
   */
  readonly startingOffsets?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#startingTimestamp
   */
  readonly startingTimestamp?: Date;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#subscribePattern
   */
  readonly subscribePattern?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions#topicName
   */
  readonly topicName?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKafkaSourceStreamingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addRecordTimestamp': obj.addRecordTimestamp,
    'assign': obj.assign,
    'bootstrapServers': obj.bootstrapServers,
    'classification': obj.classification,
    'connectionName': obj.connectionName,
    'delimiter': obj.delimiter,
    'emitConsumerLagMetrics': obj.emitConsumerLagMetrics,
    'endingOffsets': obj.endingOffsets,
    'includeHeaders': obj.includeHeaders,
    'maxOffsetsPerTrigger': obj.maxOffsetsPerTrigger,
    'minPartitions': obj.minPartitions,
    'numRetries': obj.numRetries,
    'pollTimeoutMs': obj.pollTimeoutMs,
    'retryIntervalMs': obj.retryIntervalMs,
    'securityProtocol': obj.securityProtocol,
    'startingOffsets': obj.startingOffsets,
    'startingTimestamp': obj.startingTimestamp?.toISOString(),
    'subscribePattern': obj.subscribePattern,
    'topicName': obj.topicName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies options related to data preview for viewing a sample of your data.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions#pollingTime
   */
  readonly pollingTime?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions#recordPollingLimit
   */
  readonly recordPollingLimit?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceDataPreviewOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pollingTime': obj.pollingTime,
    'recordPollingLimit': obj.recordPollingLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional options for the Amazon Kinesis streaming data source.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#addIdleTimeBetweenReads
   */
  readonly addIdleTimeBetweenReads?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#addRecordTimestamp
   */
  readonly addRecordTimestamp?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#avoidEmptyBatches
   */
  readonly avoidEmptyBatches?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#classification
   */
  readonly classification?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#describeShardInterval
   */
  readonly describeShardInterval?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#emitConsumerLagMetrics
   */
  readonly emitConsumerLagMetrics?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#idleTimeBetweenReadsInMs
   */
  readonly idleTimeBetweenReadsInMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#maxFetchRecordsPerShard
   */
  readonly maxFetchRecordsPerShard?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#maxFetchTimeInMs
   */
  readonly maxFetchTimeInMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#maxRecordPerRead
   */
  readonly maxRecordPerRead?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#maxRetryIntervalMs
   */
  readonly maxRetryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#numRetries
   */
  readonly numRetries?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#retryIntervalMs
   */
  readonly retryIntervalMs?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#roleARN
   */
  readonly roleArn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#roleSessionName
   */
  readonly roleSessionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#startingPosition
   */
  readonly startingPosition?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#startingTimestamp
   */
  readonly startingTimestamp?: Date;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#streamARN
   */
  readonly streamArn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesDirectKinesisSourceStreamingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addIdleTimeBetweenReads': obj.addIdleTimeBetweenReads,
    'addRecordTimestamp': obj.addRecordTimestamp,
    'avoidEmptyBatches': obj.avoidEmptyBatches,
    'classification': obj.classification,
    'delimiter': obj.delimiter,
    'describeShardInterval': obj.describeShardInterval,
    'emitConsumerLagMetrics': obj.emitConsumerLagMetrics,
    'endpointURL': obj.endpointUrl,
    'idleTimeBetweenReadsInMs': obj.idleTimeBetweenReadsInMs,
    'maxFetchRecordsPerShard': obj.maxFetchRecordsPerShard,
    'maxFetchTimeInMs': obj.maxFetchTimeInMs,
    'maxRecordPerRead': obj.maxRecordPerRead,
    'maxRetryIntervalMs': obj.maxRetryIntervalMs,
    'numRetries': obj.numRetries,
    'retryIntervalMs': obj.retryIntervalMs,
    'roleARN': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
    'startingPosition': obj.startingPosition,
    'startingTimestamp': obj.startingTimestamp?.toISOString(),
    'streamARN': obj.streamArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents whether certain values are recognized as null values for removal.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList#isEmpty
   */
  readonly isEmpty?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList#isNegOne
   */
  readonly isNegOne?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList#isNullString
   */
  readonly isNullString?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList(obj: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullCheckBoxList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isEmpty': obj.isEmpty,
    'isNegOne': obj.isNegOne,
    'isNullString': obj.isNullString,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList {
  /**
   * A structure representing the datatype of the value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList#datatype
   */
  readonly datatype?: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList(obj: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datatype': toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype(obj.datatype),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#isOptional
   */
  readonly isOptional?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#listType
   */
  readonly listType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#type_
   */
  readonly type?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#validationMessage
   */
  readonly validationMessage?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#validationRule
   */
  readonly validationRule?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters#value
   */
  readonly value?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters(obj: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isOptional': obj.isOptional,
    'listType': obj.listType,
    'name': obj.name,
    'type_': obj.type,
    'validationMessage': obj.validationMessage,
    'validationRule': obj.validationRule,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to configure how your data quality evaluation results are published.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions#cloudWatchMetricsEnabled
   */
  readonly cloudWatchMetricsEnabled?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions#evaluationContext
   */
  readonly evaluationContext?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions#resultsPublishingEnabled
   */
  readonly resultsPublishingEnabled?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions#resultsS3Prefix
   */
  readonly resultsS3Prefix?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchMetricsEnabled': obj.cloudWatchMetricsEnabled,
    'evaluationContext': obj.evaluationContext,
    'resultsPublishingEnabled': obj.resultsPublishingEnabled,
    'resultsS3Prefix': obj.resultsS3Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to configure how your job will stop if your data quality evaluation fails.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions#stopJobOnFailureTiming
   */
  readonly stopJobOnFailureTiming?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityStopJobOnFailureOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stopJobOnFailureTiming': obj.stopJobOnFailureTiming,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to configure how your data quality evaluation results are published.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions#cloudWatchMetricsEnabled
   */
  readonly cloudWatchMetricsEnabled?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions#evaluationContext
   */
  readonly evaluationContext?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions#resultsPublishingEnabled
   */
  readonly resultsPublishingEnabled?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions#resultsS3Prefix
   */
  readonly resultsS3Prefix?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFramePublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchMetricsEnabled': obj.cloudWatchMetricsEnabled,
    'evaluationContext': obj.evaluationContext,
    'resultsPublishingEnabled': obj.resultsPublishingEnabled,
    'resultsS3Prefix': obj.resultsS3Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to configure how your job will stop if your data quality evaluation fails.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions#stopJobOnFailureTiming
   */
  readonly stopJobOnFailureTiming?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions(obj: JobSpecForProviderCodeGenConfigurationNodesEvaluateDataQualityMultiFrameStopJobOnFailureOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stopJobOnFailureTiming': obj.stopJobOnFailureTiming,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFilters
 */
export interface JobSpecForProviderCodeGenConfigurationNodesFilterFilters {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFilters#negated
   */
  readonly negated?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFilters#operation
   */
  readonly operation?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFilters#values
   */
  readonly values?: JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesFilterFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesFilterFilters(obj: JobSpecForProviderCodeGenConfigurationNodesFilterFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'negated': obj.negated,
    'operation': obj.operation,
    'values': obj.values?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesGovernedCatalogTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional connection options for the connector.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#dataTypeMapping
   */
  readonly dataTypeMapping?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#filterPredicate
   */
  readonly filterPredicate?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#jobBookmarkKeys
   */
  readonly jobBookmarkKeys?: string[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#jobBookmarkKeysSortOrder
   */
  readonly jobBookmarkKeysSortOrder?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#lowerBound
   */
  readonly lowerBound?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#numPartitions
   */
  readonly numPartitions?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#partitionColumn
   */
  readonly partitionColumn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions#upperBound
   */
  readonly upperBound?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataTypeMapping': ((obj.dataTypeMapping) === undefined) ? undefined : (Object.entries(obj.dataTypeMapping).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'filterPredicate': obj.filterPredicate,
    'jobBookmarkKeys': obj.jobBookmarkKeys?.map(y => y),
    'jobBookmarkKeysSortOrder': obj.jobBookmarkKeysSortOrder,
    'lowerBound': obj.lowerBound,
    'numPartitions': obj.numPartitions,
    'partitionColumn': obj.partitionColumn,
    'upperBound': obj.upperBound,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesJoinColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJoinColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoinColumns#from
   */
  readonly from?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJoinColumns#keys
   */
  readonly keys?: string[][];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJoinColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJoinColumns(obj: JobSpecForProviderCodeGenConfigurationNodesJoinColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'keys': obj.keys?.map(y => y?.map(y => y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a Glue DataBrew recipe.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference#recipeARN
   */
  readonly recipeArn?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference#recipeVersion
   */
  readonly recipeVersion?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference(obj: JobSpecForProviderCodeGenConfigurationNodesRecipeRecipeReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recipeARN': obj.recipeArn,
    'recipeVersion': obj.recipeVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The options to configure an upsert operation when writing to a Redshift target .
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions#connectionName
   */
  readonly connectionName?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions#tableLocation
   */
  readonly tableLocation?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions#upsertKeys
   */
  readonly upsertKeys?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions(obj: JobSpecForProviderCodeGenConfigurationNodesRedshiftTargetUpsertRedshiftOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'tableLocation': obj.tableLocation,
    'upsertKeys': obj.upsertKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions#enableSamplePath
   */
  readonly enableSamplePath?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions#samplePath
   */
  readonly samplePath?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
    'enableSamplePath': obj.enableSamplePath,
    'samplePath': obj.samplePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaCatalogTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaDirectTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'table': obj.table,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions#enableSamplePath
   */
  readonly enableSamplePath?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions#samplePath
   */
  readonly samplePath?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
    'enableSamplePath': obj.enableSamplePath,
    'samplePath': obj.samplePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3DirectTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'table': obj.table,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3GlueParquetTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'table': obj.table,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiCatalogTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A policy that specifies update behavior for the crawler.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy#database
   */
  readonly database?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy#enableUpdateCatalog
   */
  readonly enableUpdateCatalog?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiDirectTargetSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'enableUpdateCatalog': obj.enableUpdateCatalog,
    'table': obj.table,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions#enableSamplePath
   */
  readonly enableSamplePath?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions#samplePath
   */
  readonly samplePath?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
    'enableSamplePath': obj.enableSamplePath,
    'samplePath': obj.samplePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions#enableSamplePath
   */
  readonly enableSamplePath?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions#samplePath
   */
  readonly samplePath?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
    'enableSamplePath': obj.enableSamplePath,
    'samplePath': obj.samplePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies additional connection options for the Amazon S3 data store.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions#boundedFiles
   */
  readonly boundedFiles?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions#boundedSize
   */
  readonly boundedSize?: number;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions#enableSamplePath
   */
  readonly enableSamplePath?: boolean;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions#samplePath
   */
  readonly samplePath?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions(obj: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceAdditionalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boundedFiles': obj.boundedFiles,
    'boundedSize': obj.boundedSize,
    'enableSamplePath': obj.enableSamplePath,
    'samplePath': obj.samplePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies configuration for Snowflake nodes in Glue Studio.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#action
   */
  readonly action?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#autoPushdown
   */
  readonly autoPushdown?: boolean;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#connection
   */
  readonly connection?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#database
   */
  readonly database?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#iamRole
   */
  readonly iamRole?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#mergeAction
   */
  readonly mergeAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#mergeClause
   */
  readonly mergeClause?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#mergeWhenMatched
   */
  readonly mergeWhenMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#mergeWhenNotMatched
   */
  readonly mergeWhenNotMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#postAction
   */
  readonly postAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#preAction
   */
  readonly preAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#sampleQuery
   */
  readonly sampleQuery?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#schema
   */
  readonly schema?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#selectedColumns
   */
  readonly selectedColumns?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#sourceType
   */
  readonly sourceType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#stagingTable
   */
  readonly stagingTable?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#tableSchema
   */
  readonly tableSchema?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#tempDir
   */
  readonly tempDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData#upsert
   */
  readonly upsert?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'autoPushdown': obj.autoPushdown,
    'connection': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection(obj.connection),
    'database': obj.database,
    'iamRole': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole(obj.iamRole),
    'mergeAction': obj.mergeAction,
    'mergeClause': obj.mergeClause,
    'mergeWhenMatched': obj.mergeWhenMatched,
    'mergeWhenNotMatched': obj.mergeWhenNotMatched,
    'postAction': obj.postAction,
    'preAction': obj.preAction,
    'sampleQuery': obj.sampleQuery,
    'schema': obj.schema,
    'selectedColumns': obj.selectedColumns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns(y)),
    'sourceType': obj.sourceType,
    'stagingTable': obj.stagingTable,
    'table': obj.table,
    'tableSchema': obj.tableSchema?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema(y)),
    'tempDir': obj.tempDir,
    'upsert': obj.upsert,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies configuration for Snowflake nodes in Glue Studio.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#action
   */
  readonly action?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#additionalOptions
   */
  readonly additionalOptions?: { [key: string]: string };

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#autoPushdown
   */
  readonly autoPushdown?: boolean;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#connection
   */
  readonly connection?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#database
   */
  readonly database?: string;

  /**
   * Specifies an option value.
   *
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#iamRole
   */
  readonly iamRole?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#mergeAction
   */
  readonly mergeAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#mergeClause
   */
  readonly mergeClause?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#mergeWhenMatched
   */
  readonly mergeWhenMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#mergeWhenNotMatched
   */
  readonly mergeWhenNotMatched?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#postAction
   */
  readonly postAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#preAction
   */
  readonly preAction?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#sampleQuery
   */
  readonly sampleQuery?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#schema
   */
  readonly schema?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#selectedColumns
   */
  readonly selectedColumns?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#sourceType
   */
  readonly sourceType?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#stagingTable
   */
  readonly stagingTable?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#table
   */
  readonly table?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#tableSchema
   */
  readonly tableSchema?: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema[];

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#tempDir
   */
  readonly tempDir?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData#upsert
   */
  readonly upsert?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'additionalOptions': ((obj.additionalOptions) === undefined) ? undefined : (Object.entries(obj.additionalOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'autoPushdown': obj.autoPushdown,
    'connection': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection(obj.connection),
    'database': obj.database,
    'iamRole': toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole(obj.iamRole),
    'mergeAction': obj.mergeAction,
    'mergeClause': obj.mergeClause,
    'mergeWhenMatched': obj.mergeWhenMatched,
    'mergeWhenNotMatched': obj.mergeWhenNotMatched,
    'postAction': obj.postAction,
    'preAction': obj.preAction,
    'sampleQuery': obj.sampleQuery,
    'schema': obj.schema,
    'selectedColumns': obj.selectedColumns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns(y)),
    'sourceType': obj.sourceType,
    'stagingTable': obj.stagingTable,
    'table': obj.table,
    'tableSchema': obj.tableSchema?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema(y)),
    'tempDir': obj.tempDir,
    'upsert': obj.upsert,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas#columns
   */
  readonly columns?: JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas(obj: JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases#alias
   */
  readonly alias?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases#from
   */
  readonly from?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases(obj: JobSpecForProviderCodeGenConfigurationNodesSparkSqlSqlAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'from': obj.from,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderConnectionRefsPolicyResolution
 */
export enum JobSpecForProviderConnectionRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderConnectionRefsPolicyResolve
 */
export enum JobSpecForProviderConnectionRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderConnectionSelectorPolicyResolution
 */
export enum JobSpecForProviderConnectionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderConnectionSelectorPolicyResolve
 */
export enum JobSpecForProviderConnectionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderRoleRefPolicyResolution
 */
export enum JobSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderRoleRefPolicyResolve
 */
export enum JobSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderRoleSelectorPolicyResolution
 */
export enum JobSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderRoleSelectorPolicyResolve
 */
export enum JobSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderSecurityConfigurationRefPolicyResolution
 */
export enum JobSpecForProviderSecurityConfigurationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderSecurityConfigurationRefPolicyResolve
 */
export enum JobSpecForProviderSecurityConfigurationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderSecurityConfigurationSelectorPolicyResolution
 */
export enum JobSpecForProviderSecurityConfigurationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderSecurityConfigurationSelectorPolicyResolve
 */
export enum JobSpecForProviderSecurityConfigurationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions#key
   */
  readonly key?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataAdvancedOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataCatalogTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataIamRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataSelectedColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftSourceDataTableSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions#key
   */
  readonly key?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataAdvancedOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataCatalogTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataIamRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataSelectedColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema(obj: JobSpecForProviderCodeGenConfigurationNodesAmazonRedshiftTargetDataTableSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesAthenaConnectorSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogDeltaSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesCatalogHudiSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesCustomCodeOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A structure representing the datatype of the value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype#id
   */
  readonly id?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype#label
   */
  readonly label?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype(obj: JobSpecForProviderCodeGenConfigurationNodesDropNullFieldsNullTextListDatatype | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'label': obj.label,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesDynamicTransformOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues
 */
export interface JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues#type_
   */
  readonly type?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues#value
   */
  readonly value?: string[];

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues(obj: JobSpecForProviderCodeGenConfigurationNodesFilterFiltersValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesJDbcConnectorTargetOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogDeltaSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3CatalogHudiSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3CsvSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3DeltaSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3HudiSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3JsonSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesS3ParquetSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataIamRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataSelectedColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceDataTableSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an option value.
 *
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataIamRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataSelectedColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema#description
   */
  readonly description?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema#label
   */
  readonly label?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema(obj: JobSpecForProviderCodeGenConfigurationNodesSnowflakeTargetDataTableSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorSourceOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSparkConnectorTargetOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns
 */
export interface JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns {
  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns#name
   */
  readonly name?: string;

  /**
   * @schema JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns(obj: JobSpecForProviderCodeGenConfigurationNodesSparkSqlOutputSchemasColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SecurityConfiguration is the Schema for the SecurityConfigurations API
 *
 * @schema SecurityConfiguration
 */
export class SecurityConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.crossplane.io/v1alpha1',
    kind: 'SecurityConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityConfigurationProps): any {
    return {
      ...SecurityConfiguration.GVK,
      ...toJson_SecurityConfigurationProps(props),
    };
  }

  /**
   * Defines a "SecurityConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityConfigurationProps) {
    super(scope, id, {
      ...SecurityConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityConfiguration.GVK,
      ...toJson_SecurityConfigurationProps(resolved),
    };
  }
}

/**
 * SecurityConfiguration is the Schema for the SecurityConfigurations API
 *
 * @schema SecurityConfiguration
 */
export interface SecurityConfigurationProps {
  /**
   * @schema SecurityConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecurityConfigurationSpec defines the desired state of SecurityConfiguration
   *
   * @schema SecurityConfiguration#spec
   */
  readonly spec: SecurityConfigurationSpec;

}

/**
 * Converts an object of type 'SecurityConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationProps(obj: SecurityConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityConfigurationSpec defines the desired state of SecurityConfiguration
 *
 * @schema SecurityConfigurationSpec
 */
export interface SecurityConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityConfigurationSpecDeletionPolicy;

  /**
   * SecurityConfigurationParameters defines the desired state of SecurityConfiguration
   *
   * @schema SecurityConfigurationSpec#forProvider
   */
  readonly forProvider: SecurityConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecurityConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: SecurityConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpec(obj: SecurityConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityConfigurationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecurityConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecurityConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityConfigurationSpecDeletionPolicy
 */
export enum SecurityConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecurityConfigurationParameters defines the desired state of SecurityConfiguration
 *
 * @schema SecurityConfigurationSpecForProvider
 */
export interface SecurityConfigurationSpecForProvider {
  /**
   * The encryption configuration for the new security configuration.
   *
   * @schema SecurityConfigurationSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration: SecurityConfigurationSpecForProviderEncryptionConfiguration;

  /**
   * Region is which region the SecurityConfiguration will be created.
   *
   * @schema SecurityConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProvider(obj: SecurityConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfiguration': toJson_SecurityConfigurationSpecForProviderEncryptionConfiguration(obj.encryptionConfiguration),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecurityConfigurationSpecManagementPolicies
 */
export enum SecurityConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityConfigurationSpecProviderConfigRef
 */
export interface SecurityConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecProviderConfigRef(obj: SecurityConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsTo
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsTo(obj: SecurityConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityConfigurationSpecWriteConnectionSecretToRef
 */
export interface SecurityConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecWriteConnectionSecretToRef(obj: SecurityConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption configuration for the new security configuration.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfiguration {
  /**
   * Specifies how Amazon CloudWatch data should be encrypted.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#cloudWatchEncryption
   */
  readonly cloudWatchEncryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption;

  /**
   * Specifies how job bookmark data should be encrypted.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#jobBookmarksEncryption
   */
  readonly jobBookmarksEncryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption;

  /**
   * Specifies how Amazon Simple Storage Service (Amazon S3) data should be encrypted.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#s3Encryption
   */
  readonly s3Encryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption[];

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfiguration(obj: SecurityConfigurationSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchEncryption': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption(obj.cloudWatchEncryption),
    'jobBookmarksEncryption': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption(obj.jobBookmarksEncryption),
    's3Encryption': obj.s3Encryption?.map(y => toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicy
 */
export interface SecurityConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecProviderConfigRefPolicy(obj: SecurityConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRef(obj: SecurityConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToMetadata(obj: SecurityConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies how Amazon CloudWatch data should be encrypted.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption {
  /**
   * The encryption mode to use for CloudWatch data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption#cloudWatchEncryptionMode
   */
  readonly cloudWatchEncryptionMode?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionCloudWatchEncryptionMode;

  /**
   * The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef;

  /**
   * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchEncryptionMode': obj.cloudWatchEncryptionMode,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies how job bookmark data should be encrypted.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption {
  /**
   * The encryption mode to use for job bookmarks data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#jobBookmarksEncryptionMode
   */
  readonly jobBookmarksEncryptionMode?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionJobBookmarksEncryptionMode;

  /**
   * The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef;

  /**
   * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobBookmarksEncryptionMode': obj.jobBookmarksEncryptionMode,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomS3Encryption contains the additional fields for S3Encryption
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption {
  /**
   * The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef;

  /**
   * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector;

  /**
   * The encryption mode to use for Amazon S3 data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#s3EncryptionMode
   */
  readonly s3EncryptionMode?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionS3EncryptionMode;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
    's3EncryptionMode': obj.s3EncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum SecurityConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum SecurityConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption mode to use for CloudWatch data.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionCloudWatchEncryptionMode
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionCloudWatchEncryptionMode {
  /** DISABLED */
  DISABLED = "DISABLED",
  /** SSE-KMS */
  SSE_HYPHEN_KMS = "SSE-KMS",
}

/**
 * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption mode to use for job bookmarks data.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionJobBookmarksEncryptionMode
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionJobBookmarksEncryptionMode {
  /** DISABLED */
  DISABLED = "DISABLED",
  /** CSE-KMS */
  CSE_HYPHEN_KMS = "CSE-KMS",
}

/**
 * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNRef is a reference to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNSelector selects references to an KMSKey used to set the KMSKeyARN.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption mode to use for Amazon S3 data.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionS3EncryptionMode
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionS3EncryptionMode {
  /** DISABLED */
  DISABLED = "DISABLED",
  /** SSE-KMS */
  SSE_HYPHEN_KMS = "SSE-KMS",
  /** SSE-S3 */
  SSE_HYPHEN_S3 = "SSE-S3",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudWatchEncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

