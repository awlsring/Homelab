// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.crossplane.io/v1alpha1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * ClusterParameters defines the desired state of Cluster
   *
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClusterParameters defines the desired state of Cluster
 *
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * The short name of one or more capacity providers to associate with the cluster. A capacity provider must be associated with a cluster before it can be included as part of the default capacity provider strategy of the cluster or used in a capacity provider strategy when calling the CreateService (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or RunTask (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions.
   * If specifying a capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with another cluster. New Auto Scaling group capacity providers can be created with the CreateCapacityProvider (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html) API operation.
   * To use a Fargate capacity provider, specify either the FARGATE or FARGATE_SPOT capacity providers. The Fargate capacity providers are available to all accounts and only need to be associated with a cluster to be used.
   * The PutCapacityProvider (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API operation is used to update the list of available capacity providers for a cluster after the cluster is created.
   *
   * @schema ClusterSpecForProvider#capacityProviders
   */
  readonly capacityProviders?: string[];

  /**
   * The name of your cluster. If you don't specify a name for your cluster, you create a cluster that's named default. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed.
   *
   * @schema ClusterSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * The execute command configuration for the cluster.
   *
   * @schema ClusterSpecForProvider#configuration
   */
  readonly configuration?: ClusterSpecForProviderConfiguration;

  /**
   * The capacity provider strategy to set as the default for the cluster. After a default capacity provider strategy is set for a cluster, when you call the CreateService (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or RunTask (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) APIs with no capacity provider strategy or launch type specified, the default capacity provider strategy for the cluster is used.
   * If a default capacity provider strategy isn't defined for a cluster when it was created, it can be defined later with the PutClusterCapacityProviders API operation.
   *
   * @schema ClusterSpecForProvider#defaultCapacityProviderStrategy
   */
  readonly defaultCapacityProviderStrategy?: ClusterSpecForProviderDefaultCapacityProviderStrategy[];

  /**
   * Region is which region the Cluster will be created.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the enabled parameter to true in the ServiceConnectConfiguration. You can set the namespace of each service individually in the ServiceConnectConfiguration to override this default parameter.
   * Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema ClusterSpecForProvider#serviceConnectDefaults
   */
  readonly serviceConnectDefaults?: ClusterSpecForProviderServiceConnectDefaults;

  /**
   * The setting to use when creating a cluster. This parameter is used to turn on CloudWatch Container Insights for a cluster. If this value is specified, it overrides the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
   *
   * @schema ClusterSpecForProvider#settings
   */
  readonly settings?: ClusterSpecForProviderSettings[];

  /**
   * The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.
   * The following basic restrictions apply to tags:
   * * Maximum number of tags per resource - 50
   * * For each resource, each tag key must be unique, and each tag key can have only one value.
   * * Maximum key length - 128 Unicode characters in UTF-8
   * * Maximum value length - 256 Unicode characters in UTF-8
   * * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
   * * Tag keys and values are case-sensitive.
   * * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: ClusterSpecForProviderTags[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviders': obj.capacityProviders?.map(y => y),
    'clusterName': obj.clusterName,
    'configuration': toJson_ClusterSpecForProviderConfiguration(obj.configuration),
    'defaultCapacityProviderStrategy': obj.defaultCapacityProviderStrategy?.map(y => toJson_ClusterSpecForProviderDefaultCapacityProviderStrategy(y)),
    'region': obj.region,
    'serviceConnectDefaults': toJson_ClusterSpecForProviderServiceConnectDefaults(obj.serviceConnectDefaults),
    'settings': obj.settings?.map(y => toJson_ClusterSpecForProviderSettings(y)),
    'tags': obj.tags?.map(y => toJson_ClusterSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The execute command configuration for the cluster.
 *
 * @schema ClusterSpecForProviderConfiguration
 */
export interface ClusterSpecForProviderConfiguration {
  /**
   * The details of the execute command configuration.
   *
   * @schema ClusterSpecForProviderConfiguration#executeCommandConfiguration
   */
  readonly executeCommandConfiguration?: ClusterSpecForProviderConfigurationExecuteCommandConfiguration;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfiguration(obj: ClusterSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeCommandConfiguration': toJson_ClusterSpecForProviderConfigurationExecuteCommandConfiguration(obj.executeCommandConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy
 */
export interface ClusterSpecForProviderDefaultCapacityProviderStrategy {
  /**
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultCapacityProviderStrategy(obj: ClusterSpecForProviderDefaultCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the enabled parameter to true in the ServiceConnectConfiguration. You can set the namespace of each service individually in the ServiceConnectConfiguration to override this default parameter.
 * Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema ClusterSpecForProviderServiceConnectDefaults
 */
export interface ClusterSpecForProviderServiceConnectDefaults {
  /**
   * @schema ClusterSpecForProviderServiceConnectDefaults#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderServiceConnectDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderServiceConnectDefaults(obj: ClusterSpecForProviderServiceConnectDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderSettings
 */
export interface ClusterSpecForProviderSettings {
  /**
   * @schema ClusterSpecForProviderSettings#name
   */
  readonly name?: string;

  /**
   * @schema ClusterSpecForProviderSettings#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSettings(obj: ClusterSpecForProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderTags
 */
export interface ClusterSpecForProviderTags {
  /**
   * @schema ClusterSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ClusterSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderTags(obj: ClusterSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The details of the execute command configuration.
 *
 * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration
 */
export interface ClusterSpecForProviderConfigurationExecuteCommandConfiguration {
  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#logConfiguration
   */
  readonly logConfiguration?: ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration;

  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#logging
   */
  readonly logging?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationExecuteCommandConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationExecuteCommandConfiguration(obj: ClusterSpecForProviderConfigurationExecuteCommandConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyID': obj.kmsKeyId,
    'logConfiguration': toJson_ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration(obj.logConfiguration),
    'logging': obj.logging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket.
 *
 * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration
 */
export interface ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration {
  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchEncryptionEnabled
   */
  readonly cloudWatchEncryptionEnabled?: boolean;

  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchLogGroupName
   */
  readonly cloudWatchLogGroupName?: string;

  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3EncryptionEnabled
   */
  readonly s3EncryptionEnabled?: boolean;

  /**
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration(obj: ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchEncryptionEnabled': obj.cloudWatchEncryptionEnabled,
    'cloudWatchLogGroupName': obj.cloudWatchLogGroupName,
    's3BucketName': obj.s3BucketName,
    's3EncryptionEnabled': obj.s3EncryptionEnabled,
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.crossplane.io/v1alpha1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * ServiceParameters defines the desired state of Service
   *
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ServiceParameters defines the desired state of Service
 *
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * The capacity provider strategy to use for the service.
   * If a capacityProviderStrategy is specified, the launchType parameter must be omitted. If no capacityProviderStrategy or launchType is specified, the defaultCapacityProviderStrategy for the cluster is used.
   * A capacity provider strategy may contain a maximum of 6 capacity providers.
   *
   * @schema ServiceSpecForProvider#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: ServiceSpecForProviderCapacityProviderStrategy[];

  /**
   * The short name or full Amazon Resource Name (ARN) of the cluster on which to run your service. If you do not specify a cluster, the default cluster is assumed.
   *
   * @schema ServiceSpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * A Reference to a named object.
   *
   * @schema ServiceSpecForProvider#clusterRef
   */
  readonly clusterRef?: ServiceSpecForProviderClusterRef;

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProvider#clusterSelector
   */
  readonly clusterSelector?: ServiceSpecForProviderClusterSelector;

  /**
   * Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.
   *
   * @schema ServiceSpecForProvider#deploymentConfiguration
   */
  readonly deploymentConfiguration?: ServiceSpecForProviderDeploymentConfiguration;

  /**
   * The deployment controller to use for the service. If no deployment controller is specified, the default value of ECS is used.
   *
   * @schema ServiceSpecForProvider#deploymentController
   */
  readonly deploymentController?: ServiceSpecForProviderDeploymentController;

  /**
   * The number of instantiations of the specified task definition to place and keep running in your service.
   * This is required if schedulingStrategy is REPLICA or isn't specified. If schedulingStrategy is DAEMON then this isn't required.
   *
   * @schema ServiceSpecForProvider#desiredCount
   */
  readonly desiredCount?: number;

  /**
   * Specifies whether to turn on Amazon ECS managed tags for the tasks within the service. For more information, see Tagging your Amazon ECS resources (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon Elastic Container Service Developer Guide.
   * When you use Amazon ECS managed tags, you need to set the propagateTags request parameter.
   *
   * @schema ServiceSpecForProvider#enableECSManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Determines whether the execute command functionality is turned on for the service. If true, this enables execute command functionality on all containers in the service tasks.
   *
   * @schema ServiceSpecForProvider#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Force Service to be deleted, even with task Running or Pending
   *
   * @schema ServiceSpecForProvider#forceDeletion
   */
  readonly forceDeletion?: boolean;

  /**
   * The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. This is only used when your service is configured to use a load balancer. If your service has a load balancer defined and you don't specify a health check grace period value, the default value of 0 is used.
   * If you do not use an Elastic Load Balancing, we recommend that you use the startPeriod in the task definition health check parameters. For more information, see Health check (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html).
   * If your service's tasks take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy and stopping them before they have time to come up.
   *
   * @schema ServiceSpecForProvider#healthCheckGracePeriodSeconds
   */
  readonly healthCheckGracePeriodSeconds?: number;

  /**
   * The infrastructure that you run your service on. For more information, see Amazon ECS launch types (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the Amazon Elastic Container Service Developer Guide.
   * The FARGATE launch type runs your tasks on Fargate On-Demand infrastructure.
   * Fargate Spot infrastructure is available for use but a capacity provider strategy must be used. For more information, see Fargate capacity providers (https://docs.aws.amazon.com/AmazonECS/latest/userguide/fargate-capacity-providers.html) in the Amazon ECS User Guide for Fargate.
   * The EC2 launch type runs your tasks on Amazon EC2 instances registered to your cluster.
   * The EXTERNAL launch type runs your tasks on your on-premises server or virtual machine (VM) capacity registered to your cluster.
   * A service can use either a launch type or a capacity provider strategy. If a launchType is specified, the capacityProviderStrategy parameter must be omitted.
   *
   * @schema ServiceSpecForProvider#launchType
   */
  readonly launchType?: string;

  /**
   * A load balancer object representing the load balancers to use with your service. For more information, see Service Load Balancing (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the Amazon Elastic Container Service Developer Guide.
   * If the service is using the rolling update (ECS) deployment controller and using either an Application Load Balancer or Network Load Balancer, you must specify one or more target group ARNs to attach to the service. The service-linked role is required for services that make use of multiple target groups. For more information, see Using service-linked roles for Amazon ECS (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the Amazon Elastic Container Service Developer Guide.
   * If the service is using the CODE_DEPLOY deployment controller, the service is required to use either an Application Load Balancer or Network Load Balancer. When creating an CodeDeploy deployment group, you specify two target groups (referred to as a targetGroupPair). During a deployment, CodeDeploy determines which task set in your service has the status PRIMARY and associates one target group with it, and then associates the other target group with the replacement task set. The load balancer can also have up to two listeners: a required listener for production traffic and an optional listener that allows you perform validation tests with Lambda functions before routing production traffic to it.
   * After you create a service using the ECS deployment controller, the load balancer name or target group ARN, container name, and container port specified in the service definition are immutable. If you are using the CODE_DEPLOY deployment controller, these values can be changed when updating the service.
   * For Application Load Balancers and Network Load Balancers, this object must contain the load balancer target group ARN, the container name (as it appears in a container definition), and the container port to access from the load balancer. The load balancer name parameter must be omitted. When a task from this service is placed on a container instance, the container instance and port combination is registered as a target in the target group specified here.
   * For Classic Load Balancers, this object must contain the load balancer name, the container name (as it appears in a container definition), and the container port to access from the load balancer. The target group ARN parameter must be omitted. When a task from this service is placed on a container instance, the container instance is registered with the load balancer specified here.
   * Services with tasks that use the awsvpc network mode (for example, those with the Fargate launch type) only support Application Load Balancers and Network Load Balancers. Classic Load Balancers are not supported. Also, when you create any target groups for these services, you must choose ip as the target type, not instance, because tasks that use the awsvpc network mode are associated with an elastic network interface, not an Amazon EC2 instance.
   *
   * @schema ServiceSpecForProvider#loadBalancers
   */
  readonly loadBalancers?: ServiceSpecForProviderLoadBalancers[];

  /**
   * The network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own elastic network interface, and it is not supported for other network modes. For more information, see Task networking (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema ServiceSpecForProvider#networkConfiguration
   */
  readonly networkConfiguration?: ServiceSpecForProviderNetworkConfiguration;

  /**
   * An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition and those specified at runtime.
   *
   * @schema ServiceSpecForProvider#placementConstraints
   */
  readonly placementConstraints?: ServiceSpecForProviderPlacementConstraints[];

  /**
   * The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules for each service.
   *
   * @schema ServiceSpecForProvider#placementStrategy
   */
  readonly placementStrategy?: ServiceSpecForProviderPlacementStrategy[];

  /**
   * The platform version that your tasks in the service are running on. A platform version is specified only for tasks using the Fargate launch type. If one isn't specified, the LATEST platform version is used. For more information, see Fargate platform versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema ServiceSpecForProvider#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action.
   * The default is NONE.
   *
   * @schema ServiceSpecForProvider#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * Region is which region the Service will be created.
   *
   * @schema ServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is only permitted if you are using a load balancer with your service and your task definition doesn't use the awsvpc network mode. If you specify the role parameter, you must also specify a load balancer object with the loadBalancers parameter.
   * If your account has already created the Amazon ECS service-linked role, that role is used for your service unless you specify a role here. The service-linked role is required if your task definition uses the awsvpc network mode or if the service is configured to use service discovery, an external deployment controller, multiple target groups, or Elastic Inference accelerators in which case you don't specify a role here. For more information, see Using service-linked roles for Amazon ECS (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the Amazon Elastic Container Service Developer Guide.
   * If your specified role has a path other than /, then you must either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a role with the name bar has a path of /foo/ then you would specify /foo/bar as the role name. For more information, see Friendly names and paths (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the IAM User Guide.
   *
   * @schema ServiceSpecForProvider#role
   */
  readonly role?: string;

  /**
   * The scheduling strategy to use for the service. For more information, see Services (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html).
   * There are two service scheduler strategies available:
   * * REPLICA-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the CODE_DEPLOY or EXTERNAL deployment controller types.
   * * DAEMON-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies. Tasks using the Fargate launch type or the CODE_DEPLOY or EXTERNAL deployment controller types don't support the DAEMON scheduling strategy.
   *
   * @schema ServiceSpecForProvider#schedulingStrategy
   */
  readonly schedulingStrategy?: string;

  /**
   * The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.
   * Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema ServiceSpecForProvider#serviceConnectConfiguration
   */
  readonly serviceConnectConfiguration?: ServiceSpecForProviderServiceConnectConfiguration;

  /**
   * The details of the service discovery registry to associate with this service. For more information, see Service discovery (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html).
   * Each service may be associated with one service registry. Multiple service registries for each service isn't supported.
   *
   * @schema ServiceSpecForProvider#serviceRegistries
   */
  readonly serviceRegistries?: ServiceSpecForProviderServiceRegistries[];

  /**
   * The metadata that you apply to the service to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. When a service is deleted, the tags are deleted as well.
   * The following basic restrictions apply to tags:
   * * Maximum number of tags per resource - 50
   * * For each resource, each tag key must be unique, and each tag key can have only one value.
   * * Maximum key length - 128 Unicode characters in UTF-8
   * * Maximum value length - 256 Unicode characters in UTF-8
   * * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
   * * Tag keys and values are case-sensitive.
   * * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
   *
   * @schema ServiceSpecForProvider#tags
   */
  readonly tags?: ServiceSpecForProviderTags[];

  /**
   * The family and revision (family:revision) or full ARN of the task definition to run in your service. If a revision is not specified, the latest ACTIVE revision is used.
   * A task definition must be specified if the service is using either the ECS or CODE_DEPLOY deployment controllers.
   *
   * @schema ServiceSpecForProvider#taskDefinition
   */
  readonly taskDefinition?: string;

  /**
   * A Reference to a named object.
   *
   * @schema ServiceSpecForProvider#taskDefinitionRef
   */
  readonly taskDefinitionRef?: ServiceSpecForProviderTaskDefinitionRef;

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProvider#taskDefinitionSelector
   */
  readonly taskDefinitionSelector?: ServiceSpecForProviderTaskDefinitionSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_ServiceSpecForProviderCapacityProviderStrategy(y)),
    'cluster': obj.cluster,
    'clusterRef': toJson_ServiceSpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_ServiceSpecForProviderClusterSelector(obj.clusterSelector),
    'deploymentConfiguration': toJson_ServiceSpecForProviderDeploymentConfiguration(obj.deploymentConfiguration),
    'deploymentController': toJson_ServiceSpecForProviderDeploymentController(obj.deploymentController),
    'desiredCount': obj.desiredCount,
    'enableECSManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'forceDeletion': obj.forceDeletion,
    'healthCheckGracePeriodSeconds': obj.healthCheckGracePeriodSeconds,
    'launchType': obj.launchType,
    'loadBalancers': obj.loadBalancers?.map(y => toJson_ServiceSpecForProviderLoadBalancers(y)),
    'networkConfiguration': toJson_ServiceSpecForProviderNetworkConfiguration(obj.networkConfiguration),
    'placementConstraints': obj.placementConstraints?.map(y => toJson_ServiceSpecForProviderPlacementConstraints(y)),
    'placementStrategy': obj.placementStrategy?.map(y => toJson_ServiceSpecForProviderPlacementStrategy(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'region': obj.region,
    'role': obj.role,
    'schedulingStrategy': obj.schedulingStrategy,
    'serviceConnectConfiguration': toJson_ServiceSpecForProviderServiceConnectConfiguration(obj.serviceConnectConfiguration),
    'serviceRegistries': obj.serviceRegistries?.map(y => toJson_ServiceSpecForProviderServiceRegistries(y)),
    'tags': obj.tags?.map(y => toJson_ServiceSpecForProviderTags(y)),
    'taskDefinition': obj.taskDefinition,
    'taskDefinitionRef': toJson_ServiceSpecForProviderTaskDefinitionRef(obj.taskDefinitionRef),
    'taskDefinitionSelector': toJson_ServiceSpecForProviderTaskDefinitionSelector(obj.taskDefinitionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceSpecManagementPolicies
 */
export enum ServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderCapacityProviderStrategy
 */
export interface ServiceSpecForProviderCapacityProviderStrategy {
  /**
   * @schema ServiceSpecForProviderCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * @schema ServiceSpecForProviderCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * @schema ServiceSpecForProviderCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderCapacityProviderStrategy(obj: ServiceSpecForProviderCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderClusterRef
 */
export interface ServiceSpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderClusterRef#policy
   */
  readonly policy?: ServiceSpecForProviderClusterRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterRef(obj: ServiceSpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderClusterSelector
 */
export interface ServiceSpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderClusterSelector#policy
   */
  readonly policy?: ServiceSpecForProviderClusterSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterSelector(obj: ServiceSpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.
 *
 * @schema ServiceSpecForProviderDeploymentConfiguration
 */
export interface ServiceSpecForProviderDeploymentConfiguration {
  /**
   * One of the methods which provide a way for you to quickly identify when a deployment has failed, and then to optionally roll back the failure to the last working deployment.
   * When the alarms are generated, Amazon ECS sets the service deployment to failed. Set the rollback parameter to have Amazon ECS to roll back your service to the last completed deployment after a failure.
   * You can only use the DeploymentAlarms method to detect failures when the DeploymentController is set to ECS (rolling update).
   * For more information, see Rolling update (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the Amazon Elastic Container Service Developer Guide .
   *
   * @schema ServiceSpecForProviderDeploymentConfiguration#alarms
   */
  readonly alarms?: ServiceSpecForProviderDeploymentConfigurationAlarms;

  /**
   * The deployment circuit breaker can only be used for services using the rolling update (ECS) deployment type.
   * The deployment circuit breaker determines whether a service deployment will fail if the service can't reach a steady state. If it is turned on, a service deployment will transition to a failed state and stop launching new tasks. You can also configure Amazon ECS to roll back your service to the last completed deployment after a failure. For more information, see Rolling update (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the Amazon Elastic Container Service Developer Guide.
   * For more information about API failure reasons, see API failure reasons (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/api_failures_messages.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema ServiceSpecForProviderDeploymentConfiguration#deploymentCircuitBreaker
   */
  readonly deploymentCircuitBreaker?: ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker;

  /**
   * @schema ServiceSpecForProviderDeploymentConfiguration#maximumPercent
   */
  readonly maximumPercent?: number;

  /**
   * @schema ServiceSpecForProviderDeploymentConfiguration#minimumHealthyPercent
   */
  readonly minimumHealthyPercent?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentConfiguration(obj: ServiceSpecForProviderDeploymentConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': toJson_ServiceSpecForProviderDeploymentConfigurationAlarms(obj.alarms),
    'deploymentCircuitBreaker': toJson_ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker(obj.deploymentCircuitBreaker),
    'maximumPercent': obj.maximumPercent,
    'minimumHealthyPercent': obj.minimumHealthyPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The deployment controller to use for the service. If no deployment controller is specified, the default value of ECS is used.
 *
 * @schema ServiceSpecForProviderDeploymentController
 */
export interface ServiceSpecForProviderDeploymentController {
  /**
   * @schema ServiceSpecForProviderDeploymentController#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentController(obj: ServiceSpecForProviderDeploymentController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomLoadBalancer provides custom parameters for the LoadBalancer type
 *
 * @schema ServiceSpecForProviderLoadBalancers
 */
export interface ServiceSpecForProviderLoadBalancers {
  /**
   * The name of the container (as it appears in a container definition) to associate with the load balancer.
   *
   * @schema ServiceSpecForProviderLoadBalancers#containerName
   */
  readonly containerName?: string;

  /**
   * The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they're launched on must allow ingress traffic on the hostPort of the port mapping.
   *
   * @schema ServiceSpecForProviderLoadBalancers#containerPort
   */
  readonly containerPort?: number;

  /**
   * The name of the load balancer to associate with the Amazon ECS service or task set.
   * A load balancer name is only specified when using a Classic Load Balancer. If you are using an Application Load Balancer or a Network Load Balancer the load balancer name parameter should be omitted.
   *
   * @schema ServiceSpecForProviderLoadBalancers#loadBalancerName
   */
  readonly loadBalancerName?: string;

  /**
   * A Reference to a named object.
   *
   * @schema ServiceSpecForProviderLoadBalancers#loadBalancerNameRef
   */
  readonly loadBalancerNameRef?: ServiceSpecForProviderLoadBalancersLoadBalancerNameRef;

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProviderLoadBalancers#loadBalancerNameSelector
   */
  readonly loadBalancerNameSelector?: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector;

  /**
   * The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set.
   * A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer. If you're using a Classic Load Balancer, omit the target group ARN.
   * For services using the ECS deployment controller, you can specify one or multiple target groups. For more information, see Registering multiple target groups with a service (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html) in the Amazon Elastic Container Service Developer Guide.
   * For services using the CODE_DEPLOY deployment controller, you're required to define two target groups for the load balancer. For more information, see Blue/green deployment with CodeDeploy (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html) in the Amazon Elastic Container Service Developer Guide.
   * If your service's task definition uses the awsvpc network mode, you must choose ip as the target type, not instance. Do this when creating your target groups because tasks that use the awsvpc network mode are associated with an elastic network interface, not an Amazon EC2 instance. This network mode is required for the Fargate launch type.
   *
   * @schema ServiceSpecForProviderLoadBalancers#targetGroupARN
   */
  readonly targetGroupArn?: string;

  /**
   * A Reference to a named object.
   *
   * @schema ServiceSpecForProviderLoadBalancers#targetGroupARNRef
   */
  readonly targetGroupArnRef?: ServiceSpecForProviderLoadBalancersTargetGroupArnRef;

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProviderLoadBalancers#targetGroupARNSelector
   */
  readonly targetGroupArnSelector?: ServiceSpecForProviderLoadBalancersTargetGroupArnSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancers(obj: ServiceSpecForProviderLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'loadBalancerName': obj.loadBalancerName,
    'loadBalancerNameRef': toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameRef(obj.loadBalancerNameRef),
    'loadBalancerNameSelector': toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector(obj.loadBalancerNameSelector),
    'targetGroupARN': obj.targetGroupArn,
    'targetGroupARNRef': toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupARNSelector': toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnSelector(obj.targetGroupArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own elastic network interface, and it is not supported for other network modes. For more information, see Task networking (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema ServiceSpecForProviderNetworkConfiguration
 */
export interface ServiceSpecForProviderNetworkConfiguration {
  /**
   * An object representing the networking details for a task or service.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#awsvpcConfiguration
   */
  readonly awsvpcConfiguration?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfiguration(obj: ServiceSpecForProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsvpcConfiguration': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration(obj.awsvpcConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderPlacementConstraints
 */
export interface ServiceSpecForProviderPlacementConstraints {
  /**
   * @schema ServiceSpecForProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceSpecForProviderPlacementConstraints#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderPlacementConstraints(obj: ServiceSpecForProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderPlacementStrategy
 */
export interface ServiceSpecForProviderPlacementStrategy {
  /**
   * @schema ServiceSpecForProviderPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * @schema ServiceSpecForProviderPlacementStrategy#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderPlacementStrategy(obj: ServiceSpecForProviderPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.
 * Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema ServiceSpecForProviderServiceConnectConfiguration
 */
export interface ServiceSpecForProviderServiceConnectConfiguration {
  /**
   * @schema ServiceSpecForProviderServiceConnectConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The log configuration for the container. This parameter maps to LogConfig in the Create a container (https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the Docker Remote API (https://docs.docker.com/engine/api/v1.35/) and the --log-driver option to docker run (https://docs.docker.com/engine/reference/commandline/run/).
   * By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see Configure logging drivers (https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.
   * Understand the following when specifying a log configuration for your containers.
   * * Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on Fargate, the supported log drivers are awslogs, splunk, and awsfirelens. For tasks hosted on Amazon EC2 instances, the supported log drivers are awslogs, fluentd, gelf, json-file, journald, logentries,syslog, splunk, and awsfirelens.
   * * This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.
   * * For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ECS_AVAILABLE_LOGGING_DRIVERS environment variable before containers placed on that instance can use these log configuration options. For more information, see Amazon ECS container agent configuration (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the Amazon Elastic Container Service Developer Guide.
   * * For tasks that are on Fargate, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
   *
   * @schema ServiceSpecForProviderServiceConnectConfiguration#logConfiguration
   */
  readonly logConfiguration?: ServiceSpecForProviderServiceConnectConfigurationLogConfiguration;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfiguration#namespace
   */
  readonly namespace?: string;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfiguration#services
   */
  readonly services?: ServiceSpecForProviderServiceConnectConfigurationServices[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfiguration(obj: ServiceSpecForProviderServiceConnectConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logConfiguration': toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfiguration(obj.logConfiguration),
    'namespace': obj.namespace,
    'services': obj.services?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceRegistries
 */
export interface ServiceSpecForProviderServiceRegistries {
  /**
   * @schema ServiceSpecForProviderServiceRegistries#containerName
   */
  readonly containerName?: string;

  /**
   * @schema ServiceSpecForProviderServiceRegistries#containerPort
   */
  readonly containerPort?: number;

  /**
   * @schema ServiceSpecForProviderServiceRegistries#port
   */
  readonly port?: number;

  /**
   * @schema ServiceSpecForProviderServiceRegistries#registryARN
   */
  readonly registryArn?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceRegistries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceRegistries(obj: ServiceSpecForProviderServiceRegistries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'port': obj.port,
    'registryARN': obj.registryArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTags
 */
export interface ServiceSpecForProviderTags {
  /**
   * @schema ServiceSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ServiceSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTags(obj: ServiceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRef
 */
export interface ServiceSpecForProviderTaskDefinitionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRef#policy
   */
  readonly policy?: ServiceSpecForProviderTaskDefinitionRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionRef(obj: ServiceSpecForProviderTaskDefinitionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderTaskDefinitionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelector
 */
export interface ServiceSpecForProviderTaskDefinitionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#policy
   */
  readonly policy?: ServiceSpecForProviderTaskDefinitionSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionSelector(obj: ServiceSpecForProviderTaskDefinitionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderTaskDefinitionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderClusterRefPolicy
 */
export interface ServiceSpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderClusterRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterRefPolicy(obj: ServiceSpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicy
 */
export interface ServiceSpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderClusterSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterSelectorPolicy(obj: ServiceSpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * One of the methods which provide a way for you to quickly identify when a deployment has failed, and then to optionally roll back the failure to the last working deployment.
 * When the alarms are generated, Amazon ECS sets the service deployment to failed. Set the rollback parameter to have Amazon ECS to roll back your service to the last completed deployment after a failure.
 * You can only use the DeploymentAlarms method to detect failures when the DeploymentController is set to ECS (rolling update).
 * For more information, see Rolling update (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the Amazon Elastic Container Service Developer Guide .
 *
 * @schema ServiceSpecForProviderDeploymentConfigurationAlarms
 */
export interface ServiceSpecForProviderDeploymentConfigurationAlarms {
  /**
   * @schema ServiceSpecForProviderDeploymentConfigurationAlarms#alarmNames
   */
  readonly alarmNames?: string[];

  /**
   * @schema ServiceSpecForProviderDeploymentConfigurationAlarms#enable
   */
  readonly enable?: boolean;

  /**
   * @schema ServiceSpecForProviderDeploymentConfigurationAlarms#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentConfigurationAlarms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentConfigurationAlarms(obj: ServiceSpecForProviderDeploymentConfigurationAlarms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmNames': obj.alarmNames?.map(y => y),
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The deployment circuit breaker can only be used for services using the rolling update (ECS) deployment type.
 * The deployment circuit breaker determines whether a service deployment will fail if the service can't reach a steady state. If it is turned on, a service deployment will transition to a failed state and stop launching new tasks. You can also configure Amazon ECS to roll back your service to the last completed deployment after a failure. For more information, see Rolling update (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the Amazon Elastic Container Service Developer Guide.
 * For more information about API failure reasons, see API failure reasons (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/api_failures_messages.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker
 */
export interface ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker {
  /**
   * @schema ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker#enable
   */
  readonly enable?: boolean;

  /**
   * @schema ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker(obj: ServiceSpecForProviderDeploymentConfigurationDeploymentCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRef
 */
export interface ServiceSpecForProviderLoadBalancersLoadBalancerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRef#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersLoadBalancerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameRef(obj: ServiceSpecForProviderLoadBalancersLoadBalancerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector
 */
export interface ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector(obj: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRef
 */
export interface ServiceSpecForProviderLoadBalancersTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRef#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnRef(obj: ServiceSpecForProviderLoadBalancersTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelector
 */
export interface ServiceSpecForProviderLoadBalancersTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelector#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnSelector(obj: ServiceSpecForProviderLoadBalancersTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object representing the networking details for a task or service.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration {
  /**
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#assignPublicIP
   */
  readonly assignPublicIp?: string;

  /**
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#securityGroupRefs
   */
  readonly securityGroupRefs?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs[];

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#securityGroupSelector
   */
  readonly securityGroupSelector?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector;

  /**
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#subnetRefs
   */
  readonly subnetRefs?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs[];

  /**
   * A Selector selects an object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#subnetSelector
   */
  readonly subnetSelector?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector;

  /**
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIP': obj.assignPublicIp,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs(y)),
    'subnetSelector': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The log configuration for the container. This parameter maps to LogConfig in the Create a container (https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the Docker Remote API (https://docs.docker.com/engine/api/v1.35/) and the --log-driver option to docker run (https://docs.docker.com/engine/reference/commandline/run/).
 * By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see Configure logging drivers (https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.
 * Understand the following when specifying a log configuration for your containers.
 * * Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on Fargate, the supported log drivers are awslogs, splunk, and awsfirelens. For tasks hosted on Amazon EC2 instances, the supported log drivers are awslogs, fluentd, gelf, json-file, journald, logentries,syslog, splunk, and awsfirelens.
 * * This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.
 * * For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ECS_AVAILABLE_LOGGING_DRIVERS environment variable before containers placed on that instance can use these log configuration options. For more information, see Amazon ECS container agent configuration (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the Amazon Elastic Container Service Developer Guide.
 * * For tasks that are on Fargate, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
 *
 * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration
 */
export interface ServiceSpecForProviderServiceConnectConfigurationLogConfiguration {
  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#logDriver
   */
  readonly logDriver?: string;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#options
   */
  readonly options?: { [key: string]: string };

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#secretOptions
   */
  readonly secretOptions?: ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfiguration(obj: ServiceSpecForProviderServiceConnectConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDriver': obj.logDriver,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secretOptions': obj.secretOptions?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationServices
 */
export interface ServiceSpecForProviderServiceConnectConfigurationServices {
  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServices#clientAliases
   */
  readonly clientAliases?: ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases[];

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServices#discoveryName
   */
  readonly discoveryName?: string;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServices#ingressPortOverride
   */
  readonly ingressPortOverride?: number;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServices#portName
   */
  readonly portName?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationServices(obj: ServiceSpecForProviderServiceConnectConfigurationServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAliases': obj.clientAliases?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases(y)),
    'discoveryName': obj.discoveryName,
    'ingressPortOverride': obj.ingressPortOverride,
    'portName': obj.portName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicy
 */
export interface ServiceSpecForProviderTaskDefinitionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTaskDefinitionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTaskDefinitionRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionRefPolicy(obj: ServiceSpecForProviderTaskDefinitionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy
 */
export interface ServiceSpecForProviderTaskDefinitionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionSelectorPolicy(obj: ServiceSpecForProviderTaskDefinitionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderClusterRefPolicyResolution
 */
export enum ServiceSpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderClusterRefPolicyResolve
 */
export enum ServiceSpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicyResolution
 */
export enum ServiceSpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicyResolve
 */
export enum ServiceSpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy
 */
export interface ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy(obj: ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy
 */
export interface ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy(obj: ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy
 */
export interface ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy(obj: ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy
 */
export interface ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy(obj: ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions
 */
export interface ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions {
  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions#name
   */
  readonly name?: string;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions(obj: ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases
 */
export interface ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases {
  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases#dnsName
   */
  readonly dnsName?: string;

  /**
   * @schema ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases(obj: ServiceSpecForProviderServiceConnectConfigurationServicesClientAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsName': obj.dnsName,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicyResolution
 */
export enum ServiceSpecForProviderTaskDefinitionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicyResolve
 */
export enum ServiceSpecForProviderTaskDefinitionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution
 */
export enum ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve
 */
export enum ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancersLoadBalancerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancersLoadBalancerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancersTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancersTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy(obj: ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationAwsvpcConfigurationSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TaskDefinition is the Schema for the TaskDefinitions API
 *
 * @schema TaskDefinition
 */
export class TaskDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TaskDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.crossplane.io/v1alpha1',
    kind: 'TaskDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "TaskDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TaskDefinitionProps): any {
    return {
      ...TaskDefinition.GVK,
      ...toJson_TaskDefinitionProps(props),
    };
  }

  /**
   * Defines a "TaskDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TaskDefinitionProps) {
    super(scope, id, {
      ...TaskDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TaskDefinition.GVK,
      ...toJson_TaskDefinitionProps(resolved),
    };
  }
}

/**
 * TaskDefinition is the Schema for the TaskDefinitions API
 *
 * @schema TaskDefinition
 */
export interface TaskDefinitionProps {
  /**
   * @schema TaskDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TaskDefinitionSpec defines the desired state of TaskDefinition
   *
   * @schema TaskDefinition#spec
   */
  readonly spec: TaskDefinitionSpec;

}

/**
 * Converts an object of type 'TaskDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionProps(obj: TaskDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TaskDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TaskDefinitionSpec defines the desired state of TaskDefinition
 *
 * @schema TaskDefinitionSpec
 */
export interface TaskDefinitionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TaskDefinitionSpec#deletionPolicy
   */
  readonly deletionPolicy?: TaskDefinitionSpecDeletionPolicy;

  /**
   * TaskDefinitionParameters defines the desired state of TaskDefinition
   *
   * @schema TaskDefinitionSpec#forProvider
   */
  readonly forProvider: TaskDefinitionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TaskDefinitionSpec#managementPolicies
   */
  readonly managementPolicies?: TaskDefinitionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TaskDefinitionSpec#providerConfigRef
   */
  readonly providerConfigRef?: TaskDefinitionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TaskDefinitionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TaskDefinitionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TaskDefinitionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TaskDefinitionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TaskDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpec(obj: TaskDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TaskDefinitionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TaskDefinitionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TaskDefinitionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TaskDefinitionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TaskDefinitionSpecDeletionPolicy
 */
export enum TaskDefinitionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TaskDefinitionParameters defines the desired state of TaskDefinition
 *
 * @schema TaskDefinitionSpecForProvider
 */
export interface TaskDefinitionSpecForProvider {
  /**
   * A list of container definitions in JSON format that describe the different containers that make up your task.
   *
   * @schema TaskDefinitionSpecForProvider#containerDefinitions
   */
  readonly containerDefinitions: TaskDefinitionSpecForProviderContainerDefinitions[];

  /**
   * The number of CPU units used by the task. It can be expressed as an integer using CPU units (for example, 1024) or as a string using vCPUs (for example, 1 vCPU or 1 vcpu) in a task definition. String values are converted to an integer indicating the CPU units when the task definition is registered.
   * Task-level CPU and memory parameters are ignored for Windows containers. We recommend specifying container-level resources for Windows containers.
   * If you're using the EC2 launch type, this field is optional. Supported values are between 128 CPU units (0.125 vCPUs) and 10240 CPU units (10 vCPUs). If you do not specify a value, the parameter is ignored.
   * If you're using the Fargate launch type, this field is required and you must use one of the following values, which determines your range of supported values for the memory parameter:
   * The CPU units cannot be less than 1 vCPU when you use Windows containers on Fargate.
   * * 256 (.25 vCPU) - Available memory values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB)
   * * 512 (.5 vCPU) - Available memory values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB)
   * * 1024 (1 vCPU) - Available memory values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB)
   * * 2048 (2 vCPU) - Available memory values: 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB)
   * * 4096 (4 vCPU) - Available memory values: 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB)
   * * 8192 (8 vCPU) - Available memory values: 16 GB and 60 GB in 4 GB increments This option requires Linux platform 1.4.0 or later.
   * * 16384 (16vCPU) - Available memory values: 32GB and 120 GB in 8 GB increments This option requires Linux platform 1.4.0 or later.
   *
   * @schema TaskDefinitionSpecForProvider#cpu
   */
  readonly cpu?: string;

  /**
   * The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on Fargate. For more information, see Fargate task storage (https://docs.aws.amazon.com/AmazonECS/latest/userguide/using_data_volumes.html) in the Amazon ECS User Guide for Fargate.
   * For tasks using the Fargate launch type, the task requires the following platforms:
   * * Linux platform version 1.4.0 or later.
   * * Windows platform version 1.0.0 or later.
   *
   * @schema TaskDefinitionSpecForProvider#ephemeralStorage
   */
  readonly ephemeralStorage?: TaskDefinitionSpecForProviderEphemeralStorage;

  /**
   * The Amazon Resource Name (ARN) of the task execution role that grants the Amazon ECS container agent permission to make Amazon Web Services API calls on your behalf. The task execution IAM role is required depending on the requirements of your task. For more information, see Amazon ECS task execution IAM role (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleARN
   */
  readonly executionRoleArn?: string;

  /**
   * A Reference to a named object.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleARNRef
   */
  readonly executionRoleArnRef?: TaskDefinitionSpecForProviderExecutionRoleArnRef;

  /**
   * A Selector selects an object.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleARNSelector
   */
  readonly executionRoleArnSelector?: TaskDefinitionSpecForProviderExecutionRoleArnSelector;

  /**
   * You must specify a family for a task definition. You can use it track multiple versions of the same task definition. The family is used as a name for your task definition. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed.
   *
   * @schema TaskDefinitionSpecForProvider#family
   */
  readonly family: string;

  /**
   * The Elastic Inference accelerators to use for the containers in the task.
   *
   * @schema TaskDefinitionSpecForProvider#inferenceAccelerators
   */
  readonly inferenceAccelerators?: TaskDefinitionSpecForProviderInferenceAccelerators[];

  /**
   * The IPC resource namespace to use for the containers in the task. The valid values are host, task, or none. If host is specified, then all containers within the tasks that specified the host IPC mode on the same container instance share the same IPC resources with the host Amazon EC2 instance. If task is specified, all containers within the specified task share the same IPC resources. If none is specified, then IPC resources within the containers of a task are private and not shared with other containers in a task or on the container instance. If no value is specified, then the IPC resource namespace sharing depends on the Docker daemon setting on the container instance. For more information, see IPC settings (https://docs.docker.com/engine/reference/run/#ipc-settings---ipc) in the Docker run reference.
   * If the host IPC mode is used, be aware that there is a heightened risk of undesired IPC namespace expose. For more information, see Docker security (https://docs.docker.com/engine/security/security/).
   * If you are setting namespaced kernel parameters using systemControls for the containers in the task, the following will apply to your IPC resource namespace. For more information, see System Controls (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html) in the Amazon Elastic Container Service Developer Guide.
   * * For tasks that use the host IPC mode, IPC namespace related systemControls are not supported.
   * * For tasks that use the task IPC mode, IPC namespace related systemControls will apply to all containers within a task.
   * This parameter is not supported for Windows containers or tasks run on Fargate.
   *
   * @schema TaskDefinitionSpecForProvider#ipcMode
   */
  readonly ipcMode?: string;

  /**
   * The amount of memory (in MiB) used by the task. It can be expressed as an integer using MiB (for example ,1024) or as a string using GB (for example, 1GB or 1 GB) in a task definition. String values are converted to an integer indicating the MiB when the task definition is registered.
   * Task-level CPU and memory parameters are ignored for Windows containers. We recommend specifying container-level resources for Windows containers.
   * If using the EC2 launch type, this field is optional.
   * If using the Fargate launch type, this field is required and you must use one of the following values. This determines your range of supported values for the cpu parameter.
   * The CPU units cannot be less than 1 vCPU when you use Windows containers on Fargate.
   * * 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU)
   * * 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU)
   * * 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU)
   * * Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU)
   * * Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU)
   * * Between 16 GB and 60 GB in 4 GB increments - Available cpu values: 8192 (8 vCPU) This option requires Linux platform 1.4.0 or later.
   * * Between 32GB and 120 GB in 8 GB increments - Available cpu values: 16384 (16 vCPU) This option requires Linux platform 1.4.0 or later.
   *
   * @schema TaskDefinitionSpecForProvider#memory
   */
  readonly memory?: string;

  /**
   * The Docker networking mode to use for the containers in the task. The valid values are none, bridge, awsvpc, and host. If no network mode is specified, the default is bridge.
   * For Amazon ECS tasks on Fargate, the awsvpc network mode is required. For Amazon ECS tasks on Amazon EC2 Linux instances, any network mode can be used. For Amazon ECS tasks on Amazon EC2 Windows instances, <default> or awsvpc can be used. If the network mode is set to none, you cannot specify port mappings in your container definitions, and the tasks containers do not have external connectivity. The host and awsvpc network modes offer the highest networking performance for containers because they use the EC2 network stack instead of the virtualized network stack provided by the bridge mode.
   * With the host and awsvpc network modes, exposed container ports are mapped directly to the corresponding host port (for the host network mode) or the attached elastic network interface port (for the awsvpc network mode), so you cannot take advantage of dynamic host port mappings.
   * When using the host network mode, you should not run containers using the root user (UID 0). It is considered best practice to use a non-root user.
   * If the network mode is awsvpc, the task is allocated an elastic network interface, and you must specify a NetworkConfiguration value when you create a service or run a task with the task definition. For more information, see Task Networking (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the Amazon Elastic Container Service Developer Guide.
   * If the network mode is host, you cannot run multiple instantiations of the same task on a single container instance when port mappings are used.
   * For more information, see Network settings (https://docs.docker.com/engine/reference/run/#network-settings) in the Docker run reference.
   *
   * @schema TaskDefinitionSpecForProvider#networkMode
   */
  readonly networkMode?: string;

  /**
   * The process namespace to use for the containers in the task. The valid values are host or task. If host is specified, then all containers within the tasks that specified the host PID mode on the same container instance share the same process namespace with the host Amazon EC2 instance. If task is specified, all containers within the specified task share the same process namespace. If no value is specified, the default is a private namespace. For more information, see PID settings (https://docs.docker.com/engine/reference/run/#pid-settings---pid) in the Docker run reference.
   * If the host PID mode is used, be aware that there is a heightened risk of undesired process namespace expose. For more information, see Docker security (https://docs.docker.com/engine/security/security/).
   * This parameter is not supported for Windows containers or tasks run on Fargate.
   *
   * @schema TaskDefinitionSpecForProvider#pidMode
   */
  readonly pidMode?: string;

  /**
   * An array of placement constraint objects to use for the task. You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition and those specified at runtime.
   *
   * @schema TaskDefinitionSpecForProvider#placementConstraints
   */
  readonly placementConstraints?: TaskDefinitionSpecForProviderPlacementConstraints[];

  /**
   * The configuration details for the App Mesh proxy.
   * For tasks hosted on Amazon EC2 instances, the container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ecs-init package to use a proxy configuration. If your container instances are launched from the Amazon ECS-optimized AMI version 20190301 or later, then they contain the required versions of the container agent and ecs-init. For more information, see Amazon ECS-optimized AMI versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-ami-versions.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProvider#proxyConfiguration
   */
  readonly proxyConfiguration?: TaskDefinitionSpecForProviderProxyConfiguration;

  /**
   * Region is which region the TaskDefinition will be created.
   *
   * @schema TaskDefinitionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The task launch type that Amazon ECS validates the task definition against. A client exception is returned if the task definition doesn't validate against the compatibilities specified. If no value is specified, the parameter is omitted from the response.
   *
   * @schema TaskDefinitionSpecForProvider#requiresCompatibilities
   */
  readonly requiresCompatibilities?: string[];

  /**
   * The operating system that your tasks definitions run on. A platform family is specified only for tasks using the Fargate launch type.
   * When you specify a task definition in a service, this value must match the runtimePlatform value of the service.
   *
   * @schema TaskDefinitionSpecForProvider#runtimePlatform
   */
  readonly runtimePlatform?: TaskDefinitionSpecForProviderRuntimePlatform;

  /**
   * The metadata that you apply to the task definition to help you categorize and organize them. Each tag consists of a key and an optional value. You define both of them.
   * The following basic restrictions apply to tags:
   * * Maximum number of tags per resource - 50
   * * For each resource, each tag key must be unique, and each tag key can have only one value.
   * * Maximum key length - 128 Unicode characters in UTF-8
   * * Maximum value length - 256 Unicode characters in UTF-8
   * * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
   * * Tag keys and values are case-sensitive.
   * * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
   *
   * @schema TaskDefinitionSpecForProvider#tags
   */
  readonly tags?: TaskDefinitionSpecForProviderTags[];

  /**
   * The short name or full Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role. For more information, see IAM Roles for Tasks (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html) in the Amazon Elastic Container Service Developer Guide. A list of volume definitions in JSON format that containers in your task may use.
   *
   * @schema TaskDefinitionSpecForProvider#taskRoleARN
   */
  readonly taskRoleArn?: string;

  /**
   * A Reference to a named object.
   *
   * @schema TaskDefinitionSpecForProvider#taskRoleARNRef
   */
  readonly taskRoleArnRef?: TaskDefinitionSpecForProviderTaskRoleArnRef;

  /**
   * A Selector selects an object.
   *
   * @schema TaskDefinitionSpecForProvider#taskRoleARNSelector
   */
  readonly taskRoleArnSelector?: TaskDefinitionSpecForProviderTaskRoleArnSelector;

  /**
   * @schema TaskDefinitionSpecForProvider#volumes
   */
  readonly volumes?: TaskDefinitionSpecForProviderVolumes[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProvider(obj: TaskDefinitionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerDefinitions': obj.containerDefinitions?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitions(y)),
    'cpu': obj.cpu,
    'ephemeralStorage': toJson_TaskDefinitionSpecForProviderEphemeralStorage(obj.ephemeralStorage),
    'executionRoleARN': obj.executionRoleArn,
    'executionRoleARNRef': toJson_TaskDefinitionSpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleARNSelector': toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'family': obj.family,
    'inferenceAccelerators': obj.inferenceAccelerators?.map(y => toJson_TaskDefinitionSpecForProviderInferenceAccelerators(y)),
    'ipcMode': obj.ipcMode,
    'memory': obj.memory,
    'networkMode': obj.networkMode,
    'pidMode': obj.pidMode,
    'placementConstraints': obj.placementConstraints?.map(y => toJson_TaskDefinitionSpecForProviderPlacementConstraints(y)),
    'proxyConfiguration': toJson_TaskDefinitionSpecForProviderProxyConfiguration(obj.proxyConfiguration),
    'region': obj.region,
    'requiresCompatibilities': obj.requiresCompatibilities?.map(y => y),
    'runtimePlatform': toJson_TaskDefinitionSpecForProviderRuntimePlatform(obj.runtimePlatform),
    'tags': obj.tags?.map(y => toJson_TaskDefinitionSpecForProviderTags(y)),
    'taskRoleARN': obj.taskRoleArn,
    'taskRoleARNRef': toJson_TaskDefinitionSpecForProviderTaskRoleArnRef(obj.taskRoleArnRef),
    'taskRoleARNSelector': toJson_TaskDefinitionSpecForProviderTaskRoleArnSelector(obj.taskRoleArnSelector),
    'volumes': obj.volumes?.map(y => toJson_TaskDefinitionSpecForProviderVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TaskDefinitionSpecManagementPolicies
 */
export enum TaskDefinitionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TaskDefinitionSpecProviderConfigRef
 */
export interface TaskDefinitionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecProviderConfigRef#policy
   */
  readonly policy?: TaskDefinitionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecProviderConfigRef(obj: TaskDefinitionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsTo
 */
export interface TaskDefinitionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TaskDefinitionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TaskDefinitionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsTo(obj: TaskDefinitionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TaskDefinitionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TaskDefinitionSpecWriteConnectionSecretToRef
 */
export interface TaskDefinitionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TaskDefinitionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TaskDefinitionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecWriteConnectionSecretToRef(obj: TaskDefinitionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitions
 */
export interface TaskDefinitionSpecForProviderContainerDefinitions {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#command
   */
  readonly command?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#cpu
   */
  readonly cpu?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#credentialSpecs
   */
  readonly credentialSpecs?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#dependsOn
   */
  readonly dependsOn?: TaskDefinitionSpecForProviderContainerDefinitionsDependsOn[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#disableNetworking
   */
  readonly disableNetworking?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#dnsSearchDomains
   */
  readonly dnsSearchDomains?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#dnsServers
   */
  readonly dnsServers?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#dockerLabels
   */
  readonly dockerLabels?: { [key: string]: string };

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#dockerSecurityOptions
   */
  readonly dockerSecurityOptions?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#entryPoint
   */
  readonly entryPoint?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#environment
   */
  readonly environment?: TaskDefinitionSpecForProviderContainerDefinitionsEnvironment[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#environmentFiles
   */
  readonly environmentFiles?: TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#essential
   */
  readonly essential?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#extraHosts
   */
  readonly extraHosts?: TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts[];

  /**
   * The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see Custom log routing (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#firelensConfiguration
   */
  readonly firelensConfiguration?: TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration;

  /**
   * An object representing a container health check. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image (such as those specified in a parent image or from the image's Dockerfile). This configuration maps to the HEALTHCHECK parameter of docker run (https://docs.docker.com/engine/reference/run/).
   * The Amazon ECS container agent only monitors and reports on the health checks specified in the task definition. Amazon ECS does not monitor Docker health checks that are embedded in a container image and not specified in the container definition. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image.
   * You can view the health status of both individual containers and a task with the DescribeTasks API operation or when viewing the task details in the console.
   * The health check is designed to make sure that your containers survive agent restarts, upgrades, or temporary unavailability.
   * The following describes the possible healthStatus values for a container:
   * * HEALTHY-The container health check has passed successfully.
   * * UNHEALTHY-The container health check has failed.
   * * UNKNOWN-The container health check is being evaluated or there's no container health check defined.
   * The following describes the possible healthStatus values for a task. The container health check status of non-essential containers don't have an effect on the health status of a task.
   * * HEALTHY-All essential containers within the task have passed their health checks.
   * * UNHEALTHY-One or more essential containers have failed their health check.
   * * UNKNOWN-The essential containers within the task are still having their health checks evaluated, there are only nonessential containers with health checks defined, or there are no container health checks defined.
   * If a task is run manually, and not as part of a service, the task will continue its lifecycle regardless of its health status. For tasks that are part of a service, if the task reports as unhealthy then the task will be stopped and the service scheduler will replace it.
   * The following are notes about container health check support:
   * * When the Amazon ECS agent cannot connect to the Amazon ECS service, the service reports the container as UNHEALTHY.
   * * The health check statuses are the "last heard from" response from the Amazon ECS agent. There are no assumptions made about the status of the container health checks.
   * * Container health checks require version 1.17.0 or greater of the Amazon ECS container agent. For more information, see Updating the Amazon ECS container agent (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html).
   * * Container health checks are supported for Fargate tasks if you're using platform version 1.1.0 or greater. For more information, see Fargate platform versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
   * * Container health checks aren't supported for tasks that are part of a service that's configured to use a Classic Load Balancer.
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#healthCheck
   */
  readonly healthCheck?: TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#hostname
   */
  readonly hostname?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#image
   */
  readonly image?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#interactive
   */
  readonly interactive?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#links
   */
  readonly links?: string[];

  /**
   * The Linux-specific options that are applied to the container, such as Linux KernelCapabilities (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#linuxParameters
   */
  readonly linuxParameters?: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters;

  /**
   * The log configuration for the container. This parameter maps to LogConfig in the Create a container (https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the Docker Remote API (https://docs.docker.com/engine/api/v1.35/) and the --log-driver option to docker run (https://docs.docker.com/engine/reference/commandline/run/).
   * By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see Configure logging drivers (https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.
   * Understand the following when specifying a log configuration for your containers.
   * * Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on Fargate, the supported log drivers are awslogs, splunk, and awsfirelens. For tasks hosted on Amazon EC2 instances, the supported log drivers are awslogs, fluentd, gelf, json-file, journald, logentries,syslog, splunk, and awsfirelens.
   * * This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.
   * * For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ECS_AVAILABLE_LOGGING_DRIVERS environment variable before containers placed on that instance can use these log configuration options. For more information, see Amazon ECS container agent configuration (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the Amazon Elastic Container Service Developer Guide.
   * * For tasks that are on Fargate, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#logConfiguration
   */
  readonly logConfiguration?: TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#memory
   */
  readonly memory?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#memoryReservation
   */
  readonly memoryReservation?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#mountPoints
   */
  readonly mountPoints?: TaskDefinitionSpecForProviderContainerDefinitionsMountPoints[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#portMappings
   */
  readonly portMappings?: TaskDefinitionSpecForProviderContainerDefinitionsPortMappings[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#pseudoTerminal
   */
  readonly pseudoTerminal?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#readonlyRootFilesystem
   */
  readonly readonlyRootFilesystem?: boolean;

  /**
   * The repository credentials for private registry authentication.
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#repositoryCredentials
   */
  readonly repositoryCredentials?: TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#resourceRequirements
   */
  readonly resourceRequirements?: TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#secrets
   */
  readonly secrets?: TaskDefinitionSpecForProviderContainerDefinitionsSecrets[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#startTimeout
   */
  readonly startTimeout?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#stopTimeout
   */
  readonly stopTimeout?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#systemControls
   */
  readonly systemControls?: TaskDefinitionSpecForProviderContainerDefinitionsSystemControls[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#ulimits
   */
  readonly ulimits?: TaskDefinitionSpecForProviderContainerDefinitionsUlimits[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#user
   */
  readonly user?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#volumesFrom
   */
  readonly volumesFrom?: TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitions#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitions(obj: TaskDefinitionSpecForProviderContainerDefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'cpu': obj.cpu,
    'credentialSpecs': obj.credentialSpecs?.map(y => y),
    'dependsOn': obj.dependsOn?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsDependsOn(y)),
    'disableNetworking': obj.disableNetworking,
    'dnsSearchDomains': obj.dnsSearchDomains?.map(y => y),
    'dnsServers': obj.dnsServers?.map(y => y),
    'dockerLabels': ((obj.dockerLabels) === undefined) ? undefined : (Object.entries(obj.dockerLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'dockerSecurityOptions': obj.dockerSecurityOptions?.map(y => y),
    'entryPoint': obj.entryPoint?.map(y => y),
    'environment': obj.environment?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsEnvironment(y)),
    'environmentFiles': obj.environmentFiles?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles(y)),
    'essential': obj.essential,
    'extraHosts': obj.extraHosts?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts(y)),
    'firelensConfiguration': toJson_TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration(obj.firelensConfiguration),
    'healthCheck': toJson_TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck(obj.healthCheck),
    'hostname': obj.hostname,
    'image': obj.image,
    'interactive': obj.interactive,
    'links': obj.links?.map(y => y),
    'linuxParameters': toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters(obj.linuxParameters),
    'logConfiguration': toJson_TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration(obj.logConfiguration),
    'memory': obj.memory,
    'memoryReservation': obj.memoryReservation,
    'mountPoints': obj.mountPoints?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsMountPoints(y)),
    'name': obj.name,
    'portMappings': obj.portMappings?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsPortMappings(y)),
    'privileged': obj.privileged,
    'pseudoTerminal': obj.pseudoTerminal,
    'readonlyRootFilesystem': obj.readonlyRootFilesystem,
    'repositoryCredentials': toJson_TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials(obj.repositoryCredentials),
    'resourceRequirements': obj.resourceRequirements?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements(y)),
    'secrets': obj.secrets?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsSecrets(y)),
    'startTimeout': obj.startTimeout,
    'stopTimeout': obj.stopTimeout,
    'systemControls': obj.systemControls?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsSystemControls(y)),
    'ulimits': obj.ulimits?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsUlimits(y)),
    'user': obj.user,
    'volumesFrom': obj.volumesFrom?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom(y)),
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on Fargate. For more information, see Fargate task storage (https://docs.aws.amazon.com/AmazonECS/latest/userguide/using_data_volumes.html) in the Amazon ECS User Guide for Fargate.
 * For tasks using the Fargate launch type, the task requires the following platforms:
 * * Linux platform version 1.4.0 or later.
 * * Windows platform version 1.0.0 or later.
 *
 * @schema TaskDefinitionSpecForProviderEphemeralStorage
 */
export interface TaskDefinitionSpecForProviderEphemeralStorage {
  /**
   * @schema TaskDefinitionSpecForProviderEphemeralStorage#sizeInGiB
   */
  readonly sizeInGiB?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderEphemeralStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderEphemeralStorage(obj: TaskDefinitionSpecForProviderEphemeralStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sizeInGiB': obj.sizeInGiB,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnRef(obj: TaskDefinitionSpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelector(obj: TaskDefinitionSpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderInferenceAccelerators
 */
export interface TaskDefinitionSpecForProviderInferenceAccelerators {
  /**
   * @schema TaskDefinitionSpecForProviderInferenceAccelerators#deviceName
   */
  readonly deviceName?: string;

  /**
   * @schema TaskDefinitionSpecForProviderInferenceAccelerators#deviceType
   */
  readonly deviceType?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderInferenceAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderInferenceAccelerators(obj: TaskDefinitionSpecForProviderInferenceAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'deviceType': obj.deviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderPlacementConstraints
 */
export interface TaskDefinitionSpecForProviderPlacementConstraints {
  /**
   * @schema TaskDefinitionSpecForProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * @schema TaskDefinitionSpecForProviderPlacementConstraints#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderPlacementConstraints(obj: TaskDefinitionSpecForProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration details for the App Mesh proxy.
 * For tasks hosted on Amazon EC2 instances, the container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ecs-init package to use a proxy configuration. If your container instances are launched from the Amazon ECS-optimized AMI version 20190301 or later, then they contain the required versions of the container agent and ecs-init. For more information, see Amazon ECS-optimized AMI versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-ami-versions.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema TaskDefinitionSpecForProviderProxyConfiguration
 */
export interface TaskDefinitionSpecForProviderProxyConfiguration {
  /**
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#containerName
   */
  readonly containerName?: string;

  /**
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#properties
   */
  readonly properties?: TaskDefinitionSpecForProviderProxyConfigurationProperties[];

  /**
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderProxyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderProxyConfiguration(obj: TaskDefinitionSpecForProviderProxyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'properties': obj.properties?.map(y => toJson_TaskDefinitionSpecForProviderProxyConfigurationProperties(y)),
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The operating system that your tasks definitions run on. A platform family is specified only for tasks using the Fargate launch type.
 * When you specify a task definition in a service, this value must match the runtimePlatform value of the service.
 *
 * @schema TaskDefinitionSpecForProviderRuntimePlatform
 */
export interface TaskDefinitionSpecForProviderRuntimePlatform {
  /**
   * @schema TaskDefinitionSpecForProviderRuntimePlatform#cpuArchitecture
   */
  readonly cpuArchitecture?: string;

  /**
   * @schema TaskDefinitionSpecForProviderRuntimePlatform#operatingSystemFamily
   */
  readonly operatingSystemFamily?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderRuntimePlatform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderRuntimePlatform(obj: TaskDefinitionSpecForProviderRuntimePlatform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuArchitecture': obj.cpuArchitecture,
    'operatingSystemFamily': obj.operatingSystemFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderTags
 */
export interface TaskDefinitionSpecForProviderTags {
  /**
   * @schema TaskDefinitionSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TaskDefinitionSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderTags(obj: TaskDefinitionSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnRef
 */
export interface TaskDefinitionSpecForProviderTaskRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnRef#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderTaskRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderTaskRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderTaskRoleArnRef(obj: TaskDefinitionSpecForProviderTaskRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecForProviderTaskRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnSelector
 */
export interface TaskDefinitionSpecForProviderTaskRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnSelector#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderTaskRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderTaskRoleArnSelector(obj: TaskDefinitionSpecForProviderTaskRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomVolume provides custom parameters for the Volume type
 *
 * @schema TaskDefinitionSpecForProviderVolumes
 */
export interface TaskDefinitionSpecForProviderVolumes {
  /**
   * This parameter is specified when you are using Docker volumes. Docker volumes are only supported when you are using the EC2 launch type. Windows containers only support the use of the local driver. To use bind mounts, specify a host instead.
   *
   * @schema TaskDefinitionSpecForProviderVolumes#dockerVolumeConfiguration
   */
  readonly dockerVolumeConfiguration?: TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration;

  /**
   * This parameter is specified when you are using an Amazon Elastic File System file system for task storage. For more information, see Amazon EFS Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderVolumes#efsVolumeConfiguration
   */
  readonly efsVolumeConfiguration?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration;

  /**
   * This parameter is specified when you are using Amazon FSx for Windows File Server (https://docs.aws.amazon.com/fsx/latest/WindowsGuide/what-is.html) file system for task storage.
   * For more information and the input format, see Amazon FSx for Windows File Server Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderVolumes#fsxWindowsFileServerVolumeConfiguration
   */
  readonly fsxWindowsFileServerVolumeConfiguration?: TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration;

  /**
   * Details on a container instance bind mount host volume.
   *
   * @schema TaskDefinitionSpecForProviderVolumes#host
   */
  readonly host?: TaskDefinitionSpecForProviderVolumesHost;

  /**
   * @schema TaskDefinitionSpecForProviderVolumes#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumes(obj: TaskDefinitionSpecForProviderVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerVolumeConfiguration': toJson_TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration(obj.dockerVolumeConfiguration),
    'efsVolumeConfiguration': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration(obj.efsVolumeConfiguration),
    'fsxWindowsFileServerVolumeConfiguration': toJson_TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration(obj.fsxWindowsFileServerVolumeConfiguration),
    'host': toJson_TaskDefinitionSpecForProviderVolumesHost(obj.host),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicy
 */
export interface TaskDefinitionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecProviderConfigRefPolicy(obj: TaskDefinitionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRef(obj: TaskDefinitionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToMetadata(obj: TaskDefinitionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsDependsOn
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsDependsOn {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsDependsOn#condition
   */
  readonly condition?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsDependsOn#containerName
   */
  readonly containerName?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsDependsOn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsDependsOn(obj: TaskDefinitionSpecForProviderContainerDefinitionsDependsOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition,
    'containerName': obj.containerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironment
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsEnvironment {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironment#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironment#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsEnvironment(obj: TaskDefinitionSpecForProviderContainerDefinitionsEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles#type_
   */
  readonly type?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles(obj: TaskDefinitionSpecForProviderContainerDefinitionsEnvironmentFiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts#hostname
   */
  readonly hostname?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts#ipAddress
   */
  readonly ipAddress?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts(obj: TaskDefinitionSpecForProviderContainerDefinitionsExtraHosts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'ipAddress': obj.ipAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see Custom log routing (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration#options
   */
  readonly options?: { [key: string]: string };

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration(obj: TaskDefinitionSpecForProviderContainerDefinitionsFirelensConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object representing a container health check. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image (such as those specified in a parent image or from the image's Dockerfile). This configuration maps to the HEALTHCHECK parameter of docker run (https://docs.docker.com/engine/reference/run/).
 * The Amazon ECS container agent only monitors and reports on the health checks specified in the task definition. Amazon ECS does not monitor Docker health checks that are embedded in a container image and not specified in the container definition. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image.
 * You can view the health status of both individual containers and a task with the DescribeTasks API operation or when viewing the task details in the console.
 * The health check is designed to make sure that your containers survive agent restarts, upgrades, or temporary unavailability.
 * The following describes the possible healthStatus values for a container:
 * * HEALTHY-The container health check has passed successfully.
 * * UNHEALTHY-The container health check has failed.
 * * UNKNOWN-The container health check is being evaluated or there's no container health check defined.
 * The following describes the possible healthStatus values for a task. The container health check status of non-essential containers don't have an effect on the health status of a task.
 * * HEALTHY-All essential containers within the task have passed their health checks.
 * * UNHEALTHY-One or more essential containers have failed their health check.
 * * UNKNOWN-The essential containers within the task are still having their health checks evaluated, there are only nonessential containers with health checks defined, or there are no container health checks defined.
 * If a task is run manually, and not as part of a service, the task will continue its lifecycle regardless of its health status. For tasks that are part of a service, if the task reports as unhealthy then the task will be stopped and the service scheduler will replace it.
 * The following are notes about container health check support:
 * * When the Amazon ECS agent cannot connect to the Amazon ECS service, the service reports the container as UNHEALTHY.
 * * The health check statuses are the "last heard from" response from the Amazon ECS agent. There are no assumptions made about the status of the container health checks.
 * * Container health checks require version 1.17.0 or greater of the Amazon ECS container agent. For more information, see Updating the Amazon ECS container agent (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html).
 * * Container health checks are supported for Fargate tasks if you're using platform version 1.1.0 or greater. For more information, see Fargate platform versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
 * * Container health checks aren't supported for tasks that are part of a service that's configured to use a Classic Load Balancer.
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck#command
   */
  readonly command?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck#interval
   */
  readonly interval?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck#retries
   */
  readonly retries?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck#startPeriod
   */
  readonly startPeriod?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck#timeout
   */
  readonly timeout?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck(obj: TaskDefinitionSpecForProviderContainerDefinitionsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'interval': obj.interval,
    'retries': obj.retries,
    'startPeriod': obj.startPeriod,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Linux-specific options that are applied to the container, such as Linux KernelCapabilities (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters {
  /**
   * The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker. For more information about the default capabilities and the non-default available capabilities, see Runtime privilege and Linux capabilities (https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities) in the Docker run reference. For more detailed information about these Linux capabilities, see the capabilities(7) (http://man7.org/linux/man-pages/man7/capabilities.7.html) Linux manual page.
   *
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#capabilities
   */
  readonly capabilities?: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#devices
   */
  readonly devices?: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#initProcessEnabled
   */
  readonly initProcessEnabled?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#maxSwap
   */
  readonly maxSwap?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#sharedMemorySize
   */
  readonly sharedMemorySize?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#swappiness
   */
  readonly swappiness?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters#tmpfs
   */
  readonly tmpfs?: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters(obj: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capabilities': toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities(obj.capabilities),
    'devices': obj.devices?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices(y)),
    'initProcessEnabled': obj.initProcessEnabled,
    'maxSwap': obj.maxSwap,
    'sharedMemorySize': obj.sharedMemorySize,
    'swappiness': obj.swappiness,
    'tmpfs': obj.tmpfs?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The log configuration for the container. This parameter maps to LogConfig in the Create a container (https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the Docker Remote API (https://docs.docker.com/engine/api/v1.35/) and the --log-driver option to docker run (https://docs.docker.com/engine/reference/commandline/run/).
 * By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see Configure logging drivers (https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.
 * Understand the following when specifying a log configuration for your containers.
 * * Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on Fargate, the supported log drivers are awslogs, splunk, and awsfirelens. For tasks hosted on Amazon EC2 instances, the supported log drivers are awslogs, fluentd, gelf, json-file, journald, logentries,syslog, splunk, and awsfirelens.
 * * This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.
 * * For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ECS_AVAILABLE_LOGGING_DRIVERS environment variable before containers placed on that instance can use these log configuration options. For more information, see Amazon ECS container agent configuration (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the Amazon Elastic Container Service Developer Guide.
 * * For tasks that are on Fargate, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration#logDriver
   */
  readonly logDriver?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration#options
   */
  readonly options?: { [key: string]: string };

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration#secretOptions
   */
  readonly secretOptions?: TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration(obj: TaskDefinitionSpecForProviderContainerDefinitionsLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDriver': obj.logDriver,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secretOptions': obj.secretOptions?.map(y => toJson_TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsMountPoints
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsMountPoints {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsMountPoints#containerPath
   */
  readonly containerPath?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsMountPoints#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsMountPoints#sourceVolume
   */
  readonly sourceVolume?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsMountPoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsMountPoints(obj: TaskDefinitionSpecForProviderContainerDefinitionsMountPoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPath': obj.containerPath,
    'readOnly': obj.readOnly,
    'sourceVolume': obj.sourceVolume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsPortMappings {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#appProtocol
   */
  readonly appProtocol?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#containerPort
   */
  readonly containerPort?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#containerPortRange
   */
  readonly containerPortRange?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#hostPort
   */
  readonly hostPort?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsPortMappings#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsPortMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsPortMappings(obj: TaskDefinitionSpecForProviderContainerDefinitionsPortMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appProtocol': obj.appProtocol,
    'containerPort': obj.containerPort,
    'containerPortRange': obj.containerPortRange,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The repository credentials for private registry authentication.
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials#credentialsParameter
   */
  readonly credentialsParameter?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials(obj: TaskDefinitionSpecForProviderContainerDefinitionsRepositoryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialsParameter': obj.credentialsParameter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements#type_
   */
  readonly type?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements(obj: TaskDefinitionSpecForProviderContainerDefinitionsResourceRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsSecrets
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsSecrets {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsSecrets#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsSecrets#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsSecrets(obj: TaskDefinitionSpecForProviderContainerDefinitionsSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsSystemControls
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsSystemControls {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsSystemControls#namespace
   */
  readonly namespace?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsSystemControls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsSystemControls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsSystemControls(obj: TaskDefinitionSpecForProviderContainerDefinitionsSystemControls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsUlimits
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsUlimits {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsUlimits#hardLimit
   */
  readonly hardLimit?: number;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsUlimits#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsUlimits#softLimit
   */
  readonly softLimit?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsUlimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsUlimits(obj: TaskDefinitionSpecForProviderContainerDefinitionsUlimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hardLimit': obj.hardLimit,
    'name': obj.name,
    'softLimit': obj.softLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom#sourceContainer
   */
  readonly sourceContainer?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom(obj: TaskDefinitionSpecForProviderContainerDefinitionsVolumesFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'sourceContainer': obj.sourceContainer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy(obj: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy(obj: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderProxyConfigurationProperties
 */
export interface TaskDefinitionSpecForProviderProxyConfigurationProperties {
  /**
   * @schema TaskDefinitionSpecForProviderProxyConfigurationProperties#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderProxyConfigurationProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderProxyConfigurationProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderProxyConfigurationProperties(obj: TaskDefinitionSpecForProviderProxyConfigurationProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnRefPolicy
 */
export interface TaskDefinitionSpecForProviderTaskRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderTaskRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderTaskRoleArnRefPolicy(obj: TaskDefinitionSpecForProviderTaskRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy
 */
export interface TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy(obj: TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This parameter is specified when you are using Docker volumes. Docker volumes are only supported when you are using the EC2 launch type. Windows containers only support the use of the local driver. To use bind mounts, specify a host instead.
 *
 * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration {
  /**
   * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration#autoprovision
   */
  readonly autoprovision?: boolean;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration#driver
   */
  readonly driver?: string;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration#driverOpts
   */
  readonly driverOpts?: { [key: string]: string };

  /**
   * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration#scope
   */
  readonly scope?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumesDockerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoprovision': obj.autoprovision,
    'driver': obj.driver,
    'driverOpts': ((obj.driverOpts) === undefined) ? undefined : (Object.entries(obj.driverOpts).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This parameter is specified when you are using an Amazon Elastic File System file system for task storage. For more information, see Amazon EFS Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration {
  /**
   * The authorization configuration details for the Amazon EFS file system.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#fileSystemID
   */
  readonly fileSystemId?: string;

  /**
   * A Reference to a named object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#fileSystemIDRef
   */
  readonly fileSystemIdRef?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef;

  /**
   * A Selector selects an object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#fileSystemIDSelector
   */
  readonly fileSystemIdSelector?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#transitEncryption
   */
  readonly transitEncryption?: string;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration#transitEncryptionPort
   */
  readonly transitEncryptionPort?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig(obj.authorizationConfig),
    'fileSystemID': obj.fileSystemId,
    'fileSystemIDRef': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIDSelector': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector(obj.fileSystemIdSelector),
    'rootDirectory': obj.rootDirectory,
    'transitEncryption': obj.transitEncryption,
    'transitEncryptionPort': obj.transitEncryptionPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This parameter is specified when you are using Amazon FSx for Windows File Server (https://docs.aws.amazon.com/fsx/latest/WindowsGuide/what-is.html) file system for task storage.
 * For more information and the input format, see Amazon FSx for Windows File Server Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration {
  /**
   * The authorization configuration details for Amazon FSx for Windows File Server file system. See FSxWindowsFileServerVolumeConfiguration (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_FSxWindowsFileServerVolumeConfiguration.html) in the Amazon ECS API Reference.
   * For more information and the input format, see Amazon FSx for Windows File Server Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration#fileSystemID
   */
  readonly fileSystemId?: string;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': toJson_TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(obj.authorizationConfig),
    'fileSystemID': obj.fileSystemId,
    'rootDirectory': obj.rootDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details on a container instance bind mount host volume.
 *
 * @schema TaskDefinitionSpecForProviderVolumesHost
 */
export interface TaskDefinitionSpecForProviderVolumesHost {
  /**
   * @schema TaskDefinitionSpecForProviderVolumesHost#sourcePath
   */
  readonly sourcePath?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesHost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesHost(obj: TaskDefinitionSpecForProviderVolumesHost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sourcePath': obj.sourcePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicyResolution
 */
export enum TaskDefinitionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicyResolve
 */
export enum TaskDefinitionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker. For more information about the default capabilities and the non-default available capabilities, see Runtime privilege and Linux capabilities (https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities) in the Docker run reference. For more detailed information about these Linux capabilities, see the capabilities(7) (http://man7.org/linux/man-pages/man7/capabilities.7.html) Linux manual page.
 *
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities(obj: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices#containerPath
   */
  readonly containerPath?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices#hostPath
   */
  readonly hostPath?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices#permissions
   */
  readonly permissions?: string[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices(obj: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPath': obj.containerPath,
    'hostPath': obj.hostPath,
    'permissions': obj.permissions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs#containerPath
   */
  readonly containerPath?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs#mountOptions
   */
  readonly mountOptions?: string[];

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs(obj: TaskDefinitionSpecForProviderContainerDefinitionsLinuxParametersTmpfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPath': obj.containerPath,
    'mountOptions': obj.mountOptions?.map(y => y),
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions
 */
export interface TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions {
  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions#name
   */
  readonly name?: string;

  /**
   * @schema TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions(obj: TaskDefinitionSpecForProviderContainerDefinitionsLogConfigurationSecretOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolution
 */
export enum TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolve
 */
export enum TaskDefinitionSpecForProviderTaskRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolution
 */
export enum TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolve
 */
export enum TaskDefinitionSpecForProviderTaskRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The authorization configuration details for the Amazon EFS file system.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig {
  /**
   * The Amazon EFS access point ID to use. If an access point is specified, the root directory value specified in the EFSVolumeConfiguration must either be omitted or set to / which will enforce the path set on the EFS access point. If an access point is used, transit encryption must be enabled in the EFSVolumeConfiguration. For more information, see Working with Amazon EFS Access Points (https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html) in the Amazon Elastic File System User Guide.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig#accessPointID
   */
  readonly accessPointId?: string;

  /**
   * A Reference to a named object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig#accessPointIDRef
   */
  readonly accessPointIdRef?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef;

  /**
   * A Selector selects an object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig#accessPointIDSelector
   */
  readonly accessPointIdSelector?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector;

  /**
   * Determines whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. If this parameter is omitted, the default value of DISABLED is used. For more information, see Using Amazon EFS Access Points (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the Amazon Elastic Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig#iam
   */
  readonly iam?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointID': obj.accessPointId,
    'accessPointIDRef': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef(obj.accessPointIdRef),
    'accessPointIDSelector': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector(obj.accessPointIdSelector),
    'iam': obj.iam,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The authorization configuration details for Amazon FSx for Windows File Server file system. See FSxWindowsFileServerVolumeConfiguration (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_FSxWindowsFileServerVolumeConfiguration.html) in the Amazon ECS API Reference.
 * For more information and the input format, see Amazon FSx for Windows File Server Volumes (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the Amazon Elastic Container Service Developer Guide.
 *
 * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
  /**
   * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#credentialsParameter
   */
  readonly credentialsParameter?: string;

  /**
   * @schema TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#domain
   */
  readonly domain?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecForProviderVolumesFsxWindowsFileServerVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialsParameter': obj.credentialsParameter,
    'domain': obj.domain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * A Reference to a named object.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy
 */
export interface TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy(obj: TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolution
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolve
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolution
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolve
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolution
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolve
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolution
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolve
 */
export enum TaskDefinitionSpecForProviderVolumesEfsVolumeConfigurationAuthorizationConfigAccessPointIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

