// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Broker is the Schema for the Brokers API
 *
 * @schema Broker
 */
export class Broker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Broker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mq.aws.crossplane.io/v1alpha1',
    kind: 'Broker',
  }

  /**
   * Renders a Kubernetes manifest for "Broker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BrokerProps): any {
    return {
      ...Broker.GVK,
      ...toJson_BrokerProps(props),
    };
  }

  /**
   * Defines a "Broker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BrokerProps) {
    super(scope, id, {
      ...Broker.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Broker.GVK,
      ...toJson_BrokerProps(resolved),
    };
  }
}

/**
 * Broker is the Schema for the Brokers API
 *
 * @schema Broker
 */
export interface BrokerProps {
  /**
   * @schema Broker#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BrokerSpec defines the desired state of Broker
   *
   * @schema Broker#spec
   */
  readonly spec: BrokerSpec;

}

/**
 * Converts an object of type 'BrokerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerProps(obj: BrokerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BrokerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BrokerSpec defines the desired state of Broker
 *
 * @schema BrokerSpec
 */
export interface BrokerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BrokerSpec#deletionPolicy
   */
  readonly deletionPolicy?: BrokerSpecDeletionPolicy;

  /**
   * BrokerParameters defines the desired state of Broker
   *
   * @schema BrokerSpec#forProvider
   */
  readonly forProvider: BrokerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BrokerSpec#managementPolicies
   */
  readonly managementPolicies?: BrokerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BrokerSpec#providerConfigRef
   */
  readonly providerConfigRef?: BrokerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BrokerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BrokerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BrokerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BrokerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BrokerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpec(obj: BrokerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BrokerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BrokerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BrokerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BrokerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BrokerSpecDeletionPolicy
 */
export enum BrokerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * BrokerParameters defines the desired state of Broker
 *
 * @schema BrokerSpecForProvider
 */
export interface BrokerSpecForProvider {
  /**
   * @schema BrokerSpecForProvider#authenticationStrategy
   */
  readonly authenticationStrategy?: string;

  /**
   * @schema BrokerSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade: boolean;

  /**
   * @schema BrokerSpecForProvider#configuration
   */
  readonly configuration?: BrokerSpecForProviderConfiguration;

  /**
   * @schema BrokerSpecForProvider#creatorRequestID
   */
  readonly creatorRequestId?: string;

  /**
   * @schema BrokerSpecForProvider#dataReplicationMode
   */
  readonly dataReplicationMode?: string;

  /**
   * @schema BrokerSpecForProvider#dataReplicationPrimaryBrokerARN
   */
  readonly dataReplicationPrimaryBrokerArn?: string;

  /**
   * @schema BrokerSpecForProvider#deploymentMode
   */
  readonly deploymentMode: string;

  /**
   * @schema BrokerSpecForProvider#encryptionOptions
   */
  readonly encryptionOptions?: BrokerSpecForProviderEncryptionOptions;

  /**
   * @schema BrokerSpecForProvider#engineType
   */
  readonly engineType: string;

  /**
   * @schema BrokerSpecForProvider#engineVersion
   */
  readonly engineVersion: string;

  /**
   * @schema BrokerSpecForProvider#hostInstanceType
   */
  readonly hostInstanceType: string;

  /**
   * @schema BrokerSpecForProvider#ldapServerMetadata
   */
  readonly ldapServerMetadata?: BrokerSpecForProviderLdapServerMetadata;

  /**
   * @schema BrokerSpecForProvider#logs
   */
  readonly logs?: BrokerSpecForProviderLogs;

  /**
   * @schema BrokerSpecForProvider#maintenanceWindowStartTime
   */
  readonly maintenanceWindowStartTime?: BrokerSpecForProviderMaintenanceWindowStartTime;

  /**
   * @schema BrokerSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible: boolean;

  /**
   * Region is which region the Broker will be created.
   *
   * @schema BrokerSpecForProvider#region
   */
  readonly region: string;

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupsIDs.
   *
   * @schema BrokerSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: BrokerSpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroups used to set the SecurityGroupsIDs.
   *
   * @schema BrokerSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: BrokerSpecForProviderSecurityGroupIdSelector;

  /**
   * @schema BrokerSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * @schema BrokerSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema BrokerSpecForProvider#subnetIDRefs
   */
  readonly subnetIdRefs?: BrokerSpecForProviderSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema BrokerSpecForProvider#subnetIDSelector
   */
  readonly subnetIdSelector?: BrokerSpecForProviderSubnetIdSelector;

  /**
   * @schema BrokerSpecForProvider#subnetIDs
   */
  readonly subnetIDs?: string[];

  /**
   * @schema BrokerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * @schema BrokerSpecForProvider#users
   */
  readonly users?: BrokerSpecForProviderUsers[];

}

/**
 * Converts an object of type 'BrokerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProvider(obj: BrokerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationStrategy': obj.authenticationStrategy,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'configuration': toJson_BrokerSpecForProviderConfiguration(obj.configuration),
    'creatorRequestID': obj.creatorRequestId,
    'dataReplicationMode': obj.dataReplicationMode,
    'dataReplicationPrimaryBrokerARN': obj.dataReplicationPrimaryBrokerArn,
    'deploymentMode': obj.deploymentMode,
    'encryptionOptions': toJson_BrokerSpecForProviderEncryptionOptions(obj.encryptionOptions),
    'engineType': obj.engineType,
    'engineVersion': obj.engineVersion,
    'hostInstanceType': obj.hostInstanceType,
    'ldapServerMetadata': toJson_BrokerSpecForProviderLdapServerMetadata(obj.ldapServerMetadata),
    'logs': toJson_BrokerSpecForProviderLogs(obj.logs),
    'maintenanceWindowStartTime': toJson_BrokerSpecForProviderMaintenanceWindowStartTime(obj.maintenanceWindowStartTime),
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_BrokerSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_BrokerSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'storageType': obj.storageType,
    'subnetIDRefs': obj.subnetIdRefs?.map(y => toJson_BrokerSpecForProviderSubnetIdRefs(y)),
    'subnetIDSelector': toJson_BrokerSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIDs': obj.subnetIDs?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'users': obj.users?.map(y => toJson_BrokerSpecForProviderUsers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BrokerSpecManagementPolicies
 */
export enum BrokerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BrokerSpecProviderConfigRef
 */
export interface BrokerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecProviderConfigRef#policy
   */
  readonly policy?: BrokerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BrokerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecProviderConfigRef(obj: BrokerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BrokerSpecPublishConnectionDetailsTo
 */
export interface BrokerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BrokerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BrokerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsTo(obj: BrokerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BrokerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BrokerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BrokerSpecWriteConnectionSecretToRef
 */
export interface BrokerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BrokerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BrokerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BrokerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecWriteConnectionSecretToRef(obj: BrokerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderConfiguration
 */
export interface BrokerSpecForProviderConfiguration {
  /**
   * @schema BrokerSpecForProviderConfiguration#id
   */
  readonly id?: string;

  /**
   * @schema BrokerSpecForProviderConfiguration#revision
   */
  readonly revision?: number;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfiguration(obj: BrokerSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderEncryptionOptions
 */
export interface BrokerSpecForProviderEncryptionOptions {
  /**
   * @schema BrokerSpecForProviderEncryptionOptions#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * @schema BrokerSpecForProviderEncryptionOptions#useAWSOwnedKey
   */
  readonly useAwsOwnedKey?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderEncryptionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderEncryptionOptions(obj: BrokerSpecForProviderEncryptionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyID': obj.kmsKeyId,
    'useAWSOwnedKey': obj.useAwsOwnedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderLdapServerMetadata
 */
export interface BrokerSpecForProviderLdapServerMetadata {
  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#hosts
   */
  readonly hosts?: string[];

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#roleBase
   */
  readonly roleBase?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#roleName
   */
  readonly roleName?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#roleSearchMatching
   */
  readonly roleSearchMatching?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#roleSearchSubtree
   */
  readonly roleSearchSubtree?: boolean;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#serviceAccountPassword
   */
  readonly serviceAccountPassword?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#serviceAccountUsername
   */
  readonly serviceAccountUsername?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#userBase
   */
  readonly userBase?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#userRoleName
   */
  readonly userRoleName?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#userSearchMatching
   */
  readonly userSearchMatching?: string;

  /**
   * @schema BrokerSpecForProviderLdapServerMetadata#userSearchSubtree
   */
  readonly userSearchSubtree?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderLdapServerMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderLdapServerMetadata(obj: BrokerSpecForProviderLdapServerMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'roleBase': obj.roleBase,
    'roleName': obj.roleName,
    'roleSearchMatching': obj.roleSearchMatching,
    'roleSearchSubtree': obj.roleSearchSubtree,
    'serviceAccountPassword': obj.serviceAccountPassword,
    'serviceAccountUsername': obj.serviceAccountUsername,
    'userBase': obj.userBase,
    'userRoleName': obj.userRoleName,
    'userSearchMatching': obj.userSearchMatching,
    'userSearchSubtree': obj.userSearchSubtree,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderLogs
 */
export interface BrokerSpecForProviderLogs {
  /**
   * @schema BrokerSpecForProviderLogs#audit
   */
  readonly audit?: boolean;

  /**
   * @schema BrokerSpecForProviderLogs#general
   */
  readonly general?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderLogs(obj: BrokerSpecForProviderLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audit': obj.audit,
    'general': obj.general,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderMaintenanceWindowStartTime
 */
export interface BrokerSpecForProviderMaintenanceWindowStartTime {
  /**
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#dayOfWeek
   */
  readonly dayOfWeek?: string;

  /**
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#timeOfDay
   */
  readonly timeOfDay?: string;

  /**
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderMaintenanceWindowStartTime(obj: BrokerSpecForProviderMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'timeOfDay': obj.timeOfDay,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdRefs
 */
export interface BrokerSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: BrokerSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupIdRefs(obj: BrokerSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroups used to set the SecurityGroupsIDs.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdSelector
 */
export interface BrokerSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: BrokerSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupIdSelector(obj: BrokerSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BrokerSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema BrokerSpecForProviderSubnetIdRefs
 */
export interface BrokerSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: BrokerSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdRefs(obj: BrokerSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema BrokerSpecForProviderSubnetIdSelector
 */
export interface BrokerSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: BrokerSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdSelector(obj: BrokerSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BrokerSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomUser contains the fields for Users with PasswordSecretRef
 *
 * @schema BrokerSpecForProviderUsers
 */
export interface BrokerSpecForProviderUsers {
  /**
   * @schema BrokerSpecForProviderUsers#consoleAccess
   */
  readonly consoleAccess?: boolean;

  /**
   * @schema BrokerSpecForProviderUsers#groups
   */
  readonly groups?: string[];

  /**
   * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
   *
   * @schema BrokerSpecForProviderUsers#passwordSecretRef
   */
  readonly passwordSecretRef?: BrokerSpecForProviderUsersPasswordSecretRef;

  /**
   * @schema BrokerSpecForProviderUsers#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderUsers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderUsers(obj: BrokerSpecForProviderUsers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consoleAccess': obj.consoleAccess,
    'groups': obj.groups?.map(y => y),
    'passwordSecretRef': toJson_BrokerSpecForProviderUsersPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecProviderConfigRefPolicy
 */
export interface BrokerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BrokerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BrokerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecProviderConfigRefPolicy(obj: BrokerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRef
 */
export interface BrokerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BrokerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToConfigRef(obj: BrokerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BrokerSpecPublishConnectionDetailsToMetadata
 */
export interface BrokerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToMetadata(obj: BrokerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface BrokerSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupIdRefsPolicy(obj: BrokerSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface BrokerSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupIdSelectorPolicy(obj: BrokerSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicy
 */
export interface BrokerSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdRefsPolicy(obj: BrokerSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicy
 */
export interface BrokerSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdSelectorPolicy(obj: BrokerSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
 *
 * @schema BrokerSpecForProviderUsersPasswordSecretRef
 */
export interface BrokerSpecForProviderUsersPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema BrokerSpecForProviderUsersPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BrokerSpecForProviderUsersPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BrokerSpecForProviderUsersPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderUsersPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderUsersPasswordSecretRef(obj: BrokerSpecForProviderUsersPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecProviderConfigRefPolicyResolution
 */
export enum BrokerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecProviderConfigRefPolicyResolve
 */
export enum BrokerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BrokerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToConfigRefPolicy(obj: BrokerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum BrokerSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum BrokerSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum BrokerSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum BrokerSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum BrokerSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum BrokerSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum BrokerSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mq.aws.crossplane.io/v1alpha1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * UserParameters defines the desired state of User
   *
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserSpec#managementPolicies
   */
  readonly managementPolicies?: UserSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UserParameters defines the desired state of User
 *
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * @schema UserSpecForProvider#brokerID
   */
  readonly brokerId?: string;

  /**
   * BrokerIDRef is a reference to a Broker used to set BrokerID.
   *
   * @schema UserSpecForProvider#brokerIDRef
   */
  readonly brokerIdRef?: UserSpecForProviderBrokerIdRef;

  /**
   * BrokerIDSelector selects a reference to a Broker used to set BrokerID.
   *
   * @schema UserSpecForProvider#brokerIDSelector
   */
  readonly brokerIdSelector?: UserSpecForProviderBrokerIdSelector;

  /**
   * @schema UserSpecForProvider#consoleAccess
   */
  readonly consoleAccess?: boolean;

  /**
   * @schema UserSpecForProvider#groups
   */
  readonly groups?: string[];

  /**
   * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
   *
   * @schema UserSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: UserSpecForProviderPasswordSecretRef;

  /**
   * Region is which region the User will be created.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema UserSpecForProvider#replicationUser
   */
  readonly replicationUser?: boolean;

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerID': obj.brokerId,
    'brokerIDRef': toJson_UserSpecForProviderBrokerIdRef(obj.brokerIdRef),
    'brokerIDSelector': toJson_UserSpecForProviderBrokerIdSelector(obj.brokerIdSelector),
    'consoleAccess': obj.consoleAccess,
    'groups': obj.groups?.map(y => y),
    'passwordSecretRef': toJson_UserSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'region': obj.region,
    'replicationUser': obj.replicationUser,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserSpecManagementPolicies
 */
export enum UserSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BrokerIDRef is a reference to a Broker used to set BrokerID.
 *
 * @schema UserSpecForProviderBrokerIdRef
 */
export interface UserSpecForProviderBrokerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderBrokerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderBrokerIdRef#policy
   */
  readonly policy?: UserSpecForProviderBrokerIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderBrokerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderBrokerIdRef(obj: UserSpecForProviderBrokerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderBrokerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BrokerIDSelector selects a reference to a Broker used to set BrokerID.
 *
 * @schema UserSpecForProviderBrokerIdSelector
 */
export interface UserSpecForProviderBrokerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderBrokerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderBrokerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderBrokerIdSelector#policy
   */
  readonly policy?: UserSpecForProviderBrokerIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderBrokerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderBrokerIdSelector(obj: UserSpecForProviderBrokerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderBrokerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
 *
 * @schema UserSpecForProviderPasswordSecretRef
 */
export interface UserSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UserSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPasswordSecretRef(obj: UserSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderBrokerIdRefPolicy
 */
export interface UserSpecForProviderBrokerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderBrokerIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderBrokerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderBrokerIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderBrokerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderBrokerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderBrokerIdRefPolicy(obj: UserSpecForProviderBrokerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderBrokerIdSelectorPolicy
 */
export interface UserSpecForProviderBrokerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderBrokerIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderBrokerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderBrokerIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderBrokerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderBrokerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderBrokerIdSelectorPolicy(obj: UserSpecForProviderBrokerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderBrokerIdRefPolicyResolution
 */
export enum UserSpecForProviderBrokerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderBrokerIdRefPolicyResolve
 */
export enum UserSpecForProviderBrokerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderBrokerIdSelectorPolicyResolution
 */
export enum UserSpecForProviderBrokerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderBrokerIdSelectorPolicyResolve
 */
export enum UserSpecForProviderBrokerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

