// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * APIKey is the Schema for the APIKeys API
 *
 * @schema APIKey
 */
export class ApiKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'APIKey',
  }

  /**
   * Renders a Kubernetes manifest for "APIKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiKeyProps): any {
    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(props),
    };
  }

  /**
   * Defines a "APIKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiKeyProps) {
    super(scope, id, {
      ...ApiKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(resolved),
    };
  }
}

/**
 * APIKey is the Schema for the APIKeys API
 *
 * @schema APIKey
 */
export interface ApiKeyProps {
  /**
   * @schema APIKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIKeySpec defines the desired state of APIKey
   *
   * @schema APIKey#spec
   */
  readonly spec: ApiKeySpec;

}

/**
 * Converts an object of type 'ApiKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeyProps(obj: ApiKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIKeySpec defines the desired state of APIKey
 *
 * @schema ApiKeySpec
 */
export interface ApiKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiKeySpecDeletionPolicy;

  /**
   * APIKeyParameters defines the desired state of APIKey
   *
   * @schema ApiKeySpec#forProvider
   */
  readonly forProvider: ApiKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApiKeySpec#managementPolicies
   */
  readonly managementPolicies?: ApiKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpec(obj: ApiKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiKeySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApiKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApiKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiKeySpecDeletionPolicy
 */
export enum ApiKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * APIKeyParameters defines the desired state of APIKey
 *
 * @schema ApiKeySpecForProvider
 */
export interface ApiKeySpecForProvider {
  /**
   * An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
   *
   * @schema ApiKeySpecForProvider#customerID
   */
  readonly customerId?: string;

  /**
   * The description of the ApiKey.
   *
   * @schema ApiKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether the ApiKey can be used by callers.
   *
   * @schema ApiKeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Specifies whether (true) or not (false) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
   *
   * @schema ApiKeySpecForProvider#generateDistinctID
   */
  readonly generateDistinctId?: boolean;

  /**
   * The name of the ApiKey.
   *
   * @schema ApiKeySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is which region the APIKey will be created.
   *
   * @schema ApiKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema ApiKeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies a value of the API key.
   *
   * @schema ApiKeySpecForProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ApiKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProvider(obj: ApiKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerID': obj.customerId,
    'description': obj.description,
    'enabled': obj.enabled,
    'generateDistinctID': obj.generateDistinctId,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApiKeySpecManagementPolicies
 */
export enum ApiKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiKeySpecProviderConfigRef
 */
export interface ApiKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecProviderConfigRef#policy
   */
  readonly policy?: ApiKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRef(obj: ApiKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiKeySpecPublishConnectionDetailsTo
 */
export interface ApiKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsTo(obj: ApiKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiKeySpecWriteConnectionSecretToRef
 */
export interface ApiKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecWriteConnectionSecretToRef(obj: ApiKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecProviderConfigRefPolicy
 */
export interface ApiKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRefPolicy(obj: ApiKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj: ApiKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToMetadata
 */
export interface ApiKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj: ApiKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolution
 */
export enum ApiKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolve
 */
export enum ApiKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Authorizer is the Schema for the Authorizers API
 *
 * @schema Authorizer
 */
export class Authorizer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Authorizer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Authorizer',
  }

  /**
   * Renders a Kubernetes manifest for "Authorizer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AuthorizerProps): any {
    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(props),
    };
  }

  /**
   * Defines a "Authorizer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AuthorizerProps) {
    super(scope, id, {
      ...Authorizer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(resolved),
    };
  }
}

/**
 * Authorizer is the Schema for the Authorizers API
 *
 * @schema Authorizer
 */
export interface AuthorizerProps {
  /**
   * @schema Authorizer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AuthorizerSpec defines the desired state of Authorizer
   *
   * @schema Authorizer#spec
   */
  readonly spec: AuthorizerSpec;

}

/**
 * Converts an object of type 'AuthorizerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerProps(obj: AuthorizerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AuthorizerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerSpec defines the desired state of Authorizer
 *
 * @schema AuthorizerSpec
 */
export interface AuthorizerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AuthorizerSpecDeletionPolicy;

  /**
   * AuthorizerParameters defines the desired state of Authorizer
   *
   * @schema AuthorizerSpec#forProvider
   */
  readonly forProvider: AuthorizerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AuthorizerSpec#managementPolicies
   */
  readonly managementPolicies?: AuthorizerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AuthorizerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AuthorizerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AuthorizerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AuthorizerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AuthorizerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AuthorizerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AuthorizerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpec(obj: AuthorizerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AuthorizerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AuthorizerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AuthorizerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AuthorizerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecDeletionPolicy
 */
export enum AuthorizerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AuthorizerParameters defines the desired state of Authorizer
 *
 * @schema AuthorizerSpecForProvider
 */
export interface AuthorizerSpecForProvider {
  /**
   * Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
   *
   * @schema AuthorizerSpecForProvider#authType
   */
  readonly authType?: string;

  /**
   * Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
   *
   * @schema AuthorizerSpecForProvider#authorizerCredentials
   */
  readonly authorizerCredentials?: string;

  /**
   * The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
   *
   * @schema AuthorizerSpecForProvider#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
   *
   * @schema AuthorizerSpecForProvider#authorizerURI
   */
  readonly authorizerUri?: string;

  /**
   * The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
   *
   * @schema AuthorizerSpecForProvider#identitySource
   */
  readonly identitySource?: string;

  /**
   * A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
   *
   * @schema AuthorizerSpecForProvider#identityValidationExpression
   */
  readonly identityValidationExpression?: string;

  /**
   * The name of the authorizer.
   *
   * @schema AuthorizerSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the Authorizer will be created.
   *
   * @schema AuthorizerSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema AuthorizerSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema AuthorizerSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: AuthorizerSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema AuthorizerSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: AuthorizerSpecForProviderRestApiIdSelector;

  /**
   * The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
   *
   * @schema AuthorizerSpecForProvider#type_
   */
  readonly type: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProvider(obj: AuthorizerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authType': obj.authType,
    'authorizerCredentials': obj.authorizerCredentials,
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerURI': obj.authorizerUri,
    'identitySource': obj.identitySource,
    'identityValidationExpression': obj.identityValidationExpression,
    'name': obj.name,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_AuthorizerSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_AuthorizerSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AuthorizerSpecManagementPolicies
 */
export enum AuthorizerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AuthorizerSpecProviderConfigRef
 */
export interface AuthorizerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderConfigRef#policy
   */
  readonly policy?: AuthorizerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRef(obj: AuthorizerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsTo
 */
export interface AuthorizerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AuthorizerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AuthorizerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsTo(obj: AuthorizerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AuthorizerSpecWriteConnectionSecretToRef
 */
export interface AuthorizerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AuthorizerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecWriteConnectionSecretToRef(obj: AuthorizerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRef
 */
export interface AuthorizerSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdRef(obj: AuthorizerSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelector
 */
export interface AuthorizerSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdSelector(obj: AuthorizerSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicy
 */
export interface AuthorizerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRefPolicy(obj: AuthorizerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj: AuthorizerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToMetadata
 */
export interface AuthorizerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj: AuthorizerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicy
 */
export interface AuthorizerSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdRefPolicy(obj: AuthorizerSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy
 */
export interface AuthorizerSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdSelectorPolicy(obj: AuthorizerSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolution
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolve
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicyResolution
 */
export enum AuthorizerSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicyResolve
 */
export enum AuthorizerSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BasePathMapping is the Schema for the BasePathMappings API
 *
 * @schema BasePathMapping
 */
export class BasePathMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BasePathMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'BasePathMapping',
  }

  /**
   * Renders a Kubernetes manifest for "BasePathMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BasePathMappingProps): any {
    return {
      ...BasePathMapping.GVK,
      ...toJson_BasePathMappingProps(props),
    };
  }

  /**
   * Defines a "BasePathMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BasePathMappingProps) {
    super(scope, id, {
      ...BasePathMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BasePathMapping.GVK,
      ...toJson_BasePathMappingProps(resolved),
    };
  }
}

/**
 * BasePathMapping is the Schema for the BasePathMappings API
 *
 * @schema BasePathMapping
 */
export interface BasePathMappingProps {
  /**
   * @schema BasePathMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BasePathMappingSpec defines the desired state of BasePathMapping
   *
   * @schema BasePathMapping#spec
   */
  readonly spec: BasePathMappingSpec;

}

/**
 * Converts an object of type 'BasePathMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingProps(obj: BasePathMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BasePathMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasePathMappingSpec defines the desired state of BasePathMapping
 *
 * @schema BasePathMappingSpec
 */
export interface BasePathMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BasePathMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: BasePathMappingSpecDeletionPolicy;

  /**
   * BasePathMappingParameters defines the desired state of BasePathMapping
   *
   * @schema BasePathMappingSpec#forProvider
   */
  readonly forProvider: BasePathMappingSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BasePathMappingSpec#managementPolicies
   */
  readonly managementPolicies?: BasePathMappingSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BasePathMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: BasePathMappingSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BasePathMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BasePathMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BasePathMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BasePathMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BasePathMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpec(obj: BasePathMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BasePathMappingSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BasePathMappingSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BasePathMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BasePathMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BasePathMappingSpecDeletionPolicy
 */
export enum BasePathMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * BasePathMappingParameters defines the desired state of BasePathMapping
 *
 * @schema BasePathMappingSpecForProvider
 */
export interface BasePathMappingSpecForProvider {
  /**
   * The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.
   *
   * @schema BasePathMappingSpecForProvider#basePath
   */
  readonly basePath?: string;

  /**
   * The domain name of the BasePathMapping resource to create.
   *
   * @schema BasePathMappingSpecForProvider#domainName
   */
  readonly domainName: string;

  /**
   * Region is which region the BasePathMapping will be created.
   *
   * @schema BasePathMappingSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema BasePathMappingSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema BasePathMappingSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: BasePathMappingSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema BasePathMappingSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: BasePathMappingSpecForProviderRestApiIdSelector;

  /**
   * The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.
   *
   * @schema BasePathMappingSpecForProvider#stage
   */
  readonly stage?: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProvider(obj: BasePathMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basePath': obj.basePath,
    'domainName': obj.domainName,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_BasePathMappingSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_BasePathMappingSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stage': obj.stage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BasePathMappingSpecManagementPolicies
 */
export enum BasePathMappingSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BasePathMappingSpecProviderConfigRef
 */
export interface BasePathMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecProviderConfigRef#policy
   */
  readonly policy?: BasePathMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderConfigRef(obj: BasePathMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsTo
 */
export interface BasePathMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BasePathMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BasePathMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsTo(obj: BasePathMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BasePathMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BasePathMappingSpecWriteConnectionSecretToRef
 */
export interface BasePathMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BasePathMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BasePathMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecWriteConnectionSecretToRef(obj: BasePathMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdRef
 */
export interface BasePathMappingSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: BasePathMappingSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderRestApiIdRef(obj: BasePathMappingSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdSelector
 */
export interface BasePathMappingSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: BasePathMappingSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderRestApiIdSelector(obj: BasePathMappingSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BasePathMappingSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicy
 */
export interface BasePathMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderConfigRefPolicy(obj: BasePathMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface BasePathMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRef(obj: BasePathMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata
 */
export interface BasePathMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToMetadata(obj: BasePathMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdRefPolicy
 */
export interface BasePathMappingSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderRestApiIdRefPolicy(obj: BasePathMappingSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdSelectorPolicy
 */
export interface BasePathMappingSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderRestApiIdSelectorPolicy(obj: BasePathMappingSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicyResolution
 */
export enum BasePathMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicyResolve
 */
export enum BasePathMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdRefPolicyResolution
 */
export enum BasePathMappingSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdRefPolicyResolve
 */
export enum BasePathMappingSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum BasePathMappingSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Deployment is the Schema for the Deployments API
 *
 * @schema Deployment
 */
export class Deployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Deployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Deployment',
  }

  /**
   * Renders a Kubernetes manifest for "Deployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentProps): any {
    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(props),
    };
  }

  /**
   * Defines a "Deployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentProps) {
    super(scope, id, {
      ...Deployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(resolved),
    };
  }
}

/**
 * Deployment is the Schema for the Deployments API
 *
 * @schema Deployment
 */
export interface DeploymentProps {
  /**
   * @schema Deployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentSpec defines the desired state of Deployment
   *
   * @schema Deployment#spec
   */
  readonly spec: DeploymentSpec;

}

/**
 * Converts an object of type 'DeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentProps(obj: DeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentSpec defines the desired state of Deployment
 *
 * @schema DeploymentSpec
 */
export interface DeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentSpecDeletionPolicy;

  /**
   * DeploymentParameters defines the desired state of Deployment
   *
   * @schema DeploymentSpec#forProvider
   */
  readonly forProvider: DeploymentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeploymentSpec#managementPolicies
   */
  readonly managementPolicies?: DeploymentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpec(obj: DeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecDeletionPolicy
 */
export enum DeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DeploymentParameters defines the desired state of Deployment
 *
 * @schema DeploymentSpecForProvider
 */
export interface DeploymentSpecForProvider {
  /**
   * Enables a cache cluster for the Stage resource specified in the input.
   *
   * @schema DeploymentSpecForProvider#cacheClusterEnabled
   */
  readonly cacheClusterEnabled?: boolean;

  /**
   * The stage's cache capacity in GB. For more information about choosing a cache size, see Enabling API caching to enhance responsiveness (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
   *
   * @schema DeploymentSpecForProvider#cacheClusterSize
   */
  readonly cacheClusterSize?: string;

  /**
   * The input configuration for the canary deployment when the deployment is a canary release deployment.
   *
   * @schema DeploymentSpecForProvider#canarySettings
   */
  readonly canarySettings?: DeploymentSpecForProviderCanarySettings;

  /**
   * The description for the Deployment resource to create.
   *
   * @schema DeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is which region the Deployment will be created.
   *
   * @schema DeploymentSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema DeploymentSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema DeploymentSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DeploymentSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema DeploymentSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DeploymentSpecForProviderRestApiIdSelector;

  /**
   * The description of the Stage resource for the Deployment resource to create.
   *
   * @schema DeploymentSpecForProvider#stageDescription
   */
  readonly stageDescription?: string;

  /**
   * The name of the Stage resource for the Deployment resource to create.
   *
   * @schema DeploymentSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * Specifies whether active tracing with X-ray is enabled for the Stage.
   *
   * @schema DeploymentSpecForProvider#tracingEnabled
   */
  readonly tracingEnabled?: boolean;

  /**
   * A map that defines the stage variables for the Stage resource that is associated with the new deployment. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
   *
   * @schema DeploymentSpecForProvider#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProvider(obj: DeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheClusterEnabled': obj.cacheClusterEnabled,
    'cacheClusterSize': obj.cacheClusterSize,
    'canarySettings': toJson_DeploymentSpecForProviderCanarySettings(obj.canarySettings),
    'description': obj.description,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DeploymentSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DeploymentSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stageDescription': obj.stageDescription,
    'stageName': obj.stageName,
    'tracingEnabled': obj.tracingEnabled,
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeploymentSpecManagementPolicies
 */
export enum DeploymentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentSpecProviderConfigRef
 */
export interface DeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRef(obj: DeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentSpecPublishConnectionDetailsTo
 */
export interface DeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsTo(obj: DeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentSpecWriteConnectionSecretToRef
 */
export interface DeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecWriteConnectionSecretToRef(obj: DeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The input configuration for the canary deployment when the deployment is a canary release deployment.
 *
 * @schema DeploymentSpecForProviderCanarySettings
 */
export interface DeploymentSpecForProviderCanarySettings {
  /**
   * @schema DeploymentSpecForProviderCanarySettings#percentTraffic
   */
  readonly percentTraffic?: number;

  /**
   * @schema DeploymentSpecForProviderCanarySettings#stageVariableOverrides
   */
  readonly stageVariableOverrides?: { [key: string]: string };

  /**
   * @schema DeploymentSpecForProviderCanarySettings#useStageCache
   */
  readonly useStageCache?: boolean;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderCanarySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderCanarySettings(obj: DeploymentSpecForProviderCanarySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'percentTraffic': obj.percentTraffic,
    'stageVariableOverrides': ((obj.stageVariableOverrides) === undefined) ? undefined : (Object.entries(obj.stageVariableOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useStageCache': obj.useStageCache,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema DeploymentSpecForProviderRestApiIdRef
 */
export interface DeploymentSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdRef(obj: DeploymentSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelector
 */
export interface DeploymentSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdSelector(obj: DeploymentSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderConfigRefPolicy
 */
export interface DeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRefPolicy(obj: DeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj: DeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj: DeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicy
 */
export interface DeploymentSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdRefPolicy(obj: DeploymentSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy
 */
export interface DeploymentSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdSelectorPolicy(obj: DeploymentSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DocumentationPart is the Schema for the DocumentationParts API
 *
 * @schema DocumentationPart
 */
export class DocumentationPart extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DocumentationPart"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'DocumentationPart',
  }

  /**
   * Renders a Kubernetes manifest for "DocumentationPart".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DocumentationPartProps): any {
    return {
      ...DocumentationPart.GVK,
      ...toJson_DocumentationPartProps(props),
    };
  }

  /**
   * Defines a "DocumentationPart" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DocumentationPartProps) {
    super(scope, id, {
      ...DocumentationPart.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DocumentationPart.GVK,
      ...toJson_DocumentationPartProps(resolved),
    };
  }
}

/**
 * DocumentationPart is the Schema for the DocumentationParts API
 *
 * @schema DocumentationPart
 */
export interface DocumentationPartProps {
  /**
   * @schema DocumentationPart#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DocumentationPartSpec defines the desired state of DocumentationPart
   *
   * @schema DocumentationPart#spec
   */
  readonly spec: DocumentationPartSpec;

}

/**
 * Converts an object of type 'DocumentationPartProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartProps(obj: DocumentationPartProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DocumentationPartSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DocumentationPartSpec defines the desired state of DocumentationPart
 *
 * @schema DocumentationPartSpec
 */
export interface DocumentationPartSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationPartSpec#deletionPolicy
   */
  readonly deletionPolicy?: DocumentationPartSpecDeletionPolicy;

  /**
   * DocumentationPartParameters defines the desired state of DocumentationPart
   *
   * @schema DocumentationPartSpec#forProvider
   */
  readonly forProvider: DocumentationPartSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DocumentationPartSpec#managementPolicies
   */
  readonly managementPolicies?: DocumentationPartSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DocumentationPartSpec#providerConfigRef
   */
  readonly providerConfigRef?: DocumentationPartSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DocumentationPartSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DocumentationPartSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DocumentationPartSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DocumentationPartSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DocumentationPartSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpec(obj: DocumentationPartSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DocumentationPartSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DocumentationPartSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DocumentationPartSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DocumentationPartSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationPartSpecDeletionPolicy
 */
export enum DocumentationPartSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DocumentationPartParameters defines the desired state of DocumentationPart
 *
 * @schema DocumentationPartSpecForProvider
 */
export interface DocumentationPartSpecForProvider {
  /**
   * The location of the targeted API entity of the to-be-created documentation part.
   *
   * @schema DocumentationPartSpecForProvider#location
   */
  readonly location: DocumentationPartSpecForProviderLocation;

  /**
   * The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
   *
   * @schema DocumentationPartSpecForProvider#properties
   */
  readonly properties: string;

  /**
   * Region is which region the DocumentationPart will be created.
   *
   * @schema DocumentationPartSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema DocumentationPartSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema DocumentationPartSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DocumentationPartSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema DocumentationPartSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DocumentationPartSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProvider(obj: DocumentationPartSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': toJson_DocumentationPartSpecForProviderLocation(obj.location),
    'properties': obj.properties,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DocumentationPartSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DocumentationPartSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DocumentationPartSpecManagementPolicies
 */
export enum DocumentationPartSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DocumentationPartSpecProviderConfigRef
 */
export interface DocumentationPartSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecProviderConfigRef#policy
   */
  readonly policy?: DocumentationPartSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderConfigRef(obj: DocumentationPartSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsTo
 */
export interface DocumentationPartSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DocumentationPartSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DocumentationPartSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsTo(obj: DocumentationPartSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DocumentationPartSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DocumentationPartSpecWriteConnectionSecretToRef
 */
export interface DocumentationPartSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DocumentationPartSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DocumentationPartSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecWriteConnectionSecretToRef(obj: DocumentationPartSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The location of the targeted API entity of the to-be-created documentation part.
 *
 * @schema DocumentationPartSpecForProviderLocation
 */
export interface DocumentationPartSpecForProviderLocation {
  /**
   * @schema DocumentationPartSpecForProviderLocation#method
   */
  readonly method?: string;

  /**
   * @schema DocumentationPartSpecForProviderLocation#name
   */
  readonly name?: string;

  /**
   * @schema DocumentationPartSpecForProviderLocation#path
   */
  readonly path?: string;

  /**
   * @schema DocumentationPartSpecForProviderLocation#statusCode
   */
  readonly statusCode?: string;

  /**
   * @schema DocumentationPartSpecForProviderLocation#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderLocation(obj: DocumentationPartSpecForProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'name': obj.name,
    'path': obj.path,
    'statusCode': obj.statusCode,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRef
 */
export interface DocumentationPartSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DocumentationPartSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdRef(obj: DocumentationPartSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelector
 */
export interface DocumentationPartSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DocumentationPartSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdSelector(obj: DocumentationPartSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DocumentationPartSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicy
 */
export interface DocumentationPartSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderConfigRefPolicy(obj: DocumentationPartSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef
 */
export interface DocumentationPartSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRef(obj: DocumentationPartSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata
 */
export interface DocumentationPartSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToMetadata(obj: DocumentationPartSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy
 */
export interface DocumentationPartSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdRefPolicy(obj: DocumentationPartSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy
 */
export interface DocumentationPartSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdSelectorPolicy(obj: DocumentationPartSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicyResolution
 */
export enum DocumentationPartSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicyResolve
 */
export enum DocumentationPartSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy(obj: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DocumentationPartSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DocumentationPartSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DocumentationVersion is the Schema for the DocumentationVersions API
 *
 * @schema DocumentationVersion
 */
export class DocumentationVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DocumentationVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'DocumentationVersion',
  }

  /**
   * Renders a Kubernetes manifest for "DocumentationVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DocumentationVersionProps): any {
    return {
      ...DocumentationVersion.GVK,
      ...toJson_DocumentationVersionProps(props),
    };
  }

  /**
   * Defines a "DocumentationVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DocumentationVersionProps) {
    super(scope, id, {
      ...DocumentationVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DocumentationVersion.GVK,
      ...toJson_DocumentationVersionProps(resolved),
    };
  }
}

/**
 * DocumentationVersion is the Schema for the DocumentationVersions API
 *
 * @schema DocumentationVersion
 */
export interface DocumentationVersionProps {
  /**
   * @schema DocumentationVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DocumentationVersionSpec defines the desired state of DocumentationVersion
   *
   * @schema DocumentationVersion#spec
   */
  readonly spec: DocumentationVersionSpec;

}

/**
 * Converts an object of type 'DocumentationVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionProps(obj: DocumentationVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DocumentationVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DocumentationVersionSpec defines the desired state of DocumentationVersion
 *
 * @schema DocumentationVersionSpec
 */
export interface DocumentationVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: DocumentationVersionSpecDeletionPolicy;

  /**
   * DocumentationVersionParameters defines the desired state of DocumentationVersion
   *
   * @schema DocumentationVersionSpec#forProvider
   */
  readonly forProvider: DocumentationVersionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DocumentationVersionSpec#managementPolicies
   */
  readonly managementPolicies?: DocumentationVersionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DocumentationVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: DocumentationVersionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DocumentationVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DocumentationVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DocumentationVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DocumentationVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DocumentationVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpec(obj: DocumentationVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DocumentationVersionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DocumentationVersionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DocumentationVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DocumentationVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationVersionSpecDeletionPolicy
 */
export enum DocumentationVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DocumentationVersionParameters defines the desired state of DocumentationVersion
 *
 * @schema DocumentationVersionSpecForProvider
 */
export interface DocumentationVersionSpecForProvider {
  /**
   * A description about the new documentation snapshot.
   *
   * @schema DocumentationVersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The version identifier of the new snapshot.
   *
   * @schema DocumentationVersionSpecForProvider#documentationVersion
   */
  readonly documentationVersion: string;

  /**
   * Region is which region the DocumentationVersion will be created.
   *
   * @schema DocumentationVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema DocumentationVersionSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema DocumentationVersionSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DocumentationVersionSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema DocumentationVersionSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DocumentationVersionSpecForProviderRestApiIdSelector;

  /**
   * The stage name to be associated with the new documentation snapshot.
   *
   * @schema DocumentationVersionSpecForProvider#stageName
   */
  readonly stageName?: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProvider(obj: DocumentationVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'documentationVersion': obj.documentationVersion,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DocumentationVersionSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DocumentationVersionSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stageName': obj.stageName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DocumentationVersionSpecManagementPolicies
 */
export enum DocumentationVersionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DocumentationVersionSpecProviderConfigRef
 */
export interface DocumentationVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecProviderConfigRef#policy
   */
  readonly policy?: DocumentationVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderConfigRef(obj: DocumentationVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsTo
 */
export interface DocumentationVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DocumentationVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DocumentationVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsTo(obj: DocumentationVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DocumentationVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DocumentationVersionSpecWriteConnectionSecretToRef
 */
export interface DocumentationVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DocumentationVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DocumentationVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecWriteConnectionSecretToRef(obj: DocumentationVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRef
 */
export interface DocumentationVersionSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DocumentationVersionSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdRef(obj: DocumentationVersionSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelector
 */
export interface DocumentationVersionSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdSelector(obj: DocumentationVersionSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DocumentationVersionSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicy
 */
export interface DocumentationVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderConfigRefPolicy(obj: DocumentationVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRef(obj: DocumentationVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToMetadata(obj: DocumentationVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy
 */
export interface DocumentationVersionSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdRefPolicy(obj: DocumentationVersionSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy
 */
export interface DocumentationVersionSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdSelectorPolicy(obj: DocumentationVersionSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicyResolution
 */
export enum DocumentationVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicyResolve
 */
export enum DocumentationVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainName is the Schema for the DomainNames API
 *
 * @schema DomainName
 */
export class DomainName extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainName"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'DomainName',
  }

  /**
   * Renders a Kubernetes manifest for "DomainName".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainNameProps): any {
    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(props),
    };
  }

  /**
   * Defines a "DomainName" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainNameProps) {
    super(scope, id, {
      ...DomainName.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(resolved),
    };
  }
}

/**
 * DomainName is the Schema for the DomainNames API
 *
 * @schema DomainName
 */
export interface DomainNameProps {
  /**
   * @schema DomainName#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainNameSpec defines the desired state of DomainName
   *
   * @schema DomainName#spec
   */
  readonly spec: DomainNameSpec;

}

/**
 * Converts an object of type 'DomainNameProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameProps(obj: DomainNameProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainNameSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameSpec defines the desired state of DomainName
 *
 * @schema DomainNameSpec
 */
export interface DomainNameSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainNameSpecDeletionPolicy;

  /**
   * DomainNameParameters defines the desired state of DomainName
   *
   * @schema DomainNameSpec#forProvider
   */
  readonly forProvider: DomainNameSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainNameSpec#managementPolicies
   */
  readonly managementPolicies?: DomainNameSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainNameSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainNameSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainNameSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainNameSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainNameSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainNameSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainNameSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpec(obj: DomainNameSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainNameSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainNameSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainNameSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainNameSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecDeletionPolicy
 */
export enum DomainNameSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DomainNameParameters defines the desired state of DomainName
 *
 * @schema DomainNameSpecForProvider
 */
export interface DomainNameSpecForProvider {
  /**
   * The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
   *
   * @schema DomainNameSpecForProvider#certificateARN
   */
  readonly certificateArn?: string;

  /**
   * [Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.
   *
   * @schema DomainNameSpecForProvider#certificateBody
   */
  readonly certificateBody?: string;

  /**
   * [Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.
   *
   * @schema DomainNameSpecForProvider#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.
   *
   * @schema DomainNameSpecForProvider#certificateName
   */
  readonly certificateName?: string;

  /**
   * [Deprecated] Your edge-optimized endpoint's domain name certificate's private key.
   *
   * @schema DomainNameSpecForProvider#certificatePrivateKey
   */
  readonly certificatePrivateKey?: string;

  /**
   * The name of the DomainName resource.
   *
   * @schema DomainNameSpecForProvider#domainName
   */
  readonly domainName: string;

  /**
   * The endpoint configuration of this DomainName showing the endpoint types of the domain name.
   *
   * @schema DomainNameSpecForProvider#endpointConfiguration
   */
  readonly endpointConfiguration?: DomainNameSpecForProviderEndpointConfiguration;

  /**
   * @schema DomainNameSpecForProvider#mutualTLSAuthentication
   */
  readonly mutualTlsAuthentication?: DomainNameSpecForProviderMutualTlsAuthentication;

  /**
   * The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
   *
   * @schema DomainNameSpecForProvider#ownershipVerificationCertificateARN
   */
  readonly ownershipVerificationCertificateArn?: string;

  /**
   * Region is which region the DomainName will be created.
   *
   * @schema DomainNameSpecForProvider#region
   */
  readonly region: string;

  /**
   * The reference to an Amazon Web Services-managed certificate that will be used by regional endpoint for this domain name. Certificate Manager is the only supported source.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateARN
   */
  readonly regionalCertificateArn?: string;

  /**
   * The user-friendly name of the certificate that will be used by regional endpoint for this domain name.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateName
   */
  readonly regionalCertificateName?: string;

  /**
   * The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
   *
   * @schema DomainNameSpecForProvider#securityPolicy
   */
  readonly securityPolicy?: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema DomainNameSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DomainNameSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProvider(obj: DomainNameSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateARN': obj.certificateArn,
    'certificateBody': obj.certificateBody,
    'certificateChain': obj.certificateChain,
    'certificateName': obj.certificateName,
    'certificatePrivateKey': obj.certificatePrivateKey,
    'domainName': obj.domainName,
    'endpointConfiguration': toJson_DomainNameSpecForProviderEndpointConfiguration(obj.endpointConfiguration),
    'mutualTLSAuthentication': toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj.mutualTlsAuthentication),
    'ownershipVerificationCertificateARN': obj.ownershipVerificationCertificateArn,
    'region': obj.region,
    'regionalCertificateARN': obj.regionalCertificateArn,
    'regionalCertificateName': obj.regionalCertificateName,
    'securityPolicy': obj.securityPolicy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainNameSpecManagementPolicies
 */
export enum DomainNameSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainNameSpecProviderConfigRef
 */
export interface DomainNameSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderConfigRef#policy
   */
  readonly policy?: DomainNameSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRef(obj: DomainNameSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainNameSpecPublishConnectionDetailsTo
 */
export interface DomainNameSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainNameSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainNameSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsTo(obj: DomainNameSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainNameSpecWriteConnectionSecretToRef
 */
export interface DomainNameSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainNameSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecWriteConnectionSecretToRef(obj: DomainNameSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The endpoint configuration of this DomainName showing the endpoint types of the domain name.
 *
 * @schema DomainNameSpecForProviderEndpointConfiguration
 */
export interface DomainNameSpecForProviderEndpointConfiguration {
  /**
   * @schema DomainNameSpecForProviderEndpointConfiguration#types
   */
  readonly types?: string[];

  /**
   * @schema DomainNameSpecForProviderEndpointConfiguration#vpcEndpointIDs
   */
  readonly vpcEndpointIDs?: string[];

}

/**
 * Converts an object of type 'DomainNameSpecForProviderEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderEndpointConfiguration(obj: DomainNameSpecForProviderEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'types': obj.types?.map(y => y),
    'vpcEndpointIDs': obj.vpcEndpointIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderMutualTlsAuthentication
 */
export interface DomainNameSpecForProviderMutualTlsAuthentication {
  /**
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreURI
   */
  readonly truststoreUri?: string;

  /**
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreVersion
   */
  readonly truststoreVersion?: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderMutualTlsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj: DomainNameSpecForProviderMutualTlsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'truststoreURI': obj.truststoreUri,
    'truststoreVersion': obj.truststoreVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderConfigRefPolicy
 */
export interface DomainNameSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRefPolicy(obj: DomainNameSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj: DomainNameSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToMetadata
 */
export interface DomainNameSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj: DomainNameSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolution
 */
export enum DomainNameSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolve
 */
export enum DomainNameSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GatewayResponse is the Schema for the GatewayResponses API
 *
 * @schema GatewayResponse
 */
export class GatewayResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'GatewayResponse',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayResponseProps): any {
    return {
      ...GatewayResponse.GVK,
      ...toJson_GatewayResponseProps(props),
    };
  }

  /**
   * Defines a "GatewayResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayResponseProps) {
    super(scope, id, {
      ...GatewayResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayResponse.GVK,
      ...toJson_GatewayResponseProps(resolved),
    };
  }
}

/**
 * GatewayResponse is the Schema for the GatewayResponses API
 *
 * @schema GatewayResponse
 */
export interface GatewayResponseProps {
  /**
   * @schema GatewayResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewayResponseSpec defines the desired state of GatewayResponse
   *
   * @schema GatewayResponse#spec
   */
  readonly spec: GatewayResponseSpec;

}

/**
 * Converts an object of type 'GatewayResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseProps(obj: GatewayResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayResponseSpec defines the desired state of GatewayResponse
 *
 * @schema GatewayResponseSpec
 */
export interface GatewayResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewayResponseSpecDeletionPolicy;

  /**
   * GatewayResponseParameters defines the desired state of GatewayResponse
   *
   * @schema GatewayResponseSpec#forProvider
   */
  readonly forProvider: GatewayResponseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GatewayResponseSpec#managementPolicies
   */
  readonly managementPolicies?: GatewayResponseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewayResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewayResponseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewayResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewayResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewayResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewayResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewayResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpec(obj: GatewayResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewayResponseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GatewayResponseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GatewayResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewayResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayResponseSpecDeletionPolicy
 */
export enum GatewayResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GatewayResponseParameters defines the desired state of GatewayResponse
 *
 * @schema GatewayResponseSpecForProvider
 */
export interface GatewayResponseSpecForProvider {
  /**
   * Region is which region the GatewayResponse will be created.
   *
   * @schema GatewayResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
   *
   * @schema GatewayResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: string };

  /**
   * Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
   *
   * @schema GatewayResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * The response type of the associated GatewayResponse
   *
   * @schema GatewayResponseSpecForProvider#responseType
   */
  readonly responseType: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema GatewayResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema GatewayResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: GatewayResponseSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema GatewayResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: GatewayResponseSpecForProviderRestApiIdSelector;

  /**
   * The HTTP status code of the GatewayResponse.
   *
   * @schema GatewayResponseSpecForProvider#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProvider(obj: GatewayResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseType': obj.responseType,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_GatewayResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_GatewayResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GatewayResponseSpecManagementPolicies
 */
export enum GatewayResponseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewayResponseSpecProviderConfigRef
 */
export interface GatewayResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecProviderConfigRef#policy
   */
  readonly policy?: GatewayResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderConfigRef(obj: GatewayResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsTo
 */
export interface GatewayResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewayResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewayResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsTo(obj: GatewayResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewayResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewayResponseSpecWriteConnectionSecretToRef
 */
export interface GatewayResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewayResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewayResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecWriteConnectionSecretToRef(obj: GatewayResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRef
 */
export interface GatewayResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: GatewayResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdRef(obj: GatewayResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelector
 */
export interface GatewayResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: GatewayResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdSelector(obj: GatewayResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicy
 */
export interface GatewayResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderConfigRefPolicy(obj: GatewayResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface GatewayResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRef(obj: GatewayResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata
 */
export interface GatewayResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToMetadata(obj: GatewayResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy
 */
export interface GatewayResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdRefPolicy(obj: GatewayResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface GatewayResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdSelectorPolicy(obj: GatewayResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicyResolution
 */
export enum GatewayResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicyResolve
 */
export enum GatewayResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum GatewayResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum GatewayResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Integration is the Schema for the Integrations API
 *
 * @schema Integration
 */
export class Integration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Integration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Integration',
  }

  /**
   * Renders a Kubernetes manifest for "Integration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationProps): any {
    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(props),
    };
  }

  /**
   * Defines a "Integration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationProps) {
    super(scope, id, {
      ...Integration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(resolved),
    };
  }
}

/**
 * Integration is the Schema for the Integrations API
 *
 * @schema Integration
 */
export interface IntegrationProps {
  /**
   * @schema Integration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationSpec defines the desired state of Integration
   *
   * @schema Integration#spec
   */
  readonly spec: IntegrationSpec;

}

/**
 * Converts an object of type 'IntegrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationProps(obj: IntegrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationSpec defines the desired state of Integration
 *
 * @schema IntegrationSpec
 */
export interface IntegrationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationSpecDeletionPolicy;

  /**
   * IntegrationParameters defines the desired state of Integration
   *
   * @schema IntegrationSpec#forProvider
   */
  readonly forProvider: IntegrationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IntegrationSpec#managementPolicies
   */
  readonly managementPolicies?: IntegrationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpec(obj: IntegrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IntegrationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IntegrationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecDeletionPolicy
 */
export enum IntegrationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IntegrationParameters defines the desired state of Integration
 *
 * @schema IntegrationSpecForProvider
 */
export interface IntegrationSpecForProvider {
  /**
   * A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
   *
   * @schema IntegrationSpecForProvider#cacheKeyParameters
   */
  readonly cacheKeyParameters?: string[];

  /**
   * Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
   *
   * @schema IntegrationSpecForProvider#cacheNamespace
   */
  readonly cacheNamespace?: string;

  /**
   * The ID of the VpcLink used for the integration. Specify this value only if you specify VPC_LINK as the connection type.
   *
   * @schema IntegrationSpecForProvider#connectionID
   */
  readonly connectionId?: string;

  /**
   * The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
   *
   * @schema IntegrationSpecForProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   * Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
   * If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
   *
   * @schema IntegrationSpecForProvider#contentHandling
   */
  readonly contentHandling?: string;

  /**
   * Specifies whether credentials are required for a put integration.
   *
   * @schema IntegrationSpecForProvider#credentials
   */
  readonly credentials?: string;

  /**
   * Specifies the HTTP method for the integration.
   *
   * @schema IntegrationSpecForProvider#httpMethod
   */
  readonly httpMethod: string;

  /**
   * The HTTP method for the integration.
   *
   * @schema IntegrationSpecForProvider#integrationHTTPMethod
   */
  readonly integrationHttpMethod?: string;

  /**
   * Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.
   *
   * @schema IntegrationSpecForProvider#passthroughBehavior
   */
  readonly passthroughBehavior?: string;

  /**
   * Region is which region the Integration will be created.
   *
   * @schema IntegrationSpecForProvider#region
   */
  readonly region: string;

  /**
   * A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
   *
   * @schema IntegrationSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: string };

  /**
   * Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
   *
   * @schema IntegrationSpecForProvider#requestTemplates
   */
  readonly requestTemplates?: { [key: string]: string };

  /**
   * ResourceID is the ID for the Resource.
   *
   * @schema IntegrationSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * ResourceIDRef is a reference to an Parent used to set the ResourceID.
   *
   * @schema IntegrationSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: IntegrationSpecForProviderResourceIdRef;

  /**
   * ResourceIDSelector selects references to Parent used to set the ResourceID.
   *
   * @schema IntegrationSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: IntegrationSpecForProviderResourceIdSelector;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema IntegrationSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema IntegrationSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: IntegrationSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema IntegrationSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: IntegrationSpecForProviderRestApiIdSelector;

  /**
   * Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
   *
   * @schema IntegrationSpecForProvider#timeoutInMillis
   */
  readonly timeoutInMillis?: number;

  /**
   * @schema IntegrationSpecForProvider#tlsConfig
   */
  readonly tlsConfig?: IntegrationSpecForProviderTlsConfig;

  /**
   * Specifies a put integration input's type.
   *
   * @schema IntegrationSpecForProvider#type_
   */
  readonly type: string;

  /**
   * Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification, for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
   *
   * @schema IntegrationSpecForProvider#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProvider(obj: IntegrationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheKeyParameters': obj.cacheKeyParameters?.map(y => y),
    'cacheNamespace': obj.cacheNamespace,
    'connectionID': obj.connectionId,
    'connectionType': obj.connectionType,
    'contentHandling': obj.contentHandling,
    'credentials': obj.credentials,
    'httpMethod': obj.httpMethod,
    'integrationHTTPMethod': obj.integrationHttpMethod,
    'passthroughBehavior': obj.passthroughBehavior,
    'region': obj.region,
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestTemplates': ((obj.requestTemplates) === undefined) ? undefined : (Object.entries(obj.requestTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_IntegrationSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_IntegrationSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_IntegrationSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_IntegrationSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'timeoutInMillis': obj.timeoutInMillis,
    'tlsConfig': toJson_IntegrationSpecForProviderTlsConfig(obj.tlsConfig),
    'type_': obj.type,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IntegrationSpecManagementPolicies
 */
export enum IntegrationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationSpecProviderConfigRef
 */
export interface IntegrationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRef(obj: IntegrationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationSpecPublishConnectionDetailsTo
 */
export interface IntegrationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsTo(obj: IntegrationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationSpecWriteConnectionSecretToRef
 */
export interface IntegrationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecWriteConnectionSecretToRef(obj: IntegrationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDRef is a reference to an Parent used to set the ResourceID.
 *
 * @schema IntegrationSpecForProviderResourceIdRef
 */
export interface IntegrationSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderResourceIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdRef(obj: IntegrationSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDSelector selects references to Parent used to set the ResourceID.
 *
 * @schema IntegrationSpecForProviderResourceIdSelector
 */
export interface IntegrationSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdSelector(obj: IntegrationSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema IntegrationSpecForProviderRestApiIdRef
 */
export interface IntegrationSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdRef(obj: IntegrationSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelector
 */
export interface IntegrationSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdSelector(obj: IntegrationSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecForProviderTlsConfig
 */
export interface IntegrationSpecForProviderTlsConfig {
  /**
   * @schema IntegrationSpecForProviderTlsConfig#insecureSkipVerification
   */
  readonly insecureSkipVerification?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderTlsConfig(obj: IntegrationSpecForProviderTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureSkipVerification': obj.insecureSkipVerification,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderConfigRefPolicy
 */
export interface IntegrationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRefPolicy(obj: IntegrationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj: IntegrationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj: IntegrationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicy
 */
export interface IntegrationSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdRefPolicy(obj: IntegrationSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicy
 */
export interface IntegrationSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdSelectorPolicy(obj: IntegrationSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicy
 */
export interface IntegrationSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdRefPolicy(obj: IntegrationSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy
 */
export interface IntegrationSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdSelectorPolicy(obj: IntegrationSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IntegrationResponse is the Schema for the IntegrationResponses API
 *
 * @schema IntegrationResponse
 */
export class IntegrationResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IntegrationResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'IntegrationResponse',
  }

  /**
   * Renders a Kubernetes manifest for "IntegrationResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationResponseProps): any {
    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(props),
    };
  }

  /**
   * Defines a "IntegrationResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationResponseProps) {
    super(scope, id, {
      ...IntegrationResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(resolved),
    };
  }
}

/**
 * IntegrationResponse is the Schema for the IntegrationResponses API
 *
 * @schema IntegrationResponse
 */
export interface IntegrationResponseProps {
  /**
   * @schema IntegrationResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationResponseSpec defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponse#spec
   */
  readonly spec: IntegrationResponseSpec;

}

/**
 * Converts an object of type 'IntegrationResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseProps(obj: IntegrationResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationResponseSpec defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpec
 */
export interface IntegrationResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationResponseSpecDeletionPolicy;

  /**
   * IntegrationResponseParameters defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponseSpec#forProvider
   */
  readonly forProvider: IntegrationResponseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IntegrationResponseSpec#managementPolicies
   */
  readonly managementPolicies?: IntegrationResponseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationResponseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpec(obj: IntegrationResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationResponseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IntegrationResponseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecDeletionPolicy
 */
export enum IntegrationResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IntegrationResponseParameters defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpecForProvider
 */
export interface IntegrationResponseSpecForProvider {
  /**
   * Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
   * If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
   *
   * @schema IntegrationResponseSpecForProvider#contentHandling
   */
  readonly contentHandling?: string;

  /**
   * Specifies a put integration response request's HTTP method.
   *
   * @schema IntegrationResponseSpecForProvider#httpMethod
   */
  readonly httpMethod: string;

  /**
   * Region is which region the IntegrationResponse will be created.
   *
   * @schema IntegrationResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * ResourceID is the ID for the Resource.
   *
   * @schema IntegrationResponseSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * ResourceIDRef is a reference to an Parent used to set the ResourceID.
   *
   * @schema IntegrationResponseSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: IntegrationResponseSpecForProviderResourceIdRef;

  /**
   * ResourceIDSelector selects references to Parent used to set the ResourceID.
   *
   * @schema IntegrationResponseSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: IntegrationResponseSpecForProviderResourceIdSelector;

  /**
   * A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name must be a valid and unique response header name and JSON-expression a valid JSON expression without the $ prefix.
   *
   * @schema IntegrationResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: string };

  /**
   * Specifies a put integration response's templates.
   *
   * @schema IntegrationResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema IntegrationResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema IntegrationResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: IntegrationResponseSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema IntegrationResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: IntegrationResponseSpecForProviderRestApiIdSelector;

  /**
   * Specifies the selection pattern of a put integration response.
   *
   * @schema IntegrationResponseSpecForProvider#selectionPattern
   */
  readonly selectionPattern?: string;

  /**
   * Specifies the status code that is used to map the integration response to an existing MethodResponse.
   *
   * @schema IntegrationResponseSpecForProvider#statusCode
   */
  readonly statusCode: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProvider(obj: IntegrationResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentHandling': obj.contentHandling,
    'httpMethod': obj.httpMethod,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_IntegrationResponseSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_IntegrationResponseSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_IntegrationResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_IntegrationResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'selectionPattern': obj.selectionPattern,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IntegrationResponseSpecManagementPolicies
 */
export enum IntegrationResponseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationResponseSpecProviderConfigRef
 */
export interface IntegrationResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRef(obj: IntegrationResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsTo
 */
export interface IntegrationResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj: IntegrationResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationResponseSpecWriteConnectionSecretToRef
 */
export interface IntegrationResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj: IntegrationResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDRef is a reference to an Parent used to set the ResourceID.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRef
 */
export interface IntegrationResponseSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdRef(obj: IntegrationResponseSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDSelector selects references to Parent used to set the ResourceID.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelector
 */
export interface IntegrationResponseSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdSelector(obj: IntegrationResponseSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRef
 */
export interface IntegrationResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdRef(obj: IntegrationResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelector
 */
export interface IntegrationResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdSelector(obj: IntegrationResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicy
 */
export interface IntegrationResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj: IntegrationResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj: IntegrationResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdRefPolicy(obj: IntegrationResponseSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdSelectorPolicy(obj: IntegrationResponseSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdRefPolicy(obj: IntegrationResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdSelectorPolicy(obj: IntegrationResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Method is the Schema for the Methods API
 *
 * @schema Method
 */
export class Method extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Method"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Method',
  }

  /**
   * Renders a Kubernetes manifest for "Method".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MethodProps): any {
    return {
      ...Method.GVK,
      ...toJson_MethodProps(props),
    };
  }

  /**
   * Defines a "Method" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MethodProps) {
    super(scope, id, {
      ...Method.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Method.GVK,
      ...toJson_MethodProps(resolved),
    };
  }
}

/**
 * Method is the Schema for the Methods API
 *
 * @schema Method
 */
export interface MethodProps {
  /**
   * @schema Method#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MethodSpec defines the desired state of Method
   *
   * @schema Method#spec
   */
  readonly spec: MethodSpec;

}

/**
 * Converts an object of type 'MethodProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodProps(obj: MethodProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MethodSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MethodSpec defines the desired state of Method
 *
 * @schema MethodSpec
 */
export interface MethodSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodSpec#deletionPolicy
   */
  readonly deletionPolicy?: MethodSpecDeletionPolicy;

  /**
   * MethodParameters defines the desired state of Method
   *
   * @schema MethodSpec#forProvider
   */
  readonly forProvider: MethodSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MethodSpec#managementPolicies
   */
  readonly managementPolicies?: MethodSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MethodSpec#providerConfigRef
   */
  readonly providerConfigRef?: MethodSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MethodSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MethodSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MethodSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MethodSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MethodSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpec(obj: MethodSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MethodSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MethodSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MethodSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MethodSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodSpecDeletionPolicy
 */
export enum MethodSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * MethodParameters defines the desired state of Method
 *
 * @schema MethodSpecForProvider
 */
export interface MethodSpecForProvider {
  /**
   * Specifies whether the method required a valid ApiKey.
   *
   * @schema MethodSpecForProvider#apiKeyRequired
   */
  readonly apiKeyRequired?: boolean;

  /**
   * A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
   *
   * @schema MethodSpecForProvider#authorizationScopes
   */
  readonly authorizationScopes?: string[];

  /**
   * The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
   *
   * @schema MethodSpecForProvider#authorizationType
   */
  readonly authorizationType: string;

  /**
   * Specifies the identifier of an Authorizer to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
   *
   * @schema MethodSpecForProvider#authorizerID
   */
  readonly authorizerId?: string;

  /**
   * AuthorizerID is the ID for the Authorizer.
   *
   * @schema MethodSpecForProvider#authorizerId
   */
  readonly authorizerId?: string;

  /**
   * AuthorizerIDRef is a reference to an Authorizer used to set the AuthorizerID.
   *
   * @schema MethodSpecForProvider#authorizerIdRef
   */
  readonly authorizerIdRef?: MethodSpecForProviderAuthorizerIdRef;

  /**
   * RestApiIdSelector selects references to Authorizer used to set the AuthorizerID.
   *
   * @schema MethodSpecForProvider#authorizerIdSelector
   */
  readonly authorizerIdSelector?: MethodSpecForProviderAuthorizerIdSelector;

  /**
   * Specifies the method request's HTTP method type.
   *
   * @schema MethodSpecForProvider#httpMethod
   */
  readonly httpMethod: string;

  /**
   * A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
   *
   * @schema MethodSpecForProvider#operationName
   */
  readonly operationName?: string;

  /**
   * Region is which region the Method will be created.
   *
   * @schema MethodSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the Model resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a Model name as the value.
   *
   * @schema MethodSpecForProvider#requestModels
   */
  readonly requestModels?: { [key: string]: string };

  /**
   * A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or body-mapping templates.
   *
   * @schema MethodSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: boolean };

  /**
   * The identifier of a RequestValidator for validating the method request.
   *
   * @schema MethodSpecForProvider#requestValidatorID
   */
  readonly requestValidatorId?: string;

  /**
   * RequestValidatorID is the ID for the RequestValidator.
   *
   * @schema MethodSpecForProvider#requestValidatorId
   */
  readonly requestValidatorId?: string;

  /**
   * RequestValidatorIDRef is a reference to an RequestValidator used to set the RequestValidatorID.
   *
   * @schema MethodSpecForProvider#requestValidatorIdRef
   */
  readonly requestValidatorIdRef?: MethodSpecForProviderRequestValidatorIdRef;

  /**
   * RequestValidatorIDSelector selects references to RequestValidator used to set the RequestValidatorID.
   *
   * @schema MethodSpecForProvider#requestValidatorIdSelector
   */
  readonly requestValidatorIdSelector?: MethodSpecForProviderRequestValidatorIdSelector;

  /**
   * ResourceID is the ID for the Resource.
   *
   * @schema MethodSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * ResourceIDRef is a reference to an Resource used to set the ResourceID.
   *
   * @schema MethodSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: MethodSpecForProviderResourceIdRef;

  /**
   * RestApiIdSelector selects references to Resource used to set the ResourceID.
   *
   * @schema MethodSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: MethodSpecForProviderResourceIdSelector;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema MethodSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema MethodSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: MethodSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema MethodSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: MethodSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'MethodSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProvider(obj: MethodSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRequired': obj.apiKeyRequired,
    'authorizationScopes': obj.authorizationScopes?.map(y => y),
    'authorizationType': obj.authorizationType,
    'authorizerID': obj.authorizerId,
    'authorizerId': obj.authorizerId,
    'authorizerIdRef': toJson_MethodSpecForProviderAuthorizerIdRef(obj.authorizerIdRef),
    'authorizerIdSelector': toJson_MethodSpecForProviderAuthorizerIdSelector(obj.authorizerIdSelector),
    'httpMethod': obj.httpMethod,
    'operationName': obj.operationName,
    'region': obj.region,
    'requestModels': ((obj.requestModels) === undefined) ? undefined : (Object.entries(obj.requestModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestValidatorID': obj.requestValidatorId,
    'requestValidatorId': obj.requestValidatorId,
    'requestValidatorIdRef': toJson_MethodSpecForProviderRequestValidatorIdRef(obj.requestValidatorIdRef),
    'requestValidatorIdSelector': toJson_MethodSpecForProviderRequestValidatorIdSelector(obj.requestValidatorIdSelector),
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_MethodSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_MethodSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_MethodSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_MethodSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MethodSpecManagementPolicies
 */
export enum MethodSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MethodSpecProviderConfigRef
 */
export interface MethodSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecProviderConfigRef#policy
   */
  readonly policy?: MethodSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderConfigRef(obj: MethodSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MethodSpecPublishConnectionDetailsTo
 */
export interface MethodSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MethodSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MethodSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsTo(obj: MethodSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MethodSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MethodSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MethodSpecWriteConnectionSecretToRef
 */
export interface MethodSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MethodSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MethodSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MethodSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecWriteConnectionSecretToRef(obj: MethodSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerIDRef is a reference to an Authorizer used to set the AuthorizerID.
 *
 * @schema MethodSpecForProviderAuthorizerIdRef
 */
export interface MethodSpecForProviderAuthorizerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderAuthorizerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderAuthorizerIdRef#policy
   */
  readonly policy?: MethodSpecForProviderAuthorizerIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdRef(obj: MethodSpecForProviderAuthorizerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderAuthorizerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to Authorizer used to set the AuthorizerID.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelector
 */
export interface MethodSpecForProviderAuthorizerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderAuthorizerIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdSelector(obj: MethodSpecForProviderAuthorizerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderAuthorizerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestValidatorIDRef is a reference to an RequestValidator used to set the RequestValidatorID.
 *
 * @schema MethodSpecForProviderRequestValidatorIdRef
 */
export interface MethodSpecForProviderRequestValidatorIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderRequestValidatorIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderRequestValidatorIdRef#policy
   */
  readonly policy?: MethodSpecForProviderRequestValidatorIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRequestValidatorIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRequestValidatorIdRef(obj: MethodSpecForProviderRequestValidatorIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderRequestValidatorIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestValidatorIDSelector selects references to RequestValidator used to set the RequestValidatorID.
 *
 * @schema MethodSpecForProviderRequestValidatorIdSelector
 */
export interface MethodSpecForProviderRequestValidatorIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderRequestValidatorIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderRequestValidatorIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderRequestValidatorIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderRequestValidatorIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRequestValidatorIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRequestValidatorIdSelector(obj: MethodSpecForProviderRequestValidatorIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderRequestValidatorIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDRef is a reference to an Resource used to set the ResourceID.
 *
 * @schema MethodSpecForProviderResourceIdRef
 */
export interface MethodSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderResourceIdRef#policy
   */
  readonly policy?: MethodSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdRef(obj: MethodSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to Resource used to set the ResourceID.
 *
 * @schema MethodSpecForProviderResourceIdSelector
 */
export interface MethodSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdSelector(obj: MethodSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema MethodSpecForProviderRestApiIdRef
 */
export interface MethodSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: MethodSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdRef(obj: MethodSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema MethodSpecForProviderRestApiIdSelector
 */
export interface MethodSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdSelector(obj: MethodSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecProviderConfigRefPolicy
 */
export interface MethodSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderConfigRefPolicy(obj: MethodSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRef
 */
export interface MethodSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MethodSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToConfigRef(obj: MethodSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MethodSpecPublishConnectionDetailsToMetadata
 */
export interface MethodSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToMetadata(obj: MethodSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicy
 */
export interface MethodSpecForProviderAuthorizerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderAuthorizerIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderAuthorizerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderAuthorizerIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderAuthorizerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdRefPolicy(obj: MethodSpecForProviderAuthorizerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy
 */
export interface MethodSpecForProviderAuthorizerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderAuthorizerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderAuthorizerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdSelectorPolicy(obj: MethodSpecForProviderAuthorizerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderRequestValidatorIdRefPolicy
 */
export interface MethodSpecForProviderRequestValidatorIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRequestValidatorIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRequestValidatorIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRequestValidatorIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRequestValidatorIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRequestValidatorIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRequestValidatorIdRefPolicy(obj: MethodSpecForProviderRequestValidatorIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderRequestValidatorIdSelectorPolicy
 */
export interface MethodSpecForProviderRequestValidatorIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRequestValidatorIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRequestValidatorIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRequestValidatorIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRequestValidatorIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRequestValidatorIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRequestValidatorIdSelectorPolicy(obj: MethodSpecForProviderRequestValidatorIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicy
 */
export interface MethodSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdRefPolicy(obj: MethodSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicy
 */
export interface MethodSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdSelectorPolicy(obj: MethodSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicy
 */
export interface MethodSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdRefPolicy(obj: MethodSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicy
 */
export interface MethodSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdSelectorPolicy(obj: MethodSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecProviderConfigRefPolicyResolution
 */
export enum MethodSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecProviderConfigRefPolicyResolve
 */
export enum MethodSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MethodSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToConfigRefPolicy(obj: MethodSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicyResolution
 */
export enum MethodSpecForProviderAuthorizerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicyResolve
 */
export enum MethodSpecForProviderAuthorizerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderAuthorizerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderAuthorizerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRequestValidatorIdRefPolicyResolution
 */
export enum MethodSpecForProviderRequestValidatorIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRequestValidatorIdRefPolicyResolve
 */
export enum MethodSpecForProviderRequestValidatorIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRequestValidatorIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderRequestValidatorIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRequestValidatorIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderRequestValidatorIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicyResolution
 */
export enum MethodSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicyResolve
 */
export enum MethodSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicyResolution
 */
export enum MethodSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicyResolve
 */
export enum MethodSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MethodResponse is the Schema for the MethodResponses API
 *
 * @schema MethodResponse
 */
export class MethodResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MethodResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'MethodResponse',
  }

  /**
   * Renders a Kubernetes manifest for "MethodResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MethodResponseProps): any {
    return {
      ...MethodResponse.GVK,
      ...toJson_MethodResponseProps(props),
    };
  }

  /**
   * Defines a "MethodResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MethodResponseProps) {
    super(scope, id, {
      ...MethodResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MethodResponse.GVK,
      ...toJson_MethodResponseProps(resolved),
    };
  }
}

/**
 * MethodResponse is the Schema for the MethodResponses API
 *
 * @schema MethodResponse
 */
export interface MethodResponseProps {
  /**
   * @schema MethodResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MethodResponseSpec defines the desired state of MethodResponse
   *
   * @schema MethodResponse#spec
   */
  readonly spec: MethodResponseSpec;

}

/**
 * Converts an object of type 'MethodResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseProps(obj: MethodResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MethodResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MethodResponseSpec defines the desired state of MethodResponse
 *
 * @schema MethodResponseSpec
 */
export interface MethodResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: MethodResponseSpecDeletionPolicy;

  /**
   * MethodResponseParameters defines the desired state of MethodResponse
   *
   * @schema MethodResponseSpec#forProvider
   */
  readonly forProvider: MethodResponseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MethodResponseSpec#managementPolicies
   */
  readonly managementPolicies?: MethodResponseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MethodResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: MethodResponseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MethodResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MethodResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MethodResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MethodResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MethodResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpec(obj: MethodResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MethodResponseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MethodResponseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MethodResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MethodResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodResponseSpecDeletionPolicy
 */
export enum MethodResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * MethodResponseParameters defines the desired state of MethodResponse
 *
 * @schema MethodResponseSpecForProvider
 */
export interface MethodResponseSpecForProvider {
  /**
   * The HTTP verb of the Method resource.
   *
   * @schema MethodResponseSpecForProvider#httpMethod
   */
  readonly httpMethod: string;

  /**
   * Region is which region the MethodResponse will be created.
   *
   * @schema MethodResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * ResourceID is the ID for the Resource.
   *
   * @schema MethodResponseSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * ResourceIDRef is a reference to an Resource used to set the ResourceID.
   *
   * @schema MethodResponseSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: MethodResponseSpecForProviderResourceIdRef;

  /**
   * RestApiIdSelector selects references to Resource used to set the ResourceID.
   *
   * @schema MethodResponseSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: MethodResponseSpecForProviderResourceIdSelector;

  /**
   * Specifies the Model resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a Model name as the value.
   *
   * @schema MethodResponseSpecForProvider#responseModels
   */
  readonly responseModels?: { [key: string]: string };

  /**
   * A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
   *
   * @schema MethodResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: boolean };

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema MethodResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema MethodResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: MethodResponseSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema MethodResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: MethodResponseSpecForProviderRestApiIdSelector;

  /**
   * The method response's status code.
   *
   * @schema MethodResponseSpecForProvider#statusCode
   */
  readonly statusCode: string;

}

/**
 * Converts an object of type 'MethodResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProvider(obj: MethodResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpMethod': obj.httpMethod,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_MethodResponseSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_MethodResponseSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'responseModels': ((obj.responseModels) === undefined) ? undefined : (Object.entries(obj.responseModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_MethodResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_MethodResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MethodResponseSpecManagementPolicies
 */
export enum MethodResponseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MethodResponseSpecProviderConfigRef
 */
export interface MethodResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecProviderConfigRef#policy
   */
  readonly policy?: MethodResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderConfigRef(obj: MethodResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsTo
 */
export interface MethodResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MethodResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MethodResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsTo(obj: MethodResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MethodResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MethodResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MethodResponseSpecWriteConnectionSecretToRef
 */
export interface MethodResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MethodResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MethodResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MethodResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecWriteConnectionSecretToRef(obj: MethodResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIDRef is a reference to an Resource used to set the ResourceID.
 *
 * @schema MethodResponseSpecForProviderResourceIdRef
 */
export interface MethodResponseSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecForProviderResourceIdRef#policy
   */
  readonly policy?: MethodResponseSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdRef(obj: MethodResponseSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to Resource used to set the ResourceID.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelector
 */
export interface MethodResponseSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: MethodResponseSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdSelector(obj: MethodResponseSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodResponseSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRef
 */
export interface MethodResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: MethodResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdRef(obj: MethodResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelector
 */
export interface MethodResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: MethodResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdSelector(obj: MethodResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicy
 */
export interface MethodResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderConfigRefPolicy(obj: MethodResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface MethodResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToConfigRef(obj: MethodResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToMetadata
 */
export interface MethodResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToMetadata(obj: MethodResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicy
 */
export interface MethodResponseSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdRefPolicy(obj: MethodResponseSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy
 */
export interface MethodResponseSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdSelectorPolicy(obj: MethodResponseSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicy
 */
export interface MethodResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdRefPolicy(obj: MethodResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface MethodResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdSelectorPolicy(obj: MethodResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicyResolution
 */
export enum MethodResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicyResolve
 */
export enum MethodResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicyResolution
 */
export enum MethodResponseSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicyResolve
 */
export enum MethodResponseSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum MethodResponseSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum MethodResponseSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum MethodResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum MethodResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Model is the Schema for the Models API
 *
 * @schema Model
 */
export class Model extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Model"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Model',
  }

  /**
   * Renders a Kubernetes manifest for "Model".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelProps): any {
    return {
      ...Model.GVK,
      ...toJson_ModelProps(props),
    };
  }

  /**
   * Defines a "Model" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelProps) {
    super(scope, id, {
      ...Model.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Model.GVK,
      ...toJson_ModelProps(resolved),
    };
  }
}

/**
 * Model is the Schema for the Models API
 *
 * @schema Model
 */
export interface ModelProps {
  /**
   * @schema Model#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelSpec defines the desired state of Model
   *
   * @schema Model#spec
   */
  readonly spec: ModelSpec;

}

/**
 * Converts an object of type 'ModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelProps(obj: ModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelSpec defines the desired state of Model
 *
 * @schema ModelSpec
 */
export interface ModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelSpecDeletionPolicy;

  /**
   * ModelParameters defines the desired state of Model
   *
   * @schema ModelSpec#forProvider
   */
  readonly forProvider: ModelSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ModelSpec#managementPolicies
   */
  readonly managementPolicies?: ModelSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpec(obj: ModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ModelSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecDeletionPolicy
 */
export enum ModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ModelParameters defines the desired state of Model
 *
 * @schema ModelSpecForProvider
 */
export interface ModelSpecForProvider {
  /**
   * The content-type for the model.
   *
   * @schema ModelSpecForProvider#contentType
   */
  readonly contentType: string;

  /**
   * The description of the model.
   *
   * @schema ModelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the model. Must be alphanumeric.
   *
   * @schema ModelSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the Model will be created.
   *
   * @schema ModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema ModelSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema ModelSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: ModelSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema ModelSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: ModelSpecForProviderRestApiIdSelector;

  /**
   * The schema for the model. For application/json models, this should be JSON schema draft 4 model.
   *
   * @schema ModelSpecForProvider#schema
   */
  readonly schema?: string;

}

/**
 * Converts an object of type 'ModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProvider(obj: ModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_ModelSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_ModelSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ModelSpecManagementPolicies
 */
export enum ModelSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelSpecProviderConfigRef
 */
export interface ModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderConfigRef#policy
   */
  readonly policy?: ModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRef(obj: ModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelSpecPublishConnectionDetailsTo
 */
export interface ModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsTo(obj: ModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelSpecWriteConnectionSecretToRef
 */
export interface ModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecWriteConnectionSecretToRef(obj: ModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema ModelSpecForProviderRestApiIdRef
 */
export interface ModelSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: ModelSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdRef(obj: ModelSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema ModelSpecForProviderRestApiIdSelector
 */
export interface ModelSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: ModelSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdSelector(obj: ModelSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderConfigRefPolicy
 */
export interface ModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRefPolicy(obj: ModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj: ModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelSpecPublishConnectionDetailsToMetadata
 */
export interface ModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToMetadata(obj: ModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicy
 */
export interface ModelSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdRefPolicy(obj: ModelSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicy
 */
export interface ModelSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdSelectorPolicy(obj: ModelSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolution
 */
export enum ModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolve
 */
export enum ModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicyResolution
 */
export enum ModelSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicyResolve
 */
export enum ModelSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum ModelSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum ModelSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RequestValidator is the Schema for the RequestValidators API
 *
 * @schema RequestValidator
 */
export class RequestValidator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RequestValidator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'RequestValidator',
  }

  /**
   * Renders a Kubernetes manifest for "RequestValidator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RequestValidatorProps): any {
    return {
      ...RequestValidator.GVK,
      ...toJson_RequestValidatorProps(props),
    };
  }

  /**
   * Defines a "RequestValidator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RequestValidatorProps) {
    super(scope, id, {
      ...RequestValidator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RequestValidator.GVK,
      ...toJson_RequestValidatorProps(resolved),
    };
  }
}

/**
 * RequestValidator is the Schema for the RequestValidators API
 *
 * @schema RequestValidator
 */
export interface RequestValidatorProps {
  /**
   * @schema RequestValidator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RequestValidatorSpec defines the desired state of RequestValidator
   *
   * @schema RequestValidator#spec
   */
  readonly spec: RequestValidatorSpec;

}

/**
 * Converts an object of type 'RequestValidatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorProps(obj: RequestValidatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RequestValidatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestValidatorSpec defines the desired state of RequestValidator
 *
 * @schema RequestValidatorSpec
 */
export interface RequestValidatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RequestValidatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: RequestValidatorSpecDeletionPolicy;

  /**
   * RequestValidatorParameters defines the desired state of RequestValidator
   *
   * @schema RequestValidatorSpec#forProvider
   */
  readonly forProvider: RequestValidatorSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RequestValidatorSpec#managementPolicies
   */
  readonly managementPolicies?: RequestValidatorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RequestValidatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: RequestValidatorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RequestValidatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RequestValidatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RequestValidatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RequestValidatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RequestValidatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpec(obj: RequestValidatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RequestValidatorSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RequestValidatorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RequestValidatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RequestValidatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RequestValidatorSpecDeletionPolicy
 */
export enum RequestValidatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RequestValidatorParameters defines the desired state of RequestValidator
 *
 * @schema RequestValidatorSpecForProvider
 */
export interface RequestValidatorSpecForProvider {
  /**
   * The name of the to-be-created RequestValidator.
   *
   * @schema RequestValidatorSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is which region the RequestValidator will be created.
   *
   * @schema RequestValidatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema RequestValidatorSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema RequestValidatorSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: RequestValidatorSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema RequestValidatorSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: RequestValidatorSpecForProviderRestApiIdSelector;

  /**
   * A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (true) or not (false).
   *
   * @schema RequestValidatorSpecForProvider#validateRequestBody
   */
  readonly validateRequestBody?: boolean;

  /**
   * A Boolean flag to indicate whether to validate request parameters, true, or not false.
   *
   * @schema RequestValidatorSpecForProvider#validateRequestParameters
   */
  readonly validateRequestParameters?: boolean;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProvider(obj: RequestValidatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_RequestValidatorSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_RequestValidatorSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'validateRequestBody': obj.validateRequestBody,
    'validateRequestParameters': obj.validateRequestParameters,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RequestValidatorSpecManagementPolicies
 */
export enum RequestValidatorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RequestValidatorSpecProviderConfigRef
 */
export interface RequestValidatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecProviderConfigRef#policy
   */
  readonly policy?: RequestValidatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderConfigRef(obj: RequestValidatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsTo
 */
export interface RequestValidatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RequestValidatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RequestValidatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsTo(obj: RequestValidatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RequestValidatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RequestValidatorSpecWriteConnectionSecretToRef
 */
export interface RequestValidatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RequestValidatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RequestValidatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecWriteConnectionSecretToRef(obj: RequestValidatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRef
 */
export interface RequestValidatorSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: RequestValidatorSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdRef(obj: RequestValidatorSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelector
 */
export interface RequestValidatorSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: RequestValidatorSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdSelector(obj: RequestValidatorSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RequestValidatorSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicy
 */
export interface RequestValidatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderConfigRefPolicy(obj: RequestValidatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef
 */
export interface RequestValidatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRef(obj: RequestValidatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata
 */
export interface RequestValidatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToMetadata(obj: RequestValidatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy
 */
export interface RequestValidatorSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdRefPolicy(obj: RequestValidatorSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy
 */
export interface RequestValidatorSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdSelectorPolicy(obj: RequestValidatorSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicyResolution
 */
export enum RequestValidatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicyResolve
 */
export enum RequestValidatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicyResolution
 */
export enum RequestValidatorSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicyResolve
 */
export enum RequestValidatorSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Resource is the Schema for the Resources API
 *
 * @schema Resource
 */
export class Resource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Resource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Resource',
  }

  /**
   * Renders a Kubernetes manifest for "Resource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceProps): any {
    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(props),
    };
  }

  /**
   * Defines a "Resource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceProps) {
    super(scope, id, {
      ...Resource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(resolved),
    };
  }
}

/**
 * Resource is the Schema for the Resources API
 *
 * @schema Resource
 */
export interface ResourceProps {
  /**
   * @schema Resource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceSpec defines the desired state of Resource
   *
   * @schema Resource#spec
   */
  readonly spec: ResourceSpec;

}

/**
 * Converts an object of type 'ResourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceProps(obj: ResourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceSpec defines the desired state of Resource
 *
 * @schema ResourceSpec
 */
export interface ResourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceSpecDeletionPolicy;

  /**
   * ResourceParameters defines the desired state of Resource
   *
   * @schema ResourceSpec#forProvider
   */
  readonly forProvider: ResourceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResourceSpec#managementPolicies
   */
  readonly managementPolicies?: ResourceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpec(obj: ResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResourceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceSpecDeletionPolicy
 */
export enum ResourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ResourceParameters defines the desired state of Resource
 *
 * @schema ResourceSpecForProvider
 */
export interface ResourceSpecForProvider {
  /**
   * ParentID is the ID for the Parent.
   *
   * @schema ResourceSpecForProvider#parentResourceId
   */
  readonly parentResourceId?: string;

  /**
   * ParentIDRef is a reference to an Parent used to set the ParentID.
   *
   * @schema ResourceSpecForProvider#parentResourceIdRef
   */
  readonly parentResourceIdRef?: ResourceSpecForProviderParentResourceIdRef;

  /**
   * RestApiIdSelector selects references to Parent used to set the ParentID.
   *
   * @schema ResourceSpecForProvider#parentResourceIdSelector
   */
  readonly parentResourceIdSelector?: ResourceSpecForProviderParentResourceIdSelector;

  /**
   * The last path segment for this resource.
   *
   * @schema ResourceSpecForProvider#pathPart
   */
  readonly pathPart: string;

  /**
   * Region is which region the Resource will be created.
   *
   * @schema ResourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema ResourceSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema ResourceSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: ResourceSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema ResourceSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: ResourceSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'ResourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProvider(obj: ResourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parentResourceId': obj.parentResourceId,
    'parentResourceIdRef': toJson_ResourceSpecForProviderParentResourceIdRef(obj.parentResourceIdRef),
    'parentResourceIdSelector': toJson_ResourceSpecForProviderParentResourceIdSelector(obj.parentResourceIdSelector),
    'pathPart': obj.pathPart,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_ResourceSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_ResourceSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResourceSpecManagementPolicies
 */
export enum ResourceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceSpecProviderConfigRef
 */
export interface ResourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRef(obj: ResourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceSpecPublishConnectionDetailsTo
 */
export interface ResourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsTo(obj: ResourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceSpecWriteConnectionSecretToRef
 */
export interface ResourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecWriteConnectionSecretToRef(obj: ResourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParentIDRef is a reference to an Parent used to set the ParentID.
 *
 * @schema ResourceSpecForProviderParentResourceIdRef
 */
export interface ResourceSpecForProviderParentResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderParentResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderParentResourceIdRef#policy
   */
  readonly policy?: ResourceSpecForProviderParentResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentResourceIdRef(obj: ResourceSpecForProviderParentResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderParentResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to Parent used to set the ParentID.
 *
 * @schema ResourceSpecForProviderParentResourceIdSelector
 */
export interface ResourceSpecForProviderParentResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderParentResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderParentResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderParentResourceIdSelector#policy
   */
  readonly policy?: ResourceSpecForProviderParentResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentResourceIdSelector(obj: ResourceSpecForProviderParentResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderParentResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema ResourceSpecForProviderRestApiIdRef
 */
export interface ResourceSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: ResourceSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdRef(obj: ResourceSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema ResourceSpecForProviderRestApiIdSelector
 */
export interface ResourceSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: ResourceSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdSelector(obj: ResourceSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderConfigRefPolicy
 */
export interface ResourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRefPolicy(obj: ResourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj: ResourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj: ResourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderParentResourceIdRefPolicy
 */
export interface ResourceSpecForProviderParentResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderParentResourceIdRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderParentResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderParentResourceIdRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderParentResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentResourceIdRefPolicy(obj: ResourceSpecForProviderParentResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderParentResourceIdSelectorPolicy
 */
export interface ResourceSpecForProviderParentResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderParentResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderParentResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderParentResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderParentResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentResourceIdSelectorPolicy(obj: ResourceSpecForProviderParentResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicy
 */
export interface ResourceSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdRefPolicy(obj: ResourceSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicy
 */
export interface ResourceSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdSelectorPolicy(obj: ResourceSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolution
 */
export enum ResourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolve
 */
export enum ResourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderParentResourceIdRefPolicyResolution
 */
export enum ResourceSpecForProviderParentResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderParentResourceIdRefPolicyResolve
 */
export enum ResourceSpecForProviderParentResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderParentResourceIdSelectorPolicyResolution
 */
export enum ResourceSpecForProviderParentResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderParentResourceIdSelectorPolicyResolve
 */
export enum ResourceSpecForProviderParentResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicyResolution
 */
export enum ResourceSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicyResolve
 */
export enum ResourceSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum ResourceSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum ResourceSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RestAPI is the Schema for the RestAPIS API
 *
 * @schema RestAPI
 */
export class RestApi extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RestAPI"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'RestAPI',
  }

  /**
   * Renders a Kubernetes manifest for "RestAPI".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RestApiProps): any {
    return {
      ...RestApi.GVK,
      ...toJson_RestApiProps(props),
    };
  }

  /**
   * Defines a "RestAPI" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RestApiProps) {
    super(scope, id, {
      ...RestApi.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RestApi.GVK,
      ...toJson_RestApiProps(resolved),
    };
  }
}

/**
 * RestAPI is the Schema for the RestAPIS API
 *
 * @schema RestAPI
 */
export interface RestApiProps {
  /**
   * @schema RestAPI#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RestAPISpec defines the desired state of RestAPI
   *
   * @schema RestAPI#spec
   */
  readonly spec: RestApiSpec;

}

/**
 * Converts an object of type 'RestApiProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiProps(obj: RestApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RestApiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPISpec defines the desired state of RestAPI
 *
 * @schema RestApiSpec
 */
export interface RestApiSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RestApiSpec#deletionPolicy
   */
  readonly deletionPolicy?: RestApiSpecDeletionPolicy;

  /**
   * RestAPIParameters defines the desired state of RestAPI
   *
   * @schema RestApiSpec#forProvider
   */
  readonly forProvider: RestApiSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RestApiSpec#managementPolicies
   */
  readonly managementPolicies?: RestApiSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RestApiSpec#providerConfigRef
   */
  readonly providerConfigRef?: RestApiSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RestApiSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RestApiSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RestApiSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RestApiSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RestApiSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpec(obj: RestApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RestApiSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RestApiSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RestApiSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RestApiSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RestApiSpecDeletionPolicy
 */
export enum RestApiSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RestAPIParameters defines the desired state of RestAPI
 *
 * @schema RestApiSpecForProvider
 */
export interface RestApiSpecForProvider {
  /**
   * The source of the API key for metering requests according to a usage plan. Valid values are: HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
   *
   * @schema RestApiSpecForProvider#apiKeySource
   */
  readonly apiKeySource?: string;

  /**
   * The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
   *
   * @schema RestApiSpecForProvider#binaryMediaTypes
   */
  readonly binaryMediaTypes?: string[];

  /**
   * The ID of the RestApi that you want to clone from.
   *
   * @schema RestApiSpecForProvider#cloneFrom
   */
  readonly cloneFrom?: string;

  /**
   * The description of the RestApi.
   *
   * @schema RestApiSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
   *
   * @schema RestApiSpecForProvider#disableExecuteAPIEndpoint
   */
  readonly disableExecuteApiEndpoint?: boolean;

  /**
   * The endpoint configuration of this RestApi showing the endpoint types of the API.
   *
   * @schema RestApiSpecForProvider#endpointConfiguration
   */
  readonly endpointConfiguration?: RestApiSpecForProviderEndpointConfiguration;

  /**
   * A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
   *
   * @schema RestApiSpecForProvider#minimumCompressionSize
   */
  readonly minimumCompressionSize?: number;

  /**
   * The name of the RestApi.
   *
   * @schema RestApiSpecForProvider#name
   */
  readonly name: string;

  /**
   * A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
   *
   * @schema RestApiSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is which region the RestAPI will be created.
   *
   * @schema RestApiSpecForProvider#region
   */
  readonly region: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema RestApiSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * A version identifier for the API.
   *
   * @schema RestApiSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'RestApiSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecForProvider(obj: RestApiSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySource': obj.apiKeySource,
    'binaryMediaTypes': obj.binaryMediaTypes?.map(y => y),
    'cloneFrom': obj.cloneFrom,
    'description': obj.description,
    'disableExecuteAPIEndpoint': obj.disableExecuteApiEndpoint,
    'endpointConfiguration': toJson_RestApiSpecForProviderEndpointConfiguration(obj.endpointConfiguration),
    'minimumCompressionSize': obj.minimumCompressionSize,
    'name': obj.name,
    'policy': obj.policy,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RestApiSpecManagementPolicies
 */
export enum RestApiSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RestApiSpecProviderConfigRef
 */
export interface RestApiSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiSpecProviderConfigRef#policy
   */
  readonly policy?: RestApiSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderConfigRef(obj: RestApiSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RestApiSpecPublishConnectionDetailsTo
 */
export interface RestApiSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RestApiSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RestApiSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsTo(obj: RestApiSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RestApiSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RestApiSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RestApiSpecWriteConnectionSecretToRef
 */
export interface RestApiSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RestApiSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RestApiSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RestApiSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecWriteConnectionSecretToRef(obj: RestApiSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The endpoint configuration of this RestApi showing the endpoint types of the API.
 *
 * @schema RestApiSpecForProviderEndpointConfiguration
 */
export interface RestApiSpecForProviderEndpointConfiguration {
  /**
   * @schema RestApiSpecForProviderEndpointConfiguration#types
   */
  readonly types?: string[];

  /**
   * @schema RestApiSpecForProviderEndpointConfiguration#vpcEndpointIDs
   */
  readonly vpcEndpointIDs?: string[];

}

/**
 * Converts an object of type 'RestApiSpecForProviderEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecForProviderEndpointConfiguration(obj: RestApiSpecForProviderEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'types': obj.types?.map(y => y),
    'vpcEndpointIDs': obj.vpcEndpointIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiSpecProviderConfigRefPolicy
 */
export interface RestApiSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderConfigRefPolicy(obj: RestApiSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRef
 */
export interface RestApiSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RestApiSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToConfigRef(obj: RestApiSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RestApiSpecPublishConnectionDetailsToMetadata
 */
export interface RestApiSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToMetadata(obj: RestApiSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiSpecProviderConfigRefPolicyResolution
 */
export enum RestApiSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiSpecProviderConfigRefPolicyResolve
 */
export enum RestApiSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RestApiSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToConfigRefPolicy(obj: RestApiSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stage is the Schema for the Stages API
 *
 * @schema Stage
 */
export class Stage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'Stage',
  }

  /**
   * Renders a Kubernetes manifest for "Stage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StageProps): any {
    return {
      ...Stage.GVK,
      ...toJson_StageProps(props),
    };
  }

  /**
   * Defines a "Stage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StageProps) {
    super(scope, id, {
      ...Stage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stage.GVK,
      ...toJson_StageProps(resolved),
    };
  }
}

/**
 * Stage is the Schema for the Stages API
 *
 * @schema Stage
 */
export interface StageProps {
  /**
   * @schema Stage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StageSpec defines the desired state of Stage
   *
   * @schema Stage#spec
   */
  readonly spec: StageSpec;

}

/**
 * Converts an object of type 'StageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageProps(obj: StageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageSpec defines the desired state of Stage
 *
 * @schema StageSpec
 */
export interface StageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#deletionPolicy
   */
  readonly deletionPolicy?: StageSpecDeletionPolicy;

  /**
   * StageParameters defines the desired state of Stage
   *
   * @schema StageSpec#forProvider
   */
  readonly forProvider: StageSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StageSpec#managementPolicies
   */
  readonly managementPolicies?: StageSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StageSpec#providerConfigRef
   */
  readonly providerConfigRef?: StageSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpec(obj: StageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StageSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StageSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecDeletionPolicy
 */
export enum StageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * StageParameters defines the desired state of Stage
 *
 * @schema StageSpecForProvider
 */
export interface StageSpecForProvider {
  /**
   * Whether cache clustering is enabled for the stage.
   *
   * @schema StageSpecForProvider#cacheClusterEnabled
   */
  readonly cacheClusterEnabled?: boolean;

  /**
   * The stage's cache capacity in GB. For more information about choosing a cache size, see Enabling API caching to enhance responsiveness (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
   *
   * @schema StageSpecForProvider#cacheClusterSize
   */
  readonly cacheClusterSize?: string;

  /**
   * CustomStageCanarySettings includes the custom field Stage.CanarySettings
   *
   * @schema StageSpecForProvider#canarySettings
   */
  readonly canarySettings?: StageSpecForProviderCanarySettings;

  /**
   * DeploymentID is the ID for the Deployment.
   *
   * @schema StageSpecForProvider#deploymentId
   */
  readonly deploymentId?: string;

  /**
   * DeploymentIDRef is a reference to an Deployment used to set the DeploymentID.
   *
   * @schema StageSpecForProvider#deploymentIdRef
   */
  readonly deploymentIdRef?: StageSpecForProviderDeploymentIdRef;

  /**
   * DeploymentIDSelector selects references to Deployment used to set the DeploymentID.
   *
   * @schema StageSpecForProvider#deploymentIdSelector
   */
  readonly deploymentIdSelector?: StageSpecForProviderDeploymentIdSelector;

  /**
   * The description of the Stage resource.
   *
   * @schema StageSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The version of the associated API documentation.
   *
   * @schema StageSpecForProvider#documentationVersion
   */
  readonly documentationVersion?: string;

  /**
   * Region is which region the Stage will be created.
   *
   * @schema StageSpecForProvider#region
   */
  readonly region: string;

  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema StageSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema StageSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: StageSpecForProviderRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema StageSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: StageSpecForProviderRestApiIdSelector;

  /**
   * The name for the Stage resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
   *
   * @schema StageSpecForProvider#stageName
   */
  readonly stageName: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema StageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies whether active tracing with X-ray is enabled for the Stage.
   *
   * @schema StageSpecForProvider#tracingEnabled
   */
  readonly tracingEnabled?: boolean;

  /**
   * A map that defines the stage variables for the new Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
   *
   * @schema StageSpecForProvider#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'StageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProvider(obj: StageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheClusterEnabled': obj.cacheClusterEnabled,
    'cacheClusterSize': obj.cacheClusterSize,
    'canarySettings': toJson_StageSpecForProviderCanarySettings(obj.canarySettings),
    'deploymentId': obj.deploymentId,
    'deploymentIdRef': toJson_StageSpecForProviderDeploymentIdRef(obj.deploymentIdRef),
    'deploymentIdSelector': toJson_StageSpecForProviderDeploymentIdSelector(obj.deploymentIdSelector),
    'description': obj.description,
    'documentationVersion': obj.documentationVersion,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_StageSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_StageSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stageName': obj.stageName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tracingEnabled': obj.tracingEnabled,
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StageSpecManagementPolicies
 */
export enum StageSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StageSpecProviderConfigRef
 */
export interface StageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderConfigRef#policy
   */
  readonly policy?: StageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRef(obj: StageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StageSpecPublishConnectionDetailsTo
 */
export interface StageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsTo(obj: StageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StageSpecWriteConnectionSecretToRef
 */
export interface StageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecWriteConnectionSecretToRef(obj: StageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomStageCanarySettings includes the custom field Stage.CanarySettings
 *
 * @schema StageSpecForProviderCanarySettings
 */
export interface StageSpecForProviderCanarySettings {
  /**
   * DeploymentID is the ID for the Deployment.
   *
   * @schema StageSpecForProviderCanarySettings#deploymentId
   */
  readonly deploymentId?: string;

  /**
   * DeploymentIDRef is a reference to an Deployment used to set the DeploymentID.
   *
   * @schema StageSpecForProviderCanarySettings#deploymentIdRef
   */
  readonly deploymentIdRef?: StageSpecForProviderCanarySettingsDeploymentIdRef;

  /**
   * DeploymentIDSelector selects references to Deployment used to set the DeploymentID.
   *
   * @schema StageSpecForProviderCanarySettings#deploymentIdSelector
   */
  readonly deploymentIdSelector?: StageSpecForProviderCanarySettingsDeploymentIdSelector;

  /**
   * @schema StageSpecForProviderCanarySettings#percentTraffic
   */
  readonly percentTraffic?: number;

  /**
   * @schema StageSpecForProviderCanarySettings#stageVariableOverrides
   */
  readonly stageVariableOverrides?: { [key: string]: string };

  /**
   * @schema StageSpecForProviderCanarySettings#useStageCache
   */
  readonly useStageCache?: boolean;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettings(obj: StageSpecForProviderCanarySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deploymentId': obj.deploymentId,
    'deploymentIdRef': toJson_StageSpecForProviderCanarySettingsDeploymentIdRef(obj.deploymentIdRef),
    'deploymentIdSelector': toJson_StageSpecForProviderCanarySettingsDeploymentIdSelector(obj.deploymentIdSelector),
    'percentTraffic': obj.percentTraffic,
    'stageVariableOverrides': ((obj.stageVariableOverrides) === undefined) ? undefined : (Object.entries(obj.stageVariableOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useStageCache': obj.useStageCache,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentIDRef is a reference to an Deployment used to set the DeploymentID.
 *
 * @schema StageSpecForProviderDeploymentIdRef
 */
export interface StageSpecForProviderDeploymentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderDeploymentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderDeploymentIdRef#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRef(obj: StageSpecForProviderDeploymentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderDeploymentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentIDSelector selects references to Deployment used to set the DeploymentID.
 *
 * @schema StageSpecForProviderDeploymentIdSelector
 */
export interface StageSpecForProviderDeploymentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelector(obj: StageSpecForProviderDeploymentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema StageSpecForProviderRestApiIdRef
 */
export interface StageSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: StageSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdRef(obj: StageSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema StageSpecForProviderRestApiIdSelector
 */
export interface StageSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: StageSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdSelector(obj: StageSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderConfigRefPolicy
 */
export interface StageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRefPolicy(obj: StageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRef
 */
export interface StageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRef(obj: StageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StageSpecPublishConnectionDetailsToMetadata
 */
export interface StageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToMetadata(obj: StageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentIDRef is a reference to an Deployment used to set the DeploymentID.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdRef
 */
export interface StageSpecForProviderCanarySettingsDeploymentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdRef#policy
   */
  readonly policy?: StageSpecForProviderCanarySettingsDeploymentIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettingsDeploymentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettingsDeploymentIdRef(obj: StageSpecForProviderCanarySettingsDeploymentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderCanarySettingsDeploymentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentIDSelector selects references to Deployment used to set the DeploymentID.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdSelector
 */
export interface StageSpecForProviderCanarySettingsDeploymentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdSelector#policy
   */
  readonly policy?: StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettingsDeploymentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettingsDeploymentIdSelector(obj: StageSpecForProviderCanarySettingsDeploymentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicy
 */
export interface StageSpecForProviderDeploymentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRefPolicy(obj: StageSpecForProviderDeploymentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicy
 */
export interface StageSpecForProviderDeploymentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj: StageSpecForProviderDeploymentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicy
 */
export interface StageSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdRefPolicy(obj: StageSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicy
 */
export interface StageSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdSelectorPolicy(obj: StageSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderConfigRefPolicyResolution
 */
export enum StageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderConfigRefPolicyResolve
 */
export enum StageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj: StageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdRefPolicy
 */
export interface StageSpecForProviderCanarySettingsDeploymentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettingsDeploymentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettingsDeploymentIdRefPolicy(obj: StageSpecForProviderCanarySettingsDeploymentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy
 */
export interface StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy(obj: StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicyResolution
 */
export enum StageSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicyResolve
 */
export enum StageSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum StageSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum StageSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolution
 */
export enum StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolve
 */
export enum StageSpecForProviderCanarySettingsDeploymentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolution
 */
export enum StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolve
 */
export enum StageSpecForProviderCanarySettingsDeploymentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsagePlan is the Schema for the UsagePlans API
 *
 * @schema UsagePlan
 */
export class UsagePlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsagePlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'UsagePlan',
  }

  /**
   * Renders a Kubernetes manifest for "UsagePlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsagePlanProps): any {
    return {
      ...UsagePlan.GVK,
      ...toJson_UsagePlanProps(props),
    };
  }

  /**
   * Defines a "UsagePlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsagePlanProps) {
    super(scope, id, {
      ...UsagePlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsagePlan.GVK,
      ...toJson_UsagePlanProps(resolved),
    };
  }
}

/**
 * UsagePlan is the Schema for the UsagePlans API
 *
 * @schema UsagePlan
 */
export interface UsagePlanProps {
  /**
   * @schema UsagePlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsagePlanSpec defines the desired state of UsagePlan
   *
   * @schema UsagePlan#spec
   */
  readonly spec: UsagePlanSpec;

}

/**
 * Converts an object of type 'UsagePlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanProps(obj: UsagePlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsagePlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanSpec defines the desired state of UsagePlan
 *
 * @schema UsagePlanSpec
 */
export interface UsagePlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: UsagePlanSpecDeletionPolicy;

  /**
   * UsagePlanParameters defines the desired state of UsagePlan
   *
   * @schema UsagePlanSpec#forProvider
   */
  readonly forProvider: UsagePlanSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UsagePlanSpec#managementPolicies
   */
  readonly managementPolicies?: UsagePlanSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsagePlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: UsagePlanSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsagePlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsagePlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsagePlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsagePlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsagePlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpec(obj: UsagePlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsagePlanSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UsagePlanSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UsagePlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsagePlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanSpecDeletionPolicy
 */
export enum UsagePlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UsagePlanParameters defines the desired state of UsagePlan
 *
 * @schema UsagePlanSpecForProvider
 */
export interface UsagePlanSpecForProvider {
  /**
   * The associated API stages of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#apiStages
   */
  readonly apiStages?: UsagePlanSpecForProviderApiStages[];

  /**
   * The description of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#name
   */
  readonly name: string;

  /**
   * The quota of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#quota
   */
  readonly quota?: UsagePlanSpecForProviderQuota;

  /**
   * Region is which region the UsagePlan will be created.
   *
   * @schema UsagePlanSpecForProvider#region
   */
  readonly region: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema UsagePlanSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The throttling limits of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#throttle
   */
  readonly throttle?: UsagePlanSpecForProviderThrottle;

}

/**
 * Converts an object of type 'UsagePlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProvider(obj: UsagePlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiStages': obj.apiStages?.map(y => toJson_UsagePlanSpecForProviderApiStages(y)),
    'description': obj.description,
    'name': obj.name,
    'quota': toJson_UsagePlanSpecForProviderQuota(obj.quota),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throttle': toJson_UsagePlanSpecForProviderThrottle(obj.throttle),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UsagePlanSpecManagementPolicies
 */
export enum UsagePlanSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsagePlanSpecProviderConfigRef
 */
export interface UsagePlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecProviderConfigRef#policy
   */
  readonly policy?: UsagePlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderConfigRef(obj: UsagePlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsTo
 */
export interface UsagePlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsagePlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsagePlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsTo(obj: UsagePlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsagePlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsagePlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsagePlanSpecWriteConnectionSecretToRef
 */
export interface UsagePlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsagePlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsagePlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsagePlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecWriteConnectionSecretToRef(obj: UsagePlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomUsagePlanAPIStage includes the custom fields of UsagePlan.APIStages
 *
 * @schema UsagePlanSpecForProviderApiStages
 */
export interface UsagePlanSpecForProviderApiStages {
  /**
   * RestAPIID is the ID for the RestAPI.
   *
   * @schema UsagePlanSpecForProviderApiStages#restApiId
   */
  readonly restApiId?: string;

  /**
   * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
   *
   * @schema UsagePlanSpecForProviderApiStages#restApiIdRef
   */
  readonly restApiIdRef?: UsagePlanSpecForProviderApiStagesRestApiIdRef;

  /**
   * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
   *
   * @schema UsagePlanSpecForProviderApiStages#restApiIdSelector
   */
  readonly restApiIdSelector?: UsagePlanSpecForProviderApiStagesRestApiIdSelector;

  /**
   * @schema UsagePlanSpecForProviderApiStages#stage
   */
  readonly stage?: string;

  /**
   * @schema UsagePlanSpecForProviderApiStages#throttle
   */
  readonly throttle?: { [key: string]: UsagePlanSpecForProviderApiStagesThrottle };

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStages(obj: UsagePlanSpecForProviderApiStages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_UsagePlanSpecForProviderApiStagesRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_UsagePlanSpecForProviderApiStagesRestApiIdSelector(obj.restApiIdSelector),
    'stage': obj.stage,
    'throttle': ((obj.throttle) === undefined) ? undefined : (Object.entries(obj.throttle).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_UsagePlanSpecForProviderApiStagesThrottle(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The quota of the usage plan.
 *
 * @schema UsagePlanSpecForProviderQuota
 */
export interface UsagePlanSpecForProviderQuota {
  /**
   * @schema UsagePlanSpecForProviderQuota#limit
   */
  readonly limit?: number;

  /**
   * @schema UsagePlanSpecForProviderQuota#offset
   */
  readonly offset?: number;

  /**
   * @schema UsagePlanSpecForProviderQuota#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderQuota' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderQuota(obj: UsagePlanSpecForProviderQuota | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limit': obj.limit,
    'offset': obj.offset,
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The throttling limits of the usage plan.
 *
 * @schema UsagePlanSpecForProviderThrottle
 */
export interface UsagePlanSpecForProviderThrottle {
  /**
   * @schema UsagePlanSpecForProviderThrottle#burstLimit
   */
  readonly burstLimit?: number;

  /**
   * @schema UsagePlanSpecForProviderThrottle#rateLimit
   */
  readonly rateLimit?: number;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderThrottle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderThrottle(obj: UsagePlanSpecForProviderThrottle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burstLimit': obj.burstLimit,
    'rateLimit': obj.rateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicy
 */
export interface UsagePlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderConfigRefPolicy(obj: UsagePlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef
 */
export interface UsagePlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToConfigRef(obj: UsagePlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToMetadata
 */
export interface UsagePlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToMetadata(obj: UsagePlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIIDRef is a reference to an RestAPI used to set the RestAPIID.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdRef
 */
export interface UsagePlanSpecForProviderApiStagesRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdRef#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesRestApiIdRef(obj: UsagePlanSpecForProviderApiStagesRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestApiIdSelector selects references to RestAPI used to set the RestAPIID.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelector
 */
export interface UsagePlanSpecForProviderApiStagesRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelector#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesRestApiIdSelector(obj: UsagePlanSpecForProviderApiStagesRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UsagePlanSpecForProviderApiStagesThrottle
 */
export interface UsagePlanSpecForProviderApiStagesThrottle {
  /**
   * @schema UsagePlanSpecForProviderApiStagesThrottle#burstLimit
   */
  readonly burstLimit?: number;

  /**
   * @schema UsagePlanSpecForProviderApiStagesThrottle#rateLimit
   */
  readonly rateLimit?: number;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesThrottle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesThrottle(obj: UsagePlanSpecForProviderApiStagesThrottle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burstLimit': obj.burstLimit,
    'rateLimit': obj.rateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicyResolution
 */
export enum UsagePlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicyResolve
 */
export enum UsagePlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy
 */
export interface UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy(obj: UsagePlanSpecForProviderApiStagesRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy
 */
export interface UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy(obj: UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsagePlanKey is the Schema for the UsagePlanKeys API
 *
 * @schema UsagePlanKey
 */
export class UsagePlanKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsagePlanKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'UsagePlanKey',
  }

  /**
   * Renders a Kubernetes manifest for "UsagePlanKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsagePlanKeyProps): any {
    return {
      ...UsagePlanKey.GVK,
      ...toJson_UsagePlanKeyProps(props),
    };
  }

  /**
   * Defines a "UsagePlanKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsagePlanKeyProps) {
    super(scope, id, {
      ...UsagePlanKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsagePlanKey.GVK,
      ...toJson_UsagePlanKeyProps(resolved),
    };
  }
}

/**
 * UsagePlanKey is the Schema for the UsagePlanKeys API
 *
 * @schema UsagePlanKey
 */
export interface UsagePlanKeyProps {
  /**
   * @schema UsagePlanKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsagePlanKeySpec defines the desired state of UsagePlanKey
   *
   * @schema UsagePlanKey#spec
   */
  readonly spec: UsagePlanKeySpec;

}

/**
 * Converts an object of type 'UsagePlanKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeyProps(obj: UsagePlanKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsagePlanKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanKeySpec defines the desired state of UsagePlanKey
 *
 * @schema UsagePlanKeySpec
 */
export interface UsagePlanKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: UsagePlanKeySpecDeletionPolicy;

  /**
   * UsagePlanKeyParameters defines the desired state of UsagePlanKey
   *
   * @schema UsagePlanKeySpec#forProvider
   */
  readonly forProvider: UsagePlanKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UsagePlanKeySpec#managementPolicies
   */
  readonly managementPolicies?: UsagePlanKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsagePlanKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: UsagePlanKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsagePlanKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsagePlanKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsagePlanKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsagePlanKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsagePlanKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpec(obj: UsagePlanKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsagePlanKeySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UsagePlanKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UsagePlanKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsagePlanKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanKeySpecDeletionPolicy
 */
export enum UsagePlanKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UsagePlanKeyParameters defines the desired state of UsagePlanKey
 *
 * @schema UsagePlanKeySpecForProvider
 */
export interface UsagePlanKeySpecForProvider {
  /**
   * The identifier of a UsagePlanKey resource for a plan customer.
   *
   * @schema UsagePlanKeySpecForProvider#keyID
   */
  readonly keyId: string;

  /**
   * The type of a UsagePlanKey resource for a plan customer.
   *
   * @schema UsagePlanKeySpecForProvider#keyType
   */
  readonly keyType: string;

  /**
   * Region is which region the UsagePlanKey will be created.
   *
   * @schema UsagePlanKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * UsagePlanID is the ID for the UsagePlan.
   *
   * @schema UsagePlanKeySpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * UsagePlanIDRef is a reference to an UsagePlan used to set the UsagePlanID.
   *
   * @schema UsagePlanKeySpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: UsagePlanKeySpecForProviderRestApiIdRef;

  /**
   * UsagePlanIdSelector selects references to UsagePlan used to set the UsagePlanID.
   *
   * @schema UsagePlanKeySpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: UsagePlanKeySpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProvider(obj: UsagePlanKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyID': obj.keyId,
    'keyType': obj.keyType,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_UsagePlanKeySpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_UsagePlanKeySpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UsagePlanKeySpecManagementPolicies
 */
export enum UsagePlanKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsagePlanKeySpecProviderConfigRef
 */
export interface UsagePlanKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecProviderConfigRef#policy
   */
  readonly policy?: UsagePlanKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderConfigRef(obj: UsagePlanKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsTo
 */
export interface UsagePlanKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsagePlanKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsagePlanKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsTo(obj: UsagePlanKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsagePlanKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsagePlanKeySpecWriteConnectionSecretToRef
 */
export interface UsagePlanKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsagePlanKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsagePlanKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecWriteConnectionSecretToRef(obj: UsagePlanKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanIDRef is a reference to an UsagePlan used to set the UsagePlanID.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdRef
 */
export interface UsagePlanKeySpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdRef#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderRestApiIdRef(obj: UsagePlanKeySpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanIdSelector selects references to UsagePlan used to set the UsagePlanID.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdSelector
 */
export interface UsagePlanKeySpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderRestApiIdSelector(obj: UsagePlanKeySpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanKeySpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicy
 */
export interface UsagePlanKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderConfigRefPolicy(obj: UsagePlanKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRef(obj: UsagePlanKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToMetadata(obj: UsagePlanKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdRefPolicy
 */
export interface UsagePlanKeySpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderRestApiIdRefPolicy(obj: UsagePlanKeySpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdSelectorPolicy
 */
export interface UsagePlanKeySpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderRestApiIdSelectorPolicy(obj: UsagePlanKeySpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicyResolution
 */
export enum UsagePlanKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicyResolve
 */
export enum UsagePlanKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdRefPolicyResolution
 */
export enum UsagePlanKeySpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdRefPolicyResolve
 */
export enum UsagePlanKeySpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum UsagePlanKeySpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLink
 */
export class VpcLink extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCLink"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.crossplane.io/v1alpha1',
    kind: 'VPCLink',
  }

  /**
   * Renders a Kubernetes manifest for "VPCLink".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcLinkProps): any {
    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(props),
    };
  }

  /**
   * Defines a "VPCLink" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcLinkProps) {
    super(scope, id, {
      ...VpcLink.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(resolved),
    };
  }
}

/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLink
 */
export interface VpcLinkProps {
  /**
   * @schema VPCLink#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCLinkSpec defines the desired state of VPCLink
   *
   * @schema VPCLink#spec
   */
  readonly spec: VpcLinkSpec;

}

/**
 * Converts an object of type 'VpcLinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkProps(obj: VpcLinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcLinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCLinkSpec defines the desired state of VPCLink
 *
 * @schema VpcLinkSpec
 */
export interface VpcLinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcLinkSpecDeletionPolicy;

  /**
   * VPCLinkParameters defines the desired state of VPCLink
   *
   * @schema VpcLinkSpec#forProvider
   */
  readonly forProvider: VpcLinkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcLinkSpec#managementPolicies
   */
  readonly managementPolicies?: VpcLinkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcLinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcLinkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcLinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcLinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcLinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcLinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcLinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpec(obj: VpcLinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcLinkSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcLinkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcLinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcLinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecDeletionPolicy
 */
export enum VpcLinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCLinkParameters defines the desired state of VPCLink
 *
 * @schema VpcLinkSpecForProvider
 */
export interface VpcLinkSpecForProvider {
  /**
   * The description of the VPC link.
   *
   * @schema VpcLinkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name used to label and identify the VPC link.
   *
   * @schema VpcLinkSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the VPCLink will be created.
   *
   * @schema VpcLinkSpecForProvider#region
   */
  readonly region: string;

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
   *
   * @schema VpcLinkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
   *
   * @schema VpcLinkSpecForProvider#targetARNs
   */
  readonly targetArNs: string[];

}

/**
 * Converts an object of type 'VpcLinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProvider(obj: VpcLinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetARNs': obj.targetArNs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcLinkSpecManagementPolicies
 */
export enum VpcLinkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcLinkSpecProviderConfigRef
 */
export interface VpcLinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderConfigRef#policy
   */
  readonly policy?: VpcLinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRef(obj: VpcLinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsTo
 */
export interface VpcLinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcLinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcLinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsTo(obj: VpcLinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcLinkSpecWriteConnectionSecretToRef
 */
export interface VpcLinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcLinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecWriteConnectionSecretToRef(obj: VpcLinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicy
 */
export interface VpcLinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRefPolicy(obj: VpcLinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj: VpcLinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToMetadata
 */
export interface VpcLinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj: VpcLinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolution
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolve
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

