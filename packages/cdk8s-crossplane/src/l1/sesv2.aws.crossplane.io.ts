// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConfigurationSet is the Schema for the ConfigurationSets API
 *
 * @schema ConfigurationSet
 */
export class ConfigurationSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.crossplane.io/v1alpha1',
    kind: 'ConfigurationSet',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationSetProps): any {
    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(props),
    };
  }

  /**
   * Defines a "ConfigurationSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationSetProps) {
    super(scope, id, {
      ...ConfigurationSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(resolved),
    };
  }
}

/**
 * ConfigurationSet is the Schema for the ConfigurationSets API
 *
 * @schema ConfigurationSet
 */
export interface ConfigurationSetProps {
  /**
   * @schema ConfigurationSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSetSpec defines the desired state of ConfigurationSet
   *
   * @schema ConfigurationSet#spec
   */
  readonly spec: ConfigurationSetSpec;

}

/**
 * Converts an object of type 'ConfigurationSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetProps(obj: ConfigurationSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetSpec defines the desired state of ConfigurationSet
 *
 * @schema ConfigurationSetSpec
 */
export interface ConfigurationSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSetSpecDeletionPolicy;

  /**
   * ConfigurationSetParameters defines the desired state of ConfigurationSet
   *
   * @schema ConfigurationSetSpec#forProvider
   */
  readonly forProvider: ConfigurationSetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConfigurationSetSpec#managementPolicies
   */
  readonly managementPolicies?: ConfigurationSetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpec(obj: ConfigurationSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSetSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConfigurationSetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationSetSpecDeletionPolicy
 */
export enum ConfigurationSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ConfigurationSetParameters defines the desired state of ConfigurationSet
 *
 * @schema ConfigurationSetSpecForProvider
 */
export interface ConfigurationSetSpecForProvider {
  /**
   * An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#deliveryOptions
   */
  readonly deliveryOptions?: ConfigurationSetSpecForProviderDeliveryOptions;

  /**
   * Region is which region the ConfigurationSet will be created.
   *
   * @schema ConfigurationSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#reputationOptions
   */
  readonly reputationOptions?: ConfigurationSetSpecForProviderReputationOptions;

  /**
   * An object that defines whether or not Amazon SES can send email that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#sendingOptions
   */
  readonly sendingOptions?: ConfigurationSetSpecForProviderSendingOptions;

  /**
   * @schema ConfigurationSetSpecForProvider#suppressionOptions
   */
  readonly suppressionOptions?: ConfigurationSetSpecForProviderSuppressionOptions;

  /**
   * An array of objects that define the tags (keys and values) to associate with the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#tags
   */
  readonly tags?: ConfigurationSetSpecForProviderTags[];

  /**
   * An object that defines the open and click tracking options for emails that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#trackingOptions
   */
  readonly trackingOptions?: ConfigurationSetSpecForProviderTrackingOptions;

  /**
   * An object that defines the VDM options for emails that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#vdmOptions
   */
  readonly vdmOptions?: ConfigurationSetSpecForProviderVdmOptions;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProvider(obj: ConfigurationSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryOptions': toJson_ConfigurationSetSpecForProviderDeliveryOptions(obj.deliveryOptions),
    'region': obj.region,
    'reputationOptions': toJson_ConfigurationSetSpecForProviderReputationOptions(obj.reputationOptions),
    'sendingOptions': toJson_ConfigurationSetSpecForProviderSendingOptions(obj.sendingOptions),
    'suppressionOptions': toJson_ConfigurationSetSpecForProviderSuppressionOptions(obj.suppressionOptions),
    'tags': obj.tags?.map(y => toJson_ConfigurationSetSpecForProviderTags(y)),
    'trackingOptions': toJson_ConfigurationSetSpecForProviderTrackingOptions(obj.trackingOptions),
    'vdmOptions': toJson_ConfigurationSetSpecForProviderVdmOptions(obj.vdmOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConfigurationSetSpecManagementPolicies
 */
export enum ConfigurationSetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSetSpecProviderConfigRef
 */
export interface ConfigurationSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRef(obj: ConfigurationSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj: ConfigurationSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSetSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj: ConfigurationSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
 *
 * @schema ConfigurationSetSpecForProviderDeliveryOptions
 */
export interface ConfigurationSetSpecForProviderDeliveryOptions {
  /**
   * The name of a dedicated IP pool.
   *
   * @schema ConfigurationSetSpecForProviderDeliveryOptions#sendingPoolName
   */
  readonly sendingPoolName?: string;

  /**
   * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require, messages are only delivered if a TLS connection can be established. If the value is Optional, messages can be delivered in plain text if a TLS connection can't be established.
   *
   * @schema ConfigurationSetSpecForProviderDeliveryOptions#tlsPolicy
   */
  readonly tlsPolicy?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderDeliveryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderDeliveryOptions(obj: ConfigurationSetSpecForProviderDeliveryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sendingPoolName': obj.sendingPoolName,
    'tlsPolicy': obj.tlsPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
 *
 * @schema ConfigurationSetSpecForProviderReputationOptions
 */
export interface ConfigurationSetSpecForProviderReputationOptions {
  /**
   * @schema ConfigurationSetSpecForProviderReputationOptions#reputationMetricsEnabled
   */
  readonly reputationMetricsEnabled?: boolean;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderReputationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderReputationOptions(obj: ConfigurationSetSpecForProviderReputationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'reputationMetricsEnabled': obj.reputationMetricsEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that defines whether or not Amazon SES can send email that you send using the configuration set.
 *
 * @schema ConfigurationSetSpecForProviderSendingOptions
 */
export interface ConfigurationSetSpecForProviderSendingOptions {
  /**
   * @schema ConfigurationSetSpecForProviderSendingOptions#sendingEnabled
   */
  readonly sendingEnabled?: boolean;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderSendingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderSendingOptions(obj: ConfigurationSetSpecForProviderSendingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sendingEnabled': obj.sendingEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderSuppressionOptions
 */
export interface ConfigurationSetSpecForProviderSuppressionOptions {
  /**
   * @schema ConfigurationSetSpecForProviderSuppressionOptions#suppressedReasons
   */
  readonly suppressedReasons?: string[];

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderSuppressionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderSuppressionOptions(obj: ConfigurationSetSpecForProviderSuppressionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'suppressedReasons': obj.suppressedReasons?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderTags
 */
export interface ConfigurationSetSpecForProviderTags {
  /**
   * @schema ConfigurationSetSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ConfigurationSetSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderTags(obj: ConfigurationSetSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that defines the open and click tracking options for emails that you send using the configuration set.
 *
 * @schema ConfigurationSetSpecForProviderTrackingOptions
 */
export interface ConfigurationSetSpecForProviderTrackingOptions {
  /**
   * The domain to use for tracking open and click events.
   *
   * @schema ConfigurationSetSpecForProviderTrackingOptions#customRedirectDomain
   */
  readonly customRedirectDomain?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderTrackingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderTrackingOptions(obj: ConfigurationSetSpecForProviderTrackingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customRedirectDomain': obj.customRedirectDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that defines the VDM options for emails that you send using the configuration set.
 *
 * @schema ConfigurationSetSpecForProviderVdmOptions
 */
export interface ConfigurationSetSpecForProviderVdmOptions {
  /**
   * An object containing additional settings for your VDM configuration as applicable to the Dashboard.
   *
   * @schema ConfigurationSetSpecForProviderVdmOptions#dashboardOptions
   */
  readonly dashboardOptions?: ConfigurationSetSpecForProviderVdmOptionsDashboardOptions;

  /**
   * An object containing additional settings for your VDM configuration as applicable to the Guardian.
   *
   * @schema ConfigurationSetSpecForProviderVdmOptions#guardianOptions
   */
  readonly guardianOptions?: ConfigurationSetSpecForProviderVdmOptionsGuardianOptions;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderVdmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderVdmOptions(obj: ConfigurationSetSpecForProviderVdmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dashboardOptions': toJson_ConfigurationSetSpecForProviderVdmOptionsDashboardOptions(obj.dashboardOptions),
    'guardianOptions': toJson_ConfigurationSetSpecForProviderVdmOptionsGuardianOptions(obj.guardianOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicy
 */
export interface ConfigurationSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj: ConfigurationSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object containing additional settings for your VDM configuration as applicable to the Dashboard.
 *
 * @schema ConfigurationSetSpecForProviderVdmOptionsDashboardOptions
 */
export interface ConfigurationSetSpecForProviderVdmOptionsDashboardOptions {
  /**
   * @schema ConfigurationSetSpecForProviderVdmOptionsDashboardOptions#engagementMetrics
   */
  readonly engagementMetrics?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderVdmOptionsDashboardOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderVdmOptionsDashboardOptions(obj: ConfigurationSetSpecForProviderVdmOptionsDashboardOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engagementMetrics': obj.engagementMetrics,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object containing additional settings for your VDM configuration as applicable to the Guardian.
 *
 * @schema ConfigurationSetSpecForProviderVdmOptionsGuardianOptions
 */
export interface ConfigurationSetSpecForProviderVdmOptionsGuardianOptions {
  /**
   * @schema ConfigurationSetSpecForProviderVdmOptionsGuardianOptions#optimizedSharedDelivery
   */
  readonly optimizedSharedDelivery?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderVdmOptionsGuardianOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderVdmOptionsGuardianOptions(obj: ConfigurationSetSpecForProviderVdmOptionsGuardianOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'optimizedSharedDelivery': obj.optimizedSharedDelivery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailIdentity is the Schema for the EmailIdentities API
 *
 * @schema EmailIdentity
 */
export class EmailIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.crossplane.io/v1alpha1',
    kind: 'EmailIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "EmailIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailIdentityProps): any {
    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(props),
    };
  }

  /**
   * Defines a "EmailIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailIdentityProps) {
    super(scope, id, {
      ...EmailIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(resolved),
    };
  }
}

/**
 * EmailIdentity is the Schema for the EmailIdentities API
 *
 * @schema EmailIdentity
 */
export interface EmailIdentityProps {
  /**
   * @schema EmailIdentity#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailIdentitySpec defines the desired state of EmailIdentity
   *
   * @schema EmailIdentity#spec
   */
  readonly spec: EmailIdentitySpec;

}

/**
 * Converts an object of type 'EmailIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityProps(obj: EmailIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailIdentitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailIdentitySpec defines the desired state of EmailIdentity
 *
 * @schema EmailIdentitySpec
 */
export interface EmailIdentitySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EmailIdentitySpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailIdentitySpecDeletionPolicy;

  /**
   * EmailIdentityParameters defines the desired state of EmailIdentity
   *
   * @schema EmailIdentitySpec#forProvider
   */
  readonly forProvider: EmailIdentitySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EmailIdentitySpec#managementPolicies
   */
  readonly managementPolicies?: EmailIdentitySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailIdentitySpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailIdentitySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailIdentitySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailIdentitySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailIdentitySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailIdentitySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailIdentitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpec(obj: EmailIdentitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailIdentitySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EmailIdentitySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EmailIdentitySpecDeletionPolicy
 */
export enum EmailIdentitySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * EmailIdentityParameters defines the desired state of EmailIdentity
 *
 * @schema EmailIdentitySpecForProvider
 */
export interface EmailIdentitySpecForProvider {
  /**
   * The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetName
   */
  readonly configurationSetName?: string;

  /**
   * ConfigurationSetNameRef is a reference to an API used to set the ConfigurationSetName.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetNameRef
   */
  readonly configurationSetNameRef?: EmailIdentitySpecForProviderConfigurationSetNameRef;

  /**
   * ConfigurationSetNameSelector selects references to API used to set the ConfigurationSetName.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetNameSelector
   */
  readonly configurationSetNameSelector?: EmailIdentitySpecForProviderConfigurationSetNameSelector;

  /**
   * If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM (https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html).
   * You can only specify this object if the email identity is a domain, as opposed to an address.
   *
   * @schema EmailIdentitySpecForProvider#dkimSigningAttributes
   */
  readonly dkimSigningAttributes?: EmailIdentitySpecForProviderDkimSigningAttributes;

  /**
   * DomainSigningPrivateKeySecretRef references the secret that contains the private key of the DKIM Authentication Token Constraints: Base64 encoded format
   *
   * @schema EmailIdentitySpecForProvider#domainSigningPrivateKeySecretRef
   */
  readonly domainSigningPrivateKeySecretRef?: EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef;

  /**
   * The email address or domain to verify.
   *
   * @schema EmailIdentitySpecForProvider#emailIdentity
   */
  readonly emailIdentity: string;

  /**
   * An object that contains information about the Mail-From attributes for the email identity.
   *
   * @schema EmailIdentitySpecForProvider#mailFromAttributes
   */
  readonly mailFromAttributes?: EmailIdentitySpecForProviderMailFromAttributes;

  /**
   * Region is which region the EmailIdentity will be created.
   *
   * @schema EmailIdentitySpecForProvider#region
   */
  readonly region: string;

  /**
   * An array of objects that define the tags (keys and values) to associate with the email identity.
   *
   * @schema EmailIdentitySpecForProvider#tags
   */
  readonly tags?: EmailIdentitySpecForProviderTags[];

}

/**
 * Converts an object of type 'EmailIdentitySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProvider(obj: EmailIdentitySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationSetName': obj.configurationSetName,
    'configurationSetNameRef': toJson_EmailIdentitySpecForProviderConfigurationSetNameRef(obj.configurationSetNameRef),
    'configurationSetNameSelector': toJson_EmailIdentitySpecForProviderConfigurationSetNameSelector(obj.configurationSetNameSelector),
    'dkimSigningAttributes': toJson_EmailIdentitySpecForProviderDkimSigningAttributes(obj.dkimSigningAttributes),
    'domainSigningPrivateKeySecretRef': toJson_EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef(obj.domainSigningPrivateKeySecretRef),
    'emailIdentity': obj.emailIdentity,
    'mailFromAttributes': toJson_EmailIdentitySpecForProviderMailFromAttributes(obj.mailFromAttributes),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_EmailIdentitySpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EmailIdentitySpecManagementPolicies
 */
export enum EmailIdentitySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailIdentitySpecProviderConfigRef
 */
export interface EmailIdentitySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecProviderConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRef(obj: EmailIdentitySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsTo
 */
export interface EmailIdentitySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailIdentitySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailIdentitySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj: EmailIdentitySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailIdentitySpecWriteConnectionSecretToRef
 */
export interface EmailIdentitySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj: EmailIdentitySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetNameRef is a reference to an API used to set the ConfigurationSetName.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRef
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRef#policy
   */
  readonly policy?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameRef(obj: EmailIdentitySpecForProviderConfigurationSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecForProviderConfigurationSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetNameSelector selects references to API used to set the ConfigurationSetName.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#policy
   */
  readonly policy?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameSelector(obj: EmailIdentitySpecForProviderConfigurationSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM (https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html).
 * You can only specify this object if the email identity is a domain, as opposed to an address.
 *
 * @schema EmailIdentitySpecForProviderDkimSigningAttributes
 */
export interface EmailIdentitySpecForProviderDkimSigningAttributes {
  /**
   * @schema EmailIdentitySpecForProviderDkimSigningAttributes#domainSigningSelector
   */
  readonly domainSigningSelector?: string;

  /**
   * @schema EmailIdentitySpecForProviderDkimSigningAttributes#nextSigningKeyLength
   */
  readonly nextSigningKeyLength?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderDkimSigningAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderDkimSigningAttributes(obj: EmailIdentitySpecForProviderDkimSigningAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainSigningSelector': obj.domainSigningSelector,
    'nextSigningKeyLength': obj.nextSigningKeyLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSigningPrivateKeySecretRef references the secret that contains the private key of the DKIM Authentication Token Constraints: Base64 encoded format
 *
 * @schema EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef
 */
export interface EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef {
  /**
   * The key to select.
   *
   * @schema EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef(obj: EmailIdentitySpecForProviderDomainSigningPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that contains information about the Mail-From attributes for the email identity.
 *
 * @schema EmailIdentitySpecForProviderMailFromAttributes
 */
export interface EmailIdentitySpecForProviderMailFromAttributes {
  /**
   * The action to take if the required MX record can't be found when you send an email. When you set this value to UseDefaultValue, the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage, the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
   * These behaviors are taken when the custom MAIL FROM domain configuration is in the Pending, Failed, and TemporaryFailure states.
   *
   * @schema EmailIdentitySpecForProviderMailFromAttributes#behaviorOnMxFailure
   */
  readonly behaviorOnMxFailure?: string;

  /**
   * The domain to use as a MAIL FROM domain.
   *
   * @schema EmailIdentitySpecForProviderMailFromAttributes#mailFromDomain
   */
  readonly mailFromDomain?: string;

  /**
   * The status of the MAIL FROM domain. This status can have the following values:
   * * PENDING  Amazon SES hasn't started searching for the MX record yet.
   * * SUCCESS  Amazon SES detected the required MX record for the MAIL FROM domain.
   * * FAILED  Amazon SES can't find the required MX record, or the record no longer exists.
   * * TEMPORARY_FAILURE  A temporary issue occurred, which prevented Amazon SES from determining the status of the MAIL FROM domain.
   *
   * @schema EmailIdentitySpecForProviderMailFromAttributes#mailFromDomainStatus
   */
  readonly mailFromDomainStatus?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderMailFromAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderMailFromAttributes(obj: EmailIdentitySpecForProviderMailFromAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'behaviorOnMxFailure': obj.behaviorOnMxFailure,
    'mailFromDomain': obj.mailFromDomain,
    'mailFromDomainStatus': obj.mailFromDomainStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EmailIdentitySpecForProviderTags
 */
export interface EmailIdentitySpecForProviderTags {
  /**
   * @schema EmailIdentitySpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema EmailIdentitySpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderTags(obj: EmailIdentitySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicy
 */
export interface EmailIdentitySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRefPolicy(obj: EmailIdentitySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata
 */
export interface EmailIdentitySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj: EmailIdentitySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameRefPolicy(obj: EmailIdentitySpecForProviderConfigurationSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy(obj: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolution
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolve
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailTemplate is the Schema for the EmailTemplates API
 *
 * @schema EmailTemplate
 */
export class EmailTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.crossplane.io/v1alpha1',
    kind: 'EmailTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "EmailTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailTemplateProps): any {
    return {
      ...EmailTemplate.GVK,
      ...toJson_EmailTemplateProps(props),
    };
  }

  /**
   * Defines a "EmailTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailTemplateProps) {
    super(scope, id, {
      ...EmailTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailTemplate.GVK,
      ...toJson_EmailTemplateProps(resolved),
    };
  }
}

/**
 * EmailTemplate is the Schema for the EmailTemplates API
 *
 * @schema EmailTemplate
 */
export interface EmailTemplateProps {
  /**
   * @schema EmailTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailTemplateSpec defines the desired state of EmailTemplate
   *
   * @schema EmailTemplate#spec
   */
  readonly spec: EmailTemplateSpec;

}

/**
 * Converts an object of type 'EmailTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateProps(obj: EmailTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailTemplateSpec defines the desired state of EmailTemplate
 *
 * @schema EmailTemplateSpec
 */
export interface EmailTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EmailTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailTemplateSpecDeletionPolicy;

  /**
   * EmailTemplateParameters defines the desired state of EmailTemplate
   *
   * @schema EmailTemplateSpec#forProvider
   */
  readonly forProvider: EmailTemplateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EmailTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: EmailTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpec(obj: EmailTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailTemplateSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EmailTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EmailTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EmailTemplateSpecDeletionPolicy
 */
export enum EmailTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * EmailTemplateParameters defines the desired state of EmailTemplate
 *
 * @schema EmailTemplateSpecForProvider
 */
export interface EmailTemplateSpecForProvider {
  /**
   * Region is which region the EmailTemplate will be created.
   *
   * @schema EmailTemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   * The content of the email template, composed of a subject line, an HTML part, and a text-only part.
   *
   * @schema EmailTemplateSpecForProvider#templateContent
   */
  readonly templateContent: EmailTemplateSpecForProviderTemplateContent;

}

/**
 * Converts an object of type 'EmailTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecForProvider(obj: EmailTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'templateContent': toJson_EmailTemplateSpecForProviderTemplateContent(obj.templateContent),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EmailTemplateSpecManagementPolicies
 */
export enum EmailTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailTemplateSpecProviderConfigRef
 */
export interface EmailTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: EmailTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecProviderConfigRef(obj: EmailTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsTo
 */
export interface EmailTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecPublishConnectionDetailsTo(obj: EmailTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailTemplateSpecWriteConnectionSecretToRef
 */
export interface EmailTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecWriteConnectionSecretToRef(obj: EmailTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The content of the email template, composed of a subject line, an HTML part, and a text-only part.
 *
 * @schema EmailTemplateSpecForProviderTemplateContent
 */
export interface EmailTemplateSpecForProviderTemplateContent {
  /**
   * The HTML body of the email.
   *
   * @schema EmailTemplateSpecForProviderTemplateContent#html
   */
  readonly html?: string;

  /**
   * The subject line of the email.
   *
   * @schema EmailTemplateSpecForProviderTemplateContent#subject
   */
  readonly subject?: string;

  /**
   * The email body that will be visible to recipients whose email clients do not display HTML.
   *
   * @schema EmailTemplateSpecForProviderTemplateContent#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'EmailTemplateSpecForProviderTemplateContent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecForProviderTemplateContent(obj: EmailTemplateSpecForProviderTemplateContent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'html': obj.html,
    'subject': obj.subject,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailTemplateSpecProviderConfigRefPolicy
 */
export interface EmailTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecProviderConfigRefPolicy(obj: EmailTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface EmailTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecPublishConnectionDetailsToConfigRef(obj: EmailTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface EmailTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecPublishConnectionDetailsToMetadata(obj: EmailTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailTemplateSpecProviderConfigRefPolicyResolution
 */
export enum EmailTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailTemplateSpecProviderConfigRefPolicyResolve
 */
export enum EmailTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

