// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * An Address is a managed resource that represents an AWS Elastic IP Address.
 *
 * @schema Address
 */
export class Address extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Address"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'Address',
  }

  /**
   * Renders a Kubernetes manifest for "Address".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressProps): any {
    return {
      ...Address.GVK,
      ...toJson_AddressProps(props),
    };
  }

  /**
   * Defines a "Address" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressProps) {
    super(scope, id, {
      ...Address.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Address.GVK,
      ...toJson_AddressProps(resolved),
    };
  }
}

/**
 * An Address is a managed resource that represents an AWS Elastic IP Address.
 *
 * @schema Address
 */
export interface AddressProps {
  /**
   * @schema Address#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An AddressSpec defines the desired state of an Address.
   *
   * @schema Address#spec
   */
  readonly spec: AddressSpec;

}

/**
 * Converts an object of type 'AddressProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressProps(obj: AddressProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An AddressSpec defines the desired state of an Address.
 *
 * @schema AddressSpec
 */
export interface AddressSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AddressSpec#deletionPolicy
   */
  readonly deletionPolicy?: AddressSpecDeletionPolicy;

  /**
   * AddressParameters define the desired state of an AWS Elastic IP
   *
   * @schema AddressSpec#forProvider
   */
  readonly forProvider: AddressSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AddressSpec#managementPolicies
   */
  readonly managementPolicies?: AddressSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AddressSpec#providerConfigRef
   */
  readonly providerConfigRef?: AddressSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AddressSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AddressSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AddressSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AddressSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AddressSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpec(obj: AddressSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AddressSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AddressSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AddressSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AddressSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AddressSpecDeletionPolicy
 */
export enum AddressSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AddressParameters define the desired state of an AWS Elastic IP
 *
 * @schema AddressSpecForProvider
 */
export interface AddressSpecForProvider {
  /**
   * [EC2-VPC] The Elastic IP address to recover or an IPv4 address from an address pool.
   *
   * @schema AddressSpecForProvider#address
   */
  readonly address?: string;

  /**
   * The ID of a customer-owned address pool. Use this parameter to let Amazon EC2 select an address from the address pool. Alternatively, specify a specific address from the address pool
   *
   * @schema AddressSpecForProvider#customerOwnedIPv4Pool
   */
  readonly customerOwnedIPv4Pool?: string;

  /**
   * Set to vpc to allocate the address for use with instances in a VPC. Default: The address is for use with instances in EC2-Classic.
   *
   * @schema AddressSpecForProvider#domain
   */
  readonly domain?: AddressSpecForProviderDomain;

  /**
   * The location from which the IP address is advertised. Use this parameter to limit the address to this location.
   * A network border group is a unique set of Availability Zones or Local Zones from where AWS advertises IP addresses and limits the addresses to the group. IP addresses cannot move between network border groups.
   * Use DescribeAvailabilityZones (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html) to view the network border groups.
   * You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 classic, you will receive an InvalidParameterCombination error. For more information, see Error Codes (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html).
   *
   * @schema AddressSpecForProvider#networkBorderGroup
   */
  readonly networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. To specify a specific address from the address pool, use the Address parameter instead.
   *
   * @schema AddressSpecForProvider#publicIpv4Pool
   */
  readonly publicIpv4Pool?: string;

  /**
   * Region is the region you'd like your Address to be created in.
   *
   * @schema AddressSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema AddressSpecForProvider#tags
   */
  readonly tags?: AddressSpecForProviderTags[];

}

/**
 * Converts an object of type 'AddressSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecForProvider(obj: AddressSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'customerOwnedIPv4Pool': obj.customerOwnedIPv4Pool,
    'domain': obj.domain,
    'networkBorderGroup': obj.networkBorderGroup,
    'publicIpv4Pool': obj.publicIpv4Pool,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_AddressSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AddressSpecManagementPolicies
 */
export enum AddressSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AddressSpecProviderConfigRef
 */
export interface AddressSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecProviderConfigRef#policy
   */
  readonly policy?: AddressSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AddressSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecProviderConfigRef(obj: AddressSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AddressSpecPublishConnectionDetailsTo
 */
export interface AddressSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AddressSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AddressSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AddressSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AddressSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AddressSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AddressSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecPublishConnectionDetailsTo(obj: AddressSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AddressSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AddressSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AddressSpecWriteConnectionSecretToRef
 */
export interface AddressSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AddressSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AddressSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AddressSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecWriteConnectionSecretToRef(obj: AddressSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set to vpc to allocate the address for use with instances in a VPC. Default: The address is for use with instances in EC2-Classic.
 *
 * @schema AddressSpecForProviderDomain
 */
export enum AddressSpecForProviderDomain {
  /** vpc */
  VPC = "vpc",
  /** standard */
  STANDARD = "standard",
}

/**
 * Tag defines a tag
 *
 * @schema AddressSpecForProviderTags
 */
export interface AddressSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema AddressSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema AddressSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AddressSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecForProviderTags(obj: AddressSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecProviderConfigRefPolicy
 */
export interface AddressSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddressSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AddressSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddressSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AddressSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddressSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecProviderConfigRefPolicy(obj: AddressSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AddressSpecPublishConnectionDetailsToConfigRef
 */
export interface AddressSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AddressSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AddressSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecPublishConnectionDetailsToConfigRef(obj: AddressSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AddressSpecPublishConnectionDetailsToMetadata
 */
export interface AddressSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddressSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddressSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AddressSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AddressSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecPublishConnectionDetailsToMetadata(obj: AddressSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddressSpecProviderConfigRefPolicyResolution
 */
export enum AddressSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddressSpecProviderConfigRefPolicyResolve
 */
export enum AddressSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AddressSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AddressSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddressSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AddressSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddressSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AddressSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddressSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressSpecPublishConnectionDetailsToConfigRefPolicy(obj: AddressSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddressSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AddressSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddressSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AddressSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FlowLog is the Schema for the FlowLogs API
 *
 * @schema FlowLog
 */
export class FlowLog extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FlowLog"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'FlowLog',
  }

  /**
   * Renders a Kubernetes manifest for "FlowLog".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FlowLogProps): any {
    return {
      ...FlowLog.GVK,
      ...toJson_FlowLogProps(props),
    };
  }

  /**
   * Defines a "FlowLog" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FlowLogProps) {
    super(scope, id, {
      ...FlowLog.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FlowLog.GVK,
      ...toJson_FlowLogProps(resolved),
    };
  }
}

/**
 * FlowLog is the Schema for the FlowLogs API
 *
 * @schema FlowLog
 */
export interface FlowLogProps {
  /**
   * @schema FlowLog#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FlowLogSpec defines the desired state of FlowLog
   *
   * @schema FlowLog#spec
   */
  readonly spec: FlowLogSpec;

}

/**
 * Converts an object of type 'FlowLogProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogProps(obj: FlowLogProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FlowLogSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlowLogSpec defines the desired state of FlowLog
 *
 * @schema FlowLogSpec
 */
export interface FlowLogSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FlowLogSpec#deletionPolicy
   */
  readonly deletionPolicy?: FlowLogSpecDeletionPolicy;

  /**
   * FlowLogParameters defines the desired state of FlowLog
   *
   * @schema FlowLogSpec#forProvider
   */
  readonly forProvider: FlowLogSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FlowLogSpec#managementPolicies
   */
  readonly managementPolicies?: FlowLogSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FlowLogSpec#providerConfigRef
   */
  readonly providerConfigRef?: FlowLogSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FlowLogSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FlowLogSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FlowLogSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FlowLogSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FlowLogSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpec(obj: FlowLogSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FlowLogSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FlowLogSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FlowLogSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FlowLogSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FlowLogSpecDeletionPolicy
 */
export enum FlowLogSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FlowLogParameters defines the desired state of FlowLog
 *
 * @schema FlowLogSpecForProvider
 */
export interface FlowLogSpecForProvider {
  /**
   * Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to ensure idempotency (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
   *
   * @schema FlowLogSpecForProvider#clientToken
   */
  readonly clientToken?: string;

  /**
   * The Amazon Resource Names (ARNs) of a CloudWatch Log Group.
   *
   * @schema FlowLogSpecForProvider#cloudWatchLogDestination
   */
  readonly cloudWatchLogDestination?: string;

  /**
   * CloudWatchLogDestinationRef is a reference to a CloudWatch Log Group used to set the CloudWatchLogDestination.
   *
   * @schema FlowLogSpecForProvider#cloudWatchLogDestinationRef
   */
  readonly cloudWatchLogDestinationRef?: FlowLogSpecForProviderCloudWatchLogDestinationRef;

  /**
   * CloudWatchLogDestinationSelector selects a reference to a CloudWatch Log Group used to set the CloudWatchLogDestination.
   *
   * @schema FlowLogSpecForProvider#cloudWatchLogDestinationSelector
   */
  readonly cloudWatchLogDestinationSelector?: FlowLogSpecForProviderCloudWatchLogDestinationSelector;

  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs across accounts.
   *
   * @schema FlowLogSpecForProvider#deliverCrossAccountRole
   */
  readonly deliverCrossAccountRole?: string;

  /**
   * The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. \n If you specify LogDestinationType as s3, do not specify DeliverLogsPermissionArn or LogGroupName.
   *
   * @schema FlowLogSpecForProvider#deliverLogsPermissionArn
   */
  readonly deliverLogsPermissionArn?: string;

  /**
   * DeliverLogsPermissionARNRef is a reference to DeliverLogsPermissionARN used to set the DeliverLogsPermissionARN.
   *
   * @schema FlowLogSpecForProvider#deliverLogsPermissionArnRef
   */
  readonly deliverLogsPermissionArnRef?: FlowLogSpecForProviderDeliverLogsPermissionArnRef;

  /**
   * DeliverLogsPermissionARNelector selects a reference to DeliverLogsPermissionARN used to set the DeliverLogsPermissionARN.
   *
   * @schema FlowLogSpecForProvider#deliverLogsPermissionArnSelector
   */
  readonly deliverLogsPermissionArnSelector?: FlowLogSpecForProviderDeliverLogsPermissionArnSelector;

  /**
   * The destination options.
   *
   * @schema FlowLogSpecForProvider#destinationOptions
   */
  readonly destinationOptions?: FlowLogSpecForProviderDestinationOptions;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   * * If the destination type is cloud-watch-logs, specify the ARN of a CloudWatch Logs log group. For example: arn:aws:logs:region:account_id:log-group:my_group Alternatively, use the LogGroupName parameter.
   * * If the destination type is s3, specify the ARN of an S3 bucket. For example: arn:aws:s3:::my_bucket/my_subfolder/ The subfolder is optional. Note that you can't use AWSLogs as a subfolder name.
   * * If the destination type is kinesis-data-firehose, specify the ARN of a Kinesis Data Firehose delivery stream. For example: arn:aws:firehose:region:account_id:deliverystream:my_stream
   *
   * @schema FlowLogSpecForProvider#logDestination
   */
  readonly logDestination?: string;

  /**
   * The type of destination for the flow log data.
   * Default: cloud-watch-logs
   *
   * @schema FlowLogSpecForProvider#logDestinationType
   */
  readonly logDestinationType?: string;

  /**
   * The fields to include in the flow log record. List the fields in the order in which they should appear. If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see Flow log records (https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records) in the Amazon VPC User Guide or Transit Gateway Flow Log records (https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records) in the Amazon Web Services Transit Gateway Guide.
   * Specify the fields using the ${field-id} format, separated by spaces.
   *
   * @schema FlowLogSpecForProvider#logFormat
   */
  readonly logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   * This parameter is valid only if the destination type is cloud-watch-logs.
   *
   * @schema FlowLogSpecForProvider#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.
   * When a network interface is attached to a Nitro-based instance (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances), the aggregation interval is always 60 seconds or less, regardless of the value that you specify.
   * Default: 600
   *
   * @schema FlowLogSpecForProvider#maxAggregationInterval
   */
  readonly maxAggregationInterval?: number;

  /**
   * The ID of the NetworkInterface for which you want to create a flow log.
   *
   * @schema FlowLogSpecForProvider#networkInterfaceId
   */
  readonly networkInterfaceId?: string;

  /**
   * Region is which region the FlowLog will be created.
   *
   * @schema FlowLogSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the subnet, network interface, or VPC for which you want to create a flow log.
   * Constraints: Maximum of 1000 resources
   *
   * @schema FlowLogSpecForProvider#resourceIDs
   */
  readonly resourceIDs?: string[];

  /**
   * The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
   *
   * @schema FlowLogSpecForProvider#resourceType
   */
  readonly resourceType?: string;

  /**
   * The Amazon Resource Names (ARNs) of a CloudWatch Log Group.
   *
   * @schema FlowLogSpecForProvider#s3BucketLogDestination
   */
  readonly s3BucketLogDestination?: string;

  /**
   * S3BucketLogDestinationRef is a reference to a S3 Bucket  to set the S3BucketLogDestination.
   *
   * @schema FlowLogSpecForProvider#s3BucketLogDestinationRef
   */
  readonly s3BucketLogDestinationRef?: FlowLogSpecForProviderS3BucketLogDestinationRef;

  /**
   * S3BucketLogDestinationSelector selects a reference to a S3 Bucket used to set the S3BucketLogDestination.
   *
   * @schema FlowLogSpecForProvider#s3BucketLogDestinationSelector
   */
  readonly s3BucketLogDestinationSelector?: FlowLogSpecForProviderS3BucketLogDestinationSelector;

  /**
   * S3BucketSubfolder allows you to use a subfolder in a S3Bucket, if S3BucketLogDestination is used to determin the ARN of a Bucket managed by crossplane S3BucketSubfolder starts and ends without an slash e.g. test/test2 You cannot use AWSLogs as a subfolder name. This is a reserved term.
   *
   * @schema FlowLogSpecForProvider#s3BucketSubfolder
   */
  readonly s3BucketSubfolder?: string;

  /**
   * The ID of the one or more Subnets for which you want to create a flow log.
   *
   * @schema FlowLogSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRefs is a referenc to a SubnetID used to set the SubnetID.
   *
   * @schema FlowLogSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: FlowLogSpecForProviderSubnetIdRef;

  /**
   * SubnetIDSelector selects reference to a SubnetID used to set the SubnetID.
   *
   * @schema FlowLogSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: FlowLogSpecForProviderSubnetIdSelector;

  /**
   * Metadata tagging key value pairs
   *
   * @schema FlowLogSpecForProvider#tags
   */
  readonly tags?: FlowLogSpecForProviderTags[];

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic). This parameter is not supported for transit gateway resource types. It is required for the other resource types.
   *
   * @schema FlowLogSpecForProvider#trafficType
   */
  readonly trafficType?: string;

  /**
   * The ID of the TransitGatewayAttachment for which you want to create a flow log.
   *
   * @schema FlowLogSpecForProvider#transitGatewayAttachmentId
   */
  readonly transitGatewayAttachmentId?: string;

  /**
   * TransitGatewayAttachmentIDRef is a reference to an API used to set the TransitGatewayAttachmentID.
   *
   * @schema FlowLogSpecForProvider#transitGatewayAttachmentIdRef
   */
  readonly transitGatewayAttachmentIdRef?: FlowLogSpecForProviderTransitGatewayAttachmentIdRef;

  /**
   * TransitGatewayAttachmentIDSelector selects references to API used to set the TransitGatewayAttachmentID.
   *
   * @schema FlowLogSpecForProvider#transitGatewayAttachmentIdSelector
   */
  readonly transitGatewayAttachmentIdSelector?: FlowLogSpecForProviderTransitGatewayAttachmentIdSelector;

  /**
   * The ID of the TransitGateway for which you want to create a flow log.
   *
   * @schema FlowLogSpecForProvider#transitGatewayId
   */
  readonly transitGatewayId?: string;

  /**
   * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
   *
   * @schema FlowLogSpecForProvider#transitGatewayIdRef
   */
  readonly transitGatewayIdRef?: FlowLogSpecForProviderTransitGatewayIdRef;

  /**
   * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
   *
   * @schema FlowLogSpecForProvider#transitGatewayIdSelector
   */
  readonly transitGatewayIdSelector?: FlowLogSpecForProviderTransitGatewayIdSelector;

  /**
   * The ID of the VPC for which you want to create a flow log.
   *
   * @schema FlowLogSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef is a reference to an API used to set the VPCID.
   *
   * @schema FlowLogSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: FlowLogSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects references to API used to set the VPCID.
   *
   * @schema FlowLogSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: FlowLogSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'FlowLogSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProvider(obj: FlowLogSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientToken': obj.clientToken,
    'cloudWatchLogDestination': obj.cloudWatchLogDestination,
    'cloudWatchLogDestinationRef': toJson_FlowLogSpecForProviderCloudWatchLogDestinationRef(obj.cloudWatchLogDestinationRef),
    'cloudWatchLogDestinationSelector': toJson_FlowLogSpecForProviderCloudWatchLogDestinationSelector(obj.cloudWatchLogDestinationSelector),
    'deliverCrossAccountRole': obj.deliverCrossAccountRole,
    'deliverLogsPermissionArn': obj.deliverLogsPermissionArn,
    'deliverLogsPermissionArnRef': toJson_FlowLogSpecForProviderDeliverLogsPermissionArnRef(obj.deliverLogsPermissionArnRef),
    'deliverLogsPermissionArnSelector': toJson_FlowLogSpecForProviderDeliverLogsPermissionArnSelector(obj.deliverLogsPermissionArnSelector),
    'destinationOptions': toJson_FlowLogSpecForProviderDestinationOptions(obj.destinationOptions),
    'logDestination': obj.logDestination,
    'logDestinationType': obj.logDestinationType,
    'logFormat': obj.logFormat,
    'logGroupName': obj.logGroupName,
    'maxAggregationInterval': obj.maxAggregationInterval,
    'networkInterfaceId': obj.networkInterfaceId,
    'region': obj.region,
    'resourceIDs': obj.resourceIDs?.map(y => y),
    'resourceType': obj.resourceType,
    's3BucketLogDestination': obj.s3BucketLogDestination,
    's3BucketLogDestinationRef': toJson_FlowLogSpecForProviderS3BucketLogDestinationRef(obj.s3BucketLogDestinationRef),
    's3BucketLogDestinationSelector': toJson_FlowLogSpecForProviderS3BucketLogDestinationSelector(obj.s3BucketLogDestinationSelector),
    's3BucketSubfolder': obj.s3BucketSubfolder,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_FlowLogSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_FlowLogSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tags': obj.tags?.map(y => toJson_FlowLogSpecForProviderTags(y)),
    'trafficType': obj.trafficType,
    'transitGatewayAttachmentId': obj.transitGatewayAttachmentId,
    'transitGatewayAttachmentIdRef': toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdRef(obj.transitGatewayAttachmentIdRef),
    'transitGatewayAttachmentIdSelector': toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdSelector(obj.transitGatewayAttachmentIdSelector),
    'transitGatewayId': obj.transitGatewayId,
    'transitGatewayIdRef': toJson_FlowLogSpecForProviderTransitGatewayIdRef(obj.transitGatewayIdRef),
    'transitGatewayIdSelector': toJson_FlowLogSpecForProviderTransitGatewayIdSelector(obj.transitGatewayIdSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_FlowLogSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_FlowLogSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FlowLogSpecManagementPolicies
 */
export enum FlowLogSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FlowLogSpecProviderConfigRef
 */
export interface FlowLogSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecProviderConfigRef#policy
   */
  readonly policy?: FlowLogSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecProviderConfigRef(obj: FlowLogSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FlowLogSpecPublishConnectionDetailsTo
 */
export interface FlowLogSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FlowLogSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FlowLogSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FlowLogSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FlowLogSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FlowLogSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FlowLogSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecPublishConnectionDetailsTo(obj: FlowLogSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FlowLogSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FlowLogSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FlowLogSpecWriteConnectionSecretToRef
 */
export interface FlowLogSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FlowLogSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FlowLogSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FlowLogSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecWriteConnectionSecretToRef(obj: FlowLogSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloudWatchLogDestinationRef is a reference to a CloudWatch Log Group used to set the CloudWatchLogDestination.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationRef
 */
export interface FlowLogSpecForProviderCloudWatchLogDestinationRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationRef#policy
   */
  readonly policy?: FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderCloudWatchLogDestinationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderCloudWatchLogDestinationRef(obj: FlowLogSpecForProviderCloudWatchLogDestinationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloudWatchLogDestinationSelector selects a reference to a CloudWatch Log Group used to set the CloudWatchLogDestination.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelector
 */
export interface FlowLogSpecForProviderCloudWatchLogDestinationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderCloudWatchLogDestinationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderCloudWatchLogDestinationSelector(obj: FlowLogSpecForProviderCloudWatchLogDestinationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeliverLogsPermissionARNRef is a reference to DeliverLogsPermissionARN used to set the DeliverLogsPermissionARN.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRef
 */
export interface FlowLogSpecForProviderDeliverLogsPermissionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRef#policy
   */
  readonly policy?: FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderDeliverLogsPermissionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderDeliverLogsPermissionArnRef(obj: FlowLogSpecForProviderDeliverLogsPermissionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeliverLogsPermissionARNelector selects a reference to DeliverLogsPermissionARN used to set the DeliverLogsPermissionARN.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelector
 */
export interface FlowLogSpecForProviderDeliverLogsPermissionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderDeliverLogsPermissionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderDeliverLogsPermissionArnSelector(obj: FlowLogSpecForProviderDeliverLogsPermissionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The destination options.
 *
 * @schema FlowLogSpecForProviderDestinationOptions
 */
export interface FlowLogSpecForProviderDestinationOptions {
  /**
   * @schema FlowLogSpecForProviderDestinationOptions#fileFormat
   */
  readonly fileFormat?: string;

  /**
   * @schema FlowLogSpecForProviderDestinationOptions#hiveCompatiblePartitions
   */
  readonly hiveCompatiblePartitions?: boolean;

  /**
   * @schema FlowLogSpecForProviderDestinationOptions#perHourPartition
   */
  readonly perHourPartition?: boolean;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderDestinationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderDestinationOptions(obj: FlowLogSpecForProviderDestinationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileFormat': obj.fileFormat,
    'hiveCompatiblePartitions': obj.hiveCompatiblePartitions,
    'perHourPartition': obj.perHourPartition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketLogDestinationRef is a reference to a S3 Bucket  to set the S3BucketLogDestination.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationRef
 */
export interface FlowLogSpecForProviderS3BucketLogDestinationRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationRef#policy
   */
  readonly policy?: FlowLogSpecForProviderS3BucketLogDestinationRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderS3BucketLogDestinationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderS3BucketLogDestinationRef(obj: FlowLogSpecForProviderS3BucketLogDestinationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderS3BucketLogDestinationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketLogDestinationSelector selects a reference to a S3 Bucket used to set the S3BucketLogDestination.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationSelector
 */
export interface FlowLogSpecForProviderS3BucketLogDestinationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderS3BucketLogDestinationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderS3BucketLogDestinationSelector(obj: FlowLogSpecForProviderS3BucketLogDestinationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDRefs is a referenc to a SubnetID used to set the SubnetID.
 *
 * @schema FlowLogSpecForProviderSubnetIdRef
 */
export interface FlowLogSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: FlowLogSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderSubnetIdRef(obj: FlowLogSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects reference to a SubnetID used to set the SubnetID.
 *
 * @schema FlowLogSpecForProviderSubnetIdSelector
 */
export interface FlowLogSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderSubnetIdSelector(obj: FlowLogSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowLogSpecForProviderTags
 */
export interface FlowLogSpecForProviderTags {
  /**
   * @schema FlowLogSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema FlowLogSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTags(obj: FlowLogSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayAttachmentIDRef is a reference to an API used to set the TransitGatewayAttachmentID.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRef
 */
export interface FlowLogSpecForProviderTransitGatewayAttachmentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRef#policy
   */
  readonly policy?: FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayAttachmentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdRef(obj: FlowLogSpecForProviderTransitGatewayAttachmentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayAttachmentIDSelector selects references to API used to set the TransitGatewayAttachmentID.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelector
 */
export interface FlowLogSpecForProviderTransitGatewayAttachmentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayAttachmentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdSelector(obj: FlowLogSpecForProviderTransitGatewayAttachmentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdRef
 */
export interface FlowLogSpecForProviderTransitGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdRef#policy
   */
  readonly policy?: FlowLogSpecForProviderTransitGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayIdRef(obj: FlowLogSpecForProviderTransitGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderTransitGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdSelector
 */
export interface FlowLogSpecForProviderTransitGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderTransitGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayIdSelector(obj: FlowLogSpecForProviderTransitGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderTransitGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef is a reference to an API used to set the VPCID.
 *
 * @schema FlowLogSpecForProviderVpcIdRef
 */
export interface FlowLogSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecForProviderVpcIdRef#policy
   */
  readonly policy?: FlowLogSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderVpcIdRef(obj: FlowLogSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects references to API used to set the VPCID.
 *
 * @schema FlowLogSpecForProviderVpcIdSelector
 */
export interface FlowLogSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowLogSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowLogSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowLogSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: FlowLogSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderVpcIdSelector(obj: FlowLogSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowLogSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecProviderConfigRefPolicy
 */
export interface FlowLogSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecProviderConfigRefPolicy(obj: FlowLogSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FlowLogSpecPublishConnectionDetailsToConfigRef
 */
export interface FlowLogSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FlowLogSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowLogSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecPublishConnectionDetailsToConfigRef(obj: FlowLogSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowLogSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FlowLogSpecPublishConnectionDetailsToMetadata
 */
export interface FlowLogSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FlowLogSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecPublishConnectionDetailsToMetadata(obj: FlowLogSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy
 */
export interface FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy(obj: FlowLogSpecForProviderCloudWatchLogDestinationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy
 */
export interface FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy(obj: FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy
 */
export interface FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy(obj: FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy
 */
export interface FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy(obj: FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationRefPolicy
 */
export interface FlowLogSpecForProviderS3BucketLogDestinationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderS3BucketLogDestinationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderS3BucketLogDestinationRefPolicy(obj: FlowLogSpecForProviderS3BucketLogDestinationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy
 */
export interface FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy(obj: FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderSubnetIdRefPolicy
 */
export interface FlowLogSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderSubnetIdRefPolicy(obj: FlowLogSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderSubnetIdSelectorPolicy
 */
export interface FlowLogSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderSubnetIdSelectorPolicy(obj: FlowLogSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy
 */
export interface FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy(obj: FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy
 */
export interface FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy(obj: FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdRefPolicy
 */
export interface FlowLogSpecForProviderTransitGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderTransitGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderTransitGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayIdRefPolicy(obj: FlowLogSpecForProviderTransitGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdSelectorPolicy
 */
export interface FlowLogSpecForProviderTransitGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderTransitGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderTransitGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderTransitGatewayIdSelectorPolicy(obj: FlowLogSpecForProviderTransitGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecForProviderVpcIdRefPolicy
 */
export interface FlowLogSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderVpcIdRefPolicy(obj: FlowLogSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowLogSpecForProviderVpcIdSelectorPolicy
 */
export interface FlowLogSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: FlowLogSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: FlowLogSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecForProviderVpcIdSelectorPolicy(obj: FlowLogSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecProviderConfigRefPolicyResolution
 */
export enum FlowLogSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecProviderConfigRefPolicyResolve
 */
export enum FlowLogSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FlowLogSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FlowLogSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowLogSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowLogSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowLogSpecPublishConnectionDetailsToConfigRefPolicy(obj: FlowLogSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolution
 */
export enum FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolve
 */
export enum FlowLogSpecForProviderCloudWatchLogDestinationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderCloudWatchLogDestinationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolution
 */
export enum FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolve
 */
export enum FlowLogSpecForProviderDeliverLogsPermissionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderDeliverLogsPermissionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolution
 */
export enum FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolve
 */
export enum FlowLogSpecForProviderS3BucketLogDestinationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderS3BucketLogDestinationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderSubnetIdRefPolicyResolution
 */
export enum FlowLogSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderSubnetIdRefPolicyResolve
 */
export enum FlowLogSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution
 */
export enum FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve
 */
export enum FlowLogSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdRefPolicyResolution
 */
export enum FlowLogSpecForProviderTransitGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdRefPolicyResolve
 */
export enum FlowLogSpecForProviderTransitGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderTransitGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderVpcIdRefPolicyResolution
 */
export enum FlowLogSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderVpcIdRefPolicyResolve
 */
export enum FlowLogSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum FlowLogSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum FlowLogSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FlowLogSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is a managed resource that represents a specified number of AWS EC2 Instance
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is a managed resource that represents a specified number of AWS EC2 Instance
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An InstanceSpec defines the desired state of Instances.
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An InstanceSpec defines the desired state of Instances.
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * InstanceParameters define the desired state of the Instances
   *
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * InstanceParameters define the desired state of the Instances
 *
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see Amazon EC2 Elastic GPUs (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProvider#ElasticGpuSpecification
   */
  readonly elasticGpuSpecification?: InstanceSpecForProviderElasticGpuSpecification[];

  /**
   * The block device mapping entries.
   *
   * @schema InstanceSpecForProvider#blockDeviceMappings
   */
  readonly blockDeviceMappings?: InstanceSpecForProviderBlockDeviceMappings[];

  /**
   * Information about the Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to open, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
   *
   * @schema InstanceSpecForProvider#capacityReservationSpecification
   */
  readonly capacityReservationSpecification?: InstanceSpecForProviderCapacityReservationSpecification;

  /**
   * Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
   * For more information, see Ensuring Idempotency (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
   * Constraints: Maximum 64 ASCII characters
   *
   * @schema InstanceSpecForProvider#clientToken
   */
  readonly clientToken?: string;

  /**
   * The CPU options for the instance. For more information, see Optimizing CPU Options (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProvider#cpuOptions
   */
  readonly cpuOptions?: InstanceSpecForProviderCpuOptions;

  /**
   * The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited. To change this attribute after launch, use ModifyInstanceCreditSpecification (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html). For more information, see Burstable Performance Instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the Amazon Elastic Compute Cloud User Guide.
   * Default: standard (T2 instances) or unlimited (T3/T3a instances)
   *
   * @schema InstanceSpecForProvider#creditSpecification
   */
  readonly creditSpecification?: InstanceSpecForProviderCreditSpecification;

  /**
   * If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use ModifyInstanceAttribute (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html). Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance.
   * Default: false
   *
   * @schema InstanceSpecForProvider#disableAPITermination
   */
  readonly disableApiTermination?: boolean;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
   * Default: false
   *
   * @schema InstanceSpecForProvider#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
   * You cannot specify accelerators from different generations in the same request.
   *
   * @schema InstanceSpecForProvider#elasticInferenceAccelerators
   */
  readonly elasticInferenceAccelerators?: InstanceSpecForProviderElasticInferenceAccelerators[];

  /**
   * Indicates whether an instance is enabled for hibernation. For more information, see Hibernate Your Instance (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProvider#hibernationOptions
   */
  readonly hibernationOptions?: InstanceSpecForProviderHibernationOptions;

  /**
   * The IAM instance profile.
   *
   * @schema InstanceSpecForProvider#iamInstanceProfile
   */
  readonly iamInstanceProfile?: InstanceSpecForProviderIamInstanceProfile;

  /**
   * The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.
   *
   * @schema InstanceSpecForProvider#imageId
   */
  readonly imageId: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   * Default: stop
   *
   * @schema InstanceSpecForProvider#instanceInitiatedShutdownBehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The market (purchasing) option for the instances.
   * For RunInstances, persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop.
   *
   * @schema InstanceSpecForProvider#instanceMarketOptions
   */
  readonly instanceMarketOptions?: InstanceSpecForProviderInstanceMarketOptions;

  /**
   * The instance type. For more information, see Instance Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon Elastic Compute Cloud User Guide.
   * Default: m1.small
   *
   * @schema InstanceSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * [EC2-VPC] The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @schema InstanceSpecForProvider#ipv6AddressCount
   */
  readonly ipv6AddressCount?: number;

  /**
   * [EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @schema InstanceSpecForProvider#ipv6Addresses
   */
  readonly ipv6Addresses?: InstanceSpecForProviderIpv6Addresses[];

  /**
   * The ID of the kernel.
   * AWS recommends that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProvider#kernelId
   */
  readonly kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using CreateKeyPair (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or ImportKeyPair (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
   * If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
   *
   * @schema InstanceSpecForProvider#keyName
   */
  readonly keyName?: string;

  /**
   * The launch template to use to launch the instances. Any parameters that you specify in RunInstances override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
   *
   * @schema InstanceSpecForProvider#launchTemplate
   */
  readonly launchTemplate?: InstanceSpecForProviderLaunchTemplate;

  /**
   * The Amazon Resource Name (ARN) of the license configuration
   *
   * @schema InstanceSpecForProvider#licenseSpecifications
   */
  readonly licenseSpecifications?: InstanceSpecForProviderLicenseSpecifications[];

  /**
   * The metadata options for the instance. For more information, see Instance Metadata and User Data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
   *
   * @schema InstanceSpecForProvider#metadataOptions
   */
  readonly metadataOptions?: InstanceSpecForProviderMetadataOptions;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   *
   * @schema InstanceSpecForProvider#monitoring
   */
  readonly monitoring?: InstanceSpecForProviderMonitoring;

  /**
   * The network interfaces to associate with the instance. If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
   *
   * @schema InstanceSpecForProvider#networkInterfaces
   */
  readonly networkInterfaces?: InstanceSpecForProviderNetworkInterfaces[];

  /**
   * The placement for the instance.
   *
   * @schema InstanceSpecForProvider#placement
   */
  readonly placement?: InstanceSpecForProviderPlacement;

  /**
   * [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @schema InstanceSpecForProvider#privateIpAddress
   */
  readonly privateIpAddress?: string;

  /**
   * The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
   * AWS recommends that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProvider#ramDiskId
   */
  readonly ramDiskId?: string;

  /**
   * Region is the region you'd like your Instance to be created in.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IDs of the security groups. You can create a security group using CreateSecurityGroup (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html).
   * If you specify a network interface, you must specify any security groups as part of the network interface.
   *
   * @schema InstanceSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SecurityGroupsRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema InstanceSpecForProvider#securityGroupRefs
   */
  readonly securityGroupRefs?: InstanceSpecForProviderSecurityGroupRefs[];

  /**
   * SecurityGroupsSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema InstanceSpecForProvider#securityGroupSelector
   */
  readonly securityGroupSelector?: InstanceSpecForProviderSecurityGroupSelector;

  /**
   * [EC2-VPC] The ID of the subnet to launch the instance into.
   * If you specify a network interface, you must specify any subnets as part of the network interface.
   *
   * @schema InstanceSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRef is a reference to a Subnet used to set the SubnetID.
   *
   * @schema InstanceSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: InstanceSpecForProviderSubnetIdRef;

  /**
   * SubnetIDSelector selects a reference to a Subnet used to set the SubnetID.
   *
   * @schema InstanceSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: InstanceSpecForProviderSubnetIdSelector;

  /**
   * The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
   *
   * @schema InstanceSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: InstanceSpecForProviderTagSpecifications[];

  /**
   * Tags are used as identification helpers between AWS resources.
   *
   * @schema InstanceSpecForProvider#tags
   */
  readonly tags?: InstanceSpecForProviderTags[];

  /**
   * The user data to make available to the instance. For more information, see Running Commands on Your Linux Instance at Launch (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) (Linux) and Adding User Data (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data) (Windows). If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB.
   *
   * @schema InstanceSpecForProvider#userData
   */
  readonly userData?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ElasticGpuSpecification': obj.elasticGpuSpecification?.map(y => toJson_InstanceSpecForProviderElasticGpuSpecification(y)),
    'blockDeviceMappings': obj.blockDeviceMappings?.map(y => toJson_InstanceSpecForProviderBlockDeviceMappings(y)),
    'capacityReservationSpecification': toJson_InstanceSpecForProviderCapacityReservationSpecification(obj.capacityReservationSpecification),
    'clientToken': obj.clientToken,
    'cpuOptions': toJson_InstanceSpecForProviderCpuOptions(obj.cpuOptions),
    'creditSpecification': toJson_InstanceSpecForProviderCreditSpecification(obj.creditSpecification),
    'disableAPITermination': obj.disableApiTermination,
    'ebsOptimized': obj.ebsOptimized,
    'elasticInferenceAccelerators': obj.elasticInferenceAccelerators?.map(y => toJson_InstanceSpecForProviderElasticInferenceAccelerators(y)),
    'hibernationOptions': toJson_InstanceSpecForProviderHibernationOptions(obj.hibernationOptions),
    'iamInstanceProfile': toJson_InstanceSpecForProviderIamInstanceProfile(obj.iamInstanceProfile),
    'imageId': obj.imageId,
    'instanceInitiatedShutdownBehavior': obj.instanceInitiatedShutdownBehavior,
    'instanceMarketOptions': toJson_InstanceSpecForProviderInstanceMarketOptions(obj.instanceMarketOptions),
    'instanceType': obj.instanceType,
    'ipv6AddressCount': obj.ipv6AddressCount,
    'ipv6Addresses': obj.ipv6Addresses?.map(y => toJson_InstanceSpecForProviderIpv6Addresses(y)),
    'kernelId': obj.kernelId,
    'keyName': obj.keyName,
    'launchTemplate': toJson_InstanceSpecForProviderLaunchTemplate(obj.launchTemplate),
    'licenseSpecifications': obj.licenseSpecifications?.map(y => toJson_InstanceSpecForProviderLicenseSpecifications(y)),
    'metadataOptions': toJson_InstanceSpecForProviderMetadataOptions(obj.metadataOptions),
    'monitoring': toJson_InstanceSpecForProviderMonitoring(obj.monitoring),
    'networkInterfaces': obj.networkInterfaces?.map(y => toJson_InstanceSpecForProviderNetworkInterfaces(y)),
    'placement': toJson_InstanceSpecForProviderPlacement(obj.placement),
    'privateIpAddress': obj.privateIpAddress,
    'ramDiskId': obj.ramDiskId,
    'region': obj.region,
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_InstanceSpecForProviderSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_InstanceSpecForProviderSecurityGroupSelector(obj.securityGroupSelector),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_InstanceSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_InstanceSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_InstanceSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_InstanceSpecForProviderTags(y)),
    'userData': obj.userData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ElasticGPUSpecification is a specification for an Elastic Graphics accelerator.
 *
 * @schema InstanceSpecForProviderElasticGpuSpecification
 */
export interface InstanceSpecForProviderElasticGpuSpecification {
  /**
   * The type of Elastic Graphics accelerator. For more information about the values to specify for Type, see Elastic Graphics Basics (https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics), specifically the Elastic Graphics accelerator column, in the Amazon Elastic Compute Cloud User Guide for Windows Instances.
   * Type is a required field
   *
   * @schema InstanceSpecForProviderElasticGpuSpecification#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderElasticGpuSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderElasticGpuSpecification(obj: InstanceSpecForProviderElasticGpuSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BlockDeviceMapping describes a block device mapping.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappings
 */
export interface InstanceSpecForProviderBlockDeviceMappings {
  /**
   * The device name (for example, /dev/sdh or xvdh).
   *
   * @schema InstanceSpecForProviderBlockDeviceMappings#deviceName
   */
  readonly deviceName: string;

  /**
   * Parameters used to automatically set up EBS volumes when the instance is launched.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappings#ebs
   */
  readonly ebs: InstanceSpecForProviderBlockDeviceMappingsEbs;

  /**
   * Suppresses the specified device included in the block device mapping of the AMI.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappings#noDevice
   */
  readonly noDevice?: string;

  /**
   * The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
   * NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
   * Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappings#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappings(obj: InstanceSpecForProviderBlockDeviceMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': toJson_InstanceSpecForProviderBlockDeviceMappingsEbs(obj.ebs),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to open, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
 *
 * @schema InstanceSpecForProviderCapacityReservationSpecification
 */
export interface InstanceSpecForProviderCapacityReservationSpecification {
  /**
   * Information about the target Capacity Reservation.
   *
   * @schema InstanceSpecForProviderCapacityReservationSpecification#capacityReservationTarget
   */
  readonly capacityReservationTarget?: InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget;

  /**
   * Indicates the instance's Capacity Reservation preferences. Possible preferences include:
   * * open - The instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
   * * none - The instance avoids running in a Capacity Reservation even if one is available. The instance runs as an On-Demand Instance.
   *
   * @schema InstanceSpecForProviderCapacityReservationSpecification#capacityReservationsPreference
   */
  readonly capacityReservationsPreference: InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationsPreference;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCapacityReservationSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCapacityReservationSpecification(obj: InstanceSpecForProviderCapacityReservationSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationTarget': toJson_InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget(obj.capacityReservationTarget),
    'capacityReservationsPreference': obj.capacityReservationsPreference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CPU options for the instance. For more information, see Optimizing CPU Options (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
 *
 * @schema InstanceSpecForProviderCpuOptions
 */
export interface InstanceSpecForProviderCpuOptions {
  /**
   * The number of CPU cores for the instance.
   *
   * @schema InstanceSpecForProviderCpuOptions#coreCount
   */
  readonly coreCount: number;

  /**
   * The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.
   *
   * @schema InstanceSpecForProviderCpuOptions#threadsPerCore
   */
  readonly threadsPerCore: number;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCpuOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCpuOptions(obj: InstanceSpecForProviderCpuOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coreCount': obj.coreCount,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited. To change this attribute after launch, use ModifyInstanceCreditSpecification (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html). For more information, see Burstable Performance Instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the Amazon Elastic Compute Cloud User Guide.
 * Default: standard (T2 instances) or unlimited (T3/T3a instances)
 *
 * @schema InstanceSpecForProviderCreditSpecification
 */
export interface InstanceSpecForProviderCreditSpecification {
  /**
   * The credit option for CPU usage of a T2 or T3 instance. Valid values are standard and unlimited.
   * CPUCredits is a required field
   *
   * @schema InstanceSpecForProviderCreditSpecification#cpuCredits
   */
  readonly cpuCredits: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCreditSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCreditSpecification(obj: InstanceSpecForProviderCreditSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuCredits': obj.cpuCredits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ElasticInferenceAccelerator describes an elastic inference accelerator.
 *
 * @schema InstanceSpecForProviderElasticInferenceAccelerators
 */
export interface InstanceSpecForProviderElasticInferenceAccelerators {
  /**
   * The number of elastic inference accelerators to attach to the instance.
   * Default: 1
   *
   * @schema InstanceSpecForProviderElasticInferenceAccelerators#count
   */
  readonly count?: number;

  /**
   * The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
   * Type is a required field
   *
   * @schema InstanceSpecForProviderElasticInferenceAccelerators#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderElasticInferenceAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderElasticInferenceAccelerators(obj: InstanceSpecForProviderElasticInferenceAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether an instance is enabled for hibernation. For more information, see Hibernate Your Instance (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the Amazon Elastic Compute Cloud User Guide.
 *
 * @schema InstanceSpecForProviderHibernationOptions
 */
export interface InstanceSpecForProviderHibernationOptions {
  /**
   * If you set this parameter to true, your instance is enabled for hibernation.
   * Default: false
   *
   * @schema InstanceSpecForProviderHibernationOptions#configured
   */
  readonly configured?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecForProviderHibernationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderHibernationOptions(obj: InstanceSpecForProviderHibernationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configured': obj.configured,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The IAM instance profile.
 *
 * @schema InstanceSpecForProviderIamInstanceProfile
 */
export interface InstanceSpecForProviderIamInstanceProfile {
  /**
   * The Amazon Resource Name (ARN) of the instance profile.
   *
   * @schema InstanceSpecForProviderIamInstanceProfile#arn
   */
  readonly arn?: string;

  /**
   * The name of the instance profile.
   *
   * @schema InstanceSpecForProviderIamInstanceProfile#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderIamInstanceProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderIamInstanceProfile(obj: InstanceSpecForProviderIamInstanceProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The market (purchasing) option for the instances.
 * For RunInstances, persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop.
 *
 * @schema InstanceSpecForProviderInstanceMarketOptions
 */
export interface InstanceSpecForProviderInstanceMarketOptions {
  /**
   * The market type.
   *
   * @schema InstanceSpecForProviderInstanceMarketOptions#marketType
   */
  readonly marketType: string;

  /**
   * The options for Spot Instances.
   *
   * @schema InstanceSpecForProviderInstanceMarketOptions#spotOptions
   */
  readonly spotOptions: InstanceSpecForProviderInstanceMarketOptionsSpotOptions;

}

/**
 * Converts an object of type 'InstanceSpecForProviderInstanceMarketOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderInstanceMarketOptions(obj: InstanceSpecForProviderInstanceMarketOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'marketType': obj.marketType,
    'spotOptions': toJson_InstanceSpecForProviderInstanceMarketOptionsSpotOptions(obj.spotOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceIPv6Address describes an IPv6 address.
 *
 * @schema InstanceSpecForProviderIpv6Addresses
 */
export interface InstanceSpecForProviderIpv6Addresses {
  /**
   * The IPv6 address.
   *
   * @schema InstanceSpecForProviderIpv6Addresses#ipv6Address
   */
  readonly ipv6Address: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderIpv6Addresses(obj: InstanceSpecForProviderIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Address': obj.ipv6Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The launch template to use to launch the instances. Any parameters that you specify in RunInstances override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
 *
 * @schema InstanceSpecForProviderLaunchTemplate
 */
export interface InstanceSpecForProviderLaunchTemplate {
  /**
   * The ID of the launch template.
   *
   * @schema InstanceSpecForProviderLaunchTemplate#launchTemplateId
   */
  readonly launchTemplateId: string;

  /**
   * The name of the launch template.
   *
   * @schema InstanceSpecForProviderLaunchTemplate#launchTemplateName
   */
  readonly launchTemplateName: string;

  /**
   * The version number of the launch template.
   * Default: The default version for the launch template.
   *
   * @schema InstanceSpecForProviderLaunchTemplate#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLaunchTemplate(obj: InstanceSpecForProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateName': obj.launchTemplateName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LicenseConfigurationRequest describes a license configuration
 *
 * @schema InstanceSpecForProviderLicenseSpecifications
 */
export interface InstanceSpecForProviderLicenseSpecifications {
  /**
   * Amazon Resource Name (ARN) of the license configuration
   *
   * @schema InstanceSpecForProviderLicenseSpecifications#licenseConfigurationArn
   */
  readonly licenseConfigurationArn: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLicenseSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLicenseSpecifications(obj: InstanceSpecForProviderLicenseSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseConfigurationArn': obj.licenseConfigurationArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The metadata options for the instance. For more information, see Instance Metadata and User Data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
 *
 * @schema InstanceSpecForProviderMetadataOptions
 */
export interface InstanceSpecForProviderMetadataOptions {
  /**
   * This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled.
   * If you specify a value of disabled, you will not be able to access your instance metadata.
   *
   * @schema InstanceSpecForProviderMetadataOptions#httpEndpoint
   */
  readonly httpEndpoint?: InstanceSpecForProviderMetadataOptionsHttpEndpoint;

  /**
   * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
   * Default: 1
   * Possible values: Integers from 1 to 64
   *
   * @schema InstanceSpecForProviderMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is optional.
   * If the state is optional, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.
   * If the state is required, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.
   *
   * @schema InstanceSpecForProviderMetadataOptions#httpTokens
   */
  readonly httpTokens: InstanceSpecForProviderMetadataOptionsHttpTokens;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMetadataOptions(obj: InstanceSpecForProviderMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpoint': obj.httpEndpoint,
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether detailed monitoring is enabled for the instance.
 *
 * @schema InstanceSpecForProviderMonitoring
 */
export interface InstanceSpecForProviderMonitoring {
  /**
   * Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
   * Enabled is a required field
   *
   * @schema InstanceSpecForProviderMonitoring#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMonitoring(obj: InstanceSpecForProviderMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceNetworkInterfaceSpecification describes a network interface.
 *
 * @schema InstanceSpecForProviderNetworkInterfaces
 */
export interface InstanceSpecForProviderNetworkInterfaces {
  /**
   * Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#associatePublicIpAddress
   */
  readonly associatePublicIpAddress?: boolean;

  /**
   * If set to true, the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * The description of the network interface. Applies only if creating a network interface when launching an instance.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#description
   */
  readonly description?: string;

  /**
   * The position of the network interface in the attachment order. A primary network interface has a device index of 0.
   * If you specify a network interface when launching an instance, you must specify the device index.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#deviceIndex
   */
  readonly deviceIndex: number;

  /**
   * The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#groups
   */
  readonly groups: string[];

  /**
   * The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa. For more information, see Elastic Fabric Adapter (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the Amazon Elastic Compute Cloud User Guide.
   * If you are not creating an EFA, specify interface or omit this parameter.
   * Valid values: interface | efa
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#interfaceType
   */
  readonly interfaceType: InstanceSpecForProviderNetworkInterfacesInterfaceType;

  /**
   * A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#ipv6AddressCount
   */
  readonly ipv6AddressCount?: number;

  /**
   * One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#ipv6Addresses
   */
  readonly ipv6Addresses?: InstanceSpecForProviderNetworkInterfacesIpv6Addresses[];

  /**
   * The number of IPv6 delegated prefixes to be automatically assigned to the network interface. You cannot use this option if you use the Ipv6Prefix option.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#ipv6PrefixCount
   */
  readonly ipv6PrefixCount?: number;

  /**
   * One or more IPv6 delegated prefixes to be assigned to the network interface. You cannot use this option if you use the Ipv6PrefixCount option.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#ipv6Prefixes
   */
  readonly ipv6Prefixes?: InstanceSpecForProviderNetworkInterfacesIpv6Prefixes[];

  /**
   * The ID of the network interface.
   * If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#networkInterfaceId
   */
  readonly networkInterfaceId?: string;

  /**
   * The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#privateIpAddress
   */
  readonly privateIpAddress?: string;

  /**
   * One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#privateIpAddresses
   */
  readonly privateIpAddresses?: InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses[];

  /**
   * The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#secondaryPrivateIpAddressCount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.
   *
   * @schema InstanceSpecForProviderNetworkInterfaces#subnetId
   */
  readonly subnetId?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworkInterfaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworkInterfaces(obj: InstanceSpecForProviderNetworkInterfaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associatePublicIpAddress': obj.associatePublicIpAddress,
    'deleteOnTermination': obj.deleteOnTermination,
    'description': obj.description,
    'deviceIndex': obj.deviceIndex,
    'groups': obj.groups?.map(y => y),
    'interfaceType': obj.interfaceType,
    'ipv6AddressCount': obj.ipv6AddressCount,
    'ipv6Addresses': obj.ipv6Addresses?.map(y => toJson_InstanceSpecForProviderNetworkInterfacesIpv6Addresses(y)),
    'ipv6PrefixCount': obj.ipv6PrefixCount,
    'ipv6Prefixes': obj.ipv6Prefixes?.map(y => toJson_InstanceSpecForProviderNetworkInterfacesIpv6Prefixes(y)),
    'networkInterfaceId': obj.networkInterfaceId,
    'privateIpAddress': obj.privateIpAddress,
    'privateIpAddresses': obj.privateIpAddresses?.map(y => toJson_InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses(y)),
    'secondaryPrivateIpAddressCount': obj.secondaryPrivateIpAddressCount,
    'subnetId': obj.subnetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The placement for the instance.
 *
 * @schema InstanceSpecForProviderPlacement
 */
export interface InstanceSpecForProviderPlacement {
  /**
   * The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#affinity
   */
  readonly affinity?: string;

  /**
   * The Availability Zone of the instance.
   * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The name of the placement group the instance is in.
   *
   * @schema InstanceSpecForProviderPlacement#groupName
   */
  readonly groupName: string;

  /**
   * The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#hostId
   */
  readonly hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the Tenancy parameter or set it to host.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#hostResourceGroupArn
   */
  readonly hostResourceGroupArn?: string;

  /**
   * The number of the partition the instance is in. Valid only if the placement group strategy is set to partition.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#partitionNumber
   */
  readonly partitionNumber?: number;

  /**
   * Reserved for future use.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#spreadDomain
   */
  readonly spreadDomain?: string;

  /**
   * The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the ImportInstance (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) command.
   * This parameter is not supported by CreateFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet).
   *
   * @schema InstanceSpecForProviderPlacement#tenancy
   */
  readonly tenancy?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderPlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderPlacement(obj: InstanceSpecForProviderPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'availabilityZone': obj.availabilityZone,
    'groupName': obj.groupName,
    'hostId': obj.hostId,
    'hostResourceGroupArn': obj.hostResourceGroupArn,
    'partitionNumber': obj.partitionNumber,
    'spreadDomain': obj.spreadDomain,
    'tenancy': obj.tenancy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema InstanceSpecForProviderSecurityGroupRefs
 */
export interface InstanceSpecForProviderSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderSecurityGroupRefs#policy
   */
  readonly policy?: InstanceSpecForProviderSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupRefs(obj: InstanceSpecForProviderSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupsSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
 *
 * @schema InstanceSpecForProviderSecurityGroupSelector
 */
export interface InstanceSpecForProviderSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderSecurityGroupSelector#policy
   */
  readonly policy?: InstanceSpecForProviderSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupSelector(obj: InstanceSpecForProviderSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDRef is a reference to a Subnet used to set the SubnetID.
 *
 * @schema InstanceSpecForProviderSubnetIdRef
 */
export interface InstanceSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdRef(obj: InstanceSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects a reference to a Subnet used to set the SubnetID.
 *
 * @schema InstanceSpecForProviderSubnetIdSelector
 */
export interface InstanceSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdSelector(obj: InstanceSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagSpecification defines the tags to apply to a resource when the resource is being created.
 *
 * @schema InstanceSpecForProviderTagSpecifications
 */
export interface InstanceSpecForProviderTagSpecifications {
  /**
   * The type of resource to tag. Currently, the resource types that support tagging on creation are: capacity-reservation | client-vpn-endpoint | dedicated-host | fleet | fpga-image | instance | ipv4pool-ec2 | ipv6pool-ec2 | key-pair | launch-template | natgateway | spot-fleet-request | placement-group | snapshot | traffic-mirror-filter | traffic-mirror-session | traffic-mirror-target | transit-gateway | transit-gateway-attachment | transit-gateway-route-table | vpc-endpoint (for interface VPC endpoints)| vpc-endpoint-service (for gateway VPC endpoints) | volume | vpc-flow-log.
   * To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
   *
   * @schema InstanceSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType: InstanceSpecForProviderTagSpecificationsResourceType;

  /**
   * The tags to apply to the resource
   *
   * @schema InstanceSpecForProviderTagSpecifications#tags
   */
  readonly tags: InstanceSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderTagSpecifications(obj: InstanceSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_InstanceSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema InstanceSpecForProviderTags
 */
export interface InstanceSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema InstanceSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema InstanceSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderTags(obj: InstanceSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters used to automatically set up EBS volumes when the instance is launched.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbs
 */
export interface InstanceSpecForProviderBlockDeviceMappingsEbs {
  /**
   * Indicates whether the EBS volume is deleted on instance termination. For more information, see Preserving Amazon EBS Volumes on Instance Termination (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see Amazon EBS Encryption (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the Amazon Elastic Compute Cloud User Guide.
   * In no case can you remove encryption from an encrypted volume.
   * Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see Supported Instance Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
   * This parameter is not returned by .
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information, see Amazon EBS Volume Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the Amazon Elastic Compute Cloud User Guide.
   * Constraints: Range is 100-16,000 IOPS for gp2 volumes and 100 to 64,000IOPS for io1 volumes in most Regions. Maximum io1 IOPS of 64,000 is guaranteed only on Nitro-based instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). Other instance families guarantee performance up to 32,000 IOPS. For more information, see Amazon EBS Volume Types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the Amazon Elastic Compute Cloud User Guide.
   * Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#iops
   */
  readonly iops?: number;

  /**
   * Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
   * This parameter is only supported on BlockDeviceMapping objects called by RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html), RequestSpotFleet (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html), and RequestSpotInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html).
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector;

  /**
   * The ID of the snapshot.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * The throughput that the volume supports, in MiB/s.
   * Constraints: Up to 1,000MiB/s for gp3 volumes.
   * Condition: This parameter is optional and only used to create gp3 volumes; it is not used in requests to create gp2, st1, sc1, io1, or standard volumes.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#throughput
   */
  readonly throughput?: number;

  /**
   * The size of the volume, in GiB.
   * Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
   * Constraints: 1-16384 for General Purpose SSD (gp2), 4-16384 for Provisioned IOPS SSD (io1), 500-16384 for Throughput Optimized HDD (st1), 500-16384 for Cold HDD (sc1), and 1-1024 for Magnetic (standard) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#volumeSize
   */
  readonly volumeSize: number;

  /**
   * The volume type. If you set the type to io1, you must also specify the Iops parameter. If you set the type to gp2, st1, sc1, or standard, you must omit the Iops parameter.
   * Default: gp2
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappingsEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappingsEbs(obj: InstanceSpecForProviderBlockDeviceMappingsEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the target Capacity Reservation.
 *
 * @schema InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget
 */
export interface InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget {
  /**
   * The ID of the Capacity Reservation.
   *
   * @schema InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget#capacityReservationId
   */
  readonly capacityReservationId?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget(obj: InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationId': obj.capacityReservationId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates the instance's Capacity Reservation preferences. Possible preferences include:
 * * open - The instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
 * * none - The instance avoids running in a Capacity Reservation even if one is available. The instance runs as an On-Demand Instance.
 *
 * @schema InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationsPreference
 */
export enum InstanceSpecForProviderCapacityReservationSpecificationCapacityReservationsPreference {
  /** open */
  OPEN = "open",
  /** none */
  NONE = "none",
}

/**
 * The options for Spot Instances.
 *
 * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions
 */
export interface InstanceSpecForProviderInstanceMarketOptionsSpotOptions {
  /**
   * The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).
   *
   * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions#blockDurationMinutes
   */
  readonly blockDurationMinutes?: number;

  /**
   * The behavior when a Spot Instance is interrupted. The default is terminate.
   *
   * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions#instanceInterruptionBehavior
   */
  readonly instanceInterruptionBehavior: InstanceSpecForProviderInstanceMarketOptionsSpotOptionsInstanceInterruptionBehavior;

  /**
   * The maximum hourly price you're willing to pay for the Spot Instances. The default is the On-Demand price.
   *
   * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions#maxPrice
   */
  readonly maxPrice?: string;

  /**
   * The Spot Instance request type. For RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances), persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop.
   *
   * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions#spotInstanceType
   */
  readonly spotInstanceType: InstanceSpecForProviderInstanceMarketOptionsSpotOptionsSpotInstanceType;

  /**
   * The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date. Must be in UTC format (YYYY-MM-DDTHH:MM:SSZ)
   *
   * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptions#validUntil
   */
  readonly validUntil?: Date;

}

/**
 * Converts an object of type 'InstanceSpecForProviderInstanceMarketOptionsSpotOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderInstanceMarketOptionsSpotOptions(obj: InstanceSpecForProviderInstanceMarketOptionsSpotOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDurationMinutes': obj.blockDurationMinutes,
    'instanceInterruptionBehavior': obj.instanceInterruptionBehavior,
    'maxPrice': obj.maxPrice,
    'spotInstanceType': obj.spotInstanceType,
    'validUntil': obj.validUntil?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled.
 * If you specify a value of disabled, you will not be able to access your instance metadata.
 *
 * @schema InstanceSpecForProviderMetadataOptionsHttpEndpoint
 */
export enum InstanceSpecForProviderMetadataOptionsHttpEndpoint {
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is optional.
 * If the state is optional, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.
 * If the state is required, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.
 *
 * @schema InstanceSpecForProviderMetadataOptionsHttpTokens
 */
export enum InstanceSpecForProviderMetadataOptionsHttpTokens {
  /** optional */
  OPTIONAL = "optional",
  /** required */
  REQUIRED = "required",
}

/**
 * The type of network interface. To create an Elastic Fabric Adapter (EFA), specify efa. For more information, see Elastic Fabric Adapter (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the Amazon Elastic Compute Cloud User Guide.
 * If you are not creating an EFA, specify interface or omit this parameter.
 * Valid values: interface | efa
 *
 * @schema InstanceSpecForProviderNetworkInterfacesInterfaceType
 */
export enum InstanceSpecForProviderNetworkInterfacesInterfaceType {
  /** interface */
  INTERFACE = "interface",
  /** efa */
  EFA = "efa",
}

/**
 * InstanceIPv6Address describes an IPv6 address.
 *
 * @schema InstanceSpecForProviderNetworkInterfacesIpv6Addresses
 */
export interface InstanceSpecForProviderNetworkInterfacesIpv6Addresses {
  /**
   * The IPv6 address.
   *
   * @schema InstanceSpecForProviderNetworkInterfacesIpv6Addresses#ipv6Address
   */
  readonly ipv6Address: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworkInterfacesIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworkInterfacesIpv6Addresses(obj: InstanceSpecForProviderNetworkInterfacesIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Address': obj.ipv6Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ipv6PrefixSpecificationRequest describes the IPv4 prefix option for a network interface.
 *
 * @schema InstanceSpecForProviderNetworkInterfacesIpv6Prefixes
 */
export interface InstanceSpecForProviderNetworkInterfacesIpv6Prefixes {
  /**
   * The IPv6 prefix.
   *
   * @schema InstanceSpecForProviderNetworkInterfacesIpv6Prefixes#ipv6Prefix
   */
  readonly ipv6Prefix: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworkInterfacesIpv6Prefixes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworkInterfacesIpv6Prefixes(obj: InstanceSpecForProviderNetworkInterfacesIpv6Prefixes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Prefix': obj.ipv6Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateIPAddressSpecification describes a secondary private IPv4 address for a network interface.
 *
 * @schema InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses
 */
export interface InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses {
  /**
   * Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
   *
   * @schema InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * The private IPv4 addresses.
   *
   * @schema InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses#privateIPAddress
   */
  readonly privateIpAddress: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses(obj: InstanceSpecForProviderNetworkInterfacesPrivateIpAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'privateIPAddress': obj.privateIpAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderSecurityGroupRefsPolicy
 */
export interface InstanceSpecForProviderSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupRefsPolicy(obj: InstanceSpecForProviderSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderSecurityGroupSelectorPolicy
 */
export interface InstanceSpecForProviderSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupSelectorPolicy(obj: InstanceSpecForProviderSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicy
 */
export interface InstanceSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdRefPolicy(obj: InstanceSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicy
 */
export interface InstanceSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdSelectorPolicy(obj: InstanceSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of resource to tag. Currently, the resource types that support tagging on creation are: capacity-reservation | client-vpn-endpoint | dedicated-host | fleet | fpga-image | instance | ipv4pool-ec2 | ipv6pool-ec2 | key-pair | launch-template | natgateway | spot-fleet-request | placement-group | snapshot | traffic-mirror-filter | traffic-mirror-session | traffic-mirror-target | transit-gateway | transit-gateway-attachment | transit-gateway-route-table | vpc-endpoint (for interface VPC endpoints)| vpc-endpoint-service (for gateway VPC endpoints) | volume | vpc-flow-log.
 * To tag a resource after it has been created, see CreateTags (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
 *
 * @schema InstanceSpecForProviderTagSpecificationsResourceType
 */
export enum InstanceSpecForProviderTagSpecificationsResourceType {
  /** capacity-reservation */
  CAPACITY_HYPHEN_RESERVATION = "capacity-reservation",
  /** client-vpn-endpoint */
  CLIENT_HYPHEN_VPN_HYPHEN_ENDPOINT = "client-vpn-endpoint",
  /** dedicated-host */
  DEDICATED_HYPHEN_HOST = "dedicated-host",
  /** fleet */
  FLEET = "fleet",
  /** fpga-image */
  FPGA_HYPHEN_IMAGE = "fpga-image",
  /** instance */
  INSTANCE = "instance",
  /** ipv4pool-ec2 */
  IPV4POOL_HYPHEN_EC2 = "ipv4pool-ec2",
  /** ipv6pool-ec2 */
  IPV6POOL_HYPHEN_EC2 = "ipv6pool-ec2",
  /** key-pair */
  KEY_HYPHEN_PAIR = "key-pair",
  /** launch-template */
  LAUNCH_HYPHEN_TEMPLATE = "launch-template",
  /** natgateway */
  NATGATEWAY = "natgateway",
  /** spot-fleet-request */
  SPOT_HYPHEN_FLEET_HYPHEN_REQUEST = "spot-fleet-request",
  /** placement-group */
  PLACEMENT_HYPHEN_GROUP = "placement-group",
  /** snapshot */
  SNAPSHOT = "snapshot",
  /** traffic-mirror-filter */
  TRAFFIC_HYPHEN_MIRROR_HYPHEN_FILTER = "traffic-mirror-filter",
  /** traffic-mirror-session */
  TRAFFIC_HYPHEN_MIRROR_HYPHEN_SESSION = "traffic-mirror-session",
  /** traffic-mirror-target */
  TRAFFIC_HYPHEN_MIRROR_HYPHEN_TARGET = "traffic-mirror-target",
  /** transit-gateway */
  TRANSIT_HYPHEN_GATEWAY = "transit-gateway",
  /** transit-gateway-attachment */
  TRANSIT_HYPHEN_GATEWAY_HYPHEN_ATTACHMENT = "transit-gateway-attachment",
  /** transit-gateway-route-table */
  TRANSIT_HYPHEN_GATEWAY_HYPHEN_ROUTE_HYPHEN_TABLE = "transit-gateway-route-table",
  /** vpc-endpoint */
  VPC_HYPHEN_ENDPOINT = "vpc-endpoint",
  /** vpc-endpoint-service */
  VPC_HYPHEN_ENDPOINT_HYPHEN_SERVICE = "vpc-endpoint-service",
  /** volume */
  VOLUME = "volume",
  /** vpc-flow-log */
  VPC_HYPHEN_FLOW_HYPHEN_LOG = "vpc-flow-log",
}

/**
 * Tag defines a tag
 *
 * @schema InstanceSpecForProviderTagSpecificationsTags
 */
export interface InstanceSpecForProviderTagSpecificationsTags {
  /**
   * Key is the name of the tag.
   *
   * @schema InstanceSpecForProviderTagSpecificationsTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema InstanceSpecForProviderTagSpecificationsTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderTagSpecificationsTags(obj: InstanceSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef
 */
export interface InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef(obj: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector
 */
export interface InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector(obj: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The behavior when a Spot Instance is interrupted. The default is terminate.
 *
 * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptionsInstanceInterruptionBehavior
 */
export enum InstanceSpecForProviderInstanceMarketOptionsSpotOptionsInstanceInterruptionBehavior {
  /** hibernate */
  HIBERNATE = "hibernate",
  /** stop */
  STOP = "stop",
  /** terminate */
  TERMINATE = "terminate",
}

/**
 * The Spot Instance request type. For RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances), persistent Spot Instance requests are only supported when InstanceInterruptionBehavior is set to either hibernate or stop.
 *
 * @schema InstanceSpecForProviderInstanceMarketOptionsSpotOptionsSpotInstanceType
 */
export enum InstanceSpecForProviderInstanceMarketOptionsSpotOptionsSpotInstanceType {
  /** one-time */
  ONE_HYPHEN_TIME = "one-time",
  /** persistent */
  PERSISTENT = "persistent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSecurityGroupRefsPolicyResolution
 */
export enum InstanceSpecForProviderSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSecurityGroupRefsPolicyResolve
 */
export enum InstanceSpecForProviderSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSecurityGroupSelectorPolicyResolution
 */
export enum InstanceSpecForProviderSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSecurityGroupSelectorPolicyResolve
 */
export enum InstanceSpecForProviderSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicyResolution
 */
export enum InstanceSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicyResolve
 */
export enum InstanceSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy
 */
export interface InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy(obj: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy
 */
export interface InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy(obj: InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution
 */
export enum InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve
 */
export enum InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderBlockDeviceMappingsEbsKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * An InternetGateway is a managed resource that represents an AWS VPC Internet Gateway.
 *
 * @schema InternetGateway
 */
export class InternetGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InternetGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'InternetGateway',
  }

  /**
   * Renders a Kubernetes manifest for "InternetGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InternetGatewayProps): any {
    return {
      ...InternetGateway.GVK,
      ...toJson_InternetGatewayProps(props),
    };
  }

  /**
   * Defines a "InternetGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InternetGatewayProps) {
    super(scope, id, {
      ...InternetGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InternetGateway.GVK,
      ...toJson_InternetGatewayProps(resolved),
    };
  }
}

/**
 * An InternetGateway is a managed resource that represents an AWS VPC Internet Gateway.
 *
 * @schema InternetGateway
 */
export interface InternetGatewayProps {
  /**
   * @schema InternetGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An InternetGatewaySpec defines the desired state of an InternetGateway.
   *
   * @schema InternetGateway#spec
   */
  readonly spec: InternetGatewaySpec;

}

/**
 * Converts an object of type 'InternetGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewayProps(obj: InternetGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InternetGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An InternetGatewaySpec defines the desired state of an InternetGateway.
 *
 * @schema InternetGatewaySpec
 */
export interface InternetGatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InternetGatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: InternetGatewaySpecDeletionPolicy;

  /**
   * InternetGatewayParameters define the desired state of an AWS VPC Internet Gateway.
   *
   * @schema InternetGatewaySpec#forProvider
   */
  readonly forProvider: InternetGatewaySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InternetGatewaySpec#managementPolicies
   */
  readonly managementPolicies?: InternetGatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InternetGatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: InternetGatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InternetGatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InternetGatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InternetGatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InternetGatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InternetGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpec(obj: InternetGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InternetGatewaySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InternetGatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InternetGatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InternetGatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InternetGatewaySpecDeletionPolicy
 */
export enum InternetGatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * InternetGatewayParameters define the desired state of an AWS VPC Internet Gateway.
 *
 * @schema InternetGatewaySpecForProvider
 */
export interface InternetGatewaySpecForProvider {
  /**
   * Region is the region you'd like your VPC to be created in.
   *
   * @schema InternetGatewaySpecForProvider#region
   */
  readonly region?: string;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema InternetGatewaySpecForProvider#tags
   */
  readonly tags?: InternetGatewaySpecForProviderTags[];

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema InternetGatewaySpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to and retrieves its vpcId
   *
   * @schema InternetGatewaySpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: InternetGatewaySpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
   *
   * @schema InternetGatewaySpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: InternetGatewaySpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProvider(obj: InternetGatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_InternetGatewaySpecForProviderTags(y)),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_InternetGatewaySpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_InternetGatewaySpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InternetGatewaySpecManagementPolicies
 */
export enum InternetGatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InternetGatewaySpecProviderConfigRef
 */
export interface InternetGatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InternetGatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InternetGatewaySpecProviderConfigRef#policy
   */
  readonly policy?: InternetGatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InternetGatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecProviderConfigRef(obj: InternetGatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InternetGatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsTo
 */
export interface InternetGatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InternetGatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InternetGatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InternetGatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecPublishConnectionDetailsTo(obj: InternetGatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InternetGatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InternetGatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InternetGatewaySpecWriteConnectionSecretToRef
 */
export interface InternetGatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InternetGatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InternetGatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InternetGatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecWriteConnectionSecretToRef(obj: InternetGatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema InternetGatewaySpecForProviderTags
 */
export interface InternetGatewaySpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema InternetGatewaySpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema InternetGatewaySpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProviderTags(obj: InternetGatewaySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to and retrieves its vpcId
 *
 * @schema InternetGatewaySpecForProviderVpcIdRef
 */
export interface InternetGatewaySpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InternetGatewaySpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InternetGatewaySpecForProviderVpcIdRef#policy
   */
  readonly policy?: InternetGatewaySpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProviderVpcIdRef(obj: InternetGatewaySpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InternetGatewaySpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
 *
 * @schema InternetGatewaySpecForProviderVpcIdSelector
 */
export interface InternetGatewaySpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InternetGatewaySpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InternetGatewaySpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InternetGatewaySpecForProviderVpcIdSelector#policy
   */
  readonly policy?: InternetGatewaySpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProviderVpcIdSelector(obj: InternetGatewaySpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InternetGatewaySpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InternetGatewaySpecProviderConfigRefPolicy
 */
export interface InternetGatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InternetGatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InternetGatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InternetGatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InternetGatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InternetGatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecProviderConfigRefPolicy(obj: InternetGatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface InternetGatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InternetGatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecPublishConnectionDetailsToConfigRef(obj: InternetGatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsToMetadata
 */
export interface InternetGatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InternetGatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecPublishConnectionDetailsToMetadata(obj: InternetGatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InternetGatewaySpecForProviderVpcIdRefPolicy
 */
export interface InternetGatewaySpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InternetGatewaySpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: InternetGatewaySpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InternetGatewaySpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: InternetGatewaySpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProviderVpcIdRefPolicy(obj: InternetGatewaySpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InternetGatewaySpecForProviderVpcIdSelectorPolicy
 */
export interface InternetGatewaySpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InternetGatewaySpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: InternetGatewaySpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InternetGatewaySpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: InternetGatewaySpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InternetGatewaySpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecForProviderVpcIdSelectorPolicy(obj: InternetGatewaySpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InternetGatewaySpecProviderConfigRefPolicyResolution
 */
export enum InternetGatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InternetGatewaySpecProviderConfigRefPolicyResolve
 */
export enum InternetGatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InternetGatewaySpecForProviderVpcIdRefPolicyResolution
 */
export enum InternetGatewaySpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InternetGatewaySpecForProviderVpcIdRefPolicyResolve
 */
export enum InternetGatewaySpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InternetGatewaySpecForProviderVpcIdSelectorPolicyResolution
 */
export enum InternetGatewaySpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InternetGatewaySpecForProviderVpcIdSelectorPolicyResolve
 */
export enum InternetGatewaySpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InternetGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LaunchTemplate is the Schema for the LaunchTemplates API
 *
 * @schema LaunchTemplate
 */
export class LaunchTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LaunchTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'LaunchTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "LaunchTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LaunchTemplateProps): any {
    return {
      ...LaunchTemplate.GVK,
      ...toJson_LaunchTemplateProps(props),
    };
  }

  /**
   * Defines a "LaunchTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LaunchTemplateProps) {
    super(scope, id, {
      ...LaunchTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LaunchTemplate.GVK,
      ...toJson_LaunchTemplateProps(resolved),
    };
  }
}

/**
 * LaunchTemplate is the Schema for the LaunchTemplates API
 *
 * @schema LaunchTemplate
 */
export interface LaunchTemplateProps {
  /**
   * @schema LaunchTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LaunchTemplateSpec defines the desired state of LaunchTemplate
   *
   * @schema LaunchTemplate#spec
   */
  readonly spec: LaunchTemplateSpec;

}

/**
 * Converts an object of type 'LaunchTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateProps(obj: LaunchTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LaunchTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateSpec defines the desired state of LaunchTemplate
 *
 * @schema LaunchTemplateSpec
 */
export interface LaunchTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LaunchTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: LaunchTemplateSpecDeletionPolicy;

  /**
   * LaunchTemplateParameters defines the desired state of LaunchTemplate
   *
   * @schema LaunchTemplateSpec#forProvider
   */
  readonly forProvider: LaunchTemplateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LaunchTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: LaunchTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LaunchTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: LaunchTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LaunchTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LaunchTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LaunchTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LaunchTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LaunchTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpec(obj: LaunchTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LaunchTemplateSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LaunchTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LaunchTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LaunchTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LaunchTemplateSpecDeletionPolicy
 */
export enum LaunchTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * LaunchTemplateParameters defines the desired state of LaunchTemplate
 *
 * @schema LaunchTemplateSpecForProvider
 */
export interface LaunchTemplateSpecForProvider {
  /**
   * The information for the launch template.
   *
   * @schema LaunchTemplateSpecForProvider#launchTemplateData
   */
  readonly launchTemplateData: LaunchTemplateSpecForProviderLaunchTemplateData;

  /**
   * A name for the launch template.
   *
   * @schema LaunchTemplateSpecForProvider#launchTemplateName
   */
  readonly launchTemplateName: string;

  /**
   * Region is which region the LaunchTemplate will be created.
   *
   * @schema LaunchTemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to apply to the launch template on creation. To tag the launch template, the resource type must be launch-template.
   * To specify the tags for the resources that are created when an instance is launched, you must use the TagSpecifications parameter in the launch template data (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html) structure.
   *
   * @schema LaunchTemplateSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: LaunchTemplateSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema LaunchTemplateSpecForProvider#tags
   */
  readonly tags?: LaunchTemplateSpecForProviderTags[];

  /**
   * A description for the first version of the launch template.
   *
   * @schema LaunchTemplateSpecForProvider#versionDescription
   */
  readonly versionDescription?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProvider(obj: LaunchTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateData': toJson_LaunchTemplateSpecForProviderLaunchTemplateData(obj.launchTemplateData),
    'launchTemplateName': obj.launchTemplateName,
    'region': obj.region,
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_LaunchTemplateSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_LaunchTemplateSpecForProviderTags(y)),
    'versionDescription': obj.versionDescription,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LaunchTemplateSpecManagementPolicies
 */
export enum LaunchTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LaunchTemplateSpecProviderConfigRef
 */
export interface LaunchTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: LaunchTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecProviderConfigRef(obj: LaunchTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsTo
 */
export interface LaunchTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LaunchTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LaunchTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecPublishConnectionDetailsTo(obj: LaunchTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LaunchTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LaunchTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LaunchTemplateSpecWriteConnectionSecretToRef
 */
export interface LaunchTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LaunchTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LaunchTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecWriteConnectionSecretToRef(obj: LaunchTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The information for the launch template.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateData
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateData {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#blockDeviceMappings
   */
  readonly blockDeviceMappings?: LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings[];

  /**
   * Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the CapacityReservationPreference parameter to configure the instance to run in On-Demand capacity or to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the CapacityReservationTarget parameter to explicitly target a specific Capacity Reservation or a Capacity Reservation group.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#capacityReservationSpecification
   */
  readonly capacityReservationSpecification?: LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification;

  /**
   * The CPU options for the instance. Both the core count and threads per core must be specified in the request.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#cpuOptions
   */
  readonly cpuOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions;

  /**
   * The credit option for CPU usage of a T instance.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#creditSpecification
   */
  readonly creditSpecification?: LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#disableAPIStop
   */
  readonly disableApiStop?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#disableAPITermination
   */
  readonly disableApiTermination?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#elasticGPUSpecifications
   */
  readonly elasticGpuSpecifications?: LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#elasticInferenceAccelerators
   */
  readonly elasticInferenceAccelerators?: LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators[];

  /**
   * Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the Amazon Web Services Nitro Enclaves User Guide.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#enclaveOptions
   */
  readonly enclaveOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions;

  /**
   * Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html).
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#hibernationOptions
   */
  readonly hibernationOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions;

  /**
   * An IAM instance profile.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#iamInstanceProfile
   */
  readonly iamInstanceProfile?: LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#imageID
   */
  readonly imageId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#instanceInitiatedShutdownBehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The market (purchasing) option for the instances.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#instanceMarketOptions
   */
  readonly instanceMarketOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions;

  /**
   * The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   * You must specify VCpuCount and MemoryMiB. All other attributes are optional. Any unspecified optional attribute is set to its default.
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   * * AllowedInstanceTypes - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * * ExcludedInstanceTypes - The instance types to exclude from the list, even if they match your specified attributes.
   * If you specify InstanceRequirements, you can't specify InstanceType.
   * Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the launch instance wizard (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or AWS::EC2::Instance (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) Amazon Web Services CloudFormation resource, you can't specify InstanceRequirements.
   * For more information, see Attribute-based instance type selection for EC2 Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#instanceRequirements
   */
  readonly instanceRequirements?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#instanceType
   */
  readonly instanceType?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#kernelID
   */
  readonly kernelId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#keyName
   */
  readonly keyName?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#licenseSpecifications
   */
  readonly licenseSpecifications?: LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications[];

  /**
   * The maintenance options of your instance.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#maintenanceOptions
   */
  readonly maintenanceOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions;

  /**
   * The metadata options for the instance. For more information, see Instance metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#metadataOptions
   */
  readonly metadataOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions;

  /**
   * Describes the monitoring for the instance.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#monitoring
   */
  readonly monitoring?: LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#networkInterfaces
   */
  readonly networkInterfaces?: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces[];

  /**
   * Describes the placement of an instance.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#placement
   */
  readonly placement?: LaunchTemplateSpecForProviderLaunchTemplateDataPlacement;

  /**
   * Describes the options for instance hostnames.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#privateDNSNameOptions
   */
  readonly privateDnsNameOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#ramDiskID
   */
  readonly ramDiskId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#tagSpecifications
   */
  readonly tagSpecifications?: LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateData#userData
   */
  readonly userData?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateData(obj: LaunchTemplateSpecForProviderLaunchTemplateData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMappings': obj.blockDeviceMappings?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings(y)),
    'capacityReservationSpecification': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification(obj.capacityReservationSpecification),
    'cpuOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions(obj.cpuOptions),
    'creditSpecification': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification(obj.creditSpecification),
    'disableAPIStop': obj.disableApiStop,
    'disableAPITermination': obj.disableApiTermination,
    'ebsOptimized': obj.ebsOptimized,
    'elasticGPUSpecifications': obj.elasticGpuSpecifications?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications(y)),
    'elasticInferenceAccelerators': obj.elasticInferenceAccelerators?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators(y)),
    'enclaveOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions(obj.enclaveOptions),
    'hibernationOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions(obj.hibernationOptions),
    'iamInstanceProfile': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile(obj.iamInstanceProfile),
    'imageID': obj.imageId,
    'instanceInitiatedShutdownBehavior': obj.instanceInitiatedShutdownBehavior,
    'instanceMarketOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions(obj.instanceMarketOptions),
    'instanceRequirements': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements(obj.instanceRequirements),
    'instanceType': obj.instanceType,
    'kernelID': obj.kernelId,
    'keyName': obj.keyName,
    'licenseSpecifications': obj.licenseSpecifications?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications(y)),
    'maintenanceOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions(obj.maintenanceOptions),
    'metadataOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions(obj.metadataOptions),
    'monitoring': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring(obj.monitoring),
    'networkInterfaces': obj.networkInterfaces?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces(y)),
    'placement': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataPlacement(obj.placement),
    'privateDNSNameOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions(obj.privateDnsNameOptions),
    'ramDiskID': obj.ramDiskId,
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'securityGroups': obj.securityGroups?.map(y => y),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications(y)),
    'userData': obj.userData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderTagSpecifications
 */
export interface LaunchTemplateSpecForProviderTagSpecifications {
  /**
   * @schema LaunchTemplateSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema LaunchTemplateSpecForProviderTagSpecifications#tags
   */
  readonly tags?: LaunchTemplateSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderTagSpecifications(obj: LaunchTemplateSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_LaunchTemplateSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderTags
 */
export interface LaunchTemplateSpecForProviderTags {
  /**
   * @schema LaunchTemplateSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema LaunchTemplateSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderTags(obj: LaunchTemplateSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateSpecProviderConfigRefPolicy
 */
export interface LaunchTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecProviderConfigRefPolicy(obj: LaunchTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface LaunchTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecPublishConnectionDetailsToConfigRef(obj: LaunchTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface LaunchTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecPublishConnectionDetailsToMetadata(obj: LaunchTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings#deviceName
   */
  readonly deviceName?: string;

  /**
   * The parameters for a block device for an EBS volume.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings#ebs
   */
  readonly ebs?: LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings#noDevice
   */
  readonly noDevice?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings(obj: LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs(obj.ebs),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the CapacityReservationPreference parameter to configure the instance to run in On-Demand capacity or to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the CapacityReservationTarget parameter to explicitly target a specific Capacity Reservation or a Capacity Reservation group.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification#capacityReservationPreference
   */
  readonly capacityReservationPreference?: string;

  /**
   * Describes a target Capacity Reservation or Capacity Reservation group.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification#capacityReservationTarget
   */
  readonly capacityReservationTarget?: LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification(obj: LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationPreference': obj.capacityReservationPreference,
    'capacityReservationTarget': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget(obj.capacityReservationTarget),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CPU options for the instance. Both the core count and threads per core must be specified in the request.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions#amdSevSnp
   */
  readonly amdSevSnp?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions#coreCount
   */
  readonly coreCount?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions#threadsPerCore
   */
  readonly threadsPerCore?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataCpuOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amdSevSnp': obj.amdSevSnp,
    'coreCount': obj.coreCount,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credit option for CPU usage of a T instance.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification#cpuCredits
   */
  readonly cpuCredits?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification(obj: LaunchTemplateSpecForProviderLaunchTemplateDataCreditSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuCredits': obj.cpuCredits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications(obj: LaunchTemplateSpecForProviderLaunchTemplateDataElasticGpuSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators#count
   */
  readonly count?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators(obj: LaunchTemplateSpecForProviderLaunchTemplateDataElasticInferenceAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the Amazon Web Services Nitro Enclaves User Guide.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataEnclaveOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html).
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions#configured
   */
  readonly configured?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataHibernationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configured': obj.configured,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An IAM instance profile.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile#arn
   */
  readonly arn?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile(obj: LaunchTemplateSpecForProviderLaunchTemplateDataIamInstanceProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The market (purchasing) option for the instances.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions#marketType
   */
  readonly marketType?: string;

  /**
   * The options for Spot Instances.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions#spotOptions
   */
  readonly spotOptions?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'marketType': obj.marketType,
    'spotOptions': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions(obj.spotOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
 * You must specify VCpuCount and MemoryMiB. All other attributes are optional. Any unspecified optional attribute is set to its default.
 * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
 * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
 * * AllowedInstanceTypes - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
 * * ExcludedInstanceTypes - The instance types to exclude from the list, even if they match your specified attributes.
 * If you specify InstanceRequirements, you can't specify InstanceType.
 * Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the launch instance wizard (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or AWS::EC2::Instance (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) Amazon Web Services CloudFormation resource, you can't specify InstanceRequirements.
 * For more information, see Attribute-based instance type selection for EC2 Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements {
  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set Max to 0.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorCount
   */
  readonly acceleratorCount?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorManufacturers
   */
  readonly acceleratorManufacturers?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorNames
   */
  readonly acceleratorNames?: string[];

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorTotalMemoryMiB
   */
  readonly acceleratorTotalMemoryMiB?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#allowedInstanceTypes
   */
  readonly allowedInstanceTypes?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#bareMetal
   */
  readonly bareMetal?: string;

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#baselineEBSBandwidthMbps
   */
  readonly baselineEbsBandwidthMbps?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#burstablePerformance
   */
  readonly burstablePerformance?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#cpuManufacturers
   */
  readonly cpuManufacturers?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#excludedInstanceTypes
   */
  readonly excludedInstanceTypes?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#instanceGenerations
   */
  readonly instanceGenerations?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#localStorage
   */
  readonly localStorage?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#localStorageTypes
   */
  readonly localStorageTypes?: string[];

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#memoryGiBPerVCPU
   */
  readonly memoryGiBPerVcpu?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu;

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#memoryMiB
   */
  readonly memoryMiB?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB;

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   * Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#networkBandwidthGbps
   */
  readonly networkBandwidthGbps?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps;

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#networkInterfaceCount
   */
  readonly networkInterfaceCount?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#onDemandMaxPricePercentageOverLowestPrice
   */
  readonly onDemandMaxPricePercentageOverLowestPrice?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#requireHibernateSupport
   */
  readonly requireHibernateSupport?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#spotMaxPricePercentageOverLowestPrice
   */
  readonly spotMaxPricePercentageOverLowestPrice?: number;

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#totalLocalStorageGB
   */
  readonly totalLocalStorageGb?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb;

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements#vCPUCount
   */
  readonly vCpuCount?: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorCount': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount(obj.acceleratorCount),
    'acceleratorManufacturers': obj.acceleratorManufacturers?.map(y => y),
    'acceleratorNames': obj.acceleratorNames?.map(y => y),
    'acceleratorTotalMemoryMiB': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB(obj.acceleratorTotalMemoryMiB),
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'allowedInstanceTypes': obj.allowedInstanceTypes?.map(y => y),
    'bareMetal': obj.bareMetal,
    'baselineEBSBandwidthMbps': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps(obj.baselineEbsBandwidthMbps),
    'burstablePerformance': obj.burstablePerformance,
    'cpuManufacturers': obj.cpuManufacturers?.map(y => y),
    'excludedInstanceTypes': obj.excludedInstanceTypes?.map(y => y),
    'instanceGenerations': obj.instanceGenerations?.map(y => y),
    'localStorage': obj.localStorage,
    'localStorageTypes': obj.localStorageTypes?.map(y => y),
    'memoryGiBPerVCPU': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu(obj.memoryGiBPerVcpu),
    'memoryMiB': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB(obj.memoryMiB),
    'networkBandwidthGbps': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps(obj.networkBandwidthGbps),
    'networkInterfaceCount': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount(obj.networkInterfaceCount),
    'onDemandMaxPricePercentageOverLowestPrice': obj.onDemandMaxPricePercentageOverLowestPrice,
    'requireHibernateSupport': obj.requireHibernateSupport,
    'spotMaxPricePercentageOverLowestPrice': obj.spotMaxPricePercentageOverLowestPrice,
    'totalLocalStorageGB': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb(obj.totalLocalStorageGb),
    'vCPUCount': toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount(obj.vCpuCount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications#licenseConfigurationARN
   */
  readonly licenseConfigurationArn?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications(obj: LaunchTemplateSpecForProviderLaunchTemplateDataLicenseSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseConfigurationARN': obj.licenseConfigurationArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maintenance options of your instance.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions#autoRecovery
   */
  readonly autoRecovery?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataMaintenanceOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRecovery': obj.autoRecovery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The metadata options for the instance. For more information, see Instance metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon Elastic Compute Cloud User Guide.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions#httpEndpoint
   */
  readonly httpEndpoint?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions#httpProtocolIPv6
   */
  readonly httpProtocolIPv6?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions#instanceMetadataTags
   */
  readonly instanceMetadataTags?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpoint': obj.httpEndpoint,
    'httpProtocolIPv6': obj.httpProtocolIPv6,
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
    'instanceMetadataTags': obj.instanceMetadataTags,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the monitoring for the instance.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring(obj: LaunchTemplateSpecForProviderLaunchTemplateDataMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#associateCarrierIPAddress
   */
  readonly associateCarrierIpAddress?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#associatePublicIPAddress
   */
  readonly associatePublicIpAddress?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#description
   */
  readonly description?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#deviceIndex
   */
  readonly deviceIndex?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#groups
   */
  readonly groups?: string[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#interfaceType
   */
  readonly interfaceType?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv4PrefixCount
   */
  readonly ipv4PrefixCount?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv4Prefixes
   */
  readonly ipv4Prefixes?: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6AddressCount
   */
  readonly ipv6AddressCount?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6Addresses
   */
  readonly ipv6Addresses?: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6PrefixCount
   */
  readonly ipv6PrefixCount?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6Prefixes
   */
  readonly ipv6Prefixes?: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#networkCardIndex
   */
  readonly networkCardIndex?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#networkInterfaceID
   */
  readonly networkInterfaceId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#primaryIPv6
   */
  readonly primaryIPv6?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#privateIPAddress
   */
  readonly privateIpAddress?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#privateIPAddresses
   */
  readonly privateIpAddresses?: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses[];

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#secondaryPrivateIPAddressCount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces#subnetID
   */
  readonly subnetId?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces(obj: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associateCarrierIPAddress': obj.associateCarrierIpAddress,
    'associatePublicIPAddress': obj.associatePublicIpAddress,
    'deleteOnTermination': obj.deleteOnTermination,
    'description': obj.description,
    'deviceIndex': obj.deviceIndex,
    'groups': obj.groups?.map(y => y),
    'interfaceType': obj.interfaceType,
    'ipv4PrefixCount': obj.ipv4PrefixCount,
    'ipv4Prefixes': obj.ipv4Prefixes?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes(y)),
    'ipv6AddressCount': obj.ipv6AddressCount,
    'ipv6Addresses': obj.ipv6Addresses?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses(y)),
    'ipv6PrefixCount': obj.ipv6PrefixCount,
    'ipv6Prefixes': obj.ipv6Prefixes?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes(y)),
    'networkCardIndex': obj.networkCardIndex,
    'networkInterfaceID': obj.networkInterfaceId,
    'primaryIPv6': obj.primaryIPv6,
    'privateIPAddress': obj.privateIpAddress,
    'privateIPAddresses': obj.privateIpAddresses?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses(y)),
    'secondaryPrivateIPAddressCount': obj.secondaryPrivateIpAddressCount,
    'subnetID': obj.subnetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the placement of an instance.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataPlacement {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#affinity
   */
  readonly affinity?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#groupID
   */
  readonly groupId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#groupName
   */
  readonly groupName?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#hostID
   */
  readonly hostId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#hostResourceGroupARN
   */
  readonly hostResourceGroupArn?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#partitionNumber
   */
  readonly partitionNumber?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#spreadDomain
   */
  readonly spreadDomain?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPlacement#tenancy
   */
  readonly tenancy?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataPlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataPlacement(obj: LaunchTemplateSpecForProviderLaunchTemplateDataPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'availabilityZone': obj.availabilityZone,
    'groupID': obj.groupId,
    'groupName': obj.groupName,
    'hostID': obj.hostId,
    'hostResourceGroupARN': obj.hostResourceGroupArn,
    'partitionNumber': obj.partitionNumber,
    'spreadDomain': obj.spreadDomain,
    'tenancy': obj.tenancy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the options for instance hostnames.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#enableResourceNameDNSAAAARecord
   */
  readonly enableResourceNameDnsaaaaRecord?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#enableResourceNameDNSARecord
   */
  readonly enableResourceNameDnsaRecord?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#hostnameType
   */
  readonly hostnameType?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataPrivateDnsNameOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableResourceNameDNSAAAARecord': obj.enableResourceNameDnsaaaaRecord,
    'enableResourceNameDNSARecord': obj.enableResourceNameDnsaRecord,
    'hostnameType': obj.hostnameType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications#tags
   */
  readonly tags?: LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags[];

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications(obj: LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderTagSpecificationsTags
 */
export interface LaunchTemplateSpecForProviderTagSpecificationsTags {
  /**
   * @schema LaunchTemplateSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema LaunchTemplateSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderTagSpecificationsTags(obj: LaunchTemplateSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateSpecProviderConfigRefPolicyResolution
 */
export enum LaunchTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateSpecProviderConfigRefPolicyResolve
 */
export enum LaunchTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The parameters for a block device for an EBS volume.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#iops
   */
  readonly iops?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#snapshotID
   */
  readonly snapshotId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#throughput
   */
  readonly throughput?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs(obj: LaunchTemplateSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyID': obj.kmsKeyId,
    'snapshotID': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes a target Capacity Reservation or Capacity Reservation group.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget#capacityReservationID
   */
  readonly capacityReservationId?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget#capacityReservationResourceGroupARN
   */
  readonly capacityReservationResourceGroupArn?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget(obj: LaunchTemplateSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationID': obj.capacityReservationId,
    'capacityReservationResourceGroupARN': obj.capacityReservationResourceGroupArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The options for Spot Instances.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#blockDurationMinutes
   */
  readonly blockDurationMinutes?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#instanceInterruptionBehavior
   */
  readonly instanceInterruptionBehavior?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#maxPrice
   */
  readonly maxPrice?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#spotInstanceType
   */
  readonly spotInstanceType?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#validUntil
   */
  readonly validUntil?: Date;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDurationMinutes': obj.blockDurationMinutes,
    'instanceInterruptionBehavior': obj.instanceInterruptionBehavior,
    'maxPrice': obj.maxPrice,
    'spotInstanceType': obj.spotInstanceType,
    'validUntil': obj.validUntil?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set Max to 0.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of total accelerator memory, in MiB.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of memory per vCPU, in GiB.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of memory, in MiB.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
 * Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of network interfaces.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of total local storage, in GB.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of vCPUs.
 *
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount(obj: LaunchTemplateSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes#ipv4Prefix
   */
  readonly ipv4Prefix?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes(obj: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4Prefix': obj.ipv4Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses#ipv6Address
   */
  readonly ipv6Address?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses(obj: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Address': obj.ipv6Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes#ipv6Prefix
   */
  readonly ipv6Prefix?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes(obj: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Prefix': obj.ipv6Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses#privateIPAddress
   */
  readonly privateIpAddress?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses(obj: LaunchTemplateSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'privateIPAddress': obj.privateIpAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags
 */
export interface LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags {
  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags(obj: LaunchTemplateSpecForProviderLaunchTemplateDataTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LaunchTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LaunchTemplateVersion is the Schema for the LaunchTemplateVersions API
 *
 * @schema LaunchTemplateVersion
 */
export class LaunchTemplateVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LaunchTemplateVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'LaunchTemplateVersion',
  }

  /**
   * Renders a Kubernetes manifest for "LaunchTemplateVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LaunchTemplateVersionProps): any {
    return {
      ...LaunchTemplateVersion.GVK,
      ...toJson_LaunchTemplateVersionProps(props),
    };
  }

  /**
   * Defines a "LaunchTemplateVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LaunchTemplateVersionProps) {
    super(scope, id, {
      ...LaunchTemplateVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LaunchTemplateVersion.GVK,
      ...toJson_LaunchTemplateVersionProps(resolved),
    };
  }
}

/**
 * LaunchTemplateVersion is the Schema for the LaunchTemplateVersions API
 *
 * @schema LaunchTemplateVersion
 */
export interface LaunchTemplateVersionProps {
  /**
   * @schema LaunchTemplateVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LaunchTemplateVersionSpec defines the desired state of LaunchTemplateVersion
   *
   * @schema LaunchTemplateVersion#spec
   */
  readonly spec: LaunchTemplateVersionSpec;

}

/**
 * Converts an object of type 'LaunchTemplateVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionProps(obj: LaunchTemplateVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LaunchTemplateVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateVersionSpec defines the desired state of LaunchTemplateVersion
 *
 * @schema LaunchTemplateVersionSpec
 */
export interface LaunchTemplateVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LaunchTemplateVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: LaunchTemplateVersionSpecDeletionPolicy;

  /**
   * LaunchTemplateVersionParameters defines the desired state of LaunchTemplateVersion
   *
   * @schema LaunchTemplateVersionSpec#forProvider
   */
  readonly forProvider: LaunchTemplateVersionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LaunchTemplateVersionSpec#managementPolicies
   */
  readonly managementPolicies?: LaunchTemplateVersionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LaunchTemplateVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: LaunchTemplateVersionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LaunchTemplateVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LaunchTemplateVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LaunchTemplateVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LaunchTemplateVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpec(obj: LaunchTemplateVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LaunchTemplateVersionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LaunchTemplateVersionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LaunchTemplateVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LaunchTemplateVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LaunchTemplateVersionSpecDeletionPolicy
 */
export enum LaunchTemplateVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * LaunchTemplateVersionParameters defines the desired state of LaunchTemplateVersion
 *
 * @schema LaunchTemplateVersionSpecForProvider
 */
export interface LaunchTemplateVersionSpecForProvider {
  /**
   * The information for the launch template.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateData
   */
  readonly launchTemplateData: LaunchTemplateVersionSpecForProviderLaunchTemplateData;

  /**
   * The ID of the Launch Template. You must specify this parameter in the request.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateId
   */
  readonly launchTemplateId?: string;

  /**
   * LaunchTemplateIDRef is a reference to an API used to set the LaunchTemplateID.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateIdRef
   */
  readonly launchTemplateIdRef?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef;

  /**
   * LaunchTemplateIDSelector selects references to API used to set the LaunchTemplateID.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateIdSelector
   */
  readonly launchTemplateIdSelector?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector;

  /**
   * The Name of the Launch Template. You must specify this parameter in the request.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * LaunchTemplateNameRef is a reference to an API used to set the LaunchTemplateName.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateNameRef
   */
  readonly launchTemplateNameRef?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef;

  /**
   * LaunchTemplateNameSelector selects references to API used to set the LaunchTemplateName.
   *
   * @schema LaunchTemplateVersionSpecForProvider#launchTemplateNameSelector
   */
  readonly launchTemplateNameSelector?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector;

  /**
   * Region is which region the LaunchTemplateVersion will be created.
   *
   * @schema LaunchTemplateVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * If true, and if a Systems Manager parameter is specified for ImageId, the AMI ID is displayed in the response for imageID. For more information, see Use a Systems Manager parameter instead of an AMI ID (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#use-an-ssm-parameter-instead-of-an-ami-id) in the Amazon Elastic Compute Cloud User Guide.
   * Default: false
   *
   * @schema LaunchTemplateVersionSpecForProvider#resolveAlias
   */
  readonly resolveAlias?: boolean;

  /**
   * The version number of the launch template version on which to base the new version. The new version inherits the same launch parameters as the source version, except for parameters that you specify in LaunchTemplateData. Snapshots applied to the block device mapping are ignored when creating a new version unless they are explicitly included.
   *
   * @schema LaunchTemplateVersionSpecForProvider#sourceVersion
   */
  readonly sourceVersion?: string;

  /**
   * A description for the version of the launch template.
   *
   * @schema LaunchTemplateVersionSpecForProvider#versionDescription
   */
  readonly versionDescription?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProvider(obj: LaunchTemplateVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateData': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateData(obj.launchTemplateData),
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateIdRef': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef(obj.launchTemplateIdRef),
    'launchTemplateIdSelector': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector(obj.launchTemplateIdSelector),
    'launchTemplateName': obj.launchTemplateName,
    'launchTemplateNameRef': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef(obj.launchTemplateNameRef),
    'launchTemplateNameSelector': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector(obj.launchTemplateNameSelector),
    'region': obj.region,
    'resolveAlias': obj.resolveAlias,
    'sourceVersion': obj.sourceVersion,
    'versionDescription': obj.versionDescription,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LaunchTemplateVersionSpecManagementPolicies
 */
export enum LaunchTemplateVersionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LaunchTemplateVersionSpecProviderConfigRef
 */
export interface LaunchTemplateVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateVersionSpecProviderConfigRef#policy
   */
  readonly policy?: LaunchTemplateVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecProviderConfigRef(obj: LaunchTemplateVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsTo
 */
export interface LaunchTemplateVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecPublishConnectionDetailsTo(obj: LaunchTemplateVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LaunchTemplateVersionSpecWriteConnectionSecretToRef
 */
export interface LaunchTemplateVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LaunchTemplateVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LaunchTemplateVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecWriteConnectionSecretToRef(obj: LaunchTemplateVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The information for the launch template.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateData {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#blockDeviceMappings
   */
  readonly blockDeviceMappings?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings[];

  /**
   * Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the CapacityReservationPreference parameter to configure the instance to run in On-Demand capacity or to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the CapacityReservationTarget parameter to explicitly target a specific Capacity Reservation or a Capacity Reservation group.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#capacityReservationSpecification
   */
  readonly capacityReservationSpecification?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification;

  /**
   * The CPU options for the instance. Both the core count and threads per core must be specified in the request.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#cpuOptions
   */
  readonly cpuOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions;

  /**
   * The credit option for CPU usage of a T instance.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#creditSpecification
   */
  readonly creditSpecification?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#disableAPIStop
   */
  readonly disableApiStop?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#disableAPITermination
   */
  readonly disableApiTermination?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#elasticGPUSpecifications
   */
  readonly elasticGpuSpecifications?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#elasticInferenceAccelerators
   */
  readonly elasticInferenceAccelerators?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators[];

  /**
   * Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the Amazon Web Services Nitro Enclaves User Guide.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#enclaveOptions
   */
  readonly enclaveOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions;

  /**
   * Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html).
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#hibernationOptions
   */
  readonly hibernationOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions;

  /**
   * An IAM instance profile.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#iamInstanceProfile
   */
  readonly iamInstanceProfile?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#imageID
   */
  readonly imageId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#instanceInitiatedShutdownBehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The market (purchasing) option for the instances.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#instanceMarketOptions
   */
  readonly instanceMarketOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions;

  /**
   * The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
   * You must specify VCpuCount and MemoryMiB. All other attributes are optional. Any unspecified optional attribute is set to its default.
   * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
   * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
   * * AllowedInstanceTypes - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
   * * ExcludedInstanceTypes - The instance types to exclude from the list, even if they match your specified attributes.
   * If you specify InstanceRequirements, you can't specify InstanceType.
   * Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the launch instance wizard (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or AWS::EC2::Instance (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) Amazon Web Services CloudFormation resource, you can't specify InstanceRequirements.
   * For more information, see Attribute-based instance type selection for EC2 Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#instanceRequirements
   */
  readonly instanceRequirements?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#instanceType
   */
  readonly instanceType?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#kernelID
   */
  readonly kernelId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#keyName
   */
  readonly keyName?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#licenseSpecifications
   */
  readonly licenseSpecifications?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications[];

  /**
   * The maintenance options of your instance.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#maintenanceOptions
   */
  readonly maintenanceOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions;

  /**
   * The metadata options for the instance. For more information, see Instance metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#metadataOptions
   */
  readonly metadataOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions;

  /**
   * Describes the monitoring for the instance.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#monitoring
   */
  readonly monitoring?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#networkInterfaces
   */
  readonly networkInterfaces?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces[];

  /**
   * Describes the placement of an instance.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#placement
   */
  readonly placement?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement;

  /**
   * Describes the options for instance hostnames.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#privateDNSNameOptions
   */
  readonly privateDnsNameOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#ramDiskID
   */
  readonly ramDiskId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#tagSpecifications
   */
  readonly tagSpecifications?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateData#userData
   */
  readonly userData?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateData(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMappings': obj.blockDeviceMappings?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings(y)),
    'capacityReservationSpecification': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification(obj.capacityReservationSpecification),
    'cpuOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions(obj.cpuOptions),
    'creditSpecification': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification(obj.creditSpecification),
    'disableAPIStop': obj.disableApiStop,
    'disableAPITermination': obj.disableApiTermination,
    'ebsOptimized': obj.ebsOptimized,
    'elasticGPUSpecifications': obj.elasticGpuSpecifications?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications(y)),
    'elasticInferenceAccelerators': obj.elasticInferenceAccelerators?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators(y)),
    'enclaveOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions(obj.enclaveOptions),
    'hibernationOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions(obj.hibernationOptions),
    'iamInstanceProfile': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile(obj.iamInstanceProfile),
    'imageID': obj.imageId,
    'instanceInitiatedShutdownBehavior': obj.instanceInitiatedShutdownBehavior,
    'instanceMarketOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions(obj.instanceMarketOptions),
    'instanceRequirements': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements(obj.instanceRequirements),
    'instanceType': obj.instanceType,
    'kernelID': obj.kernelId,
    'keyName': obj.keyName,
    'licenseSpecifications': obj.licenseSpecifications?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications(y)),
    'maintenanceOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions(obj.maintenanceOptions),
    'metadataOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions(obj.metadataOptions),
    'monitoring': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring(obj.monitoring),
    'networkInterfaces': obj.networkInterfaces?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces(y)),
    'placement': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement(obj.placement),
    'privateDNSNameOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions(obj.privateDnsNameOptions),
    'ramDiskID': obj.ramDiskId,
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'securityGroups': obj.securityGroups?.map(y => y),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications(y)),
    'userData': obj.userData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateIDRef is a reference to an API used to set the LaunchTemplateID.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef#policy
   */
  readonly policy?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateIDSelector selects references to API used to set the LaunchTemplateID.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector#policy
   */
  readonly policy?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateNameRef is a reference to an API used to set the LaunchTemplateName.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef#policy
   */
  readonly policy?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchTemplateNameSelector selects references to API used to set the LaunchTemplateName.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector#policy
   */
  readonly policy?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateVersionSpecProviderConfigRefPolicy
 */
export interface LaunchTemplateVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecProviderConfigRefPolicy(obj: LaunchTemplateVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef(obj: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata
 */
export interface LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata(obj: LaunchTemplateVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings#deviceName
   */
  readonly deviceName?: string;

  /**
   * The parameters for a block device for an EBS volume.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings#ebs
   */
  readonly ebs?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings#noDevice
   */
  readonly noDevice?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs(obj.ebs),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the CapacityReservationPreference parameter to configure the instance to run in On-Demand capacity or to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the CapacityReservationTarget parameter to explicitly target a specific Capacity Reservation or a Capacity Reservation group.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification#capacityReservationPreference
   */
  readonly capacityReservationPreference?: string;

  /**
   * Describes a target Capacity Reservation or Capacity Reservation group.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification#capacityReservationTarget
   */
  readonly capacityReservationTarget?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationPreference': obj.capacityReservationPreference,
    'capacityReservationTarget': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget(obj.capacityReservationTarget),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CPU options for the instance. Both the core count and threads per core must be specified in the request.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions#amdSevSnp
   */
  readonly amdSevSnp?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions#coreCount
   */
  readonly coreCount?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions#threadsPerCore
   */
  readonly threadsPerCore?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCpuOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amdSevSnp': obj.amdSevSnp,
    'coreCount': obj.coreCount,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credit option for CPU usage of a T instance.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification#cpuCredits
   */
  readonly cpuCredits?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCreditSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuCredits': obj.cpuCredits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticGpuSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators#count
   */
  readonly count?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators#type_
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataElasticInferenceAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'type_': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the Amazon Web Services Nitro Enclaves User Guide.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataEnclaveOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html).
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions#configured
   */
  readonly configured?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataHibernationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configured': obj.configured,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An IAM instance profile.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile#arn
   */
  readonly arn?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataIamInstanceProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The market (purchasing) option for the instances.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions#marketType
   */
  readonly marketType?: string;

  /**
   * The options for Spot Instances.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions#spotOptions
   */
  readonly spotOptions?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'marketType': obj.marketType,
    'spotOptions': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions(obj.spotOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
 * You must specify VCpuCount and MemoryMiB. All other attributes are optional. Any unspecified optional attribute is set to its default.
 * When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
 * To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
 * * AllowedInstanceTypes - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
 * * ExcludedInstanceTypes - The instance types to exclude from the list, even if they match your specified attributes.
 * If you specify InstanceRequirements, you can't specify InstanceType.
 * Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the launch instance wizard (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the RunInstances (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or AWS::EC2::Instance (https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) Amazon Web Services CloudFormation resource, you can't specify InstanceRequirements.
 * For more information, see Attribute-based instance type selection for EC2 Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements {
  /**
   * The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set Max to 0.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorCount
   */
  readonly acceleratorCount?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorManufacturers
   */
  readonly acceleratorManufacturers?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorNames
   */
  readonly acceleratorNames?: string[];

  /**
   * The minimum and maximum amount of total accelerator memory, in MiB.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorTotalMemoryMiB
   */
  readonly acceleratorTotalMemoryMiB?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#allowedInstanceTypes
   */
  readonly allowedInstanceTypes?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#bareMetal
   */
  readonly bareMetal?: string;

  /**
   * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#baselineEBSBandwidthMbps
   */
  readonly baselineEbsBandwidthMbps?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#burstablePerformance
   */
  readonly burstablePerformance?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#cpuManufacturers
   */
  readonly cpuManufacturers?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#excludedInstanceTypes
   */
  readonly excludedInstanceTypes?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#instanceGenerations
   */
  readonly instanceGenerations?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#localStorage
   */
  readonly localStorage?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#localStorageTypes
   */
  readonly localStorageTypes?: string[];

  /**
   * The minimum and maximum amount of memory per vCPU, in GiB.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#memoryGiBPerVCPU
   */
  readonly memoryGiBPerVcpu?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu;

  /**
   * The minimum and maximum amount of memory, in MiB.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#memoryMiB
   */
  readonly memoryMiB?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB;

  /**
   * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
   * Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the Amazon EC2 User Guide.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#networkBandwidthGbps
   */
  readonly networkBandwidthGbps?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps;

  /**
   * The minimum and maximum number of network interfaces.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#networkInterfaceCount
   */
  readonly networkInterfaceCount?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#onDemandMaxPricePercentageOverLowestPrice
   */
  readonly onDemandMaxPricePercentageOverLowestPrice?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#requireHibernateSupport
   */
  readonly requireHibernateSupport?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#spotMaxPricePercentageOverLowestPrice
   */
  readonly spotMaxPricePercentageOverLowestPrice?: number;

  /**
   * The minimum and maximum amount of total local storage, in GB.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#totalLocalStorageGB
   */
  readonly totalLocalStorageGb?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb;

  /**
   * The minimum and maximum number of vCPUs.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements#vCPUCount
   */
  readonly vCpuCount?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorCount': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount(obj.acceleratorCount),
    'acceleratorManufacturers': obj.acceleratorManufacturers?.map(y => y),
    'acceleratorNames': obj.acceleratorNames?.map(y => y),
    'acceleratorTotalMemoryMiB': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB(obj.acceleratorTotalMemoryMiB),
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'allowedInstanceTypes': obj.allowedInstanceTypes?.map(y => y),
    'bareMetal': obj.bareMetal,
    'baselineEBSBandwidthMbps': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps(obj.baselineEbsBandwidthMbps),
    'burstablePerformance': obj.burstablePerformance,
    'cpuManufacturers': obj.cpuManufacturers?.map(y => y),
    'excludedInstanceTypes': obj.excludedInstanceTypes?.map(y => y),
    'instanceGenerations': obj.instanceGenerations?.map(y => y),
    'localStorage': obj.localStorage,
    'localStorageTypes': obj.localStorageTypes?.map(y => y),
    'memoryGiBPerVCPU': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu(obj.memoryGiBPerVcpu),
    'memoryMiB': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB(obj.memoryMiB),
    'networkBandwidthGbps': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps(obj.networkBandwidthGbps),
    'networkInterfaceCount': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount(obj.networkInterfaceCount),
    'onDemandMaxPricePercentageOverLowestPrice': obj.onDemandMaxPricePercentageOverLowestPrice,
    'requireHibernateSupport': obj.requireHibernateSupport,
    'spotMaxPricePercentageOverLowestPrice': obj.spotMaxPricePercentageOverLowestPrice,
    'totalLocalStorageGB': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb(obj.totalLocalStorageGb),
    'vCPUCount': toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount(obj.vCpuCount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications#licenseConfigurationARN
   */
  readonly licenseConfigurationArn?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataLicenseSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseConfigurationARN': obj.licenseConfigurationArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maintenance options of your instance.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions#autoRecovery
   */
  readonly autoRecovery?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMaintenanceOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRecovery': obj.autoRecovery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The metadata options for the instance. For more information, see Instance metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon Elastic Compute Cloud User Guide.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions#httpEndpoint
   */
  readonly httpEndpoint?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions#httpProtocolIPv6
   */
  readonly httpProtocolIPv6?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions#instanceMetadataTags
   */
  readonly instanceMetadataTags?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpoint': obj.httpEndpoint,
    'httpProtocolIPv6': obj.httpProtocolIPv6,
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
    'instanceMetadataTags': obj.instanceMetadataTags,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the monitoring for the instance.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#associateCarrierIPAddress
   */
  readonly associateCarrierIpAddress?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#associatePublicIPAddress
   */
  readonly associatePublicIpAddress?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#description
   */
  readonly description?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#deviceIndex
   */
  readonly deviceIndex?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#groups
   */
  readonly groups?: string[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#interfaceType
   */
  readonly interfaceType?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv4PrefixCount
   */
  readonly ipv4PrefixCount?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv4Prefixes
   */
  readonly ipv4Prefixes?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6AddressCount
   */
  readonly ipv6AddressCount?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6Addresses
   */
  readonly ipv6Addresses?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6PrefixCount
   */
  readonly ipv6PrefixCount?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#ipv6Prefixes
   */
  readonly ipv6Prefixes?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#networkCardIndex
   */
  readonly networkCardIndex?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#networkInterfaceID
   */
  readonly networkInterfaceId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#primaryIPv6
   */
  readonly primaryIPv6?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#privateIPAddress
   */
  readonly privateIpAddress?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#privateIPAddresses
   */
  readonly privateIpAddresses?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses[];

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#secondaryPrivateIPAddressCount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces#subnetID
   */
  readonly subnetId?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associateCarrierIPAddress': obj.associateCarrierIpAddress,
    'associatePublicIPAddress': obj.associatePublicIpAddress,
    'deleteOnTermination': obj.deleteOnTermination,
    'description': obj.description,
    'deviceIndex': obj.deviceIndex,
    'groups': obj.groups?.map(y => y),
    'interfaceType': obj.interfaceType,
    'ipv4PrefixCount': obj.ipv4PrefixCount,
    'ipv4Prefixes': obj.ipv4Prefixes?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes(y)),
    'ipv6AddressCount': obj.ipv6AddressCount,
    'ipv6Addresses': obj.ipv6Addresses?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses(y)),
    'ipv6PrefixCount': obj.ipv6PrefixCount,
    'ipv6Prefixes': obj.ipv6Prefixes?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes(y)),
    'networkCardIndex': obj.networkCardIndex,
    'networkInterfaceID': obj.networkInterfaceId,
    'primaryIPv6': obj.primaryIPv6,
    'privateIPAddress': obj.privateIpAddress,
    'privateIPAddresses': obj.privateIpAddresses?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses(y)),
    'secondaryPrivateIPAddressCount': obj.secondaryPrivateIpAddressCount,
    'subnetID': obj.subnetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the placement of an instance.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#affinity
   */
  readonly affinity?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#groupID
   */
  readonly groupId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#groupName
   */
  readonly groupName?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#hostID
   */
  readonly hostId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#hostResourceGroupARN
   */
  readonly hostResourceGroupArn?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#partitionNumber
   */
  readonly partitionNumber?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#spreadDomain
   */
  readonly spreadDomain?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement#tenancy
   */
  readonly tenancy?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'availabilityZone': obj.availabilityZone,
    'groupID': obj.groupId,
    'groupName': obj.groupName,
    'hostID': obj.hostId,
    'hostResourceGroupARN': obj.hostResourceGroupArn,
    'partitionNumber': obj.partitionNumber,
    'spreadDomain': obj.spreadDomain,
    'tenancy': obj.tenancy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the options for instance hostnames.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#enableResourceNameDNSAAAARecord
   */
  readonly enableResourceNameDnsaaaaRecord?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#enableResourceNameDNSARecord
   */
  readonly enableResourceNameDnsaRecord?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions#hostnameType
   */
  readonly hostnameType?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataPrivateDnsNameOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableResourceNameDNSAAAARecord': obj.enableResourceNameDnsaaaaRecord,
    'enableResourceNameDNSARecord': obj.enableResourceNameDnsaRecord,
    'hostnameType': obj.hostnameType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications#tags
   */
  readonly tags?: LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags[];

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecProviderConfigRefPolicyResolution
 */
export enum LaunchTemplateVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecProviderConfigRefPolicyResolve
 */
export enum LaunchTemplateVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The parameters for a block device for an EBS volume.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#iops
   */
  readonly iops?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#snapshotID
   */
  readonly snapshotId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#throughput
   */
  readonly throughput?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataBlockDeviceMappingsEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyID': obj.kmsKeyId,
    'snapshotID': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes a target Capacity Reservation or Capacity Reservation group.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget#capacityReservationID
   */
  readonly capacityReservationId?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget#capacityReservationResourceGroupARN
   */
  readonly capacityReservationResourceGroupArn?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataCapacityReservationSpecificationCapacityReservationTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservationID': obj.capacityReservationId,
    'capacityReservationResourceGroupARN': obj.capacityReservationResourceGroupArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The options for Spot Instances.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#blockDurationMinutes
   */
  readonly blockDurationMinutes?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#instanceInterruptionBehavior
   */
  readonly instanceInterruptionBehavior?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#maxPrice
   */
  readonly maxPrice?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#spotInstanceType
   */
  readonly spotInstanceType?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions#validUntil
   */
  readonly validUntil?: Date;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceMarketOptionsSpotOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDurationMinutes': obj.blockDurationMinutes,
    'instanceInterruptionBehavior': obj.instanceInterruptionBehavior,
    'maxPrice': obj.maxPrice,
    'spotInstanceType': obj.spotInstanceType,
    'validUntil': obj.validUntil?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set Max to 0.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of total accelerator memory, in MiB.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiB | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of memory per vCPU, in GiB.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryGiBPerVcpu | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of memory, in MiB.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsMemoryMiB | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
 * Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the Amazon EC2 User Guide.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkBandwidthGbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of network interfaces.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsNetworkInterfaceCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum amount of total local storage, in GB.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsTotalLocalStorageGb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum number of vCPUs.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount#max
   */
  readonly max?: number;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataInstanceRequirementsVCpuCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes#ipv4Prefix
   */
  readonly ipv4Prefix?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv4Prefixes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4Prefix': obj.ipv4Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses#ipv6Address
   */
  readonly ipv6Address?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Address': obj.ipv6Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes#ipv6Prefix
   */
  readonly ipv6Prefix?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesIpv6Prefixes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv6Prefix': obj.ipv6Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses#privateIPAddress
   */
  readonly privateIpAddress?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataNetworkInterfacesPrivateIpAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'privateIPAddress': obj.privateIpAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags
 */
export interface LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags {
  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags(obj: LaunchTemplateVersionSpecForProviderLaunchTemplateDataTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolution
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolve
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolution
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolve
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolution
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolve
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolution
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolve
 */
export enum LaunchTemplateVersionSpecForProviderLaunchTemplateNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LaunchTemplateVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A NATGateway is a managed resource that represents an AWS VPC NAT Gateway.
 *
 * @schema NATGateway
 */
export class NatGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NATGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'NATGateway',
  }

  /**
   * Renders a Kubernetes manifest for "NATGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NatGatewayProps): any {
    return {
      ...NatGateway.GVK,
      ...toJson_NatGatewayProps(props),
    };
  }

  /**
   * Defines a "NATGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NatGatewayProps) {
    super(scope, id, {
      ...NatGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NatGateway.GVK,
      ...toJson_NatGatewayProps(resolved),
    };
  }
}

/**
 * A NATGateway is a managed resource that represents an AWS VPC NAT Gateway.
 *
 * @schema NATGateway
 */
export interface NatGatewayProps {
  /**
   * @schema NATGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NATGatewaySpec defines the desired state of a NAT Gateway
   *
   * @schema NATGateway#spec
   */
  readonly spec: NatGatewaySpec;

}

/**
 * Converts an object of type 'NatGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewayProps(obj: NatGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NatGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NATGatewaySpec defines the desired state of a NAT Gateway
 *
 * @schema NatGatewaySpec
 */
export interface NatGatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NatGatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: NatGatewaySpecDeletionPolicy;

  /**
   * NATGatewayParameters defined the desired state of an AWS VPC NAT Gateway
   *
   * @schema NatGatewaySpec#forProvider
   */
  readonly forProvider: NatGatewaySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NatGatewaySpec#managementPolicies
   */
  readonly managementPolicies?: NatGatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NatGatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: NatGatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NatGatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NatGatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NatGatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NatGatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NatGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpec(obj: NatGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NatGatewaySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NatGatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NatGatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NatGatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NatGatewaySpecDeletionPolicy
 */
export enum NatGatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * NATGatewayParameters defined the desired state of an AWS VPC NAT Gateway
 *
 * @schema NatGatewaySpecForProvider
 */
export interface NatGatewaySpecForProvider {
  /**
   * AllocationID is the Elastic IP allocation ID
   *
   * @schema NatGatewaySpecForProvider#allocationId
   */
  readonly allocationId?: string;

  /**
   * AllocationIDRef references an EIP and retrieves it's allocation id
   *
   * @schema NatGatewaySpecForProvider#allocationIdRef
   */
  readonly allocationIdRef?: NatGatewaySpecForProviderAllocationIdRef;

  /**
   * AllocationIDSelector references an EIP by selector and retrieves it's allocation id
   *
   * @schema NatGatewaySpecForProvider#allocationIdSelector
   */
  readonly allocationIdSelector?: NatGatewaySpecForProviderAllocationIdSelector;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity. The default is public connectivity.
   *
   * @schema NatGatewaySpecForProvider#connectivityType
   */
  readonly connectivityType?: NatGatewaySpecForProviderConnectivityType;

  /**
   * Region is the region you'd like your NATGateway to be created in.
   *
   * @schema NatGatewaySpecForProvider#region
   */
  readonly region: string;

  /**
   * SubnetID is the subnet the NAT gateways needs to be associated to
   *
   * @schema NatGatewaySpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRef references a subnet and retrives it's subnet id
   *
   * @schema NatGatewaySpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: NatGatewaySpecForProviderSubnetIdRef;

  /**
   * SubnetIDSelector references a subnet by selector and retrives it's subnet id
   *
   * @schema NatGatewaySpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: NatGatewaySpecForProviderSubnetIdSelector;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema NatGatewaySpecForProvider#tags
   */
  readonly tags?: NatGatewaySpecForProviderTags[];

}

/**
 * Converts an object of type 'NatGatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProvider(obj: NatGatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocationId': obj.allocationId,
    'allocationIdRef': toJson_NatGatewaySpecForProviderAllocationIdRef(obj.allocationIdRef),
    'allocationIdSelector': toJson_NatGatewaySpecForProviderAllocationIdSelector(obj.allocationIdSelector),
    'connectivityType': obj.connectivityType,
    'region': obj.region,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_NatGatewaySpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_NatGatewaySpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tags': obj.tags?.map(y => toJson_NatGatewaySpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NatGatewaySpecManagementPolicies
 */
export enum NatGatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NatGatewaySpecProviderConfigRef
 */
export interface NatGatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatGatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatGatewaySpecProviderConfigRef#policy
   */
  readonly policy?: NatGatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecProviderConfigRef(obj: NatGatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatGatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsTo
 */
export interface NatGatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NatGatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NatGatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NatGatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecPublishConnectionDetailsTo(obj: NatGatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NatGatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NatGatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NatGatewaySpecWriteConnectionSecretToRef
 */
export interface NatGatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NatGatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NatGatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NatGatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecWriteConnectionSecretToRef(obj: NatGatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllocationIDRef references an EIP and retrieves it's allocation id
 *
 * @schema NatGatewaySpecForProviderAllocationIdRef
 */
export interface NatGatewaySpecForProviderAllocationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatGatewaySpecForProviderAllocationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatGatewaySpecForProviderAllocationIdRef#policy
   */
  readonly policy?: NatGatewaySpecForProviderAllocationIdRefPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderAllocationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderAllocationIdRef(obj: NatGatewaySpecForProviderAllocationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatGatewaySpecForProviderAllocationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllocationIDSelector references an EIP by selector and retrieves it's allocation id
 *
 * @schema NatGatewaySpecForProviderAllocationIdSelector
 */
export interface NatGatewaySpecForProviderAllocationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NatGatewaySpecForProviderAllocationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NatGatewaySpecForProviderAllocationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NatGatewaySpecForProviderAllocationIdSelector#policy
   */
  readonly policy?: NatGatewaySpecForProviderAllocationIdSelectorPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderAllocationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderAllocationIdSelector(obj: NatGatewaySpecForProviderAllocationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NatGatewaySpecForProviderAllocationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether the NAT gateway supports public or private connectivity. The default is public connectivity.
 *
 * @schema NatGatewaySpecForProviderConnectivityType
 */
export enum NatGatewaySpecForProviderConnectivityType {
  /** public */
  PUBLIC = "public",
  /** private */
  PRIVATE = "private",
}

/**
 * SubnetIDRef references a subnet and retrives it's subnet id
 *
 * @schema NatGatewaySpecForProviderSubnetIdRef
 */
export interface NatGatewaySpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatGatewaySpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatGatewaySpecForProviderSubnetIdRef#policy
   */
  readonly policy?: NatGatewaySpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderSubnetIdRef(obj: NatGatewaySpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatGatewaySpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector references a subnet by selector and retrives it's subnet id
 *
 * @schema NatGatewaySpecForProviderSubnetIdSelector
 */
export interface NatGatewaySpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NatGatewaySpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NatGatewaySpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NatGatewaySpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: NatGatewaySpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderSubnetIdSelector(obj: NatGatewaySpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NatGatewaySpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema NatGatewaySpecForProviderTags
 */
export interface NatGatewaySpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema NatGatewaySpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema NatGatewaySpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderTags(obj: NatGatewaySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatGatewaySpecProviderConfigRefPolicy
 */
export interface NatGatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecProviderConfigRefPolicy(obj: NatGatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface NatGatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NatGatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecPublishConnectionDetailsToConfigRef(obj: NatGatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsToMetadata
 */
export interface NatGatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NatGatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecPublishConnectionDetailsToMetadata(obj: NatGatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatGatewaySpecForProviderAllocationIdRefPolicy
 */
export interface NatGatewaySpecForProviderAllocationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecForProviderAllocationIdRefPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecForProviderAllocationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecForProviderAllocationIdRefPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecForProviderAllocationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderAllocationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderAllocationIdRefPolicy(obj: NatGatewaySpecForProviderAllocationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NatGatewaySpecForProviderAllocationIdSelectorPolicy
 */
export interface NatGatewaySpecForProviderAllocationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecForProviderAllocationIdSelectorPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecForProviderAllocationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecForProviderAllocationIdSelectorPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecForProviderAllocationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderAllocationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderAllocationIdSelectorPolicy(obj: NatGatewaySpecForProviderAllocationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatGatewaySpecForProviderSubnetIdRefPolicy
 */
export interface NatGatewaySpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderSubnetIdRefPolicy(obj: NatGatewaySpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NatGatewaySpecForProviderSubnetIdSelectorPolicy
 */
export interface NatGatewaySpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecForProviderSubnetIdSelectorPolicy(obj: NatGatewaySpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecProviderConfigRefPolicyResolution
 */
export enum NatGatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecProviderConfigRefPolicyResolve
 */
export enum NatGatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: NatGatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecForProviderAllocationIdRefPolicyResolution
 */
export enum NatGatewaySpecForProviderAllocationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecForProviderAllocationIdRefPolicyResolve
 */
export enum NatGatewaySpecForProviderAllocationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecForProviderAllocationIdSelectorPolicyResolution
 */
export enum NatGatewaySpecForProviderAllocationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecForProviderAllocationIdSelectorPolicyResolve
 */
export enum NatGatewaySpecForProviderAllocationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecForProviderSubnetIdRefPolicyResolution
 */
export enum NatGatewaySpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecForProviderSubnetIdRefPolicyResolve
 */
export enum NatGatewaySpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum NatGatewaySpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum NatGatewaySpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NatGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Route is the Schema for the Routes API
 *
 * @schema Route
 */
export class Route extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Route"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'Route',
  }

  /**
   * Renders a Kubernetes manifest for "Route".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteProps): any {
    return {
      ...Route.GVK,
      ...toJson_RouteProps(props),
    };
  }

  /**
   * Defines a "Route" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteProps) {
    super(scope, id, {
      ...Route.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route.GVK,
      ...toJson_RouteProps(resolved),
    };
  }
}

/**
 * Route is the Schema for the Routes API
 *
 * @schema Route
 */
export interface RouteProps {
  /**
   * @schema Route#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteSpec defines the desired state of Route
   *
   * @schema Route#spec
   */
  readonly spec: RouteSpec;

}

/**
 * Converts an object of type 'RouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteProps(obj: RouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteSpec defines the desired state of Route
 *
 * @schema RouteSpec
 */
export interface RouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteSpecDeletionPolicy;

  /**
   * RouteParameters defines the desired state of Route
   *
   * @schema RouteSpec#forProvider
   */
  readonly forProvider: RouteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteSpec#managementPolicies
   */
  readonly managementPolicies?: RouteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpec(obj: RouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteSpecDeletionPolicy
 */
export enum RouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RouteParameters defines the desired state of Route
 *
 * @schema RouteSpecForProvider
 */
export interface RouteSpecForProvider {
  /**
   * The ID of the carrier gateway.
   * You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.
   *
   * @schema RouteSpecForProvider#carrierGatewayID
   */
  readonly carrierGatewayId?: string;

  /**
   * The Amazon Resource Name (ARN) of the core network.
   *
   * @schema RouteSpecForProvider#coreNetworkARN
   */
  readonly coreNetworkArn?: string;

  /**
   * The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify 100.68.0.18/18, we modify it to 100.68.0.0/18.
   *
   * @schema RouteSpecForProvider#destinationCIDRBlock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.
   *
   * @schema RouteSpecForProvider#destinationIPv6CIDRBlock
   */
  readonly destinationIPv6CidrBlock?: string;

  /**
   * The ID of a prefix list used for the destination match.
   *
   * @schema RouteSpecForProvider#destinationPrefixListID
   */
  readonly destinationPrefixListId?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   *
   * @schema RouteSpecForProvider#egressOnlyInternetGatewayID
   */
  readonly egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway attached to your VPC.
   *
   * @schema RouteSpecForProvider#gatewayId
   */
  readonly gatewayId?: string;

  /**
   * GatewayIDRef is a reference to an API used to set the GatewayID.
   *
   * @schema RouteSpecForProvider#gatewayIdRef
   */
  readonly gatewayIdRef?: RouteSpecForProviderGatewayIdRef;

  /**
   * GatewayIDSelector selects references to API used to set the GatewayID.
   *
   * @schema RouteSpecForProvider#gatewayIdSelector
   */
  readonly gatewayIdSelector?: RouteSpecForProviderGatewayIdSelector;

  /**
   * The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
   *
   * @schema RouteSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * InstanceIDRef is a reference to an API used to set the InstanceID.
   *
   * @schema RouteSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: RouteSpecForProviderInstanceIdRef;

  /**
   * InstanceIDSelector selects references to API used to set the InstanceID.
   *
   * @schema RouteSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: RouteSpecForProviderInstanceIdSelector;

  /**
   * The ID of the local gateway.
   *
   * @schema RouteSpecForProvider#localGatewayID
   */
  readonly localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   *
   * @schema RouteSpecForProvider#natGatewayId
   */
  readonly natGatewayId?: string;

  /**
   * NATGatewayIDRef is a reference to an API used to set the NATGatewayID.
   *
   * @schema RouteSpecForProvider#natGatewayIdRef
   */
  readonly natGatewayIdRef?: RouteSpecForProviderNatGatewayIdRef;

  /**
   * NATGatewayIDSelector selects references to API used to set the NATGatewayID.
   *
   * @schema RouteSpecForProvider#natGatewayIdSelector
   */
  readonly natGatewayIdSelector?: RouteSpecForProviderNatGatewayIdSelector;

  /**
   * The ID of a network interface.
   *
   * @schema RouteSpecForProvider#networkInterfaceID
   */
  readonly networkInterfaceId?: string;

  /**
   * Region is which region the Route will be created.
   *
   * @schema RouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the route table for the route. provider-aws currently provides both a standalone Route resource and a RouteTable resource with routes defined in-line. At this time you cannot use a RouteTable with in-line routes in conjunction with any Route resources. Set the flag ignoreRoutes=true in RouteTable to use Route resource
   *
   * @schema RouteSpecForProvider#routeTableId
   */
  readonly routeTableId?: string;

  /**
   * RouteTableIDRef is a reference to an API used to set the RouteTableID.
   *
   * @schema RouteSpecForProvider#routeTableIdRef
   */
  readonly routeTableIdRef?: RouteSpecForProviderRouteTableIdRef;

  /**
   * RouteTableIDSelector selects references to API used to set the RouteTableID.
   *
   * @schema RouteSpecForProvider#routeTableIdSelector
   */
  readonly routeTableIdSelector?: RouteSpecForProviderRouteTableIdSelector;

  /**
   * The ID of a transit gateway.
   *
   * @schema RouteSpecForProvider#transitGatewayId
   */
  readonly transitGatewayId?: string;

  /**
   * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
   *
   * @schema RouteSpecForProvider#transitGatewayIdRef
   */
  readonly transitGatewayIdRef?: RouteSpecForProviderTransitGatewayIdRef;

  /**
   * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
   *
   * @schema RouteSpecForProvider#transitGatewayIdSelector
   */
  readonly transitGatewayIdSelector?: RouteSpecForProviderTransitGatewayIdSelector;

  /**
   * The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
   *
   * @schema RouteSpecForProvider#vpcEndpointID
   */
  readonly vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @schema RouteSpecForProvider#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

  /**
   * VPCPeeringConnectionIDRef is a reference to an API used to set the VPCPeeringConnectionID.
   *
   * @schema RouteSpecForProvider#vpcPeeringConnectionIdRef
   */
  readonly vpcPeeringConnectionIdRef?: RouteSpecForProviderVpcPeeringConnectionIdRef;

  /**
   * VPCPeeringConnectionIDSelector selects references to API used to set the VPCPeeringConnectionID.
   *
   * @schema RouteSpecForProvider#vpcPeeringConnectionIdSelector
   */
  readonly vpcPeeringConnectionIdSelector?: RouteSpecForProviderVpcPeeringConnectionIdSelector;

}

/**
 * Converts an object of type 'RouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProvider(obj: RouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'carrierGatewayID': obj.carrierGatewayId,
    'coreNetworkARN': obj.coreNetworkArn,
    'destinationCIDRBlock': obj.destinationCidrBlock,
    'destinationIPv6CIDRBlock': obj.destinationIPv6CidrBlock,
    'destinationPrefixListID': obj.destinationPrefixListId,
    'egressOnlyInternetGatewayID': obj.egressOnlyInternetGatewayId,
    'gatewayId': obj.gatewayId,
    'gatewayIdRef': toJson_RouteSpecForProviderGatewayIdRef(obj.gatewayIdRef),
    'gatewayIdSelector': toJson_RouteSpecForProviderGatewayIdSelector(obj.gatewayIdSelector),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_RouteSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_RouteSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'localGatewayID': obj.localGatewayId,
    'natGatewayId': obj.natGatewayId,
    'natGatewayIdRef': toJson_RouteSpecForProviderNatGatewayIdRef(obj.natGatewayIdRef),
    'natGatewayIdSelector': toJson_RouteSpecForProviderNatGatewayIdSelector(obj.natGatewayIdSelector),
    'networkInterfaceID': obj.networkInterfaceId,
    'region': obj.region,
    'routeTableId': obj.routeTableId,
    'routeTableIdRef': toJson_RouteSpecForProviderRouteTableIdRef(obj.routeTableIdRef),
    'routeTableIdSelector': toJson_RouteSpecForProviderRouteTableIdSelector(obj.routeTableIdSelector),
    'transitGatewayId': obj.transitGatewayId,
    'transitGatewayIdRef': toJson_RouteSpecForProviderTransitGatewayIdRef(obj.transitGatewayIdRef),
    'transitGatewayIdSelector': toJson_RouteSpecForProviderTransitGatewayIdSelector(obj.transitGatewayIdSelector),
    'vpcEndpointID': obj.vpcEndpointId,
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
    'vpcPeeringConnectionIdRef': toJson_RouteSpecForProviderVpcPeeringConnectionIdRef(obj.vpcPeeringConnectionIdRef),
    'vpcPeeringConnectionIdSelector': toJson_RouteSpecForProviderVpcPeeringConnectionIdSelector(obj.vpcPeeringConnectionIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteSpecManagementPolicies
 */
export enum RouteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteSpecProviderConfigRef
 */
export interface RouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecProviderConfigRef#policy
   */
  readonly policy?: RouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRef(obj: RouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteSpecPublishConnectionDetailsTo
 */
export interface RouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsTo(obj: RouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteSpecWriteConnectionSecretToRef
 */
export interface RouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecWriteConnectionSecretToRef(obj: RouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayIDRef is a reference to an API used to set the GatewayID.
 *
 * @schema RouteSpecForProviderGatewayIdRef
 */
export interface RouteSpecForProviderGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderGatewayIdRef#policy
   */
  readonly policy?: RouteSpecForProviderGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderGatewayIdRef(obj: RouteSpecForProviderGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayIDSelector selects references to API used to set the GatewayID.
 *
 * @schema RouteSpecForProviderGatewayIdSelector
 */
export interface RouteSpecForProviderGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderGatewayIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderGatewayIdSelector(obj: RouteSpecForProviderGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceIDRef is a reference to an API used to set the InstanceID.
 *
 * @schema RouteSpecForProviderInstanceIdRef
 */
export interface RouteSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: RouteSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderInstanceIdRef(obj: RouteSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceIDSelector selects references to API used to set the InstanceID.
 *
 * @schema RouteSpecForProviderInstanceIdSelector
 */
export interface RouteSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderInstanceIdSelector(obj: RouteSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NATGatewayIDRef is a reference to an API used to set the NATGatewayID.
 *
 * @schema RouteSpecForProviderNatGatewayIdRef
 */
export interface RouteSpecForProviderNatGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderNatGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderNatGatewayIdRef#policy
   */
  readonly policy?: RouteSpecForProviderNatGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderNatGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderNatGatewayIdRef(obj: RouteSpecForProviderNatGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderNatGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NATGatewayIDSelector selects references to API used to set the NATGatewayID.
 *
 * @schema RouteSpecForProviderNatGatewayIdSelector
 */
export interface RouteSpecForProviderNatGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderNatGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderNatGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderNatGatewayIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderNatGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderNatGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderNatGatewayIdSelector(obj: RouteSpecForProviderNatGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderNatGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteTableIDRef is a reference to an API used to set the RouteTableID.
 *
 * @schema RouteSpecForProviderRouteTableIdRef
 */
export interface RouteSpecForProviderRouteTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderRouteTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderRouteTableIdRef#policy
   */
  readonly policy?: RouteSpecForProviderRouteTableIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderRouteTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRouteTableIdRef(obj: RouteSpecForProviderRouteTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderRouteTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteTableIDSelector selects references to API used to set the RouteTableID.
 *
 * @schema RouteSpecForProviderRouteTableIdSelector
 */
export interface RouteSpecForProviderRouteTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderRouteTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderRouteTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderRouteTableIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderRouteTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderRouteTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRouteTableIdSelector(obj: RouteSpecForProviderRouteTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderRouteTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
 *
 * @schema RouteSpecForProviderTransitGatewayIdRef
 */
export interface RouteSpecForProviderTransitGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderTransitGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderTransitGatewayIdRef#policy
   */
  readonly policy?: RouteSpecForProviderTransitGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTransitGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTransitGatewayIdRef(obj: RouteSpecForProviderTransitGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderTransitGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
 *
 * @schema RouteSpecForProviderTransitGatewayIdSelector
 */
export interface RouteSpecForProviderTransitGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderTransitGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderTransitGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderTransitGatewayIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderTransitGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTransitGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTransitGatewayIdSelector(obj: RouteSpecForProviderTransitGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderTransitGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCPeeringConnectionIDRef is a reference to an API used to set the VPCPeeringConnectionID.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdRef
 */
export interface RouteSpecForProviderVpcPeeringConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdRef#policy
   */
  readonly policy?: RouteSpecForProviderVpcPeeringConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderVpcPeeringConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVpcPeeringConnectionIdRef(obj: RouteSpecForProviderVpcPeeringConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderVpcPeeringConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCPeeringConnectionIDSelector selects references to API used to set the VPCPeeringConnectionID.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdSelector
 */
export interface RouteSpecForProviderVpcPeeringConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderVpcPeeringConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVpcPeeringConnectionIdSelector(obj: RouteSpecForProviderVpcPeeringConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecProviderConfigRefPolicy
 */
export interface RouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRefPolicy(obj: RouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj: RouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteSpecPublishConnectionDetailsToMetadata
 */
export interface RouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToMetadata(obj: RouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderGatewayIdRefPolicy
 */
export interface RouteSpecForProviderGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderGatewayIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderGatewayIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderGatewayIdRefPolicy(obj: RouteSpecForProviderGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderGatewayIdSelectorPolicy
 */
export interface RouteSpecForProviderGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderGatewayIdSelectorPolicy(obj: RouteSpecForProviderGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderInstanceIdRefPolicy
 */
export interface RouteSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderInstanceIdRefPolicy(obj: RouteSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderInstanceIdSelectorPolicy
 */
export interface RouteSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderInstanceIdSelectorPolicy(obj: RouteSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderNatGatewayIdRefPolicy
 */
export interface RouteSpecForProviderNatGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderNatGatewayIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderNatGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderNatGatewayIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderNatGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderNatGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderNatGatewayIdRefPolicy(obj: RouteSpecForProviderNatGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderNatGatewayIdSelectorPolicy
 */
export interface RouteSpecForProviderNatGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderNatGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderNatGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderNatGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderNatGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderNatGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderNatGatewayIdSelectorPolicy(obj: RouteSpecForProviderNatGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderRouteTableIdRefPolicy
 */
export interface RouteSpecForProviderRouteTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderRouteTableIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderRouteTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderRouteTableIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderRouteTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderRouteTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRouteTableIdRefPolicy(obj: RouteSpecForProviderRouteTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderRouteTableIdSelectorPolicy
 */
export interface RouteSpecForProviderRouteTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderRouteTableIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderRouteTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderRouteTableIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderRouteTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderRouteTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRouteTableIdSelectorPolicy(obj: RouteSpecForProviderRouteTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderTransitGatewayIdRefPolicy
 */
export interface RouteSpecForProviderTransitGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTransitGatewayIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTransitGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTransitGatewayIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTransitGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTransitGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTransitGatewayIdRefPolicy(obj: RouteSpecForProviderTransitGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderTransitGatewayIdSelectorPolicy
 */
export interface RouteSpecForProviderTransitGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTransitGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTransitGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTransitGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTransitGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTransitGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTransitGatewayIdSelectorPolicy(obj: RouteSpecForProviderTransitGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdRefPolicy
 */
export interface RouteSpecForProviderVpcPeeringConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderVpcPeeringConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVpcPeeringConnectionIdRefPolicy(obj: RouteSpecForProviderVpcPeeringConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy
 */
export interface RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy(obj: RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolution
 */
export enum RouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolve
 */
export enum RouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderGatewayIdRefPolicyResolution
 */
export enum RouteSpecForProviderGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderGatewayIdRefPolicyResolve
 */
export enum RouteSpecForProviderGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderGatewayIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderGatewayIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderInstanceIdRefPolicyResolution
 */
export enum RouteSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderInstanceIdRefPolicyResolve
 */
export enum RouteSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderNatGatewayIdRefPolicyResolution
 */
export enum RouteSpecForProviderNatGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderNatGatewayIdRefPolicyResolve
 */
export enum RouteSpecForProviderNatGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderNatGatewayIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderNatGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderNatGatewayIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderNatGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderRouteTableIdRefPolicyResolution
 */
export enum RouteSpecForProviderRouteTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderRouteTableIdRefPolicyResolve
 */
export enum RouteSpecForProviderRouteTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderRouteTableIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderRouteTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderRouteTableIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderRouteTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTransitGatewayIdRefPolicyResolution
 */
export enum RouteSpecForProviderTransitGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTransitGatewayIdRefPolicyResolve
 */
export enum RouteSpecForProviderTransitGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTransitGatewayIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderTransitGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTransitGatewayIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderTransitGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolution
 */
export enum RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolve
 */
export enum RouteSpecForProviderVpcPeeringConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderVpcPeeringConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A RouteTable is a managed resource that represents an AWS VPC Route Table.
 *
 * @schema RouteTable
 */
export class RouteTable extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RouteTable"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'RouteTable',
  }

  /**
   * Renders a Kubernetes manifest for "RouteTable".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteTableProps): any {
    return {
      ...RouteTable.GVK,
      ...toJson_RouteTableProps(props),
    };
  }

  /**
   * Defines a "RouteTable" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteTableProps) {
    super(scope, id, {
      ...RouteTable.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RouteTable.GVK,
      ...toJson_RouteTableProps(resolved),
    };
  }
}

/**
 * A RouteTable is a managed resource that represents an AWS VPC Route Table.
 *
 * @schema RouteTable
 */
export interface RouteTableProps {
  /**
   * @schema RouteTable#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RouteTableSpec defines the desired state of a RouteTable.
   *
   * @schema RouteTable#spec
   */
  readonly spec: RouteTableSpec;

}

/**
 * Converts an object of type 'RouteTableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableProps(obj: RouteTableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteTableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RouteTableSpec defines the desired state of a RouteTable.
 *
 * @schema RouteTableSpec
 */
export interface RouteTableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteTableSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteTableSpecDeletionPolicy;

  /**
   * RouteTableParameters define the desired state of an AWS VPC Route Table.
   *
   * @schema RouteTableSpec#forProvider
   */
  readonly forProvider: RouteTableSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteTableSpec#managementPolicies
   */
  readonly managementPolicies?: RouteTableSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteTableSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteTableSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteTableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteTableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteTableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteTableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteTableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpec(obj: RouteTableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteTableSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteTableSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteTableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteTableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteTableSpecDeletionPolicy
 */
export enum RouteTableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RouteTableParameters define the desired state of an AWS VPC Route Table.
 *
 * @schema RouteTableSpecForProvider
 */
export interface RouteTableSpecForProvider {
  /**
   * The associations between the route table and one or more subnets.
   *
   * @schema RouteTableSpecForProvider#associations
   */
  readonly associations: RouteTableSpecForProviderAssociations[];

  /**
   * Indicates whether we reconcile inline routes
   *
   * @schema RouteTableSpecForProvider#ignoreRoutes
   */
  readonly ignoreRoutes?: boolean;

  /**
   * Region is the region you'd like your VPC to be created in.
   *
   * @schema RouteTableSpecForProvider#region
   */
  readonly region: string;

  /**
   * inline routes in the route table Deprecated: Routes inline exists for historical compatibility and should not be used. Please use separate route resource.
   *
   * @schema RouteTableSpecForProvider#routes
   */
  readonly routes?: RouteTableSpecForProviderRoutes[];

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema RouteTableSpecForProvider#tags
   */
  readonly tags?: RouteTableSpecForProviderTags[];

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema RouteTableSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to retrieve its vpcId
   *
   * @schema RouteTableSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: RouteTableSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to retrieve its vpcId
   *
   * @schema RouteTableSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: RouteTableSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'RouteTableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProvider(obj: RouteTableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associations': obj.associations?.map(y => toJson_RouteTableSpecForProviderAssociations(y)),
    'ignoreRoutes': obj.ignoreRoutes,
    'region': obj.region,
    'routes': obj.routes?.map(y => toJson_RouteTableSpecForProviderRoutes(y)),
    'tags': obj.tags?.map(y => toJson_RouteTableSpecForProviderTags(y)),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_RouteTableSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_RouteTableSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteTableSpecManagementPolicies
 */
export enum RouteTableSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteTableSpecProviderConfigRef
 */
export interface RouteTableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecProviderConfigRef#policy
   */
  readonly policy?: RouteTableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecProviderConfigRef(obj: RouteTableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteTableSpecPublishConnectionDetailsTo
 */
export interface RouteTableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteTableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteTableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteTableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteTableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteTableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteTableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecPublishConnectionDetailsTo(obj: RouteTableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteTableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteTableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteTableSpecWriteConnectionSecretToRef
 */
export interface RouteTableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteTableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteTableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteTableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecWriteConnectionSecretToRef(obj: RouteTableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Association describes an association between a route table and a subnet.
 *
 * @schema RouteTableSpecForProviderAssociations
 */
export interface RouteTableSpecForProviderAssociations {
  /**
   * The ID of the subnet. A subnet ID is not returned for an implicit association.
   *
   * @schema RouteTableSpecForProviderAssociations#subnetId
   */
  readonly subnetId?: string;

  /**
   * A referencer to retrieve the ID of a subnet
   *
   * @schema RouteTableSpecForProviderAssociations#subnetIdRef
   */
  readonly subnetIdRef?: RouteTableSpecForProviderAssociationsSubnetIdRef;

  /**
   * A selector to select a referencer to retrieve the ID of a subnet
   *
   * @schema RouteTableSpecForProviderAssociations#subnetIdSelector
   */
  readonly subnetIdSelector?: RouteTableSpecForProviderAssociationsSubnetIdSelector;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderAssociations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderAssociations(obj: RouteTableSpecForProviderAssociations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_RouteTableSpecForProviderAssociationsSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_RouteTableSpecForProviderAssociationsSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteBeta describes a route in a route table. provider-aws currently provides both a standalone Route resource and a RouteTable resource with routes defined in-line. At this time you cannot use a Route Table with in-line routes in conjunction with any Route resources. Doing so will cause a conflict of rule settings and will overwrite rules.
 *
 * @schema RouteTableSpecForProviderRoutes
 */
export interface RouteTableSpecForProviderRoutes {
  /**
   * The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.
   *
   * @schema RouteTableSpecForProviderRoutes#destinationCidrBlock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR address block used for the destination match. Routing decisions are based on the most specific match.
   *
   * @schema RouteTableSpecForProviderRoutes#destinationIpv6CidrBlock
   */
  readonly destinationIpv6CidrBlock?: string;

  /**
   * [IPv6 traffic only] The ID of an egress-only internet gateway.
   *
   * @schema RouteTableSpecForProviderRoutes#egressOnlyInternetGatewayId
   */
  readonly egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   *
   * @schema RouteTableSpecForProviderRoutes#gatewayId
   */
  readonly gatewayId?: string;

  /**
   * A referencer to retrieve the ID of a gateway
   *
   * @schema RouteTableSpecForProviderRoutes#gatewayIdRef
   */
  readonly gatewayIdRef?: RouteTableSpecForProviderRoutesGatewayIdRef;

  /**
   * A selector to select a referencer to retrieve the ID of a gateway
   *
   * @schema RouteTableSpecForProviderRoutes#gatewayIdSelector
   */
  readonly gatewayIdSelector?: RouteTableSpecForProviderRoutesGatewayIdSelector;

  /**
   * The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
   *
   * @schema RouteTableSpecForProviderRoutes#instanceId
   */
  readonly instanceId?: string;

  /**
   * The ID of the local gateway.
   *
   * @schema RouteTableSpecForProviderRoutes#localGatewayId
   */
  readonly localGatewayId?: string;

  /**
   * [IPv4 traffic only] The ID of a NAT gateway.
   *
   * @schema RouteTableSpecForProviderRoutes#natGatewayId
   */
  readonly natGatewayId?: string;

  /**
   * A referencer to retrieve the ID of a NAT gateway
   *
   * @schema RouteTableSpecForProviderRoutes#natGatewayIdRef
   */
  readonly natGatewayIdRef?: RouteTableSpecForProviderRoutesNatGatewayIdRef;

  /**
   * A selector to select a referencer to retrieve the ID of a NAT gateway
   *
   * @schema RouteTableSpecForProviderRoutes#natGatewayIdSelector
   */
  readonly natGatewayIdSelector?: RouteTableSpecForProviderRoutesNatGatewayIdSelector;

  /**
   * The ID of a network interface.
   *
   * @schema RouteTableSpecForProviderRoutes#networkInterfaceId
   */
  readonly networkInterfaceId?: string;

  /**
   * The ID of a transit gateway.
   *
   * @schema RouteTableSpecForProviderRoutes#transitGatewayId
   */
  readonly transitGatewayId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @schema RouteTableSpecForProviderRoutes#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutes(obj: RouteTableSpecForProviderRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationCidrBlock': obj.destinationCidrBlock,
    'destinationIpv6CidrBlock': obj.destinationIpv6CidrBlock,
    'egressOnlyInternetGatewayId': obj.egressOnlyInternetGatewayId,
    'gatewayId': obj.gatewayId,
    'gatewayIdRef': toJson_RouteTableSpecForProviderRoutesGatewayIdRef(obj.gatewayIdRef),
    'gatewayIdSelector': toJson_RouteTableSpecForProviderRoutesGatewayIdSelector(obj.gatewayIdSelector),
    'instanceId': obj.instanceId,
    'localGatewayId': obj.localGatewayId,
    'natGatewayId': obj.natGatewayId,
    'natGatewayIdRef': toJson_RouteTableSpecForProviderRoutesNatGatewayIdRef(obj.natGatewayIdRef),
    'natGatewayIdSelector': toJson_RouteTableSpecForProviderRoutesNatGatewayIdSelector(obj.natGatewayIdSelector),
    'networkInterfaceId': obj.networkInterfaceId,
    'transitGatewayId': obj.transitGatewayId,
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema RouteTableSpecForProviderTags
 */
export interface RouteTableSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema RouteTableSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema RouteTableSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderTags(obj: RouteTableSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to retrieve its vpcId
 *
 * @schema RouteTableSpecForProviderVpcIdRef
 */
export interface RouteTableSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecForProviderVpcIdRef#policy
   */
  readonly policy?: RouteTableSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderVpcIdRef(obj: RouteTableSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to retrieve its vpcId
 *
 * @schema RouteTableSpecForProviderVpcIdSelector
 */
export interface RouteTableSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteTableSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteTableSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteTableSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: RouteTableSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderVpcIdSelector(obj: RouteTableSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteTableSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecProviderConfigRefPolicy
 */
export interface RouteTableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecProviderConfigRefPolicy(obj: RouteTableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteTableSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteTableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteTableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecPublishConnectionDetailsToConfigRef(obj: RouteTableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteTableSpecPublishConnectionDetailsToMetadata
 */
export interface RouteTableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteTableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecPublishConnectionDetailsToMetadata(obj: RouteTableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the ID of a subnet
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdRef
 */
export interface RouteTableSpecForProviderAssociationsSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdRef#policy
   */
  readonly policy?: RouteTableSpecForProviderAssociationsSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderAssociationsSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderAssociationsSubnetIdRef(obj: RouteTableSpecForProviderAssociationsSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecForProviderAssociationsSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the ID of a subnet
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdSelector
 */
export interface RouteTableSpecForProviderAssociationsSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdSelector#policy
   */
  readonly policy?: RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderAssociationsSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderAssociationsSubnetIdSelector(obj: RouteTableSpecForProviderAssociationsSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the ID of a gateway
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdRef
 */
export interface RouteTableSpecForProviderRoutesGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdRef#policy
   */
  readonly policy?: RouteTableSpecForProviderRoutesGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesGatewayIdRef(obj: RouteTableSpecForProviderRoutesGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecForProviderRoutesGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the ID of a gateway
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdSelector
 */
export interface RouteTableSpecForProviderRoutesGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdSelector#policy
   */
  readonly policy?: RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesGatewayIdSelector(obj: RouteTableSpecForProviderRoutesGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A referencer to retrieve the ID of a NAT gateway
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdRef
 */
export interface RouteTableSpecForProviderRoutesNatGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdRef#policy
   */
  readonly policy?: RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesNatGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesNatGatewayIdRef(obj: RouteTableSpecForProviderRoutesNatGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A selector to select a referencer to retrieve the ID of a NAT gateway
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelector
 */
export interface RouteTableSpecForProviderRoutesNatGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelector#policy
   */
  readonly policy?: RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesNatGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesNatGatewayIdSelector(obj: RouteTableSpecForProviderRoutesNatGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecForProviderVpcIdRefPolicy
 */
export interface RouteTableSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderVpcIdRefPolicy(obj: RouteTableSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteTableSpecForProviderVpcIdSelectorPolicy
 */
export interface RouteTableSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderVpcIdSelectorPolicy(obj: RouteTableSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecProviderConfigRefPolicyResolution
 */
export enum RouteTableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecProviderConfigRefPolicyResolve
 */
export enum RouteTableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteTableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteTableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdRefPolicy
 */
export interface RouteTableSpecForProviderAssociationsSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderAssociationsSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderAssociationsSubnetIdRefPolicy(obj: RouteTableSpecForProviderAssociationsSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy
 */
export interface RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy(obj: RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdRefPolicy
 */
export interface RouteTableSpecForProviderRoutesGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesGatewayIdRefPolicy(obj: RouteTableSpecForProviderRoutesGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy
 */
export interface RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy(obj: RouteTableSpecForProviderRoutesGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy
 */
export interface RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy(obj: RouteTableSpecForProviderRoutesNatGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy
 */
export interface RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy(obj: RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderVpcIdRefPolicyResolution
 */
export enum RouteTableSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderVpcIdRefPolicyResolve
 */
export enum RouteTableSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum RouteTableSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum RouteTableSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolution
 */
export enum RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolve
 */
export enum RouteTableSpecForProviderAssociationsSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolution
 */
export enum RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolve
 */
export enum RouteTableSpecForProviderAssociationsSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolution
 */
export enum RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolve
 */
export enum RouteTableSpecForProviderRoutesGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolution
 */
export enum RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolve
 */
export enum RouteTableSpecForProviderRoutesGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolution
 */
export enum RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolve
 */
export enum RouteTableSpecForProviderRoutesNatGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolution
 */
export enum RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolve
 */
export enum RouteTableSpecForProviderRoutesNatGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A SecurityGroup is a managed resource that represents an AWS VPC Security Group.
 *
 * @schema SecurityGroup
 */
export class SecurityGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'SecurityGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityGroupProps): any {
    return {
      ...SecurityGroup.GVK,
      ...toJson_SecurityGroupProps(props),
    };
  }

  /**
   * Defines a "SecurityGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityGroupProps) {
    super(scope, id, {
      ...SecurityGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityGroup.GVK,
      ...toJson_SecurityGroupProps(resolved),
    };
  }
}

/**
 * A SecurityGroup is a managed resource that represents an AWS VPC Security Group.
 *
 * @schema SecurityGroup
 */
export interface SecurityGroupProps {
  /**
   * @schema SecurityGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A SecurityGroupSpec defines the desired state of a SecurityGroup.
   *
   * @schema SecurityGroup#spec
   */
  readonly spec: SecurityGroupSpec;

}

/**
 * Converts an object of type 'SecurityGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupProps(obj: SecurityGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecurityGroupSpec defines the desired state of a SecurityGroup.
 *
 * @schema SecurityGroupSpec
 */
export interface SecurityGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityGroupSpecDeletionPolicy;

  /**
   * SecurityGroupParameters define the desired state of an AWS VPC Security Group.
   *
   * @schema SecurityGroupSpec#forProvider
   */
  readonly forProvider: SecurityGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecurityGroupSpec#managementPolicies
   */
  readonly managementPolicies?: SecurityGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpec(obj: SecurityGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecurityGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecurityGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityGroupSpecDeletionPolicy
 */
export enum SecurityGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecurityGroupParameters define the desired state of an AWS VPC Security Group.
 *
 * @schema SecurityGroupSpecForProvider
 */
export interface SecurityGroupSpecForProvider {
  /**
   * A description of the security group.
   *
   * @schema SecurityGroupSpecForProvider#description
   */
  readonly description: string;

  /**
   * [EC2-VPC] One or more outbound rules associated with the security group.
   *
   * @schema SecurityGroupSpecForProvider#egress
   */
  readonly egress?: SecurityGroupSpecForProviderEgress[];

  /**
   * The name of the security group.
   *
   * @schema SecurityGroupSpecForProvider#groupName
   */
  readonly groupName: string;

  /**
   * Dont manage the egress settings for the created resource
   *
   * @schema SecurityGroupSpecForProvider#ignoreEgress
   */
  readonly ignoreEgress?: boolean;

  /**
   * Dont manage the ingress settings for the created resource
   *
   * @schema SecurityGroupSpecForProvider#ignoreIngress
   */
  readonly ignoreIngress?: boolean;

  /**
   * One or more inbound rules associated with the security group.
   *
   * @schema SecurityGroupSpecForProvider#ingress
   */
  readonly ingress?: SecurityGroupSpecForProviderIngress[];

  /**
   * Region is the region you'd like your SecurityGroup to be created in.
   *
   * @schema SecurityGroupSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema SecurityGroupSpecForProvider#tags
   */
  readonly tags?: SecurityGroupSpecForProviderTags[];

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema SecurityGroupSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to and retrieves its vpcId
   *
   * @schema SecurityGroupSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
   *
   * @schema SecurityGroupSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProvider(obj: SecurityGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_SecurityGroupSpecForProviderEgress(y)),
    'groupName': obj.groupName,
    'ignoreEgress': obj.ignoreEgress,
    'ignoreIngress': obj.ignoreIngress,
    'ingress': obj.ingress?.map(y => toJson_SecurityGroupSpecForProviderIngress(y)),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_SecurityGroupSpecForProviderTags(y)),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecurityGroupSpecManagementPolicies
 */
export enum SecurityGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityGroupSpecProviderConfigRef
 */
export interface SecurityGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderConfigRef(obj: SecurityGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsTo
 */
export interface SecurityGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsTo(obj: SecurityGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityGroupSpecWriteConnectionSecretToRef
 */
export interface SecurityGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecWriteConnectionSecretToRef(obj: SecurityGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPPermission Describes a set of permissions for a security group rule.
 *
 * @schema SecurityGroupSpecForProviderEgress
 */
export interface SecurityGroupSpecForProviderEgress {
  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderEgress#fromPort
   */
  readonly fromPort?: number;

  /**
   * The IP protocol name (tcp, udp, icmp, icmpv6) or number (see Protocol Numbers (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
   * [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @schema SecurityGroupSpecForProviderEgress#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The IPv4 ranges.
   *
   * @schema SecurityGroupSpecForProviderEgress#ipRanges
   */
  readonly ipRanges?: SecurityGroupSpecForProviderEgressIpRanges[];

  /**
   * The IPv6 ranges.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderEgress#ipv6Ranges
   */
  readonly ipv6Ranges?: SecurityGroupSpecForProviderEgressIpv6Ranges[];

  /**
   * PrefixListIDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderEgress#prefixListIds
   */
  readonly prefixListIds?: SecurityGroupSpecForProviderEgressPrefixListIds[];

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderEgress#toPort
   */
  readonly toPort?: number;

  /**
   * UserIDGroupPairs are the source security group and AWS account ID pairs. It contains one or more accounts and security groups to allow flows from security groups of other accounts.
   *
   * @schema SecurityGroupSpecForProviderEgress#userIdGroupPairs
   */
  readonly userIdGroupPairs?: SecurityGroupSpecForProviderEgressUserIdGroupPairs[];

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgress(obj: SecurityGroupSpecForProviderEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipProtocol': obj.ipProtocol,
    'ipRanges': obj.ipRanges?.map(y => toJson_SecurityGroupSpecForProviderEgressIpRanges(y)),
    'ipv6Ranges': obj.ipv6Ranges?.map(y => toJson_SecurityGroupSpecForProviderEgressIpv6Ranges(y)),
    'prefixListIds': obj.prefixListIds?.map(y => toJson_SecurityGroupSpecForProviderEgressPrefixListIds(y)),
    'toPort': obj.toPort,
    'userIdGroupPairs': obj.userIdGroupPairs?.map(y => toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPPermission Describes a set of permissions for a security group rule.
 *
 * @schema SecurityGroupSpecForProviderIngress
 */
export interface SecurityGroupSpecForProviderIngress {
  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderIngress#fromPort
   */
  readonly fromPort?: number;

  /**
   * The IP protocol name (tcp, udp, icmp, icmpv6) or number (see Protocol Numbers (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
   * [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @schema SecurityGroupSpecForProviderIngress#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The IPv4 ranges.
   *
   * @schema SecurityGroupSpecForProviderIngress#ipRanges
   */
  readonly ipRanges?: SecurityGroupSpecForProviderIngressIpRanges[];

  /**
   * The IPv6 ranges.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderIngress#ipv6Ranges
   */
  readonly ipv6Ranges?: SecurityGroupSpecForProviderIngressIpv6Ranges[];

  /**
   * PrefixListIDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderIngress#prefixListIds
   */
  readonly prefixListIds?: SecurityGroupSpecForProviderIngressPrefixListIds[];

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderIngress#toPort
   */
  readonly toPort?: number;

  /**
   * UserIDGroupPairs are the source security group and AWS account ID pairs. It contains one or more accounts and security groups to allow flows from security groups of other accounts.
   *
   * @schema SecurityGroupSpecForProviderIngress#userIdGroupPairs
   */
  readonly userIdGroupPairs?: SecurityGroupSpecForProviderIngressUserIdGroupPairs[];

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngress(obj: SecurityGroupSpecForProviderIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipProtocol': obj.ipProtocol,
    'ipRanges': obj.ipRanges?.map(y => toJson_SecurityGroupSpecForProviderIngressIpRanges(y)),
    'ipv6Ranges': obj.ipv6Ranges?.map(y => toJson_SecurityGroupSpecForProviderIngressIpv6Ranges(y)),
    'prefixListIds': obj.prefixListIds?.map(y => toJson_SecurityGroupSpecForProviderIngressPrefixListIds(y)),
    'toPort': obj.toPort,
    'userIdGroupPairs': obj.userIdGroupPairs?.map(y => toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema SecurityGroupSpecForProviderTags
 */
export interface SecurityGroupSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema SecurityGroupSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema SecurityGroupSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderTags(obj: SecurityGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to and retrieves its vpcId
 *
 * @schema SecurityGroupSpecForProviderVpcIdRef
 */
export interface SecurityGroupSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdRef(obj: SecurityGroupSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelector
 */
export interface SecurityGroupSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdSelector(obj: SecurityGroupSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicy
 */
export interface SecurityGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderConfigRefPolicy(obj: SecurityGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRef(obj: SecurityGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToMetadata(obj: SecurityGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPRange describes an IPv4 range.
 *
 * @schema SecurityGroupSpecForProviderEgressIpRanges
 */
export interface SecurityGroupSpecForProviderEgressIpRanges {
  /**
   * The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.
   *
   * @schema SecurityGroupSpecForProviderEgressIpRanges#cidrIp
   */
  readonly cidrIp: string;

  /**
   * A description for the security group rule that references this IPv4 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressIpRanges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressIpRanges(obj: SecurityGroupSpecForProviderEgressIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIp': obj.cidrIp,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv6Range describes an IPv6 range.
 *
 * @schema SecurityGroupSpecForProviderEgressIpv6Ranges
 */
export interface SecurityGroupSpecForProviderEgressIpv6Ranges {
  /**
   * The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.
   *
   * @schema SecurityGroupSpecForProviderEgressIpv6Ranges#cidrIPv6
   */
  readonly cidrIPv6: string;

  /**
   * A description for the security group rule that references this IPv6 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressIpv6Ranges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressIpv6Ranges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressIpv6Ranges(obj: SecurityGroupSpecForProviderEgressIpv6Ranges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIPv6': obj.cidrIPv6,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrefixListID describes a prefix list ID.
 *
 * @schema SecurityGroupSpecForProviderEgressPrefixListIds
 */
export interface SecurityGroupSpecForProviderEgressPrefixListIds {
  /**
   * A description for the security group rule that references this prefix list ID.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressPrefixListIds#description
   */
  readonly description?: string;

  /**
   * The ID of the prefix.
   *
   * @schema SecurityGroupSpecForProviderEgressPrefixListIds#prefixListId
   */
  readonly prefixListId: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressPrefixListIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressPrefixListIds(obj: SecurityGroupSpecForProviderEgressPrefixListIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'prefixListId': obj.prefixListId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserIDGroupPair describes a security group and AWS account ID pair.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairs {
  /**
   * A description for the security group rule that references this user ID group pair.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#description
   */
  readonly description?: string;

  /**
   * The ID of the security group.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupId
   */
  readonly groupId?: string;

  /**
   * GroupIDRef reference a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupIdRef
   */
  readonly groupIdRef?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef;

  /**
   * GroupIDSelector selects reference to a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupIdSelector
   */
  readonly groupIdSelector?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector;

  /**
   * The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
   * For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupName
   */
  readonly groupName?: string;

  /**
   * The ID of an AWS account.
   * For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.
   * [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#userId
   */
  readonly userId?: string;

  /**
   * The ID of the VPC for the referenced security group, if applicable.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef reference a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef;

  /**
   * VPCIDSelector selects reference to a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector;

  /**
   * The ID of the VPC peering connection, if applicable.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairs(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'groupId': obj.groupId,
    'groupIdRef': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector(obj.groupIdSelector),
    'groupName': obj.groupName,
    'userId': obj.userId,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector(obj.vpcIdSelector),
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPRange describes an IPv4 range.
 *
 * @schema SecurityGroupSpecForProviderIngressIpRanges
 */
export interface SecurityGroupSpecForProviderIngressIpRanges {
  /**
   * The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.
   *
   * @schema SecurityGroupSpecForProviderIngressIpRanges#cidrIp
   */
  readonly cidrIp: string;

  /**
   * A description for the security group rule that references this IPv4 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressIpRanges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressIpRanges(obj: SecurityGroupSpecForProviderIngressIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIp': obj.cidrIp,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv6Range describes an IPv6 range.
 *
 * @schema SecurityGroupSpecForProviderIngressIpv6Ranges
 */
export interface SecurityGroupSpecForProviderIngressIpv6Ranges {
  /**
   * The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.
   *
   * @schema SecurityGroupSpecForProviderIngressIpv6Ranges#cidrIPv6
   */
  readonly cidrIPv6: string;

  /**
   * A description for the security group rule that references this IPv6 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressIpv6Ranges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressIpv6Ranges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressIpv6Ranges(obj: SecurityGroupSpecForProviderIngressIpv6Ranges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIPv6': obj.cidrIPv6,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrefixListID describes a prefix list ID.
 *
 * @schema SecurityGroupSpecForProviderIngressPrefixListIds
 */
export interface SecurityGroupSpecForProviderIngressPrefixListIds {
  /**
   * A description for the security group rule that references this prefix list ID.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressPrefixListIds#description
   */
  readonly description?: string;

  /**
   * The ID of the prefix.
   *
   * @schema SecurityGroupSpecForProviderIngressPrefixListIds#prefixListId
   */
  readonly prefixListId: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressPrefixListIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressPrefixListIds(obj: SecurityGroupSpecForProviderIngressPrefixListIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'prefixListId': obj.prefixListId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserIDGroupPair describes a security group and AWS account ID pair.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairs {
  /**
   * A description for the security group rule that references this user ID group pair.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#description
   */
  readonly description?: string;

  /**
   * The ID of the security group.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupId
   */
  readonly groupId?: string;

  /**
   * GroupIDRef reference a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupIdRef
   */
  readonly groupIdRef?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef;

  /**
   * GroupIDSelector selects reference to a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupIdSelector
   */
  readonly groupIdSelector?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector;

  /**
   * The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
   * For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupName
   */
  readonly groupName?: string;

  /**
   * The ID of an AWS account.
   * For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.
   * [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#userId
   */
  readonly userId?: string;

  /**
   * The ID of the VPC for the referenced security group, if applicable.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef reference a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef;

  /**
   * VPCIDSelector selects reference to a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector;

  /**
   * The ID of the VPC peering connection, if applicable.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairs(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'groupId': obj.groupId,
    'groupIdRef': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector(obj.groupIdSelector),
    'groupName': obj.groupName,
    'userId': obj.userId,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector(obj.vpcIdSelector),
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdRefPolicy(obj: SecurityGroupSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicyResolution
 */
export enum SecurityGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicyResolve
 */
export enum SecurityGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDRef reference a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDSelector selects reference to a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef reference a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects reference to a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDRef reference a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDSelector selects reference to a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef reference a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects reference to a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A SecurityGroupRule is a managed resource that represents an SecurityGroupRule
 *
 * @schema SecurityGroupRule
 */
export class SecurityGroupRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityGroupRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'SecurityGroupRule',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityGroupRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityGroupRuleProps): any {
    return {
      ...SecurityGroupRule.GVK,
      ...toJson_SecurityGroupRuleProps(props),
    };
  }

  /**
   * Defines a "SecurityGroupRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityGroupRuleProps) {
    super(scope, id, {
      ...SecurityGroupRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityGroupRule.GVK,
      ...toJson_SecurityGroupRuleProps(resolved),
    };
  }
}

/**
 * A SecurityGroupRule is a managed resource that represents an SecurityGroupRule
 *
 * @schema SecurityGroupRule
 */
export interface SecurityGroupRuleProps {
  /**
   * @schema SecurityGroupRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A SecurityGroupRuleSpec defines the desired state of a SecurityGroupRule.
   *
   * @schema SecurityGroupRule#spec
   */
  readonly spec: SecurityGroupRuleSpec;

}

/**
 * Converts an object of type 'SecurityGroupRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleProps(obj: SecurityGroupRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityGroupRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecurityGroupRuleSpec defines the desired state of a SecurityGroupRule.
 *
 * @schema SecurityGroupRuleSpec
 */
export interface SecurityGroupRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityGroupRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityGroupRuleSpecDeletionPolicy;

  /**
   * SecurityGroupRuleParameters define the desired state of the SecurityGroupRule
   *
   * @schema SecurityGroupRuleSpec#forProvider
   */
  readonly forProvider: SecurityGroupRuleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecurityGroupRuleSpec#managementPolicies
   */
  readonly managementPolicies?: SecurityGroupRuleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityGroupRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityGroupRuleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityGroupRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityGroupRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityGroupRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityGroupRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpec(obj: SecurityGroupRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityGroupRuleSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecurityGroupRuleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecurityGroupRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityGroupRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityGroupRuleSpecDeletionPolicy
 */
export enum SecurityGroupRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecurityGroupRuleParameters define the desired state of the SecurityGroupRule
 *
 * @schema SecurityGroupRuleSpecForProvider
 */
export interface SecurityGroupRuleSpecForProvider {
  /**
   * @schema SecurityGroupRuleSpecForProvider#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * @schema SecurityGroupRuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * @schema SecurityGroupRuleSpecForProvider#fromPort
   */
  readonly fromPort: number;

  /**
   * @schema SecurityGroupRuleSpecForProvider#ipv6cidrBlock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * @schema SecurityGroupRuleSpecForProvider#prefixListId
   */
  readonly prefixListId?: string;

  /**
   * @schema SecurityGroupRuleSpecForProvider#protocol
   */
  readonly protocol: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecurityGroupRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * If using a SecurityGroup managed by crossplane as reference, enable ignoreIngress or ignoreEgress on the sg to prevent the rules to be constantly created and deleted
   *
   * @schema SecurityGroupRuleSpecForProvider#securityGroupId
   */
  readonly securityGroupId?: string;

  /**
   * If using a SecurityGroup managed by crossplane as reference, enable ignoreIngress or ignoreEgress on the sg to prevent the rules to be constantly created and deleted
   *
   * @schema SecurityGroupRuleSpecForProvider#securityGroupIdRef
   */
  readonly securityGroupIdRef?: SecurityGroupRuleSpecForProviderSecurityGroupIdRef;

  /**
   * A Selector selects an object.
   *
   * @schema SecurityGroupRuleSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: SecurityGroupRuleSpecForProviderSecurityGroupIdSelector;

  /**
   * @schema SecurityGroupRuleSpecForProvider#sourceSecurityGroupId
   */
  readonly sourceSecurityGroupId?: string;

  /**
   * A Reference to a named object.
   *
   * @schema SecurityGroupRuleSpecForProvider#sourceSecurityGroupIdRef
   */
  readonly sourceSecurityGroupIdRef?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef;

  /**
   * A Selector selects an object.
   *
   * @schema SecurityGroupRuleSpecForProvider#sourceSecurityGroupIdSelector
   */
  readonly sourceSecurityGroupIdSelector?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector;

  /**
   * @schema SecurityGroupRuleSpecForProvider#toPort
   */
  readonly toPort: number;

  /**
   * Type of rule, ingress (inbound) or egress (outbound).
   *
   * @schema SecurityGroupRuleSpecForProvider#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProvider(obj: SecurityGroupRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'description': obj.description,
    'fromPort': obj.fromPort,
    'ipv6cidrBlock': obj.ipv6CidrBlock,
    'prefixListId': obj.prefixListId,
    'protocol': obj.protocol,
    'region': obj.region,
    'securityGroupId': obj.securityGroupId,
    'securityGroupIdRef': toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdRef(obj.securityGroupIdRef),
    'securityGroupIdSelector': toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'sourceSecurityGroupId': obj.sourceSecurityGroupId,
    'sourceSecurityGroupIdRef': toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef(obj.sourceSecurityGroupIdRef),
    'sourceSecurityGroupIdSelector': toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector(obj.sourceSecurityGroupIdSelector),
    'toPort': obj.toPort,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecurityGroupRuleSpecManagementPolicies
 */
export enum SecurityGroupRuleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityGroupRuleSpecProviderConfigRef
 */
export interface SecurityGroupRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupRuleSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityGroupRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecProviderConfigRef(obj: SecurityGroupRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsTo
 */
export interface SecurityGroupRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityGroupRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecPublishConnectionDetailsTo(obj: SecurityGroupRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityGroupRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityGroupRuleSpecWriteConnectionSecretToRef
 */
export interface SecurityGroupRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityGroupRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityGroupRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecWriteConnectionSecretToRef(obj: SecurityGroupRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If using a SecurityGroup managed by crossplane as reference, enable ignoreIngress or ignoreEgress on the sg to prevent the rules to be constantly created and deleted
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRef
 */
export interface SecurityGroupRuleSpecForProviderSecurityGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRef#policy
   */
  readonly policy?: SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSecurityGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdRef(obj: SecurityGroupRuleSpecForProviderSecurityGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelector
 */
export interface SecurityGroupRuleSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdSelector(obj: SecurityGroupRuleSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef
 */
export interface SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef#policy
   */
  readonly policy?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef(obj: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector
 */
export interface SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector(obj: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupRuleSpecProviderConfigRefPolicy
 */
export interface SecurityGroupRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecProviderConfigRefPolicy(obj: SecurityGroupRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef(obj: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityGroupRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecPublishConnectionDetailsToMetadata(obj: SecurityGroupRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy
 */
export interface SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy(obj: SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy(obj: SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy
 */
export interface SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy(obj: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy
 */
export interface SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy(obj: SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecProviderConfigRefPolicyResolution
 */
export enum SecurityGroupRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecProviderConfigRefPolicyResolve
 */
export enum SecurityGroupRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolution
 */
export enum SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolve
 */
export enum SecurityGroupRuleSpecForProviderSecurityGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupRuleSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolution
 */
export enum SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolve
 */
export enum SecurityGroupRuleSpecForProviderSourceSecurityGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupRuleSpecForProviderSourceSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityGroupRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Subnet is a managed resource that represents an AWS VPC Subnet.
 *
 * @schema Subnet
 */
export class Subnet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subnet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'Subnet',
  }

  /**
   * Renders a Kubernetes manifest for "Subnet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetProps): any {
    return {
      ...Subnet.GVK,
      ...toJson_SubnetProps(props),
    };
  }

  /**
   * Defines a "Subnet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetProps) {
    super(scope, id, {
      ...Subnet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subnet.GVK,
      ...toJson_SubnetProps(resolved),
    };
  }
}

/**
 * A Subnet is a managed resource that represents an AWS VPC Subnet.
 *
 * @schema Subnet
 */
export interface SubnetProps {
  /**
   * @schema Subnet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A SubnetSpec defines the desired state of a Subnet.
   *
   * @schema Subnet#spec
   */
  readonly spec: SubnetSpec;

}

/**
 * Converts an object of type 'SubnetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetProps(obj: SubnetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SubnetSpec defines the desired state of a Subnet.
 *
 * @schema SubnetSpec
 */
export interface SubnetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetSpecDeletionPolicy;

  /**
   * SubnetParameters define the desired state of an AWS VPC Subnet.
   *
   * @schema SubnetSpec#forProvider
   */
  readonly forProvider: SubnetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetSpec#managementPolicies
   */
  readonly managementPolicies?: SubnetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubnetSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubnetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubnetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubnetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpec(obj: SubnetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SubnetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetSpecDeletionPolicy
 */
export enum SubnetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SubnetParameters define the desired state of an AWS VPC Subnet.
 *
 * @schema SubnetSpecForProvider
 */
export interface SubnetSpecForProvider {
  /**
   * Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives an IPv6 address.
   *
   * @schema SubnetSpecForProvider#assignIpv6AddressOnCreation
   */
  readonly assignIpv6AddressOnCreation?: boolean;

  /**
   * The Availability Zone for the subnet. Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.
   *
   * @schema SubnetSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The AZ ID or the Local Zone ID of the subnet.
   *
   * @schema SubnetSpecForProvider#availabilityZoneId
   */
  readonly availabilityZoneId?: string;

  /**
   * CIDRBlock is the IPv4 network range for the Subnet, in CIDR notation. For example, 10.0.0.0/18.
   *
   * @schema SubnetSpecForProvider#cidrBlock
   */
  readonly cidrBlock: string;

  /**
   * The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
   *
   * @schema SubnetSpecForProvider#ipv6CIDRBlock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address.
   *
   * @schema SubnetSpecForProvider#mapPublicIPOnLaunch
   */
  readonly mapPublicIpOnLaunch?: boolean;

  /**
   * Region is the region you'd like your Subnet to be created in.
   *
   * @schema SubnetSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema SubnetSpecForProvider#tags
   */
  readonly tags?: SubnetSpecForProviderTags[];

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema SubnetSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef reference a VPC to retrieve its vpcId
   *
   * @schema SubnetSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: SubnetSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects reference to a VPC to retrieve its vpcId
   *
   * @schema SubnetSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: SubnetSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'SubnetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProvider(obj: SubnetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignIpv6AddressOnCreation': obj.assignIpv6AddressOnCreation,
    'availabilityZone': obj.availabilityZone,
    'availabilityZoneId': obj.availabilityZoneId,
    'cidrBlock': obj.cidrBlock,
    'ipv6CIDRBlock': obj.ipv6CidrBlock,
    'mapPublicIPOnLaunch': obj.mapPublicIpOnLaunch,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_SubnetSpecForProviderTags(y)),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SubnetSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SubnetSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SubnetSpecManagementPolicies
 */
export enum SubnetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubnetSpecProviderConfigRef
 */
export interface SubnetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecProviderConfigRef(obj: SubnetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubnetSpecPublishConnectionDetailsTo
 */
export interface SubnetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubnetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubnetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecPublishConnectionDetailsTo(obj: SubnetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubnetSpecWriteConnectionSecretToRef
 */
export interface SubnetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubnetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecWriteConnectionSecretToRef(obj: SubnetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema SubnetSpecForProviderTags
 */
export interface SubnetSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema SubnetSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema SubnetSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SubnetSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProviderTags(obj: SubnetSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef reference a VPC to retrieve its vpcId
 *
 * @schema SubnetSpecForProviderVpcIdRef
 */
export interface SubnetSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetSpecForProviderVpcIdRef#policy
   */
  readonly policy?: SubnetSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SubnetSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProviderVpcIdRef(obj: SubnetSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects reference to a VPC to retrieve its vpcId
 *
 * @schema SubnetSpecForProviderVpcIdSelector
 */
export interface SubnetSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubnetSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: SubnetSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SubnetSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProviderVpcIdSelector(obj: SubnetSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetSpecProviderConfigRefPolicy
 */
export interface SubnetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecProviderConfigRefPolicy(obj: SubnetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubnetSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecPublishConnectionDetailsToConfigRef(obj: SubnetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubnetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecPublishConnectionDetailsToMetadata(obj: SubnetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetSpecForProviderVpcIdRefPolicy
 */
export interface SubnetSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: SubnetSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: SubnetSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProviderVpcIdRefPolicy(obj: SubnetSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetSpecForProviderVpcIdSelectorPolicy
 */
export interface SubnetSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SubnetSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SubnetSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubnetSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecForProviderVpcIdSelectorPolicy(obj: SubnetSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetSpecProviderConfigRefPolicyResolution
 */
export enum SubnetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetSpecProviderConfigRefPolicyResolve
 */
export enum SubnetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetSpecForProviderVpcIdRefPolicyResolution
 */
export enum SubnetSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetSpecForProviderVpcIdRefPolicyResolve
 */
export enum SubnetSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum SubnetSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum SubnetSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGateway is the Schema for the TransitGateways API
 *
 * @schema TransitGateway
 */
export class TransitGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'TransitGateway',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayProps): any {
    return {
      ...TransitGateway.GVK,
      ...toJson_TransitGatewayProps(props),
    };
  }

  /**
   * Defines a "TransitGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayProps) {
    super(scope, id, {
      ...TransitGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGateway.GVK,
      ...toJson_TransitGatewayProps(resolved),
    };
  }
}

/**
 * TransitGateway is the Schema for the TransitGateways API
 *
 * @schema TransitGateway
 */
export interface TransitGatewayProps {
  /**
   * @schema TransitGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewaySpec defines the desired state of TransitGateway
   *
   * @schema TransitGateway#spec
   */
  readonly spec: TransitGatewaySpec;

}

/**
 * Converts an object of type 'TransitGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayProps(obj: TransitGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewaySpec defines the desired state of TransitGateway
 *
 * @schema TransitGatewaySpec
 */
export interface TransitGatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewaySpecDeletionPolicy;

  /**
   * TransitGatewayParameters defines the desired state of TransitGateway
   *
   * @schema TransitGatewaySpec#forProvider
   */
  readonly forProvider: TransitGatewaySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewaySpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpec(obj: TransitGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewaySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewaySpecDeletionPolicy
 */
export enum TransitGatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TransitGatewayParameters defines the desired state of TransitGateway
 *
 * @schema TransitGatewaySpecForProvider
 */
export interface TransitGatewaySpecForProvider {
  /**
   * A description of the transit gateway.
   *
   * @schema TransitGatewaySpecForProvider#description
   */
  readonly description?: string;

  /**
   * The transit gateway options.
   *
   * @schema TransitGatewaySpecForProvider#options
   */
  readonly options?: TransitGatewaySpecForProviderOptions;

  /**
   * Region is which region the TransitGateway will be created.
   *
   * @schema TransitGatewaySpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to apply to the transit gateway.
   *
   * @schema TransitGatewaySpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: TransitGatewaySpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema TransitGatewaySpecForProvider#tags
   */
  readonly tags?: TransitGatewaySpecForProviderTags[];

}

/**
 * Converts an object of type 'TransitGatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecForProvider(obj: TransitGatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'options': toJson_TransitGatewaySpecForProviderOptions(obj.options),
    'region': obj.region,
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_TransitGatewaySpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_TransitGatewaySpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewaySpecManagementPolicies
 */
export enum TransitGatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewaySpecProviderConfigRef
 */
export interface TransitGatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewaySpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecProviderConfigRef(obj: TransitGatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsTo
 */
export interface TransitGatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecPublishConnectionDetailsTo(obj: TransitGatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewaySpecWriteConnectionSecretToRef
 */
export interface TransitGatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecWriteConnectionSecretToRef(obj: TransitGatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The transit gateway options.
 *
 * @schema TransitGatewaySpecForProviderOptions
 */
export interface TransitGatewaySpecForProviderOptions {
  /**
   * @schema TransitGatewaySpecForProviderOptions#amazonSideASN
   */
  readonly amazonSideAsn?: number;

  /**
   * @schema TransitGatewaySpecForProviderOptions#autoAcceptSharedAttachments
   */
  readonly autoAcceptSharedAttachments?: string;

  /**
   * @schema TransitGatewaySpecForProviderOptions#defaultRouteTableAssociation
   */
  readonly defaultRouteTableAssociation?: string;

  /**
   * @schema TransitGatewaySpecForProviderOptions#defaultRouteTablePropagation
   */
  readonly defaultRouteTablePropagation?: string;

  /**
   * @schema TransitGatewaySpecForProviderOptions#dnsSupport
   */
  readonly dnsSupport?: string;

  /**
   * @schema TransitGatewaySpecForProviderOptions#multicastSupport
   */
  readonly multicastSupport?: string;

  /**
   * @schema TransitGatewaySpecForProviderOptions#transitGatewayCIDRBlocks
   */
  readonly transitGatewayCidrBlocks?: string[];

  /**
   * @schema TransitGatewaySpecForProviderOptions#vpnECMPSupport
   */
  readonly vpnEcmpSupport?: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecForProviderOptions(obj: TransitGatewaySpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonSideASN': obj.amazonSideAsn,
    'autoAcceptSharedAttachments': obj.autoAcceptSharedAttachments,
    'defaultRouteTableAssociation': obj.defaultRouteTableAssociation,
    'defaultRouteTablePropagation': obj.defaultRouteTablePropagation,
    'dnsSupport': obj.dnsSupport,
    'multicastSupport': obj.multicastSupport,
    'transitGatewayCIDRBlocks': obj.transitGatewayCidrBlocks?.map(y => y),
    'vpnECMPSupport': obj.vpnEcmpSupport,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewaySpecForProviderTagSpecifications
 */
export interface TransitGatewaySpecForProviderTagSpecifications {
  /**
   * @schema TransitGatewaySpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema TransitGatewaySpecForProviderTagSpecifications#tags
   */
  readonly tags?: TransitGatewaySpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'TransitGatewaySpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecForProviderTagSpecifications(obj: TransitGatewaySpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_TransitGatewaySpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewaySpecForProviderTags
 */
export interface TransitGatewaySpecForProviderTags {
  /**
   * @schema TransitGatewaySpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewaySpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecForProviderTags(obj: TransitGatewaySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewaySpecProviderConfigRefPolicy
 */
export interface TransitGatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecProviderConfigRefPolicy(obj: TransitGatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecPublishConnectionDetailsToConfigRef(obj: TransitGatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecPublishConnectionDetailsToMetadata(obj: TransitGatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewaySpecForProviderTagSpecificationsTags
 */
export interface TransitGatewaySpecForProviderTagSpecificationsTags {
  /**
   * @schema TransitGatewaySpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewaySpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewaySpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecForProviderTagSpecificationsTags(obj: TransitGatewaySpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewaySpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewaySpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGatewayRoute is the Schema for the TransitGatewayRoutes API
 *
 * @schema TransitGatewayRoute
 */
export class TransitGatewayRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGatewayRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'TransitGatewayRoute',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGatewayRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayRouteProps): any {
    return {
      ...TransitGatewayRoute.GVK,
      ...toJson_TransitGatewayRouteProps(props),
    };
  }

  /**
   * Defines a "TransitGatewayRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayRouteProps) {
    super(scope, id, {
      ...TransitGatewayRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGatewayRoute.GVK,
      ...toJson_TransitGatewayRouteProps(resolved),
    };
  }
}

/**
 * TransitGatewayRoute is the Schema for the TransitGatewayRoutes API
 *
 * @schema TransitGatewayRoute
 */
export interface TransitGatewayRouteProps {
  /**
   * @schema TransitGatewayRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewayRouteSpec defines the desired state of TransitGatewayRoute
   *
   * @schema TransitGatewayRoute#spec
   */
  readonly spec: TransitGatewayRouteSpec;

}

/**
 * Converts an object of type 'TransitGatewayRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteProps(obj: TransitGatewayRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewayRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayRouteSpec defines the desired state of TransitGatewayRoute
 *
 * @schema TransitGatewayRouteSpec
 */
export interface TransitGatewayRouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewayRouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewayRouteSpecDeletionPolicy;

  /**
   * TransitGatewayRouteParameters defines the desired state of TransitGatewayRoute
   *
   * @schema TransitGatewayRouteSpec#forProvider
   */
  readonly forProvider: TransitGatewayRouteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewayRouteSpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewayRouteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewayRouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewayRouteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewayRouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewayRouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewayRouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewayRouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpec(obj: TransitGatewayRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewayRouteSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewayRouteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewayRouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewayRouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewayRouteSpecDeletionPolicy
 */
export enum TransitGatewayRouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TransitGatewayRouteParameters defines the desired state of TransitGatewayRoute
 *
 * @schema TransitGatewayRouteSpecForProvider
 */
export interface TransitGatewayRouteSpecForProvider {
  /**
   * Indicates whether to drop traffic that matches this route.
   *
   * @schema TransitGatewayRouteSpecForProvider#blackhole
   */
  readonly blackhole?: boolean;

  /**
   * The CIDR range used for destination matches. Routing decisions are based on the most specific match.
   *
   * @schema TransitGatewayRouteSpecForProvider#destinationCIDRBlock
   */
  readonly destinationCidrBlock: string;

  /**
   * Region is which region the TransitGatewayRoute will be created.
   *
   * @schema TransitGatewayRouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the attachment.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayAttachmentId
   */
  readonly transitGatewayAttachmentId?: string;

  /**
   * TransitGatewayAttachmentIDRef is a reference to an API used to set the TransitGatewayAttachmentID.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayAttachmentIdRef
   */
  readonly transitGatewayAttachmentIdRef?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef;

  /**
   * TransitGatewayAttachmentIDSelector selects references to API used to set the TransitGatewayAttachmentID.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayAttachmentIdSelector
   */
  readonly transitGatewayAttachmentIdSelector?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector;

  /**
   * The ID of the transit gateway route table.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayRouteTableId
   */
  readonly transitGatewayRouteTableId?: string;

  /**
   * TransitGatewayRouteTableIDRef is a reference to an API used to set the TransitGatewayRouteTableID.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayRouteTableIdRef
   */
  readonly transitGatewayRouteTableIdRef?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef;

  /**
   * TransitGatewayRouteTableIDSelector selects references to API used to set the TransitGatewayRouteTableID.
   *
   * @schema TransitGatewayRouteSpecForProvider#transitGatewayRouteTableIdSelector
   */
  readonly transitGatewayRouteTableIdSelector?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProvider(obj: TransitGatewayRouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blackhole': obj.blackhole,
    'destinationCIDRBlock': obj.destinationCidrBlock,
    'region': obj.region,
    'transitGatewayAttachmentId': obj.transitGatewayAttachmentId,
    'transitGatewayAttachmentIdRef': toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef(obj.transitGatewayAttachmentIdRef),
    'transitGatewayAttachmentIdSelector': toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector(obj.transitGatewayAttachmentIdSelector),
    'transitGatewayRouteTableId': obj.transitGatewayRouteTableId,
    'transitGatewayRouteTableIdRef': toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef(obj.transitGatewayRouteTableIdRef),
    'transitGatewayRouteTableIdSelector': toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector(obj.transitGatewayRouteTableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewayRouteSpecManagementPolicies
 */
export enum TransitGatewayRouteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewayRouteSpecProviderConfigRef
 */
export interface TransitGatewayRouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteSpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewayRouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecProviderConfigRef(obj: TransitGatewayRouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsTo
 */
export interface TransitGatewayRouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewayRouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecPublishConnectionDetailsTo(obj: TransitGatewayRouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewayRouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewayRouteSpecWriteConnectionSecretToRef
 */
export interface TransitGatewayRouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewayRouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewayRouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecWriteConnectionSecretToRef(obj: TransitGatewayRouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayAttachmentIDRef is a reference to an API used to set the TransitGatewayAttachmentID.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef#policy
   */
  readonly policy?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef(obj: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayAttachmentIDSelector selects references to API used to set the TransitGatewayAttachmentID.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector#policy
   */
  readonly policy?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector(obj: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayRouteTableIDRef is a reference to an API used to set the TransitGatewayRouteTableID.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef#policy
   */
  readonly policy?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef(obj: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayRouteTableIDSelector selects references to API used to set the TransitGatewayRouteTableID.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector#policy
   */
  readonly policy?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector(obj: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteSpecProviderConfigRefPolicy
 */
export interface TransitGatewayRouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecProviderConfigRefPolicy(obj: TransitGatewayRouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef(obj: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewayRouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecPublishConnectionDetailsToMetadata(obj: TransitGatewayRouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy(obj: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy(obj: TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy(obj: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy
 */
export interface TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy(obj: TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewayRouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewayRouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayAttachmentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolution
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolve
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolution
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolve
 */
export enum TransitGatewayRouteSpecForProviderTransitGatewayRouteTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGatewayRouteTable is the Schema for the TransitGatewayRouteTables API
 *
 * @schema TransitGatewayRouteTable
 */
export class TransitGatewayRouteTable extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGatewayRouteTable"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'TransitGatewayRouteTable',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGatewayRouteTable".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayRouteTableProps): any {
    return {
      ...TransitGatewayRouteTable.GVK,
      ...toJson_TransitGatewayRouteTableProps(props),
    };
  }

  /**
   * Defines a "TransitGatewayRouteTable" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayRouteTableProps) {
    super(scope, id, {
      ...TransitGatewayRouteTable.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGatewayRouteTable.GVK,
      ...toJson_TransitGatewayRouteTableProps(resolved),
    };
  }
}

/**
 * TransitGatewayRouteTable is the Schema for the TransitGatewayRouteTables API
 *
 * @schema TransitGatewayRouteTable
 */
export interface TransitGatewayRouteTableProps {
  /**
   * @schema TransitGatewayRouteTable#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewayRouteTableSpec defines the desired state of TransitGatewayRouteTable
   *
   * @schema TransitGatewayRouteTable#spec
   */
  readonly spec: TransitGatewayRouteTableSpec;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableProps(obj: TransitGatewayRouteTableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewayRouteTableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayRouteTableSpec defines the desired state of TransitGatewayRouteTable
 *
 * @schema TransitGatewayRouteTableSpec
 */
export interface TransitGatewayRouteTableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewayRouteTableSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewayRouteTableSpecDeletionPolicy;

  /**
   * TransitGatewayRouteTableParameters defines the desired state of TransitGatewayRouteTable
   *
   * @schema TransitGatewayRouteTableSpec#forProvider
   */
  readonly forProvider: TransitGatewayRouteTableSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewayRouteTableSpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewayRouteTableSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewayRouteTableSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewayRouteTableSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewayRouteTableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewayRouteTableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewayRouteTableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewayRouteTableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpec(obj: TransitGatewayRouteTableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewayRouteTableSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewayRouteTableSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewayRouteTableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewayRouteTableSpecDeletionPolicy
 */
export enum TransitGatewayRouteTableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TransitGatewayRouteTableParameters defines the desired state of TransitGatewayRouteTable
 *
 * @schema TransitGatewayRouteTableSpecForProvider
 */
export interface TransitGatewayRouteTableSpecForProvider {
  /**
   * Region is which region the TransitGatewayRouteTable will be created.
   *
   * @schema TransitGatewayRouteTableSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to apply to the transit gateway route table.
   *
   * @schema TransitGatewayRouteTableSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: TransitGatewayRouteTableSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema TransitGatewayRouteTableSpecForProvider#tags
   */
  readonly tags?: TransitGatewayRouteTableSpecForProviderTags[];

  /**
   * The ID of the transit gateway.
   *
   * @schema TransitGatewayRouteTableSpecForProvider#transitGatewayId
   */
  readonly transitGatewayId?: string;

  /**
   * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
   *
   * @schema TransitGatewayRouteTableSpecForProvider#transitGatewayIdRef
   */
  readonly transitGatewayIdRef?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef;

  /**
   * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
   *
   * @schema TransitGatewayRouteTableSpecForProvider#transitGatewayIdSelector
   */
  readonly transitGatewayIdSelector?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProvider(obj: TransitGatewayRouteTableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_TransitGatewayRouteTableSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_TransitGatewayRouteTableSpecForProviderTags(y)),
    'transitGatewayId': obj.transitGatewayId,
    'transitGatewayIdRef': toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef(obj.transitGatewayIdRef),
    'transitGatewayIdSelector': toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector(obj.transitGatewayIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewayRouteTableSpecManagementPolicies
 */
export enum TransitGatewayRouteTableSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewayRouteTableSpecProviderConfigRef
 */
export interface TransitGatewayRouteTableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteTableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteTableSpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewayRouteTableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecProviderConfigRef(obj: TransitGatewayRouteTableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteTableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsTo
 */
export interface TransitGatewayRouteTableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsTo(obj: TransitGatewayRouteTableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewayRouteTableSpecWriteConnectionSecretToRef
 */
export interface TransitGatewayRouteTableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewayRouteTableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewayRouteTableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecWriteConnectionSecretToRef(obj: TransitGatewayRouteTableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayRouteTableSpecForProviderTagSpecifications
 */
export interface TransitGatewayRouteTableSpecForProviderTagSpecifications {
  /**
   * @schema TransitGatewayRouteTableSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema TransitGatewayRouteTableSpecForProviderTagSpecifications#tags
   */
  readonly tags?: TransitGatewayRouteTableSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTagSpecifications(obj: TransitGatewayRouteTableSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_TransitGatewayRouteTableSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayRouteTableSpecForProviderTags
 */
export interface TransitGatewayRouteTableSpecForProviderTags {
  /**
   * @schema TransitGatewayRouteTableSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewayRouteTableSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTags(obj: TransitGatewayRouteTableSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef
 */
export interface TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef#policy
   */
  readonly policy?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef(obj: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector
 */
export interface TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector#policy
   */
  readonly policy?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector(obj: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteTableSpecProviderConfigRefPolicy
 */
export interface TransitGatewayRouteTableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteTableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteTableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteTableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteTableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecProviderConfigRefPolicy(obj: TransitGatewayRouteTableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef(obj: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata(obj: TransitGatewayRouteTableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayRouteTableSpecForProviderTagSpecificationsTags
 */
export interface TransitGatewayRouteTableSpecForProviderTagSpecificationsTags {
  /**
   * @schema TransitGatewayRouteTableSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewayRouteTableSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTagSpecificationsTags(obj: TransitGatewayRouteTableSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy
 */
export interface TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy(obj: TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy
 */
export interface TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy(obj: TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteTableSpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewayRouteTableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteTableSpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewayRouteTableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolution
 */
export enum TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolve
 */
export enum TransitGatewayRouteTableSpecForProviderTransitGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolution
 */
export enum TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolve
 */
export enum TransitGatewayRouteTableSpecForProviderTransitGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewayRouteTableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGatewayVPCAttachment is the Schema for the TransitGatewayVPCAttachments API
 *
 * @schema TransitGatewayVPCAttachment
 */
export class TransitGatewayVpcAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGatewayVPCAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'TransitGatewayVPCAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGatewayVPCAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayVpcAttachmentProps): any {
    return {
      ...TransitGatewayVpcAttachment.GVK,
      ...toJson_TransitGatewayVpcAttachmentProps(props),
    };
  }

  /**
   * Defines a "TransitGatewayVPCAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayVpcAttachmentProps) {
    super(scope, id, {
      ...TransitGatewayVpcAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGatewayVpcAttachment.GVK,
      ...toJson_TransitGatewayVpcAttachmentProps(resolved),
    };
  }
}

/**
 * TransitGatewayVPCAttachment is the Schema for the TransitGatewayVPCAttachments API
 *
 * @schema TransitGatewayVPCAttachment
 */
export interface TransitGatewayVpcAttachmentProps {
  /**
   * @schema TransitGatewayVPCAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewayVPCAttachmentSpec defines the desired state of TransitGatewayVPCAttachment
   *
   * @schema TransitGatewayVPCAttachment#spec
   */
  readonly spec: TransitGatewayVpcAttachmentSpec;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentProps(obj: TransitGatewayVpcAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewayVpcAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayVPCAttachmentSpec defines the desired state of TransitGatewayVPCAttachment
 *
 * @schema TransitGatewayVpcAttachmentSpec
 */
export interface TransitGatewayVpcAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewayVpcAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewayVpcAttachmentSpecDeletionPolicy;

  /**
   * TransitGatewayVPCAttachmentParameters defines the desired state of TransitGatewayVPCAttachment
   *
   * @schema TransitGatewayVpcAttachmentSpec#forProvider
   */
  readonly forProvider: TransitGatewayVpcAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewayVpcAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewayVpcAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewayVpcAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewayVpcAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewayVpcAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewayVpcAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpec(obj: TransitGatewayVpcAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewayVpcAttachmentSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewayVpcAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewayVpcAttachmentSpecDeletionPolicy
 */
export enum TransitGatewayVpcAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TransitGatewayVPCAttachmentParameters defines the desired state of TransitGatewayVPCAttachment
 *
 * @schema TransitGatewayVpcAttachmentSpecForProvider
 */
export interface TransitGatewayVpcAttachmentSpecForProvider {
  /**
   * The VPC attachment options.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#options
   */
  readonly options?: TransitGatewayVpcAttachmentSpecForProviderOptions;

  /**
   * Region is which region the TransitGatewayVPCAttachment will be created.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * SubnetIDRefs is a list of references to SubnetIDs used to set the SubnetIDs.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs[];

  /**
   * SubnetIDSelector selects references to SubnetIDs used to set the SubnetIDs.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector;

  /**
   * The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * The tags to apply to the VPC attachment.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: TransitGatewayVpcAttachmentSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#tags
   */
  readonly tags?: TransitGatewayVpcAttachmentSpecForProviderTags[];

  /**
   * The ID of the transit gateway.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#transitGatewayId
   */
  readonly transitGatewayId?: string;

  /**
   * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#transitGatewayIdRef
   */
  readonly transitGatewayIdRef?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef;

  /**
   * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#transitGatewayIdSelector
   */
  readonly transitGatewayIdSelector?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector;

  /**
   * The ID of the VPC.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef is a reference to an API used to set the VPCID.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: TransitGatewayVpcAttachmentSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects references to API used to set the VPCID.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProvider(obj: TransitGatewayVpcAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': toJson_TransitGatewayVpcAttachmentSpecForProviderOptions(obj.options),
    'region': obj.region,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_TransitGatewayVpcAttachmentSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_TransitGatewayVpcAttachmentSpecForProviderTags(y)),
    'transitGatewayId': obj.transitGatewayId,
    'transitGatewayIdRef': toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef(obj.transitGatewayIdRef),
    'transitGatewayIdSelector': toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector(obj.transitGatewayIdSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewayVpcAttachmentSpecManagementPolicies
 */
export enum TransitGatewayVpcAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewayVpcAttachmentSpecProviderConfigRef
 */
export interface TransitGatewayVpcAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayVpcAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayVpcAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecProviderConfigRef(obj: TransitGatewayVpcAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo
 */
export interface TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo(obj: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef
 */
export interface TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef(obj: TransitGatewayVpcAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The VPC attachment options.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderOptions
 */
export interface TransitGatewayVpcAttachmentSpecForProviderOptions {
  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderOptions#applianceModeSupport
   */
  readonly applianceModeSupport?: string;

  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderOptions#dnsSupport
   */
  readonly dnsSupport?: string;

  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderOptions#ipv6Support
   */
  readonly ipv6Support?: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderOptions(obj: TransitGatewayVpcAttachmentSpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applianceModeSupport': obj.applianceModeSupport,
    'dnsSupport': obj.dnsSupport,
    'ipv6Support': obj.ipv6Support,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs
 */
export interface TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs(obj: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects references to SubnetIDs used to set the SubnetIDs.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector
 */
export interface TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector(obj: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecifications
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTagSpecifications {
  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecifications#tags
   */
  readonly tags?: TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTagSpecifications(obj: TransitGatewayVpcAttachmentSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayVpcAttachmentSpecForProviderTags
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTags {
  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTags(obj: TransitGatewayVpcAttachmentSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDRef is a reference to an API used to set the TransitGatewayID.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef(obj: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayIDSelector selects references to API used to set the TransitGatewayID.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector(obj: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef is a reference to an API used to set the VPCID.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRef
 */
export interface TransitGatewayVpcAttachmentSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRef#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdRef(obj: TransitGatewayVpcAttachmentSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects references to API used to set the VPCID.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector
 */
export interface TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector(obj: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy
 */
export interface TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy(obj: TransitGatewayVpcAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef(obj: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata(obj: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags {
  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags(obj: TransitGatewayVpcAttachmentSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy
 */
export interface TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy(obj: TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderTransitGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewayVpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Volume is the Schema for the Volumes API
 *
 * @schema Volume
 */
export class Volume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Volume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'Volume',
  }

  /**
   * Renders a Kubernetes manifest for "Volume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeProps): any {
    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(props),
    };
  }

  /**
   * Defines a "Volume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeProps) {
    super(scope, id, {
      ...Volume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(resolved),
    };
  }
}

/**
 * Volume is the Schema for the Volumes API
 *
 * @schema Volume
 */
export interface VolumeProps {
  /**
   * @schema Volume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeSpec defines the desired state of Volume
   *
   * @schema Volume#spec
   */
  readonly spec: VolumeSpec;

}

/**
 * Converts an object of type 'VolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeProps(obj: VolumeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VolumeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeSpec defines the desired state of Volume
 *
 * @schema VolumeSpec
 */
export interface VolumeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VolumeSpec#deletionPolicy
   */
  readonly deletionPolicy?: VolumeSpecDeletionPolicy;

  /**
   * VolumeParameters defines the desired state of Volume
   *
   * @schema VolumeSpec#forProvider
   */
  readonly forProvider: VolumeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VolumeSpec#managementPolicies
   */
  readonly managementPolicies?: VolumeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VolumeSpec#providerConfigRef
   */
  readonly providerConfigRef?: VolumeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VolumeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VolumeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VolumeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VolumeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VolumeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpec(obj: VolumeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VolumeSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VolumeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VolumeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VolumeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VolumeSpecDeletionPolicy
 */
export enum VolumeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VolumeParameters defines the desired state of Volume
 *
 * @schema VolumeSpecForProvider
 */
export interface VolumeSpecForProvider {
  /**
   * The ID of the Availability Zone in which to create the volume. For example, us-east-1a.
   *
   * @schema VolumeSpecForProvider#availabilityZone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see Encryption by default (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the Amazon Elastic Compute Cloud User Guide.
   * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see Supported instance types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
   *
   * @schema VolumeSpecForProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
   * The following are the supported values for each volume type:
   * * gp3: 3,000-16,000 IOPS
   * * io1: 100-64,000 IOPS
   * * io2: 100-64,000 IOPS
   * io1 and io2 volumes support up to 64,000 IOPS only on Instances built on the Nitro System (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). Other instance families support performance up to 32,000 IOPS.
   * This parameter is required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS. This parameter is not supported for gp2, st1, sc1, or standard volumes.
   *
   * @schema VolumeSpecForProvider#iops
   */
  readonly iops?: number;

  /**
   * The identifier of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for Amazon EBS encryption. If this parameter is not specified, your AWS managed CMK for EBS is used. If KmsKeyId is specified, the encrypted state must be true.
   * You can specify the CMK using any of the following:
   * * Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
   * * Key alias. For example, alias/ExampleAlias.
   * * Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
   * * Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
   * AWS authenticates the CMK asynchronously. Therefore, if you specify an ID, alias, or ARN that is not valid, the action can appear to complete, but eventually fails.
   *
   * @schema VolumeSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema VolumeSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: VolumeSpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema VolumeSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: VolumeSpecForProviderKmsKeyIdSelector;

  /**
   * Indicates whether to enable Amazon EBS Multi-Attach. If you enable Multi-Attach, you can attach the volume to up to 16 Instances built on the Nitro System (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) in the same Availability Zone. This parameter is supported with io1 and io2 volumes only. For more information, see Amazon EBS Multi-Attach (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html) in the Amazon Elastic Compute Cloud User Guide.
   *
   * @schema VolumeSpecForProvider#multiAttachEnabled
   */
  readonly multiAttachEnabled?: boolean;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @schema VolumeSpecForProvider#outpostARN
   */
  readonly outpostArn?: string;

  /**
   * Region is which region the Volume will be created.
   *
   * @schema VolumeSpecForProvider#region
   */
  readonly region: string;

  /**
   * The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
   * The following are the supported volumes sizes for each volume type:
   * * gp2 and gp3: 1-16,384
   * * io1 and io2: 4-16,384
   * * st1 and sc1: 125-16,384
   * * standard: 1-1,024
   *
   * @schema VolumeSpecForProvider#size
   */
  readonly size?: number;

  /**
   * The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.
   *
   * @schema VolumeSpecForProvider#snapshotID
   */
  readonly snapshotId?: string;

  /**
   * The tags to apply to the volume during creation.
   *
   * @schema VolumeSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: VolumeSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema VolumeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   * This parameter is valid only for gp3 volumes.
   * Valid Range: Minimum value of 125. Maximum value of 1000.
   *
   * @schema VolumeSpecForProvider#throughput
   */
  readonly throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:
   * * General Purpose SSD: gp2 | gp3
   * * Provisioned IOPS SSD: io1 | io2
   * * Throughput Optimized HDD: st1
   * * Cold HDD: sc1
   * * Magnetic: standard
   * Throughput Optimized HDD (st1) and Cold HDD (sc1) volumes can't be used as boot volumes.
   * For more information, see Amazon EBS volume types (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the Amazon Elastic Compute Cloud User Guide.
   * Default: gp2
   *
   * @schema VolumeSpecForProvider#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'VolumeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProvider(obj: VolumeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZone': obj.availabilityZone,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_VolumeSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_VolumeSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'multiAttachEnabled': obj.multiAttachEnabled,
    'outpostARN': obj.outpostArn,
    'region': obj.region,
    'size': obj.size,
    'snapshotID': obj.snapshotId,
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_VolumeSpecForProviderTagSpecifications(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VolumeSpecManagementPolicies
 */
export enum VolumeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VolumeSpecProviderConfigRef
 */
export interface VolumeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VolumeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VolumeSpecProviderConfigRef#policy
   */
  readonly policy?: VolumeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VolumeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecProviderConfigRef(obj: VolumeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VolumeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VolumeSpecPublishConnectionDetailsTo
 */
export interface VolumeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VolumeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VolumeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VolumeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VolumeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VolumeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VolumeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecPublishConnectionDetailsTo(obj: VolumeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VolumeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VolumeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VolumeSpecWriteConnectionSecretToRef
 */
export interface VolumeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VolumeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VolumeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VolumeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecWriteConnectionSecretToRef(obj: VolumeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema VolumeSpecForProviderKmsKeyIdRef
 */
export interface VolumeSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VolumeSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VolumeSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: VolumeSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'VolumeSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderKmsKeyIdRef(obj: VolumeSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VolumeSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema VolumeSpecForProviderKmsKeyIdSelector
 */
export interface VolumeSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VolumeSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VolumeSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VolumeSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: VolumeSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'VolumeSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderKmsKeyIdSelector(obj: VolumeSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VolumeSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeSpecForProviderTagSpecifications
 */
export interface VolumeSpecForProviderTagSpecifications {
  /**
   * @schema VolumeSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema VolumeSpecForProviderTagSpecifications#tags
   */
  readonly tags?: VolumeSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'VolumeSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderTagSpecifications(obj: VolumeSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_VolumeSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VolumeSpecProviderConfigRefPolicy
 */
export interface VolumeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VolumeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VolumeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VolumeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VolumeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VolumeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecProviderConfigRefPolicy(obj: VolumeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VolumeSpecPublishConnectionDetailsToConfigRef
 */
export interface VolumeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VolumeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VolumeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VolumeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VolumeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecPublishConnectionDetailsToConfigRef(obj: VolumeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VolumeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VolumeSpecPublishConnectionDetailsToMetadata
 */
export interface VolumeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VolumeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VolumeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VolumeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VolumeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecPublishConnectionDetailsToMetadata(obj: VolumeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VolumeSpecForProviderKmsKeyIdRefPolicy
 */
export interface VolumeSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VolumeSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: VolumeSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VolumeSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: VolumeSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VolumeSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderKmsKeyIdRefPolicy(obj: VolumeSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VolumeSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface VolumeSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VolumeSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: VolumeSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VolumeSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: VolumeSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VolumeSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderKmsKeyIdSelectorPolicy(obj: VolumeSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeSpecForProviderTagSpecificationsTags
 */
export interface VolumeSpecForProviderTagSpecificationsTags {
  /**
   * @schema VolumeSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema VolumeSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VolumeSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecForProviderTagSpecificationsTags(obj: VolumeSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VolumeSpecProviderConfigRefPolicyResolution
 */
export enum VolumeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VolumeSpecProviderConfigRefPolicyResolve
 */
export enum VolumeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VolumeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VolumeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VolumeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VolumeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VolumeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeSpecPublishConnectionDetailsToConfigRefPolicy(obj: VolumeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VolumeSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum VolumeSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VolumeSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum VolumeSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VolumeSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum VolumeSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VolumeSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum VolumeSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VolumeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A VPC is a managed resource that represents an AWS Virtual Private Cloud.
 *
 * @schema VPC
 */
export class Vpc extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPC"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'VPC',
  }

  /**
   * Renders a Kubernetes manifest for "VPC".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcProps): any {
    return {
      ...Vpc.GVK,
      ...toJson_VpcProps(props),
    };
  }

  /**
   * Defines a "VPC" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcProps) {
    super(scope, id, {
      ...Vpc.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Vpc.GVK,
      ...toJson_VpcProps(resolved),
    };
  }
}

/**
 * A VPC is a managed resource that represents an AWS Virtual Private Cloud.
 *
 * @schema VPC
 */
export interface VpcProps {
  /**
   * @schema VPC#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A VPCSpec defines the desired state of a VPC.
   *
   * @schema VPC#spec
   */
  readonly spec: VpcSpec;

}

/**
 * Converts an object of type 'VpcProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcProps(obj: VpcProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A VPCSpec defines the desired state of a VPC.
 *
 * @schema VpcSpec
 */
export interface VpcSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcSpecDeletionPolicy;

  /**
   * VPCParameters define the desired state of an AWS Virtual Private Cloud.
   *
   * @schema VpcSpec#forProvider
   */
  readonly forProvider: VpcSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcSpec#managementPolicies
   */
  readonly managementPolicies?: VpcSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpec(obj: VpcSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcSpecDeletionPolicy
 */
export enum VpcSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCParameters define the desired state of an AWS Virtual Private Cloud.
 *
 * @schema VpcSpecForProvider
 */
export interface VpcSpecForProvider {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.
   *
   * @schema VpcSpecForProvider#amazonProvidedIpv6CidrBlock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean;

  /**
   * CIDRBlock is the IPv4 network range for the VPC, in CIDR notation. For example, 10.0.0.0/16.
   *
   * @schema VpcSpecForProvider#cidrBlock
   */
  readonly cidrBlock: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   *
   * @schema VpcSpecForProvider#enableDnsHostNames
   */
  readonly enableDnsHostNames?: boolean;

  /**
   * A boolean flag to enable/disable DNS support in the VPC
   *
   * @schema VpcSpecForProvider#enableDnsSupport
   */
  readonly enableDnsSupport?: boolean;

  /**
   * The allowed tenancy of instances launched into the VPC.
   *
   * @schema VpcSpecForProvider#instanceTenancy
   */
  readonly instanceTenancy?: string;

  /**
   * The IPv6 CIDR block from the IPv6 address pool. You must also specify Ipv6Pool in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @schema VpcSpecForProvider#ipv6CidrBlock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @schema VpcSpecForProvider#ipv6Pool
   */
  readonly ipv6Pool?: string;

  /**
   * Region is the region you'd like your VPC to be created in.
   *
   * @schema VpcSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Tags are used as identification helpers between AWS resources.
   *
   * @schema VpcSpecForProvider#tags
   */
  readonly tags?: VpcSpecForProviderTags[];

}

/**
 * Converts an object of type 'VpcSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecForProvider(obj: VpcSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonProvidedIpv6CidrBlock': obj.amazonProvidedIpv6CidrBlock,
    'cidrBlock': obj.cidrBlock,
    'enableDnsHostNames': obj.enableDnsHostNames,
    'enableDnsSupport': obj.enableDnsSupport,
    'instanceTenancy': obj.instanceTenancy,
    'ipv6CidrBlock': obj.ipv6CidrBlock,
    'ipv6Pool': obj.ipv6Pool,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_VpcSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcSpecManagementPolicies
 */
export enum VpcSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcSpecProviderConfigRef
 */
export interface VpcSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcSpecProviderConfigRef#policy
   */
  readonly policy?: VpcSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecProviderConfigRef(obj: VpcSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcSpecPublishConnectionDetailsTo
 */
export interface VpcSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecPublishConnectionDetailsTo(obj: VpcSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcSpecWriteConnectionSecretToRef
 */
export interface VpcSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecWriteConnectionSecretToRef(obj: VpcSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema VpcSpecForProviderTags
 */
export interface VpcSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema VpcSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema VpcSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'VpcSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecForProviderTags(obj: VpcSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcSpecProviderConfigRefPolicy
 */
export interface VpcSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecProviderConfigRefPolicy(obj: VpcSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecPublishConnectionDetailsToConfigRef(obj: VpcSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcSpecPublishConnectionDetailsToMetadata
 */
export interface VpcSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecPublishConnectionDetailsToMetadata(obj: VpcSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcSpecProviderConfigRefPolicyResolution
 */
export enum VpcSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcSpecProviderConfigRefPolicyResolve
 */
export enum VpcSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A VPCCIDRBlock is a managed resource that represents an secondary CIDR block for a VPC Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema VPCCIDRBlock
 */
export class VpccidrBlock extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCCIDRBlock"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'VPCCIDRBlock',
  }

  /**
   * Renders a Kubernetes manifest for "VPCCIDRBlock".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpccidrBlockProps): any {
    return {
      ...VpccidrBlock.GVK,
      ...toJson_VpccidrBlockProps(props),
    };
  }

  /**
   * Defines a "VPCCIDRBlock" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpccidrBlockProps) {
    super(scope, id, {
      ...VpccidrBlock.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpccidrBlock.GVK,
      ...toJson_VpccidrBlockProps(resolved),
    };
  }
}

/**
 * A VPCCIDRBlock is a managed resource that represents an secondary CIDR block for a VPC Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema VPCCIDRBlock
 */
export interface VpccidrBlockProps {
  /**
   * @schema VPCCIDRBlock#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A VPCCIDRBlockSpec defines the desired state of a VPCCIDRBlock.
   *
   * @schema VPCCIDRBlock#spec
   */
  readonly spec: VpccidrBlockSpec;

}

/**
 * Converts an object of type 'VpccidrBlockProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockProps(obj: VpccidrBlockProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpccidrBlockSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A VPCCIDRBlockSpec defines the desired state of a VPCCIDRBlock.
 *
 * @schema VpccidrBlockSpec
 */
export interface VpccidrBlockSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpccidrBlockSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpccidrBlockSpecDeletionPolicy;

  /**
   * VPCCIDRBlockParameters define the desired state of an VPC CIDR Block
   *
   * @schema VpccidrBlockSpec#forProvider
   */
  readonly forProvider: VpccidrBlockSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpccidrBlockSpec#managementPolicies
   */
  readonly managementPolicies?: VpccidrBlockSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpccidrBlockSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpccidrBlockSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpccidrBlockSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpccidrBlockSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpccidrBlockSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpccidrBlockSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpccidrBlockSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpec(obj: VpccidrBlockSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpccidrBlockSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpccidrBlockSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpccidrBlockSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpccidrBlockSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpccidrBlockSpecDeletionPolicy
 */
export enum VpccidrBlockSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCCIDRBlockParameters define the desired state of an VPC CIDR Block
 *
 * @schema VpccidrBlockSpecForProvider
 */
export interface VpccidrBlockSpecForProvider {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
   *
   * @schema VpccidrBlockSpecForProvider#amazonProvidedIpv6CidrBlock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @schema VpccidrBlockSpecForProvider#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify Ipv6Pool in the request.
   * To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @schema VpccidrBlockSpecForProvider#ipv6CdirBlock
   */
  readonly ipv6CdirBlock?: string;

  /**
   * The name of the location from which we advertise the IPV6 CIDR block. Use this parameter to limit the CiDR block to this location.
   * You must set AmazonProvidedIpv6CIDRBlock to true to use this parameter.
   * You can have one IPv6 CIDR block association per network border group.
   *
   * @schema VpccidrBlockSpecForProvider#ipv6CidrBlockNetworkBorderGroup
   */
  readonly ipv6CidrBlockNetworkBorderGroup?: string;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @schema VpccidrBlockSpecForProvider#ipv6Pool
   */
  readonly ipv6Pool?: string;

  /**
   * Region is the region you'd like your VPC CIDR to be created in.
   *
   * @schema VpccidrBlockSpecForProvider#region
   */
  readonly region: string;

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema VpccidrBlockSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to and retrieves its vpcId
   *
   * @schema VpccidrBlockSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpccidrBlockSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
   *
   * @schema VpccidrBlockSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpccidrBlockSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'VpccidrBlockSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecForProvider(obj: VpccidrBlockSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonProvidedIpv6CidrBlock': obj.amazonProvidedIpv6CidrBlock,
    'cidrBlock': obj.cidrBlock,
    'ipv6CdirBlock': obj.ipv6CdirBlock,
    'ipv6CidrBlockNetworkBorderGroup': obj.ipv6CidrBlockNetworkBorderGroup,
    'ipv6Pool': obj.ipv6Pool,
    'region': obj.region,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpccidrBlockSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpccidrBlockSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpccidrBlockSpecManagementPolicies
 */
export enum VpccidrBlockSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpccidrBlockSpecProviderConfigRef
 */
export interface VpccidrBlockSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockSpecProviderConfigRef#policy
   */
  readonly policy?: VpccidrBlockSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecProviderConfigRef(obj: VpccidrBlockSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsTo
 */
export interface VpccidrBlockSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpccidrBlockSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpccidrBlockSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpccidrBlockSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecPublishConnectionDetailsTo(obj: VpccidrBlockSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpccidrBlockSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpccidrBlockSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpccidrBlockSpecWriteConnectionSecretToRef
 */
export interface VpccidrBlockSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpccidrBlockSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpccidrBlockSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpccidrBlockSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecWriteConnectionSecretToRef(obj: VpccidrBlockSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to and retrieves its vpcId
 *
 * @schema VpccidrBlockSpecForProviderVpcIdRef
 */
export interface VpccidrBlockSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpccidrBlockSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecForProviderVpcIdRef(obj: VpccidrBlockSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
 *
 * @schema VpccidrBlockSpecForProviderVpcIdSelector
 */
export interface VpccidrBlockSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpccidrBlockSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecForProviderVpcIdSelector(obj: VpccidrBlockSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpccidrBlockSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockSpecProviderConfigRefPolicy
 */
export interface VpccidrBlockSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecProviderConfigRefPolicy(obj: VpccidrBlockSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRef
 */
export interface VpccidrBlockSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecPublishConnectionDetailsToConfigRef(obj: VpccidrBlockSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsToMetadata
 */
export interface VpccidrBlockSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpccidrBlockSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecPublishConnectionDetailsToMetadata(obj: VpccidrBlockSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdRefPolicy
 */
export interface VpccidrBlockSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecForProviderVpcIdRefPolicy(obj: VpccidrBlockSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdSelectorPolicy
 */
export interface VpccidrBlockSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecForProviderVpcIdSelectorPolicy(obj: VpccidrBlockSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockSpecProviderConfigRefPolicyResolution
 */
export enum VpccidrBlockSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockSpecProviderConfigRefPolicyResolve
 */
export enum VpccidrBlockSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdRefPolicyResolution
 */
export enum VpccidrBlockSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdRefPolicyResolve
 */
export enum VpccidrBlockSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpccidrBlockSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpccidrBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A VPCCIDRBlock is a managed resource that represents an secondary CIDR block for a VPC
 *
 * @schema VPCCIDRBlockV1Beta1
 */
export class VpccidrBlockV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCCIDRBlockV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'VPCCIDRBlock',
  }

  /**
   * Renders a Kubernetes manifest for "VPCCIDRBlockV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpccidrBlockV1Beta1Props): any {
    return {
      ...VpccidrBlockV1Beta1.GVK,
      ...toJson_VpccidrBlockV1Beta1Props(props),
    };
  }

  /**
   * Defines a "VPCCIDRBlockV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpccidrBlockV1Beta1Props) {
    super(scope, id, {
      ...VpccidrBlockV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpccidrBlockV1Beta1.GVK,
      ...toJson_VpccidrBlockV1Beta1Props(resolved),
    };
  }
}

/**
 * A VPCCIDRBlock is a managed resource that represents an secondary CIDR block for a VPC
 *
 * @schema VPCCIDRBlockV1Beta1
 */
export interface VpccidrBlockV1Beta1Props {
  /**
   * @schema VPCCIDRBlockV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A VPCCIDRBlockSpec defines the desired state of a VPCCIDRBlock.
   *
   * @schema VPCCIDRBlockV1Beta1#spec
   */
  readonly spec: VpccidrBlockV1Beta1Spec;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1Props(obj: VpccidrBlockV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpccidrBlockV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A VPCCIDRBlockSpec defines the desired state of a VPCCIDRBlock.
 *
 * @schema VpccidrBlockV1Beta1Spec
 */
export interface VpccidrBlockV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpccidrBlockV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: VpccidrBlockV1Beta1SpecDeletionPolicy;

  /**
   * VPCCIDRBlockParameters define the desired state of an VPC CIDR Block
   *
   * @schema VpccidrBlockV1Beta1Spec#forProvider
   */
  readonly forProvider: VpccidrBlockV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpccidrBlockV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: VpccidrBlockV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpccidrBlockV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: VpccidrBlockV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpccidrBlockV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpccidrBlockV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1Spec(obj: VpccidrBlockV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpccidrBlockV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpccidrBlockV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpccidrBlockV1Beta1SpecDeletionPolicy
 */
export enum VpccidrBlockV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCCIDRBlockParameters define the desired state of an VPC CIDR Block
 *
 * @schema VpccidrBlockV1Beta1SpecForProvider
 */
export interface VpccidrBlockV1Beta1SpecForProvider {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#amazonProvidedIpv6CidrBlock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify Ipv6Pool in the request.
   * To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#ipv6CdirBlock
   */
  readonly ipv6CdirBlock?: string;

  /**
   * The name of the location from which we advertise the IPV6 CIDR block. Use this parameter to limit the CiDR block to this location.
   * You must set AmazonProvidedIpv6CIDRBlock to true to use this parameter.
   * You can have one IPv6 CIDR block association per network border group.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#ipv6CidrBlockNetworkBorderGroup
   */
  readonly ipv6CidrBlockNetworkBorderGroup?: string;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#ipv6Pool
   */
  readonly ipv6Pool?: string;

  /**
   * Region is the region you'd like your VPC CIDR to be created in.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to and retrieves its vpcId
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpccidrBlockV1Beta1SpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
   *
   * @schema VpccidrBlockV1Beta1SpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpccidrBlockV1Beta1SpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecForProvider(obj: VpccidrBlockV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonProvidedIpv6CidrBlock': obj.amazonProvidedIpv6CidrBlock,
    'cidrBlock': obj.cidrBlock,
    'ipv6CdirBlock': obj.ipv6CdirBlock,
    'ipv6CidrBlockNetworkBorderGroup': obj.ipv6CidrBlockNetworkBorderGroup,
    'ipv6Pool': obj.ipv6Pool,
    'region': obj.region,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpccidrBlockV1Beta1SpecManagementPolicies
 */
export enum VpccidrBlockV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpccidrBlockV1Beta1SpecProviderConfigRef
 */
export interface VpccidrBlockV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: VpccidrBlockV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecProviderConfigRef(obj: VpccidrBlockV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo
 */
export interface VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo(obj: VpccidrBlockV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef
 */
export interface VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef(obj: VpccidrBlockV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to and retrieves its vpcId
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRef
 */
export interface VpccidrBlockV1Beta1SpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdRef(obj: VpccidrBlockV1Beta1SpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelector
 */
export interface VpccidrBlockV1Beta1SpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdSelector(obj: VpccidrBlockV1Beta1SpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockV1Beta1SpecProviderConfigRefPolicy
 */
export interface VpccidrBlockV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecProviderConfigRefPolicy(obj: VpccidrBlockV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata(obj: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy
 */
export interface VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy(obj: VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy
 */
export interface VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy(obj: VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum VpccidrBlockV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolution
 */
export enum VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolve
 */
export enum VpccidrBlockV1Beta1SpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpccidrBlockV1Beta1SpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpccidrBlockV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCEndpoint is the Schema for the VPCEndpoints API
 *
 * @schema VPCEndpoint
 */
export class VpcEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'VPCEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "VPCEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcEndpointProps): any {
    return {
      ...VpcEndpoint.GVK,
      ...toJson_VpcEndpointProps(props),
    };
  }

  /**
   * Defines a "VPCEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcEndpointProps) {
    super(scope, id, {
      ...VpcEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcEndpoint.GVK,
      ...toJson_VpcEndpointProps(resolved),
    };
  }
}

/**
 * VPCEndpoint is the Schema for the VPCEndpoints API
 *
 * @schema VPCEndpoint
 */
export interface VpcEndpointProps {
  /**
   * @schema VPCEndpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCEndpointSpec defines the desired state of VPCEndpoint
   *
   * @schema VPCEndpoint#spec
   */
  readonly spec: VpcEndpointSpec;

}

/**
 * Converts an object of type 'VpcEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointProps(obj: VpcEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcEndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCEndpointSpec defines the desired state of VPCEndpoint
 *
 * @schema VpcEndpointSpec
 */
export interface VpcEndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcEndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcEndpointSpecDeletionPolicy;

  /**
   * VPCEndpointParameters defines the desired state of VPCEndpoint
   *
   * @schema VpcEndpointSpec#forProvider
   */
  readonly forProvider: VpcEndpointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcEndpointSpec#managementPolicies
   */
  readonly managementPolicies?: VpcEndpointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcEndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcEndpointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcEndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcEndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcEndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcEndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcEndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpec(obj: VpcEndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcEndpointSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcEndpointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcEndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcEndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcEndpointSpecDeletionPolicy
 */
export enum VpcEndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCEndpointParameters defines the desired state of VPCEndpoint
 *
 * @schema VpcEndpointSpecForProvider
 */
export interface VpcEndpointSpecForProvider {
  /**
   * The DNS options for the endpoint.
   *
   * @schema VpcEndpointSpecForProvider#dnsOptions
   */
  readonly dnsOptions?: VpcEndpointSpecForProviderDnsOptions;

  /**
   * The IP address type for the endpoint.
   *
   * @schema VpcEndpointSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * (Interface and gateway endpoints) A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.
   *
   * @schema VpcEndpointSpecForProvider#policyDocument
   */
  readonly policyDocument?: string;

  /**
   * (Interface endpoint) Indicates whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, kinesis.us-east-1.amazonaws.com), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.
   * To use a private hosted zone, you must set the following VPC attributes to true: enableDnsHostnames and enableDnsSupport. Use ModifyVpcAttribute to set the VPC attributes.
   * Default: true
   *
   * @schema VpcEndpointSpecForProvider#privateDNSEnabled
   */
  readonly privateDnsEnabled?: boolean;

  /**
   * Region is which region the VPCEndpoint will be created.
   *
   * @schema VpcEndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * RouteTableIDRefs is a list of references to RouteTables used to set the RouteTableIDs.
   *
   * @schema VpcEndpointSpecForProvider#routeTableIdRefs
   */
  readonly routeTableIdRefs?: VpcEndpointSpecForProviderRouteTableIdRefs[];

  /**
   * RouteTableIDsSelector selects references to RouteTables used to set the RouteTableIDs.
   *
   * @schema VpcEndpointSpecForProvider#routeTableIdSelector
   */
  readonly routeTableIdSelector?: VpcEndpointSpecForProviderRouteTableIdSelector;

  /**
   * (Gateway endpoint) One or more route table IDs.
   *
   * @schema VpcEndpointSpecForProvider#routeTableIds
   */
  readonly routeTableIds?: string[];

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema VpcEndpointSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: VpcEndpointSpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema VpcEndpointSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: VpcEndpointSpecForProviderSecurityGroupIdSelector;

  /**
   * (Interface endpoint) The ID of one or more security groups to associate with the endpoint network interface.
   *
   * @schema VpcEndpointSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The name of the endpoint service.
   *
   * @schema VpcEndpointSpecForProvider#serviceName
   */
  readonly serviceName: string;

  /**
   * The subnet configurations for the endpoint.
   *
   * @schema VpcEndpointSpecForProvider#subnetConfigurations
   */
  readonly subnetConfigurations?: VpcEndpointSpecForProviderSubnetConfigurations[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcEndpointSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: VpcEndpointSpecForProviderSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcEndpointSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: VpcEndpointSpecForProviderSubnetIdSelector;

  /**
   * (Interface and Gateway Load Balancer endpoints) The ID of one or more subnets in which to create an endpoint network interface. For a Gateway Load Balancer endpoint, you can specify one subnet only.
   *
   * @schema VpcEndpointSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * The tags to associate with the endpoint.
   *
   * @schema VpcEndpointSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: VpcEndpointSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema VpcEndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of endpoint.
   * Default: Gateway
   *
   * @schema VpcEndpointSpecForProvider#vpcEndpointType
   */
  readonly vpcEndpointType?: string;

  /**
   * The ID of the VPC. You must specify this parameter in the request.
   *
   * @schema VpcEndpointSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef is a reference to an API used to set the VPCID.
   *
   * @schema VpcEndpointSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpcEndpointSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects references to API used to set the VPCID.
   *
   * @schema VpcEndpointSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpcEndpointSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProvider(obj: VpcEndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsOptions': toJson_VpcEndpointSpecForProviderDnsOptions(obj.dnsOptions),
    'ipAddressType': obj.ipAddressType,
    'policyDocument': obj.policyDocument,
    'privateDNSEnabled': obj.privateDnsEnabled,
    'region': obj.region,
    'routeTableIdRefs': obj.routeTableIdRefs?.map(y => toJson_VpcEndpointSpecForProviderRouteTableIdRefs(y)),
    'routeTableIdSelector': toJson_VpcEndpointSpecForProviderRouteTableIdSelector(obj.routeTableIdSelector),
    'routeTableIds': obj.routeTableIds?.map(y => y),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_VpcEndpointSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_VpcEndpointSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'serviceName': obj.serviceName,
    'subnetConfigurations': obj.subnetConfigurations?.map(y => toJson_VpcEndpointSpecForProviderSubnetConfigurations(y)),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_VpcEndpointSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_VpcEndpointSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_VpcEndpointSpecForProviderTagSpecifications(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcEndpointType': obj.vpcEndpointType,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpcEndpointSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpcEndpointSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcEndpointSpecManagementPolicies
 */
export enum VpcEndpointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcEndpointSpecProviderConfigRef
 */
export interface VpcEndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecProviderConfigRef#policy
   */
  readonly policy?: VpcEndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecProviderConfigRef(obj: VpcEndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsTo
 */
export interface VpcEndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcEndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcEndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcEndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecPublishConnectionDetailsTo(obj: VpcEndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcEndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcEndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcEndpointSpecWriteConnectionSecretToRef
 */
export interface VpcEndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcEndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcEndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcEndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecWriteConnectionSecretToRef(obj: VpcEndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The DNS options for the endpoint.
 *
 * @schema VpcEndpointSpecForProviderDnsOptions
 */
export interface VpcEndpointSpecForProviderDnsOptions {
  /**
   * @schema VpcEndpointSpecForProviderDnsOptions#dnsRecordIPType
   */
  readonly dnsRecordIpType?: string;

  /**
   * @schema VpcEndpointSpecForProviderDnsOptions#privateDNSOnlyForInboundResolverEndpoint
   */
  readonly privateDnsOnlyForInboundResolverEndpoint?: boolean;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderDnsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderDnsOptions(obj: VpcEndpointSpecForProviderDnsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRecordIPType': obj.dnsRecordIpType,
    'privateDNSOnlyForInboundResolverEndpoint': obj.privateDnsOnlyForInboundResolverEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdRefs
 */
export interface VpcEndpointSpecForProviderRouteTableIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdRefs#policy
   */
  readonly policy?: VpcEndpointSpecForProviderRouteTableIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderRouteTableIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderRouteTableIdRefs(obj: VpcEndpointSpecForProviderRouteTableIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecForProviderRouteTableIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteTableIDsSelector selects references to RouteTables used to set the RouteTableIDs.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdSelector
 */
export interface VpcEndpointSpecForProviderRouteTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdSelector#policy
   */
  readonly policy?: VpcEndpointSpecForProviderRouteTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderRouteTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderRouteTableIdSelector(obj: VpcEndpointSpecForProviderRouteTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointSpecForProviderRouteTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdRefs
 */
export interface VpcEndpointSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSecurityGroupIdRefs(obj: VpcEndpointSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdSelector
 */
export interface VpcEndpointSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSecurityGroupIdSelector(obj: VpcEndpointSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointSpecForProviderSubnetConfigurations
 */
export interface VpcEndpointSpecForProviderSubnetConfigurations {
  /**
   * @schema VpcEndpointSpecForProviderSubnetConfigurations#ipv4
   */
  readonly ipv4?: string;

  /**
   * @schema VpcEndpointSpecForProviderSubnetConfigurations#ipv6
   */
  readonly ipv6?: string;

  /**
   * @schema VpcEndpointSpecForProviderSubnetConfigurations#subnetID
   */
  readonly subnetId?: string;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSubnetConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSubnetConfigurations(obj: VpcEndpointSpecForProviderSubnetConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4': obj.ipv4,
    'ipv6': obj.ipv6,
    'subnetID': obj.subnetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdRefs
 */
export interface VpcEndpointSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: VpcEndpointSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSubnetIdRefs(obj: VpcEndpointSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdSelector
 */
export interface VpcEndpointSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: VpcEndpointSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSubnetIdSelector(obj: VpcEndpointSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointSpecForProviderTagSpecifications
 */
export interface VpcEndpointSpecForProviderTagSpecifications {
  /**
   * @schema VpcEndpointSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema VpcEndpointSpecForProviderTagSpecifications#tags
   */
  readonly tags?: VpcEndpointSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderTagSpecifications(obj: VpcEndpointSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_VpcEndpointSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef is a reference to an API used to set the VPCID.
 *
 * @schema VpcEndpointSpecForProviderVpcIdRef
 */
export interface VpcEndpointSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpcEndpointSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderVpcIdRef(obj: VpcEndpointSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects references to API used to set the VPCID.
 *
 * @schema VpcEndpointSpecForProviderVpcIdSelector
 */
export interface VpcEndpointSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpcEndpointSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderVpcIdSelector(obj: VpcEndpointSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecProviderConfigRefPolicy
 */
export interface VpcEndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecProviderConfigRefPolicy(obj: VpcEndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcEndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcEndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecPublishConnectionDetailsToConfigRef(obj: VpcEndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsToMetadata
 */
export interface VpcEndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcEndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecPublishConnectionDetailsToMetadata(obj: VpcEndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdRefsPolicy
 */
export interface VpcEndpointSpecForProviderRouteTableIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdRefsPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdRefsPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderRouteTableIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderRouteTableIdRefsPolicy(obj: VpcEndpointSpecForProviderRouteTableIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdSelectorPolicy
 */
export interface VpcEndpointSpecForProviderRouteTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderRouteTableIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderRouteTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderRouteTableIdSelectorPolicy(obj: VpcEndpointSpecForProviderRouteTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy(obj: VpcEndpointSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj: VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdRefsPolicy
 */
export interface VpcEndpointSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSubnetIdRefsPolicy(obj: VpcEndpointSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdSelectorPolicy
 */
export interface VpcEndpointSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderSubnetIdSelectorPolicy(obj: VpcEndpointSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointSpecForProviderTagSpecificationsTags
 */
export interface VpcEndpointSpecForProviderTagSpecificationsTags {
  /**
   * @schema VpcEndpointSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema VpcEndpointSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderTagSpecificationsTags(obj: VpcEndpointSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecForProviderVpcIdRefPolicy
 */
export interface VpcEndpointSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderVpcIdRefPolicy(obj: VpcEndpointSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointSpecForProviderVpcIdSelectorPolicy
 */
export interface VpcEndpointSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecForProviderVpcIdSelectorPolicy(obj: VpcEndpointSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecProviderConfigRefPolicyResolution
 */
export enum VpcEndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecProviderConfigRefPolicyResolve
 */
export enum VpcEndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolution
 */
export enum VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolve
 */
export enum VpcEndpointSpecForProviderRouteTableIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolution
 */
export enum VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolve
 */
export enum VpcEndpointSpecForProviderRouteTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum VpcEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum VpcEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum VpcEndpointSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum VpcEndpointSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum VpcEndpointSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderVpcIdRefPolicyResolution
 */
export enum VpcEndpointSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderVpcIdRefPolicyResolve
 */
export enum VpcEndpointSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpcEndpointSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpcEndpointSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCEndpointServiceConfiguration is the Schema for the VPCEndpointServiceConfigurations API
 *
 * @schema VPCEndpointServiceConfiguration
 */
export class VpcEndpointServiceConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCEndpointServiceConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'VPCEndpointServiceConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "VPCEndpointServiceConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcEndpointServiceConfigurationProps): any {
    return {
      ...VpcEndpointServiceConfiguration.GVK,
      ...toJson_VpcEndpointServiceConfigurationProps(props),
    };
  }

  /**
   * Defines a "VPCEndpointServiceConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcEndpointServiceConfigurationProps) {
    super(scope, id, {
      ...VpcEndpointServiceConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcEndpointServiceConfiguration.GVK,
      ...toJson_VpcEndpointServiceConfigurationProps(resolved),
    };
  }
}

/**
 * VPCEndpointServiceConfiguration is the Schema for the VPCEndpointServiceConfigurations API
 *
 * @schema VPCEndpointServiceConfiguration
 */
export interface VpcEndpointServiceConfigurationProps {
  /**
   * @schema VPCEndpointServiceConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCEndpointServiceConfigurationSpec defines the desired state of VPCEndpointServiceConfiguration
   *
   * @schema VPCEndpointServiceConfiguration#spec
   */
  readonly spec: VpcEndpointServiceConfigurationSpec;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationProps(obj: VpcEndpointServiceConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcEndpointServiceConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCEndpointServiceConfigurationSpec defines the desired state of VPCEndpointServiceConfiguration
 *
 * @schema VpcEndpointServiceConfigurationSpec
 */
export interface VpcEndpointServiceConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcEndpointServiceConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcEndpointServiceConfigurationSpecDeletionPolicy;

  /**
   * VPCEndpointServiceConfigurationParameters defines the desired state of VPCEndpointServiceConfiguration
   *
   * @schema VpcEndpointServiceConfigurationSpec#forProvider
   */
  readonly forProvider: VpcEndpointServiceConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcEndpointServiceConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: VpcEndpointServiceConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcEndpointServiceConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcEndpointServiceConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcEndpointServiceConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcEndpointServiceConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpec(obj: VpcEndpointServiceConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcEndpointServiceConfigurationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcEndpointServiceConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcEndpointServiceConfigurationSpecDeletionPolicy
 */
export enum VpcEndpointServiceConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCEndpointServiceConfigurationParameters defines the desired state of VPCEndpointServiceConfiguration
 *
 * @schema VpcEndpointServiceConfigurationSpecForProvider
 */
export interface VpcEndpointServiceConfigurationSpecForProvider {
  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted manually.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#acceptanceRequired
   */
  readonly acceptanceRequired?: boolean;

  /**
   * GatewayLoadBalancerARNRefs is a list of references to GatewayLoadBalancerARNs used to set the GatewayLoadBalancerARNs.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#gatewayLoadBalancerARNRefs
   */
  readonly gatewayLoadBalancerArnRefs?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs[];

  /**
   * GatewayLoadBalancerARNSelector selects references to GatewayLoadBalancerARNs used to set the GatewayLoadBalancerARNs.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#gatewayLoadBalancerARNSelector
   */
  readonly gatewayLoadBalancerArnSelector?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector;

  /**
   * The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#gatewayLoadBalancerARNs
   */
  readonly gatewayLoadBalancerArNs?: string[];

  /**
   * NetworkLoadBalancerARNRefs is a list of references to NetworkLoadBalancerARNs used to set the NetworkLoadBalancerARNs.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#networkLoadBalancerARNRefs
   */
  readonly networkLoadBalancerArnRefs?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs[];

  /**
   * NetworkLoadBalancerARNSelector selects references to NetworkLoadBalancerARNs used to set the NetworkLoadBalancerARNs.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#networkLoadBalancerARNSelector
   */
  readonly networkLoadBalancerArnSelector?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector;

  /**
   * The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#networkLoadBalancerARNs
   */
  readonly networkLoadBalancerArNs?: string[];

  /**
   * (Interface endpoint configuration) The private DNS name to assign to the VPC endpoint service.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#privateDNSName
   */
  readonly privateDnsName?: string;

  /**
   * Region is which region the VPCEndpointServiceConfiguration will be created.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The supported IP address types. The possible values are ipv4 and ipv6.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#supportedIPAddressTypes
   */
  readonly supportedIpAddressTypes?: string[];

  /**
   * The tags to associate with the service.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: VpcEndpointServiceConfigurationSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema VpcEndpointServiceConfigurationSpecForProvider#tags
   */
  readonly tags?: VpcEndpointServiceConfigurationSpecForProviderTags[];

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProvider(obj: VpcEndpointServiceConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptanceRequired': obj.acceptanceRequired,
    'gatewayLoadBalancerARNRefs': obj.gatewayLoadBalancerArnRefs?.map(y => toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs(y)),
    'gatewayLoadBalancerARNSelector': toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector(obj.gatewayLoadBalancerArnSelector),
    'gatewayLoadBalancerARNs': obj.gatewayLoadBalancerArNs?.map(y => y),
    'networkLoadBalancerARNRefs': obj.networkLoadBalancerArnRefs?.map(y => toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs(y)),
    'networkLoadBalancerARNSelector': toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector(obj.networkLoadBalancerArnSelector),
    'networkLoadBalancerARNs': obj.networkLoadBalancerArNs?.map(y => y),
    'privateDNSName': obj.privateDnsName,
    'region': obj.region,
    'supportedIPAddressTypes': obj.supportedIpAddressTypes?.map(y => y),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_VpcEndpointServiceConfigurationSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_VpcEndpointServiceConfigurationSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcEndpointServiceConfigurationSpecManagementPolicies
 */
export enum VpcEndpointServiceConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcEndpointServiceConfigurationSpecProviderConfigRef
 */
export interface VpcEndpointServiceConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointServiceConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointServiceConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecProviderConfigRef(obj: VpcEndpointServiceConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo
 */
export interface VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo(obj: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef
 */
export interface VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef(obj: VpcEndpointServiceConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs
 */
export interface VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs(obj: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayLoadBalancerARNSelector selects references to GatewayLoadBalancerARNs used to set the GatewayLoadBalancerARNs.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector
 */
export interface VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector(obj: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs
 */
export interface VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs(obj: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkLoadBalancerARNSelector selects references to NetworkLoadBalancerARNs used to set the NetworkLoadBalancerARNs.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector
 */
export interface VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector(obj: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecifications
 */
export interface VpcEndpointServiceConfigurationSpecForProviderTagSpecifications {
  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecifications#tags
   */
  readonly tags?: VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderTagSpecifications(obj: VpcEndpointServiceConfigurationSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointServiceConfigurationSpecForProviderTags
 */
export interface VpcEndpointServiceConfigurationSpecForProviderTags {
  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderTags(obj: VpcEndpointServiceConfigurationSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy
 */
export interface VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy(obj: VpcEndpointServiceConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef(obj: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata(obj: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy
 */
export interface VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy(obj: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy
 */
export interface VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy(obj: VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy
 */
export interface VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy(obj: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy
 */
export interface VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy(obj: VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags
 */
export interface VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags {
  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags(obj: VpcEndpointServiceConfigurationSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecForProviderGatewayLoadBalancerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecForProviderNetworkLoadBalancerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcEndpointServiceConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCPeeringConnection is the Schema for the VPCPeeringConnections API
 *
 * @schema VPCPeeringConnection
 */
export class VpcPeeringConnection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCPeeringConnection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1alpha1',
    kind: 'VPCPeeringConnection',
  }

  /**
   * Renders a Kubernetes manifest for "VPCPeeringConnection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcPeeringConnectionProps): any {
    return {
      ...VpcPeeringConnection.GVK,
      ...toJson_VpcPeeringConnectionProps(props),
    };
  }

  /**
   * Defines a "VPCPeeringConnection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcPeeringConnectionProps) {
    super(scope, id, {
      ...VpcPeeringConnection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcPeeringConnection.GVK,
      ...toJson_VpcPeeringConnectionProps(resolved),
    };
  }
}

/**
 * VPCPeeringConnection is the Schema for the VPCPeeringConnections API
 *
 * @schema VPCPeeringConnection
 */
export interface VpcPeeringConnectionProps {
  /**
   * @schema VPCPeeringConnection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCPeeringConnectionSpec defines the desired state of VPCPeeringConnection
   *
   * @schema VPCPeeringConnection#spec
   */
  readonly spec: VpcPeeringConnectionSpec;

}

/**
 * Converts an object of type 'VpcPeeringConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionProps(obj: VpcPeeringConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcPeeringConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCPeeringConnectionSpec defines the desired state of VPCPeeringConnection
 *
 * @schema VpcPeeringConnectionSpec
 */
export interface VpcPeeringConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcPeeringConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcPeeringConnectionSpecDeletionPolicy;

  /**
   * VPCPeeringConnectionParameters defines the desired state of VPCPeeringConnection
   *
   * @schema VpcPeeringConnectionSpec#forProvider
   */
  readonly forProvider: VpcPeeringConnectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcPeeringConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: VpcPeeringConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcPeeringConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcPeeringConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcPeeringConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcPeeringConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcPeeringConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcPeeringConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpec(obj: VpcPeeringConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcPeeringConnectionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcPeeringConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcPeeringConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcPeeringConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcPeeringConnectionSpecDeletionPolicy
 */
export enum VpcPeeringConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCPeeringConnectionParameters defines the desired state of VPCPeeringConnection
 *
 * @schema VpcPeeringConnectionSpecForProvider
 */
export interface VpcPeeringConnectionSpecForProvider {
  /**
   * Automatically accepts the peering connection. If this is not set, the peering connection will be created, but will be in pending-acceptance state. This will only lead to an active connection if both VPCs are in the same tenant.
   *
   * @schema VpcPeeringConnectionSpecForProvider#acceptRequest
   */
  readonly acceptRequest?: boolean;

  /**
   * AccepterRequesterPeeringOptions describes the Accepter VPC peering connection options.
   *
   * @schema VpcPeeringConnectionSpecForProvider#accepterPeeringOptions
   */
  readonly accepterPeeringOptions?: VpcPeeringConnectionSpecForProviderAccepterPeeringOptions;

  /**
   * The Amazon Web Services account ID of the owner of the accepter VPC.
   * Default: Your Amazon Web Services account ID
   *
   * @schema VpcPeeringConnectionSpecForProvider#peerOwnerID
   */
  readonly peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   * Default: The Region in which you make the request.
   *
   * @schema VpcPeeringConnectionSpecForProvider#peerRegion
   */
  readonly peerRegion?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
   *
   * @schema VpcPeeringConnectionSpecForProvider#peerVPCID
   */
  readonly peerVpcid?: string;

  /**
   * PeerVPCIDRef is a reference to an API used to set the PeerVPCID.
   *
   * @schema VpcPeeringConnectionSpecForProvider#peerVPCIDRef
   */
  readonly peerVpcidRef?: VpcPeeringConnectionSpecForProviderPeerVpcidRef;

  /**
   * PeerVPCIDSelector selects references to API used to set the PeerVPCID.
   *
   * @schema VpcPeeringConnectionSpecForProvider#peerVPCIDSelector
   */
  readonly peerVpcidSelector?: VpcPeeringConnectionSpecForProviderPeerVpcidSelector;

  /**
   * Region is which region the VPCPeeringConnection will be created.
   *
   * @schema VpcPeeringConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * RequesterPeeringOptions describes the Requester VPC peering connection options.
   *
   * @schema VpcPeeringConnectionSpecForProvider#requesterPeeringOptions
   */
  readonly requesterPeeringOptions?: VpcPeeringConnectionSpecForProviderRequesterPeeringOptions;

  /**
   * The tags to assign to the peering connection.
   *
   * @schema VpcPeeringConnectionSpecForProvider#tagSpecifications
   */
  readonly tagSpecifications?: VpcPeeringConnectionSpecForProviderTagSpecifications[];

  /**
   * Metadata tagging key value pairs
   *
   * @schema VpcPeeringConnectionSpecForProvider#tags
   */
  readonly tags?: VpcPeeringConnectionSpecForProviderTags[];

  /**
   * The ID of the requester VPC. You must specify this parameter in the request.
   *
   * @schema VpcPeeringConnectionSpecForProvider#vpcID
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef is a reference to an API used to set the VPCID.
   *
   * @schema VpcPeeringConnectionSpecForProvider#vpcIDRef
   */
  readonly vpcIdRef?: VpcPeeringConnectionSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects references to API used to set the VPCID.
   *
   * @schema VpcPeeringConnectionSpecForProvider#vpcIDSelector
   */
  readonly vpcIdSelector?: VpcPeeringConnectionSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProvider(obj: VpcPeeringConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptRequest': obj.acceptRequest,
    'accepterPeeringOptions': toJson_VpcPeeringConnectionSpecForProviderAccepterPeeringOptions(obj.accepterPeeringOptions),
    'peerOwnerID': obj.peerOwnerId,
    'peerRegion': obj.peerRegion,
    'peerVPCID': obj.peerVpcid,
    'peerVPCIDRef': toJson_VpcPeeringConnectionSpecForProviderPeerVpcidRef(obj.peerVpcidRef),
    'peerVPCIDSelector': toJson_VpcPeeringConnectionSpecForProviderPeerVpcidSelector(obj.peerVpcidSelector),
    'region': obj.region,
    'requesterPeeringOptions': toJson_VpcPeeringConnectionSpecForProviderRequesterPeeringOptions(obj.requesterPeeringOptions),
    'tagSpecifications': obj.tagSpecifications?.map(y => toJson_VpcPeeringConnectionSpecForProviderTagSpecifications(y)),
    'tags': obj.tags?.map(y => toJson_VpcPeeringConnectionSpecForProviderTags(y)),
    'vpcID': obj.vpcId,
    'vpcIDRef': toJson_VpcPeeringConnectionSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIDSelector': toJson_VpcPeeringConnectionSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcPeeringConnectionSpecManagementPolicies
 */
export enum VpcPeeringConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcPeeringConnectionSpecProviderConfigRef
 */
export interface VpcPeeringConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcPeeringConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcPeeringConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: VpcPeeringConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecProviderConfigRef(obj: VpcPeeringConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcPeeringConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsTo
 */
export interface VpcPeeringConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecPublishConnectionDetailsTo(obj: VpcPeeringConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcPeeringConnectionSpecWriteConnectionSecretToRef
 */
export interface VpcPeeringConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcPeeringConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcPeeringConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecWriteConnectionSecretToRef(obj: VpcPeeringConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccepterRequesterPeeringOptions describes the Accepter VPC peering connection options.
 *
 * @schema VpcPeeringConnectionSpecForProviderAccepterPeeringOptions
 */
export interface VpcPeeringConnectionSpecForProviderAccepterPeeringOptions {
  /**
   * @schema VpcPeeringConnectionSpecForProviderAccepterPeeringOptions#allowDNSResolutionFromRemoteVPC
   */
  readonly allowDnsResolutionFromRemoteVpc?: boolean;

  /**
   * @schema VpcPeeringConnectionSpecForProviderAccepterPeeringOptions#allowEgressFromLocalClassicLinkToRemoteVPC
   */
  readonly allowEgressFromLocalClassicLinkToRemoteVpc?: boolean;

  /**
   * @schema VpcPeeringConnectionSpecForProviderAccepterPeeringOptions#allowEgressFromLocalVPCToRemoteClassicLink
   */
  readonly allowEgressFromLocalVpcToRemoteClassicLink?: boolean;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderAccepterPeeringOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderAccepterPeeringOptions(obj: VpcPeeringConnectionSpecForProviderAccepterPeeringOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowDNSResolutionFromRemoteVPC': obj.allowDnsResolutionFromRemoteVpc,
    'allowEgressFromLocalClassicLinkToRemoteVPC': obj.allowEgressFromLocalClassicLinkToRemoteVpc,
    'allowEgressFromLocalVPCToRemoteClassicLink': obj.allowEgressFromLocalVpcToRemoteClassicLink,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PeerVPCIDRef is a reference to an API used to set the PeerVPCID.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRef
 */
export interface VpcPeeringConnectionSpecForProviderPeerVpcidRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRef#policy
   */
  readonly policy?: VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderPeerVpcidRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderPeerVpcidRef(obj: VpcPeeringConnectionSpecForProviderPeerVpcidRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PeerVPCIDSelector selects references to API used to set the PeerVPCID.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelector
 */
export interface VpcPeeringConnectionSpecForProviderPeerVpcidSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelector#policy
   */
  readonly policy?: VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderPeerVpcidSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderPeerVpcidSelector(obj: VpcPeeringConnectionSpecForProviderPeerVpcidSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequesterPeeringOptions describes the Requester VPC peering connection options.
 *
 * @schema VpcPeeringConnectionSpecForProviderRequesterPeeringOptions
 */
export interface VpcPeeringConnectionSpecForProviderRequesterPeeringOptions {
  /**
   * @schema VpcPeeringConnectionSpecForProviderRequesterPeeringOptions#allowDNSResolutionFromRemoteVPC
   */
  readonly allowDnsResolutionFromRemoteVpc?: boolean;

  /**
   * @schema VpcPeeringConnectionSpecForProviderRequesterPeeringOptions#allowEgressFromLocalClassicLinkToRemoteVPC
   */
  readonly allowEgressFromLocalClassicLinkToRemoteVpc?: boolean;

  /**
   * @schema VpcPeeringConnectionSpecForProviderRequesterPeeringOptions#allowEgressFromLocalVPCToRemoteClassicLink
   */
  readonly allowEgressFromLocalVpcToRemoteClassicLink?: boolean;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderRequesterPeeringOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderRequesterPeeringOptions(obj: VpcPeeringConnectionSpecForProviderRequesterPeeringOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowDNSResolutionFromRemoteVPC': obj.allowDnsResolutionFromRemoteVpc,
    'allowEgressFromLocalClassicLinkToRemoteVPC': obj.allowEgressFromLocalClassicLinkToRemoteVpc,
    'allowEgressFromLocalVPCToRemoteClassicLink': obj.allowEgressFromLocalVpcToRemoteClassicLink,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcPeeringConnectionSpecForProviderTagSpecifications
 */
export interface VpcPeeringConnectionSpecForProviderTagSpecifications {
  /**
   * @schema VpcPeeringConnectionSpecForProviderTagSpecifications#resourceType
   */
  readonly resourceType?: string;

  /**
   * @schema VpcPeeringConnectionSpecForProviderTagSpecifications#tags
   */
  readonly tags?: VpcPeeringConnectionSpecForProviderTagSpecificationsTags[];

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderTagSpecifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderTagSpecifications(obj: VpcPeeringConnectionSpecForProviderTagSpecifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'tags': obj.tags?.map(y => toJson_VpcPeeringConnectionSpecForProviderTagSpecificationsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcPeeringConnectionSpecForProviderTags
 */
export interface VpcPeeringConnectionSpecForProviderTags {
  /**
   * @schema VpcPeeringConnectionSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema VpcPeeringConnectionSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderTags(obj: VpcPeeringConnectionSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef is a reference to an API used to set the VPCID.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdRef
 */
export interface VpcPeeringConnectionSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpcPeeringConnectionSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderVpcIdRef(obj: VpcPeeringConnectionSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcPeeringConnectionSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects references to API used to set the VPCID.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdSelector
 */
export interface VpcPeeringConnectionSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderVpcIdSelector(obj: VpcPeeringConnectionSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcPeeringConnectionSpecProviderConfigRefPolicy
 */
export interface VpcPeeringConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecProviderConfigRefPolicy(obj: VpcPeeringConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef(obj: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata(obj: VpcPeeringConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy
 */
export interface VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy(obj: VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy
 */
export interface VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy(obj: VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcPeeringConnectionSpecForProviderTagSpecificationsTags
 */
export interface VpcPeeringConnectionSpecForProviderTagSpecificationsTags {
  /**
   * @schema VpcPeeringConnectionSpecForProviderTagSpecificationsTags#key
   */
  readonly key?: string;

  /**
   * @schema VpcPeeringConnectionSpecForProviderTagSpecificationsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderTagSpecificationsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderTagSpecificationsTags(obj: VpcPeeringConnectionSpecForProviderTagSpecificationsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdRefPolicy
 */
export interface VpcPeeringConnectionSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderVpcIdRefPolicy(obj: VpcPeeringConnectionSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy
 */
export interface VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy(obj: VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecProviderConfigRefPolicyResolution
 */
export enum VpcPeeringConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecProviderConfigRefPolicyResolve
 */
export enum VpcPeeringConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolution
 */
export enum VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolve
 */
export enum VpcPeeringConnectionSpecForProviderPeerVpcidRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolution
 */
export enum VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolve
 */
export enum VpcPeeringConnectionSpecForProviderPeerVpcidSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolution
 */
export enum VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolve
 */
export enum VpcPeeringConnectionSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpcPeeringConnectionSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcPeeringConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

