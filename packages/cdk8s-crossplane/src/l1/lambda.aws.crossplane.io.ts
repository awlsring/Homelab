// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Function is the Schema for the Functions API
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.crossplane.io/v1alpha1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * FunctionParameters defines the desired state of Function
   *
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FunctionSpec#managementPolicies
   */
  readonly managementPolicies?: FunctionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FunctionParameters defines the desired state of Function
 *
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * The code for the function.
   *
   * @schema FunctionSpecForProvider#code
   */
  readonly code: FunctionSpecForProviderCode;

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
   *
   * @schema FunctionSpecForProvider#codeSigningConfigARN
   */
  readonly codeSigningConfigArn?: string;

  /**
   * A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
   *
   * @schema FunctionSpecForProvider#deadLetterConfig
   */
  readonly deadLetterConfig?: FunctionSpecForProviderDeadLetterConfig;

  /**
   * A description of the function.
   *
   * @schema FunctionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Environment variables that are accessible from function code during execution.
   *
   * @schema FunctionSpecForProvider#environment
   */
  readonly environment?: FunctionSpecForProviderEnvironment;

  /**
   * Connection settings for an Amazon EFS file system.
   *
   * @schema FunctionSpecForProvider#fileSystemConfigs
   */
  readonly fileSystemConfigs?: FunctionSpecForProviderFileSystemConfigs[];

  /**
   * The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Programming Model (https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html).
   *
   * @schema FunctionSpecForProvider#handler
   */
  readonly handler?: string;

  /**
   * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html) that override the values in the container image Dockerfile.
   *
   * @schema FunctionSpecForProvider#imageConfig
   */
  readonly imageConfig?: FunctionSpecForProviderImageConfig;

  /**
   * The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.
   *
   * @schema FunctionSpecForProvider#kmsKeyARN
   */
  readonly kmsKeyArn?: string;

  /**
   * KMSKeyARNRef is a reference to a kms key used to set the KMSKeyARN.
   *
   * @schema FunctionSpecForProvider#kmsKeyARNRef
   */
  readonly kmsKeyArnRef?: FunctionSpecForProviderKmsKeyArnRef;

  /**
   * KMSKeyARNSelector selects references to kms key arn used to set the KMSKeyARN.
   *
   * @schema FunctionSpecForProvider#kmsKeyARNSelector
   */
  readonly kmsKeyArnSelector?: FunctionSpecForProviderKmsKeyArnSelector;

  /**
   * A list of function layers (https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
   *
   * @schema FunctionSpecForProvider#layers
   */
  readonly layers?: string[];

  /**
   * The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
   *
   * @schema FunctionSpecForProvider#memorySize
   */
  readonly memorySize?: number;

  /**
   * The type of deployment package. Set to Image for container image and set Zip for ZIP archive.
   *
   * @schema FunctionSpecForProvider#packageType
   */
  readonly packageType?: string;

  /**
   * Set to true to publish the first version of the function during creation.
   *
   * @schema FunctionSpecForProvider#publish
   */
  readonly publish?: boolean;

  /**
   * Region is which region the Function will be created.
   *
   * @schema FunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the function's execution role. One of role, roleRef or roleSelector is required.
   *
   * @schema FunctionSpecForProvider#role
   */
  readonly role?: string;

  /**
   * RoleRef is a reference to an iam role
   *
   * @schema FunctionSpecForProvider#roleRef
   */
  readonly roleRef?: FunctionSpecForProviderRoleRef;

  /**
   * RoleSelector selects references to iam role arn used to set the lambda Role.
   *
   * @schema FunctionSpecForProvider#roleSelector
   */
  readonly roleSelector?: FunctionSpecForProviderRoleSelector;

  /**
   * The identifier of the function's runtime (https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).
   *
   * @schema FunctionSpecForProvider#runtime
   */
  readonly runtime?: string;

  /**
   * A list of tags (https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
   *
   * @schema FunctionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds.
   *
   * @schema FunctionSpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.
   *
   * @schema FunctionSpecForProvider#tracingConfig
   */
  readonly tracingConfig?: FunctionSpecForProviderTracingConfig;

  /**
   * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
   *
   * @schema FunctionSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: FunctionSpecForProviderVpcConfig;

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': toJson_FunctionSpecForProviderCode(obj.code),
    'codeSigningConfigARN': obj.codeSigningConfigArn,
    'deadLetterConfig': toJson_FunctionSpecForProviderDeadLetterConfig(obj.deadLetterConfig),
    'description': obj.description,
    'environment': toJson_FunctionSpecForProviderEnvironment(obj.environment),
    'fileSystemConfigs': obj.fileSystemConfigs?.map(y => toJson_FunctionSpecForProviderFileSystemConfigs(y)),
    'handler': obj.handler,
    'imageConfig': toJson_FunctionSpecForProviderImageConfig(obj.imageConfig),
    'kmsKeyARN': obj.kmsKeyArn,
    'kmsKeyARNRef': toJson_FunctionSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyARNSelector': toJson_FunctionSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'layers': obj.layers?.map(y => y),
    'memorySize': obj.memorySize,
    'packageType': obj.packageType,
    'publish': obj.publish,
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_FunctionSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_FunctionSpecForProviderRoleSelector(obj.roleSelector),
    'runtime': obj.runtime,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'tracingConfig': toJson_FunctionSpecForProviderTracingConfig(obj.tracingConfig),
    'vpcConfig': toJson_FunctionSpecForProviderVpcConfig(obj.vpcConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FunctionSpecManagementPolicies
 */
export enum FunctionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The code for the function.
 *
 * @schema FunctionSpecForProviderCode
 */
export interface FunctionSpecForProviderCode {
  /**
   * @schema FunctionSpecForProviderCode#imageURI
   */
  readonly imageUri?: string;

  /**
   * @schema FunctionSpecForProviderCode#s3Bucket
   */
  readonly s3Bucket?: string;

  /**
   * S3BucketRef is a reference to an S3 Bucket.
   *
   * @schema FunctionSpecForProviderCode#s3BucketRef
   */
  readonly s3BucketRef?: FunctionSpecForProviderCodeS3BucketRef;

  /**
   * S3BucketSelector selects references to an S3 Bucket.
   *
   * @schema FunctionSpecForProviderCode#s3BucketSelector
   */
  readonly s3BucketSelector?: FunctionSpecForProviderCodeS3BucketSelector;

  /**
   * @schema FunctionSpecForProviderCode#s3Key
   */
  readonly s3Key?: string;

  /**
   * @schema FunctionSpecForProviderCode#s3ObjectVersion
   */
  readonly s3ObjectVersion?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCode(obj: FunctionSpecForProviderCode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageURI': obj.imageUri,
    's3Bucket': obj.s3Bucket,
    's3BucketRef': toJson_FunctionSpecForProviderCodeS3BucketRef(obj.s3BucketRef),
    's3BucketSelector': toJson_FunctionSpecForProviderCodeS3BucketSelector(obj.s3BucketSelector),
    's3Key': obj.s3Key,
    's3ObjectVersion': obj.s3ObjectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
 *
 * @schema FunctionSpecForProviderDeadLetterConfig
 */
export interface FunctionSpecForProviderDeadLetterConfig {
  /**
   * @schema FunctionSpecForProviderDeadLetterConfig#targetARN
   */
  readonly targetArn?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDeadLetterConfig(obj: FunctionSpecForProviderDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetARN': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment variables that are accessible from function code during execution.
 *
 * @schema FunctionSpecForProviderEnvironment
 */
export interface FunctionSpecForProviderEnvironment {
  /**
   * @schema FunctionSpecForProviderEnvironment#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'FunctionSpecForProviderEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEnvironment(obj: FunctionSpecForProviderEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderFileSystemConfigs
 */
export interface FunctionSpecForProviderFileSystemConfigs {
  /**
   * @schema FunctionSpecForProviderFileSystemConfigs#arn
   */
  readonly arn?: string;

  /**
   * @schema FunctionSpecForProviderFileSystemConfigs#localMountPath
   */
  readonly localMountPath?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfigs(obj: FunctionSpecForProviderFileSystemConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'localMountPath': obj.localMountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html) that override the values in the container image Dockerfile.
 *
 * @schema FunctionSpecForProviderImageConfig
 */
export interface FunctionSpecForProviderImageConfig {
  /**
   * @schema FunctionSpecForProviderImageConfig#command
   */
  readonly command?: string[];

  /**
   * @schema FunctionSpecForProviderImageConfig#entryPoint
   */
  readonly entryPoint?: string[];

  /**
   * @schema FunctionSpecForProviderImageConfig#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderImageConfig(obj: FunctionSpecForProviderImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'entryPoint': obj.entryPoint?.map(y => y),
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNRef is a reference to a kms key used to set the KMSKeyARN.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRef
 */
export interface FunctionSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: FunctionSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnRef(obj: FunctionSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNSelector selects references to kms key arn used to set the KMSKeyARN.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelector
 */
export interface FunctionSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: FunctionSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnSelector(obj: FunctionSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleRef is a reference to an iam role
 *
 * @schema FunctionSpecForProviderRoleRef
 */
export interface FunctionSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderRoleRef#policy
   */
  readonly policy?: FunctionSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleRef(obj: FunctionSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects references to iam role arn used to set the lambda Role.
 *
 * @schema FunctionSpecForProviderRoleSelector
 */
export interface FunctionSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderRoleSelector#policy
   */
  readonly policy?: FunctionSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleSelector(obj: FunctionSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.
 *
 * @schema FunctionSpecForProviderTracingConfig
 */
export interface FunctionSpecForProviderTracingConfig {
  /**
   * @schema FunctionSpecForProviderTracingConfig#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderTracingConfig(obj: FunctionSpecForProviderTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
 *
 * @schema FunctionSpecForProviderVpcConfig
 */
export interface FunctionSpecForProviderVpcConfig {
  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIDRefs
   */
  readonly securityGroupIdRefs?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIDSelector
   */
  readonly securityGroupIdSelector?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelector;

  /**
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema FunctionSpecForProviderVpcConfig#subnetIDRefs
   */
  readonly subnetIdRefs?: FunctionSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema FunctionSpecForProviderVpcConfig#subnetIDSelector
   */
  readonly subnetIdSelector?: FunctionSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * @schema FunctionSpecForProviderVpcConfig#subnetIDs
   */
  readonly subnetIDs?: string[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfig(obj: FunctionSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIDRefs': obj.securityGroupIdRefs?.map(y => toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIDSelector': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'subnetIDRefs': obj.subnetIdRefs?.map(y => toJson_FunctionSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIDSelector': toJson_FunctionSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIDs': obj.subnetIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketRef is a reference to an S3 Bucket.
 *
 * @schema FunctionSpecForProviderCodeS3BucketRef
 */
export interface FunctionSpecForProviderCodeS3BucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderCodeS3BucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderCodeS3BucketRef#policy
   */
  readonly policy?: FunctionSpecForProviderCodeS3BucketRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCodeS3BucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCodeS3BucketRef(obj: FunctionSpecForProviderCodeS3BucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderCodeS3BucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketSelector selects references to an S3 Bucket.
 *
 * @schema FunctionSpecForProviderCodeS3BucketSelector
 */
export interface FunctionSpecForProviderCodeS3BucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderCodeS3BucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderCodeS3BucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderCodeS3BucketSelector#policy
   */
  readonly policy?: FunctionSpecForProviderCodeS3BucketSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCodeS3BucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCodeS3BucketSelector(obj: FunctionSpecForProviderCodeS3BucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderCodeS3BucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicy
 */
export interface FunctionSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnRefPolicy(obj: FunctionSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface FunctionSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnSelectorPolicy(obj: FunctionSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderRoleRefPolicy
 */
export interface FunctionSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleRefPolicy(obj: FunctionSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicy
 */
export interface FunctionSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleSelectorPolicy(obj: FunctionSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefs(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelector(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdRefs(obj: FunctionSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdSelector(obj: FunctionSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderCodeS3BucketRefPolicy
 */
export interface FunctionSpecForProviderCodeS3BucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderCodeS3BucketRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderCodeS3BucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderCodeS3BucketRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderCodeS3BucketRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCodeS3BucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCodeS3BucketRefPolicy(obj: FunctionSpecForProviderCodeS3BucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderCodeS3BucketSelectorPolicy
 */
export interface FunctionSpecForProviderCodeS3BucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderCodeS3BucketSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderCodeS3BucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderCodeS3BucketSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderCodeS3BucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCodeS3BucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCodeS3BucketSelectorPolicy(obj: FunctionSpecForProviderCodeS3BucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum FunctionSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum FunctionSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderRoleRefPolicyResolution
 */
export enum FunctionSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderRoleRefPolicyResolve
 */
export enum FunctionSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicyResolution
 */
export enum FunctionSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicyResolve
 */
export enum FunctionSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderCodeS3BucketRefPolicyResolution
 */
export enum FunctionSpecForProviderCodeS3BucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderCodeS3BucketRefPolicyResolve
 */
export enum FunctionSpecForProviderCodeS3BucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderCodeS3BucketSelectorPolicyResolution
 */
export enum FunctionSpecForProviderCodeS3BucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderCodeS3BucketSelectorPolicyResolve
 */
export enum FunctionSpecForProviderCodeS3BucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Function is the Schema for the Functions API
 *
 * @schema FunctionV1Beta1
 */
export class FunctionV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FunctionV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.crossplane.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "FunctionV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionV1Beta1Props): any {
    return {
      ...FunctionV1Beta1.GVK,
      ...toJson_FunctionV1Beta1Props(props),
    };
  }

  /**
   * Defines a "FunctionV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionV1Beta1Props) {
    super(scope, id, {
      ...FunctionV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FunctionV1Beta1.GVK,
      ...toJson_FunctionV1Beta1Props(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API
 *
 * @schema FunctionV1Beta1
 */
export interface FunctionV1Beta1Props {
  /**
   * @schema FunctionV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema FunctionV1Beta1#spec
   */
  readonly spec: FunctionV1Beta1Spec;

}

/**
 * Converts an object of type 'FunctionV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1Props(obj: FunctionV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionV1Beta1Spec
 */
export interface FunctionV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FunctionV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionV1Beta1SpecDeletionPolicy;

  /**
   * FunctionParameters defines the desired state of Function
   *
   * @schema FunctionV1Beta1Spec#forProvider
   */
  readonly forProvider: FunctionV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FunctionV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: FunctionV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1Spec(obj: FunctionV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FunctionV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FunctionV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FunctionV1Beta1SpecDeletionPolicy
 */
export enum FunctionV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FunctionParameters defines the desired state of Function
 *
 * @schema FunctionV1Beta1SpecForProvider
 */
export interface FunctionV1Beta1SpecForProvider {
  /**
   * The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
   *
   * @schema FunctionV1Beta1SpecForProvider#architectures
   */
  readonly architectures?: string[];

  /**
   * The code for the function.
   *
   * @schema FunctionV1Beta1SpecForProvider#code
   */
  readonly code: FunctionV1Beta1SpecForProviderCode;

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
   *
   * @schema FunctionV1Beta1SpecForProvider#codeSigningConfigARN
   */
  readonly codeSigningConfigArn?: string;

  /**
   * A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
   *
   * @schema FunctionV1Beta1SpecForProvider#deadLetterConfig
   */
  readonly deadLetterConfig?: FunctionV1Beta1SpecForProviderDeadLetterConfig;

  /**
   * A description of the function.
   *
   * @schema FunctionV1Beta1SpecForProvider#description
   */
  readonly description?: string;

  /**
   * Environment variables that are accessible from function code during execution.
   *
   * @schema FunctionV1Beta1SpecForProvider#environment
   */
  readonly environment?: FunctionV1Beta1SpecForProviderEnvironment;

  /**
   * The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB.
   *
   * @schema FunctionV1Beta1SpecForProvider#ephemeralStorage
   */
  readonly ephemeralStorage?: FunctionV1Beta1SpecForProviderEphemeralStorage;

  /**
   * Connection settings for an Amazon EFS file system.
   *
   * @schema FunctionV1Beta1SpecForProvider#fileSystemConfigs
   */
  readonly fileSystemConfigs?: FunctionV1Beta1SpecForProviderFileSystemConfigs[];

  /**
   * The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model (https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
   *
   * @schema FunctionV1Beta1SpecForProvider#handler
   */
  readonly handler?: string;

  /**
   * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
   *
   * @schema FunctionV1Beta1SpecForProvider#imageConfig
   */
  readonly imageConfig?: FunctionV1Beta1SpecForProviderImageConfig;

  /**
   * The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's environment variables (https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When Lambda SnapStart (https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
   *
   * @schema FunctionV1Beta1SpecForProvider#kmsKeyARN
   */
  readonly kmsKeyArn?: string;

  /**
   * KMSKeyARNRef is a reference to a kms key used to set the KMSKeyARN.
   *
   * @schema FunctionV1Beta1SpecForProvider#kmsKeyARNRef
   */
  readonly kmsKeyArnRef?: FunctionV1Beta1SpecForProviderKmsKeyArnRef;

  /**
   * KMSKeyARNSelector selects references to kms key arn used to set the KMSKeyARN.
   *
   * @schema FunctionV1Beta1SpecForProvider#kmsKeyARNSelector
   */
  readonly kmsKeyArnSelector?: FunctionV1Beta1SpecForProviderKmsKeyArnSelector;

  /**
   * A list of function layers (https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
   *
   * @schema FunctionV1Beta1SpecForProvider#layers
   */
  readonly layers?: string[];

  /**
   * The amount of memory available to the function (https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
   *
   * @schema FunctionV1Beta1SpecForProvider#memorySize
   */
  readonly memorySize?: number;

  /**
   * The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
   *
   * @schema FunctionV1Beta1SpecForProvider#packageType
   */
  readonly packageType?: string;

  /**
   * Set to true to publish the first version of the function during creation.
   *
   * @schema FunctionV1Beta1SpecForProvider#publish
   */
  readonly publish?: boolean;

  /**
   * Region is which region the Function will be created.
   *
   * @schema FunctionV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the function's execution role. One of role, roleRef or roleSelector is required.
   *
   * @schema FunctionV1Beta1SpecForProvider#role
   */
  readonly role?: string;

  /**
   * RoleRef is a reference to an iam role
   *
   * @schema FunctionV1Beta1SpecForProvider#roleRef
   */
  readonly roleRef?: FunctionV1Beta1SpecForProviderRoleRef;

  /**
   * RoleSelector selects references to iam role arn used to set the lambda Role.
   *
   * @schema FunctionV1Beta1SpecForProvider#roleSelector
   */
  readonly roleSelector?: FunctionV1Beta1SpecForProviderRoleSelector;

  /**
   * The identifier of the function's runtime (https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive.
   * The following list includes deprecated runtimes. For more information, see Runtime deprecation policy (https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
   *
   * @schema FunctionV1Beta1SpecForProvider#runtime
   */
  readonly runtime?: string;

  /**
   * The function's SnapStart (https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
   *
   * @schema FunctionV1Beta1SpecForProvider#snapStart
   */
  readonly snapStart?: FunctionV1Beta1SpecForProviderSnapStart;

  /**
   * A list of tags (https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
   *
   * @schema FunctionV1Beta1SpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment (https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
   *
   * @schema FunctionV1Beta1SpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * Set Mode to Active to sample and trace a subset of incoming requests with X-Ray (https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
   *
   * @schema FunctionV1Beta1SpecForProvider#tracingConfig
   */
  readonly tracingConfig?: FunctionV1Beta1SpecForProviderTracingConfig;

  /**
   * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
   *
   * @schema FunctionV1Beta1SpecForProvider#vpcConfig
   */
  readonly vpcConfig?: FunctionV1Beta1SpecForProviderVpcConfig;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProvider(obj: FunctionV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'architectures': obj.architectures?.map(y => y),
    'code': toJson_FunctionV1Beta1SpecForProviderCode(obj.code),
    'codeSigningConfigARN': obj.codeSigningConfigArn,
    'deadLetterConfig': toJson_FunctionV1Beta1SpecForProviderDeadLetterConfig(obj.deadLetterConfig),
    'description': obj.description,
    'environment': toJson_FunctionV1Beta1SpecForProviderEnvironment(obj.environment),
    'ephemeralStorage': toJson_FunctionV1Beta1SpecForProviderEphemeralStorage(obj.ephemeralStorage),
    'fileSystemConfigs': obj.fileSystemConfigs?.map(y => toJson_FunctionV1Beta1SpecForProviderFileSystemConfigs(y)),
    'handler': obj.handler,
    'imageConfig': toJson_FunctionV1Beta1SpecForProviderImageConfig(obj.imageConfig),
    'kmsKeyARN': obj.kmsKeyArn,
    'kmsKeyARNRef': toJson_FunctionV1Beta1SpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyARNSelector': toJson_FunctionV1Beta1SpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'layers': obj.layers?.map(y => y),
    'memorySize': obj.memorySize,
    'packageType': obj.packageType,
    'publish': obj.publish,
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_FunctionV1Beta1SpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_FunctionV1Beta1SpecForProviderRoleSelector(obj.roleSelector),
    'runtime': obj.runtime,
    'snapStart': toJson_FunctionV1Beta1SpecForProviderSnapStart(obj.snapStart),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'tracingConfig': toJson_FunctionV1Beta1SpecForProviderTracingConfig(obj.tracingConfig),
    'vpcConfig': toJson_FunctionV1Beta1SpecForProviderVpcConfig(obj.vpcConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FunctionV1Beta1SpecManagementPolicies
 */
export enum FunctionV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionV1Beta1SpecProviderConfigRef
 */
export interface FunctionV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: FunctionV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecProviderConfigRef(obj: FunctionV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsTo
 */
export interface FunctionV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecPublishConnectionDetailsTo(obj: FunctionV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionV1Beta1SpecWriteConnectionSecretToRef
 */
export interface FunctionV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecWriteConnectionSecretToRef(obj: FunctionV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The code for the function.
 *
 * @schema FunctionV1Beta1SpecForProviderCode
 */
export interface FunctionV1Beta1SpecForProviderCode {
  /**
   * @schema FunctionV1Beta1SpecForProviderCode#imageURI
   */
  readonly imageUri?: string;

  /**
   * @schema FunctionV1Beta1SpecForProviderCode#s3Bucket
   */
  readonly s3Bucket?: string;

  /**
   * S3BucketRef is a reference to an S3 Bucket.
   *
   * @schema FunctionV1Beta1SpecForProviderCode#s3BucketRef
   */
  readonly s3BucketRef?: FunctionV1Beta1SpecForProviderCodeS3BucketRef;

  /**
   * S3BucketSelector selects references to an S3 Bucket.
   *
   * @schema FunctionV1Beta1SpecForProviderCode#s3BucketSelector
   */
  readonly s3BucketSelector?: FunctionV1Beta1SpecForProviderCodeS3BucketSelector;

  /**
   * @schema FunctionV1Beta1SpecForProviderCode#s3Key
   */
  readonly s3Key?: string;

  /**
   * @schema FunctionV1Beta1SpecForProviderCode#s3ObjectVersion
   */
  readonly s3ObjectVersion?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderCode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderCode(obj: FunctionV1Beta1SpecForProviderCode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageURI': obj.imageUri,
    's3Bucket': obj.s3Bucket,
    's3BucketRef': toJson_FunctionV1Beta1SpecForProviderCodeS3BucketRef(obj.s3BucketRef),
    's3BucketSelector': toJson_FunctionV1Beta1SpecForProviderCodeS3BucketSelector(obj.s3BucketSelector),
    's3Key': obj.s3Key,
    's3ObjectVersion': obj.s3ObjectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
 *
 * @schema FunctionV1Beta1SpecForProviderDeadLetterConfig
 */
export interface FunctionV1Beta1SpecForProviderDeadLetterConfig {
  /**
   * @schema FunctionV1Beta1SpecForProviderDeadLetterConfig#targetARN
   */
  readonly targetArn?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderDeadLetterConfig(obj: FunctionV1Beta1SpecForProviderDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetARN': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment variables that are accessible from function code during execution.
 *
 * @schema FunctionV1Beta1SpecForProviderEnvironment
 */
export interface FunctionV1Beta1SpecForProviderEnvironment {
  /**
   * @schema FunctionV1Beta1SpecForProviderEnvironment#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderEnvironment(obj: FunctionV1Beta1SpecForProviderEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB.
 *
 * @schema FunctionV1Beta1SpecForProviderEphemeralStorage
 */
export interface FunctionV1Beta1SpecForProviderEphemeralStorage {
  /**
   * @schema FunctionV1Beta1SpecForProviderEphemeralStorage#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderEphemeralStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderEphemeralStorage(obj: FunctionV1Beta1SpecForProviderEphemeralStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionV1Beta1SpecForProviderFileSystemConfigs
 */
export interface FunctionV1Beta1SpecForProviderFileSystemConfigs {
  /**
   * @schema FunctionV1Beta1SpecForProviderFileSystemConfigs#arn
   */
  readonly arn?: string;

  /**
   * @schema FunctionV1Beta1SpecForProviderFileSystemConfigs#localMountPath
   */
  readonly localMountPath?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderFileSystemConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderFileSystemConfigs(obj: FunctionV1Beta1SpecForProviderFileSystemConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'localMountPath': obj.localMountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
 *
 * @schema FunctionV1Beta1SpecForProviderImageConfig
 */
export interface FunctionV1Beta1SpecForProviderImageConfig {
  /**
   * @schema FunctionV1Beta1SpecForProviderImageConfig#command
   */
  readonly command?: string[];

  /**
   * @schema FunctionV1Beta1SpecForProviderImageConfig#entryPoint
   */
  readonly entryPoint?: string[];

  /**
   * @schema FunctionV1Beta1SpecForProviderImageConfig#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderImageConfig(obj: FunctionV1Beta1SpecForProviderImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'entryPoint': obj.entryPoint?.map(y => y),
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNRef is a reference to a kms key used to set the KMSKeyARN.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRef
 */
export interface FunctionV1Beta1SpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderKmsKeyArnRef(obj: FunctionV1Beta1SpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyARNSelector selects references to kms key arn used to set the KMSKeyARN.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelector
 */
export interface FunctionV1Beta1SpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderKmsKeyArnSelector(obj: FunctionV1Beta1SpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleRef is a reference to an iam role
 *
 * @schema FunctionV1Beta1SpecForProviderRoleRef
 */
export interface FunctionV1Beta1SpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleRef#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderRoleRef(obj: FunctionV1Beta1SpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSelector selects references to iam role arn used to set the lambda Role.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleSelector
 */
export interface FunctionV1Beta1SpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleSelector#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderRoleSelector(obj: FunctionV1Beta1SpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionV1Beta1SpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The function's SnapStart (https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
 *
 * @schema FunctionV1Beta1SpecForProviderSnapStart
 */
export interface FunctionV1Beta1SpecForProviderSnapStart {
  /**
   * @schema FunctionV1Beta1SpecForProviderSnapStart#applyOn
   */
  readonly applyOn?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderSnapStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderSnapStart(obj: FunctionV1Beta1SpecForProviderSnapStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyOn': obj.applyOn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set Mode to Active to sample and trace a subset of incoming requests with X-Ray (https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
 *
 * @schema FunctionV1Beta1SpecForProviderTracingConfig
 */
export interface FunctionV1Beta1SpecForProviderTracingConfig {
  /**
   * @schema FunctionV1Beta1SpecForProviderTracingConfig#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderTracingConfig(obj: FunctionV1Beta1SpecForProviderTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfig
 */
export interface FunctionV1Beta1SpecForProviderVpcConfig {
  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#securityGroupIDRefs
   */
  readonly securityGroupIdRefs?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#securityGroupIDSelector
   */
  readonly securityGroupIdSelector?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector;

  /**
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#subnetIDRefs
   */
  readonly subnetIdRefs?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#subnetIDSelector
   */
  readonly subnetIdSelector?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector;

  /**
   * @schema FunctionV1Beta1SpecForProviderVpcConfig#subnetIDs
   */
  readonly subnetIDs?: string[];

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfig(obj: FunctionV1Beta1SpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIDRefs': obj.securityGroupIdRefs?.map(y => toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIDSelector': toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'subnetIDRefs': obj.subnetIdRefs?.map(y => toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIDSelector': toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIDs': obj.subnetIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecProviderConfigRefPolicy
 */
export interface FunctionV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecProviderConfigRefPolicy(obj: FunctionV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface FunctionV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecPublishConnectionDetailsToMetadata(obj: FunctionV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketRef is a reference to an S3 Bucket.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRef
 */
export interface FunctionV1Beta1SpecForProviderCodeS3BucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRef#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderCodeS3BucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderCodeS3BucketRef(obj: FunctionV1Beta1SpecForProviderCodeS3BucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3BucketSelector selects references to an S3 Bucket.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelector
 */
export interface FunctionV1Beta1SpecForProviderCodeS3BucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelector#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderCodeS3BucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderCodeS3BucketSelector(obj: FunctionV1Beta1SpecForProviderCodeS3BucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy
 */
export interface FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy(obj: FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy
 */
export interface FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy(obj: FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleRefPolicy
 */
export interface FunctionV1Beta1SpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderRoleRefPolicy(obj: FunctionV1Beta1SpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleSelectorPolicy
 */
export interface FunctionV1Beta1SpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderRoleSelectorPolicy(obj: FunctionV1Beta1SpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs(obj: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector(obj: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs(obj: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector(obj: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum FunctionV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum FunctionV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy
 */
export interface FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy(obj: FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy
 */
export interface FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy(obj: FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleRefPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleRefPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj: FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy(obj: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderCodeS3BucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderCodeS3BucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum FunctionV1Beta1SpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FunctionURLConfig is the Schema for the FunctionURLConfigs API
 *
 * @schema FunctionURLConfig
 */
export class FunctionUrlConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FunctionURLConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.crossplane.io/v1alpha1',
    kind: 'FunctionURLConfig',
  }

  /**
   * Renders a Kubernetes manifest for "FunctionURLConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionUrlConfigProps): any {
    return {
      ...FunctionUrlConfig.GVK,
      ...toJson_FunctionUrlConfigProps(props),
    };
  }

  /**
   * Defines a "FunctionURLConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionUrlConfigProps) {
    super(scope, id, {
      ...FunctionUrlConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FunctionUrlConfig.GVK,
      ...toJson_FunctionUrlConfigProps(resolved),
    };
  }
}

/**
 * FunctionURLConfig is the Schema for the FunctionURLConfigs API
 *
 * @schema FunctionURLConfig
 */
export interface FunctionUrlConfigProps {
  /**
   * @schema FunctionURLConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionURLConfigSpec defines the desired state of FunctionURLConfig
   *
   * @schema FunctionURLConfig#spec
   */
  readonly spec: FunctionUrlConfigSpec;

}

/**
 * Converts an object of type 'FunctionUrlConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigProps(obj: FunctionUrlConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionUrlConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionURLConfigSpec defines the desired state of FunctionURLConfig
 *
 * @schema FunctionUrlConfigSpec
 */
export interface FunctionUrlConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FunctionUrlConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionUrlConfigSpecDeletionPolicy;

  /**
   * FunctionURLConfigParameters defines the desired state of FunctionURLConfig
   *
   * @schema FunctionUrlConfigSpec#forProvider
   */
  readonly forProvider: FunctionUrlConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FunctionUrlConfigSpec#managementPolicies
   */
  readonly managementPolicies?: FunctionUrlConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionUrlConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionUrlConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionUrlConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionUrlConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionUrlConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionUrlConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpec(obj: FunctionUrlConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionUrlConfigSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FunctionUrlConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FunctionUrlConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionUrlConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FunctionUrlConfigSpecDeletionPolicy
 */
export enum FunctionUrlConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FunctionURLConfigParameters defines the desired state of FunctionURLConfig
 *
 * @schema FunctionUrlConfigSpecForProvider
 */
export interface FunctionUrlConfigSpecForProvider {
  /**
   * The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs (https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
   *
   * @schema FunctionUrlConfigSpecForProvider#authType
   */
  readonly authType: string;

  /**
   * The cross-origin resource sharing (CORS) (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
   *
   * @schema FunctionUrlConfigSpecForProvider#cors
   */
  readonly cors?: FunctionUrlConfigSpecForProviderCors;

  /**
   * @schema FunctionUrlConfigSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * FunctionNameRef is a reference to a function used to set the FunctionName.
   *
   * @schema FunctionUrlConfigSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: FunctionUrlConfigSpecForProviderFunctionNameRef;

  /**
   * FunctionNameSelector selects references to function used to set the FunctionName.
   *
   * @schema FunctionUrlConfigSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: FunctionUrlConfigSpecForProviderFunctionNameSelector;

  /**
   * Use one of the following options:
   * * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
   * * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase (https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
   *
   * @schema FunctionUrlConfigSpecForProvider#invokeMode
   */
  readonly invokeMode?: string;

  /**
   * The alias name.
   *
   * @schema FunctionUrlConfigSpecForProvider#qualifier
   */
  readonly qualifier?: string;

  /**
   * Region is which region the FunctionURLConfig will be created.
   *
   * @schema FunctionUrlConfigSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProvider(obj: FunctionUrlConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authType': obj.authType,
    'cors': toJson_FunctionUrlConfigSpecForProviderCors(obj.cors),
    'functionName': obj.functionName,
    'functionNameRef': toJson_FunctionUrlConfigSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_FunctionUrlConfigSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'invokeMode': obj.invokeMode,
    'qualifier': obj.qualifier,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FunctionUrlConfigSpecManagementPolicies
 */
export enum FunctionUrlConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionUrlConfigSpecProviderConfigRef
 */
export interface FunctionUrlConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlConfigSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionUrlConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecProviderConfigRef(obj: FunctionUrlConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsTo
 */
export interface FunctionUrlConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionUrlConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecPublishConnectionDetailsTo(obj: FunctionUrlConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionUrlConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionUrlConfigSpecWriteConnectionSecretToRef
 */
export interface FunctionUrlConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionUrlConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionUrlConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecWriteConnectionSecretToRef(obj: FunctionUrlConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The cross-origin resource sharing (CORS) (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
 *
 * @schema FunctionUrlConfigSpecForProviderCors
 */
export interface FunctionUrlConfigSpecForProviderCors {
  /**
   * @schema FunctionUrlConfigSpecForProviderCors#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * @schema FunctionUrlConfigSpecForProviderCors#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * @schema FunctionUrlConfigSpecForProviderCors#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema FunctionUrlConfigSpecForProviderCors#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * @schema FunctionUrlConfigSpecForProviderCors#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * @schema FunctionUrlConfigSpecForProviderCors#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProviderCors(obj: FunctionUrlConfigSpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionNameRef is a reference to a function used to set the FunctionName.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameRef
 */
export interface FunctionUrlConfigSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: FunctionUrlConfigSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProviderFunctionNameRef(obj: FunctionUrlConfigSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlConfigSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionNameSelector selects references to function used to set the FunctionName.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameSelector
 */
export interface FunctionUrlConfigSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProviderFunctionNameSelector(obj: FunctionUrlConfigSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlConfigSpecProviderConfigRefPolicy
 */
export interface FunctionUrlConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecProviderConfigRefPolicy(obj: FunctionUrlConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef(obj: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionUrlConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecPublishConnectionDetailsToMetadata(obj: FunctionUrlConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameRefPolicy
 */
export interface FunctionUrlConfigSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProviderFunctionNameRefPolicy(obj: FunctionUrlConfigSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy
 */
export interface FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy(obj: FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlConfigSpecProviderConfigRefPolicyResolution
 */
export enum FunctionUrlConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlConfigSpecProviderConfigRefPolicyResolve
 */
export enum FunctionUrlConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolution
 */
export enum FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolve
 */
export enum FunctionUrlConfigSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum FunctionUrlConfigSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionUrlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Permission is a managed resource that represents a AWS Lambda Permission.
 *
 * @schema Permission
 */
export class Permission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.crossplane.io/v1alpha1',
    kind: 'Permission',
  }

  /**
   * Renders a Kubernetes manifest for "Permission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionProps): any {
    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(props),
    };
  }

  /**
   * Defines a "Permission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionProps) {
    super(scope, id, {
      ...Permission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(resolved),
    };
  }
}

/**
 * A Permission is a managed resource that represents a AWS Lambda Permission.
 *
 * @schema Permission
 */
export interface PermissionProps {
  /**
   * @schema Permission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A PermissionSpec defines the desired state of a Permission.
   *
   * @schema Permission#spec
   */
  readonly spec: PermissionSpec;

}

/**
 * Converts an object of type 'PermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionProps(obj: PermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A PermissionSpec defines the desired state of a Permission.
 *
 * @schema PermissionSpec
 */
export interface PermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSpecDeletionPolicy;

  /**
   * PermissionParameters define the desired state of a Lambda Permission
   *
   * @schema PermissionSpec#forProvider
   */
  readonly forProvider: PermissionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionSpec#managementPolicies
   */
  readonly managementPolicies?: PermissionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpec(obj: PermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecDeletionPolicy
 */
export enum PermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * PermissionParameters define the desired state of a Lambda Permission
 *
 * @schema PermissionSpecForProvider
 */
export interface PermissionSpecForProvider {
  /**
   * The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
   * This member is required.
   *
   * @schema PermissionSpecForProvider#action
   */
  readonly action: string;

  /**
   * For Alexa Smart Home functions, a token that must be supplied by the invoker.
   *
   * @schema PermissionSpecForProvider#eventSourceToken
   */
  readonly eventSourceToken?: string;

  /**
   * The name of the Lambda function, version, or alias. Name formats
   * * Function name - my-function (name-only), my-function:v1 (with alias).
   * * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
   * * Partial ARN - 123456789012:function:my-function.
   * You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
   * This member is required.
   *
   * @schema PermissionSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * FunctionNameRef is a reference to a function used to set the FunctionName.
   *
   * @schema PermissionSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: PermissionSpecForProviderFunctionNameRef;

  /**
   * FunctionNameSelector selects references to function used to set the FunctionName.
   *
   * @schema PermissionSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: PermissionSpecForProviderFunctionNameSelector;

  /**
   * The Amazon Web Services service or account that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
   * This member is required.
   *
   * @schema PermissionSpecForProvider#principal
   */
  readonly principal: string;

  /**
   * The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.
   *
   * @schema PermissionSpecForProvider#principalOrgId
   */
  readonly principalOrgId?: string;

  /**
   * Region is which region the Function will be created.
   *
   * @schema PermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
   *
   * @schema PermissionSpecForProvider#sourceARN
   */
  readonly sourceArn?: string;

  /**
   * For Amazon S3, the ID of the account that owns the resource. Use this together with SourceArn to ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
   *
   * @schema PermissionSpecForProvider#sourceAccount
   */
  readonly sourceAccount?: string;

}

/**
 * Converts an object of type 'PermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProvider(obj: PermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'eventSourceToken': obj.eventSourceToken,
    'functionName': obj.functionName,
    'functionNameRef': toJson_PermissionSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_PermissionSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'principal': obj.principal,
    'principalOrgId': obj.principalOrgId,
    'region': obj.region,
    'sourceARN': obj.sourceArn,
    'sourceAccount': obj.sourceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PermissionSpecManagementPolicies
 */
export enum PermissionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSpecProviderConfigRef
 */
export interface PermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRef(obj: PermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSpecPublishConnectionDetailsTo
 */
export interface PermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsTo(obj: PermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSpecWriteConnectionSecretToRef
 */
export interface PermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecWriteConnectionSecretToRef(obj: PermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionNameRef is a reference to a function used to set the FunctionName.
 *
 * @schema PermissionSpecForProviderFunctionNameRef
 */
export interface PermissionSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: PermissionSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameRef(obj: PermissionSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionNameSelector selects references to function used to set the FunctionName.
 *
 * @schema PermissionSpecForProviderFunctionNameSelector
 */
export interface PermissionSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: PermissionSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameSelector(obj: PermissionSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderConfigRefPolicy
 */
export interface PermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRefPolicy(obj: PermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj: PermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj: PermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicy
 */
export interface PermissionSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameRefPolicy(obj: PermissionSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicy
 */
export interface PermissionSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameSelectorPolicy(obj: PermissionSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicyResolution
 */
export enum PermissionSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicyResolve
 */
export enum PermissionSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum PermissionSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum PermissionSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

