// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * An ELB is a managed resource that represents an AWS Classic Load Balancer.
 *
 * @schema ELB
 */
export class Elb extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ELB"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticloadbalancing.aws.crossplane.io/v1alpha1',
    kind: 'ELB',
  }

  /**
   * Renders a Kubernetes manifest for "ELB".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ElbProps): any {
    return {
      ...Elb.GVK,
      ...toJson_ElbProps(props),
    };
  }

  /**
   * Defines a "ELB" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ElbProps) {
    super(scope, id, {
      ...Elb.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Elb.GVK,
      ...toJson_ElbProps(resolved),
    };
  }
}

/**
 * An ELB is a managed resource that represents an AWS Classic Load Balancer.
 *
 * @schema ELB
 */
export interface ElbProps {
  /**
   * @schema ELB#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An ELBSpec defines the desired state of an ELB.
   *
   * @schema ELB#spec
   */
  readonly spec: ElbSpec;

}

/**
 * Converts an object of type 'ElbProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbProps(obj: ElbProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ElbSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An ELBSpec defines the desired state of an ELB.
 *
 * @schema ElbSpec
 */
export interface ElbSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ElbSpec#deletionPolicy
   */
  readonly deletionPolicy?: ElbSpecDeletionPolicy;

  /**
   * ELBParameters define the desired state of an AWS ELB.
   *
   * @schema ElbSpec#forProvider
   */
  readonly forProvider: ElbSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ElbSpec#managementPolicies
   */
  readonly managementPolicies?: ElbSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ElbSpec#providerConfigRef
   */
  readonly providerConfigRef?: ElbSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ElbSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ElbSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ElbSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ElbSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ElbSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpec(obj: ElbSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ElbSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ElbSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ElbSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ElbSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ElbSpecDeletionPolicy
 */
export enum ElbSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ELBParameters define the desired state of an AWS ELB.
 *
 * @schema ElbSpecForProvider
 */
export interface ElbSpecForProvider {
  /**
   * One or more Availability Zones from the same region as the load balancer.
   *
   * @schema ElbSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * Information about the health checks conducted on the load balancer.
   *
   * @schema ElbSpecForProvider#healthCheck
   */
  readonly healthCheck?: ElbSpecForProviderHealthCheck;

  /**
   * The listeners for this ELB.
   *
   * @schema ElbSpecForProvider#listeners
   */
  readonly listeners: ElbSpecForProviderListeners[];

  /**
   * Region is the region you'd like your ELB to be created in.
   *
   * @schema ElbSpecForProvider#region
   */
  readonly region: string;

  /**
   * The type of a load balancer. Valid only for load balancers in a VPC.
   *
   * @schema ElbSpecForProvider#scheme
   */
  readonly scheme?: string;

  /**
   * SecurityGroupIDRefs references to a SecurityGroup and retrieves its SecurityGroupID
   *
   * @schema ElbSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: ElbSpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDSelector selects a set of references that each retrieve the SecurityGroupID from the referenced SecurityGroup
   *
   * @schema ElbSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: ElbSpecForProviderSecurityGroupIdSelector;

  /**
   * The IDs of the security groups to assign to the load balancer.
   *
   * @schema ElbSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetRefs references to a Subnet to and retrieves its SubnetID
   *
   * @schema ElbSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: ElbSpecForProviderSubnetIdRefs[];

  /**
   * SubnetSelector selects a set of references that each retrieve the subnetID from the referenced Subnet
   *
   * @schema ElbSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: ElbSpecForProviderSubnetIdSelector;

  /**
   * The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per Availability Zone specified in AvailabilityZones.
   *
   * @schema ElbSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * A list of tags to assign to the load balancer.
   *
   * @schema ElbSpecForProvider#tags
   */
  readonly tags?: ElbSpecForProviderTags[];

}

/**
 * Converts an object of type 'ElbSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProvider(obj: ElbSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'healthCheck': toJson_ElbSpecForProviderHealthCheck(obj.healthCheck),
    'listeners': obj.listeners?.map(y => toJson_ElbSpecForProviderListeners(y)),
    'region': obj.region,
    'scheme': obj.scheme,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_ElbSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_ElbSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_ElbSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_ElbSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': obj.tags?.map(y => toJson_ElbSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ElbSpecManagementPolicies
 */
export enum ElbSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ElbSpecProviderConfigRef
 */
export interface ElbSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecProviderConfigRef#policy
   */
  readonly policy?: ElbSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderConfigRef(obj: ElbSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ElbSpecPublishConnectionDetailsTo
 */
export interface ElbSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ElbSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ElbSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsTo(obj: ElbSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ElbSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ElbSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ElbSpecWriteConnectionSecretToRef
 */
export interface ElbSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ElbSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ElbSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ElbSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecWriteConnectionSecretToRef(obj: ElbSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the health checks conducted on the load balancer.
 *
 * @schema ElbSpecForProviderHealthCheck
 */
export interface ElbSpecForProviderHealthCheck {
  /**
   * The number of consecutive health checks successes required before moving the instance to the Healthy state.
   *
   * @schema ElbSpecForProviderHealthCheck#healthyThreshold
   */
  readonly healthyThreshold: number;

  /**
   * The approximate interval, in seconds, between health checks of an individual instance.
   *
   * @schema ElbSpecForProviderHealthCheck#interval
   */
  readonly interval: number;

  /**
   * The instance being checked.
   *
   * @schema ElbSpecForProviderHealthCheck#target
   */
  readonly target: string;

  /**
   * The amount of time, in seconds, during which no response means a failed health check.
   *
   * @schema ElbSpecForProviderHealthCheck#timeout
   */
  readonly timeout: number;

  /**
   * The number of consecutive health check failures required before moving the instance to the Unhealthy state.
   *
   * @schema ElbSpecForProviderHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold: number;

}

/**
 * Converts an object of type 'ElbSpecForProviderHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderHealthCheck(obj: ElbSpecForProviderHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'interval': obj.interval,
    'target': obj.target,
    'timeout': obj.timeout,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Listener represents the port binding(s) between the ELB and EC2 instances.
 *
 * @schema ElbSpecForProviderListeners
 */
export interface ElbSpecForProviderListeners {
  /**
   * The port on which the instance is listening.
   *
   * @schema ElbSpecForProviderListeners#instancePort
   */
  readonly instancePort: number;

  /**
   * The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If not specified, the value is same as for Protocol.
   *
   * @schema ElbSpecForProviderListeners#instanceProtocol
   */
  readonly instanceProtocol?: string;

  /**
   * The port on which the load balancer is listening.
   *
   * @schema ElbSpecForProviderListeners#loadBalancerPort
   */
  readonly loadBalancerPort: number;

  /**
   * The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.
   *
   * @schema ElbSpecForProviderListeners#protocol
   */
  readonly protocol: string;

  /**
   * The Amazon Resource Name (ARN) of the server certificate.
   *
   * @schema ElbSpecForProviderListeners#sslCertificateId
   */
  readonly sslCertificateId?: string;

}

/**
 * Converts an object of type 'ElbSpecForProviderListeners' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderListeners(obj: ElbSpecForProviderListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancePort': obj.instancePort,
    'instanceProtocol': obj.instanceProtocol,
    'loadBalancerPort': obj.loadBalancerPort,
    'protocol': obj.protocol,
    'sslCertificateId': obj.sslCertificateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ElbSpecForProviderSecurityGroupIdRefs
 */
export interface ElbSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: ElbSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSecurityGroupIdRefs(obj: ElbSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDSelector selects a set of references that each retrieve the SecurityGroupID from the referenced SecurityGroup
 *
 * @schema ElbSpecForProviderSecurityGroupIdSelector
 */
export interface ElbSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ElbSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ElbSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ElbSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: ElbSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSecurityGroupIdSelector(obj: ElbSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ElbSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ElbSpecForProviderSubnetIdRefs
 */
export interface ElbSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: ElbSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetIdRefs(obj: ElbSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetSelector selects a set of references that each retrieve the subnetID from the referenced Subnet
 *
 * @schema ElbSpecForProviderSubnetIdSelector
 */
export interface ElbSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ElbSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ElbSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ElbSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: ElbSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetIdSelector(obj: ElbSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ElbSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a key value pair that can be attached to an ELB
 *
 * @schema ElbSpecForProviderTags
 */
export interface ElbSpecForProviderTags {
  /**
   * The key of the tag.
   *
   * @schema ElbSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value of the tag.
   *
   * @schema ElbSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ElbSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderTags(obj: ElbSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecProviderConfigRefPolicy
 */
export interface ElbSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ElbSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ElbSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderConfigRefPolicy(obj: ElbSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRef
 */
export interface ElbSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ElbSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToConfigRef(obj: ElbSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ElbSpecPublishConnectionDetailsToMetadata
 */
export interface ElbSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToMetadata(obj: ElbSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface ElbSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSecurityGroupIdRefsPolicy(obj: ElbSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ElbSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface ElbSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSecurityGroupIdSelectorPolicy(obj: ElbSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecForProviderSubnetIdRefsPolicy
 */
export interface ElbSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetIdRefsPolicy(obj: ElbSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ElbSpecForProviderSubnetIdSelectorPolicy
 */
export interface ElbSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetIdSelectorPolicy(obj: ElbSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecProviderConfigRefPolicyResolution
 */
export enum ElbSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecProviderConfigRefPolicyResolve
 */
export enum ElbSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ElbSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToConfigRefPolicy(obj: ElbSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum ElbSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum ElbSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum ElbSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum ElbSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum ElbSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum ElbSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum ElbSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum ElbSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * An ELBAttachment is a managed resource that represents attachment of an AWS Classic Load Balancer and an AWS EC2 instance.
 *
 * @schema ELBAttachment
 */
export class ElbAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ELBAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticloadbalancing.aws.crossplane.io/v1alpha1',
    kind: 'ELBAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ELBAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ElbAttachmentProps): any {
    return {
      ...ElbAttachment.GVK,
      ...toJson_ElbAttachmentProps(props),
    };
  }

  /**
   * Defines a "ELBAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ElbAttachmentProps) {
    super(scope, id, {
      ...ElbAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ElbAttachment.GVK,
      ...toJson_ElbAttachmentProps(resolved),
    };
  }
}

/**
 * An ELBAttachment is a managed resource that represents attachment of an AWS Classic Load Balancer and an AWS EC2 instance.
 *
 * @schema ELBAttachment
 */
export interface ElbAttachmentProps {
  /**
   * @schema ELBAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An ELBAttachmentSpec defines the desired state of an ELBAttachment.
   *
   * @schema ELBAttachment#spec
   */
  readonly spec: ElbAttachmentSpec;

}

/**
 * Converts an object of type 'ElbAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentProps(obj: ElbAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ElbAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An ELBAttachmentSpec defines the desired state of an ELBAttachment.
 *
 * @schema ElbAttachmentSpec
 */
export interface ElbAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ElbAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ElbAttachmentSpecDeletionPolicy;

  /**
   * ELBAttachmentParameters define the desired state of an AWS ELBAttachment.
   *
   * @schema ElbAttachmentSpec#forProvider
   */
  readonly forProvider: ElbAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ElbAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: ElbAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ElbAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ElbAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ElbAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ElbAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ElbAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ElbAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ElbAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpec(obj: ElbAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ElbAttachmentSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ElbAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ElbAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ElbAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ElbAttachmentSpecDeletionPolicy
 */
export enum ElbAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ELBAttachmentParameters define the desired state of an AWS ELBAttachment.
 *
 * @schema ElbAttachmentSpecForProvider
 */
export interface ElbAttachmentSpecForProvider {
  /**
   * Name of the Elastic Load Balancer to which the instances will attach.
   *
   * @schema ElbAttachmentSpecForProvider#elbName
   */
  readonly elbName?: string;

  /**
   * ELBNameRef references an ELB to and retrieves its external-name.
   *
   * @schema ElbAttachmentSpecForProvider#elbNameRef
   */
  readonly elbNameRef?: ElbAttachmentSpecForProviderElbNameRef;

  /**
   * ELBNameSelector selects a reference to a ELB to and retrieves its external-name.
   *
   * @schema ElbAttachmentSpecForProvider#elbNameSelector
   */
  readonly elbNameSelector?: ElbAttachmentSpecForProviderElbNameSelector;

  /**
   * List of identities of the instances to be attached.
   *
   * @schema ElbAttachmentSpecForProvider#instanceId
   */
  readonly instanceId: string;

  /**
   * Region is the region you'd like your ELBAttachment to be in.
   *
   * @schema ElbAttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ElbAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecForProvider(obj: ElbAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'elbName': obj.elbName,
    'elbNameRef': toJson_ElbAttachmentSpecForProviderElbNameRef(obj.elbNameRef),
    'elbNameSelector': toJson_ElbAttachmentSpecForProviderElbNameSelector(obj.elbNameSelector),
    'instanceId': obj.instanceId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ElbAttachmentSpecManagementPolicies
 */
export enum ElbAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ElbAttachmentSpecProviderConfigRef
 */
export interface ElbAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: ElbAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecProviderConfigRef(obj: ElbAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsTo
 */
export interface ElbAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ElbAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ElbAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ElbAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecPublishConnectionDetailsTo(obj: ElbAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ElbAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ElbAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ElbAttachmentSpecWriteConnectionSecretToRef
 */
export interface ElbAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ElbAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ElbAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ElbAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecWriteConnectionSecretToRef(obj: ElbAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ELBNameRef references an ELB to and retrieves its external-name.
 *
 * @schema ElbAttachmentSpecForProviderElbNameRef
 */
export interface ElbAttachmentSpecForProviderElbNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbAttachmentSpecForProviderElbNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbAttachmentSpecForProviderElbNameRef#policy
   */
  readonly policy?: ElbAttachmentSpecForProviderElbNameRefPolicy;

}

/**
 * Converts an object of type 'ElbAttachmentSpecForProviderElbNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecForProviderElbNameRef(obj: ElbAttachmentSpecForProviderElbNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbAttachmentSpecForProviderElbNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ELBNameSelector selects a reference to a ELB to and retrieves its external-name.
 *
 * @schema ElbAttachmentSpecForProviderElbNameSelector
 */
export interface ElbAttachmentSpecForProviderElbNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ElbAttachmentSpecForProviderElbNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ElbAttachmentSpecForProviderElbNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ElbAttachmentSpecForProviderElbNameSelector#policy
   */
  readonly policy?: ElbAttachmentSpecForProviderElbNameSelectorPolicy;

}

/**
 * Converts an object of type 'ElbAttachmentSpecForProviderElbNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecForProviderElbNameSelector(obj: ElbAttachmentSpecForProviderElbNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ElbAttachmentSpecForProviderElbNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbAttachmentSpecProviderConfigRefPolicy
 */
export interface ElbAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ElbAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ElbAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecProviderConfigRefPolicy(obj: ElbAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ElbAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecPublishConnectionDetailsToConfigRef(obj: ElbAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface ElbAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ElbAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecPublishConnectionDetailsToMetadata(obj: ElbAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbAttachmentSpecForProviderElbNameRefPolicy
 */
export interface ElbAttachmentSpecForProviderElbNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbAttachmentSpecForProviderElbNameRefPolicy#resolution
   */
  readonly resolution?: ElbAttachmentSpecForProviderElbNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbAttachmentSpecForProviderElbNameRefPolicy#resolve
   */
  readonly resolve?: ElbAttachmentSpecForProviderElbNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbAttachmentSpecForProviderElbNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecForProviderElbNameRefPolicy(obj: ElbAttachmentSpecForProviderElbNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ElbAttachmentSpecForProviderElbNameSelectorPolicy
 */
export interface ElbAttachmentSpecForProviderElbNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbAttachmentSpecForProviderElbNameSelectorPolicy#resolution
   */
  readonly resolution?: ElbAttachmentSpecForProviderElbNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbAttachmentSpecForProviderElbNameSelectorPolicy#resolve
   */
  readonly resolve?: ElbAttachmentSpecForProviderElbNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ElbAttachmentSpecForProviderElbNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecForProviderElbNameSelectorPolicy(obj: ElbAttachmentSpecForProviderElbNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum ElbAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum ElbAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbAttachmentSpecForProviderElbNameRefPolicyResolution
 */
export enum ElbAttachmentSpecForProviderElbNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbAttachmentSpecForProviderElbNameRefPolicyResolve
 */
export enum ElbAttachmentSpecForProviderElbNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbAttachmentSpecForProviderElbNameSelectorPolicyResolution
 */
export enum ElbAttachmentSpecForProviderElbNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbAttachmentSpecForProviderElbNameSelectorPolicyResolve
 */
export enum ElbAttachmentSpecForProviderElbNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ElbAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

