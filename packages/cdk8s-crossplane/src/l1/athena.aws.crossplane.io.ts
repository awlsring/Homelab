// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * WorkGroup is the Schema for the WorkGroups API
 *
 * @schema WorkGroup
 */
export class WorkGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'athena.aws.crossplane.io/v1alpha1',
    kind: 'WorkGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkGroupProps): any {
    return {
      ...WorkGroup.GVK,
      ...toJson_WorkGroupProps(props),
    };
  }

  /**
   * Defines a "WorkGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkGroupProps) {
    super(scope, id, {
      ...WorkGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkGroup.GVK,
      ...toJson_WorkGroupProps(resolved),
    };
  }
}

/**
 * WorkGroup is the Schema for the WorkGroups API
 *
 * @schema WorkGroup
 */
export interface WorkGroupProps {
  /**
   * @schema WorkGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkGroupSpec defines the desired state of WorkGroup
   *
   * @schema WorkGroup#spec
   */
  readonly spec: WorkGroupSpec;

}

/**
 * Converts an object of type 'WorkGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupProps(obj: WorkGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkGroupSpec defines the desired state of WorkGroup
 *
 * @schema WorkGroupSpec
 */
export interface WorkGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkGroupSpecDeletionPolicy;

  /**
   * WorkGroupParameters defines the desired state of WorkGroup
   *
   * @schema WorkGroupSpec#forProvider
   */
  readonly forProvider: WorkGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkGroupSpec#managementPolicies
   */
  readonly managementPolicies?: WorkGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpec(obj: WorkGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkGroupSpecDeletionPolicy
 */
export enum WorkGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * WorkGroupParameters defines the desired state of WorkGroup
 *
 * @schema WorkGroupSpecForProvider
 */
export interface WorkGroupSpecForProvider {
  /**
   * Contains configuration information for creating an Athena SQL workgroup or Spark enabled Athena workgroup. Athena SQL workgroup configuration includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See WorkGroupConfiguration$EnforceWorkGroupConfiguration.
   *
   * @schema WorkGroupSpecForProvider#configuration
   */
  readonly configuration?: WorkGroupSpecForProviderConfiguration;

  /**
   * The workgroup description.
   *
   * @schema WorkGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is which region the WorkGroup will be created.
   *
   * @schema WorkGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of comma separated tags to add to the workgroup that is created.
   *
   * @schema WorkGroupSpecForProvider#tags
   */
  readonly tags?: WorkGroupSpecForProviderTags[];

}

/**
 * Converts an object of type 'WorkGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProvider(obj: WorkGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': toJson_WorkGroupSpecForProviderConfiguration(obj.configuration),
    'description': obj.description,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_WorkGroupSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkGroupSpecManagementPolicies
 */
export enum WorkGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkGroupSpecProviderConfigRef
 */
export interface WorkGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkGroupSpecProviderConfigRef#policy
   */
  readonly policy?: WorkGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecProviderConfigRef(obj: WorkGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsTo
 */
export interface WorkGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecPublishConnectionDetailsTo(obj: WorkGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkGroupSpecWriteConnectionSecretToRef
 */
export interface WorkGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecWriteConnectionSecretToRef(obj: WorkGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains configuration information for creating an Athena SQL workgroup or Spark enabled Athena workgroup. Athena SQL workgroup configuration includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See WorkGroupConfiguration$EnforceWorkGroupConfiguration.
 *
 * @schema WorkGroupSpecForProviderConfiguration
 */
export interface WorkGroupSpecForProviderConfiguration {
  /**
   * @schema WorkGroupSpecForProviderConfiguration#additionalConfiguration
   */
  readonly additionalConfiguration?: string;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#bytesScannedCutoffPerQuery
   */
  readonly bytesScannedCutoffPerQuery?: number;

  /**
   * Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
   *
   * @schema WorkGroupSpecForProviderConfiguration#customerContentEncryptionConfiguration
   */
  readonly customerContentEncryptionConfiguration?: WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#enableMinimumEncryptionConfiguration
   */
  readonly enableMinimumEncryptionConfiguration?: boolean;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#enforceWorkGroupConfiguration
   */
  readonly enforceWorkGroupConfiguration?: boolean;

  /**
   * The Athena engine version for running queries, or the PySpark engine version for running sessions.
   *
   * @schema WorkGroupSpecForProviderConfiguration#engineVersion
   */
  readonly engineVersion?: WorkGroupSpecForProviderConfigurationEngineVersion;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#executionRole
   */
  readonly executionRole?: string;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#publishCloudWatchMetricsEnabled
   */
  readonly publishCloudWatchMetricsEnabled?: boolean;

  /**
   * @schema WorkGroupSpecForProviderConfiguration#requesterPaysEnabled
   */
  readonly requesterPaysEnabled?: boolean;

  /**
   * The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
   *
   * @schema WorkGroupSpecForProviderConfiguration#resultConfiguration
   */
  readonly resultConfiguration?: WorkGroupSpecForProviderConfigurationResultConfiguration;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfiguration(obj: WorkGroupSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalConfiguration': obj.additionalConfiguration,
    'bytesScannedCutoffPerQuery': obj.bytesScannedCutoffPerQuery,
    'customerContentEncryptionConfiguration': toJson_WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration(obj.customerContentEncryptionConfiguration),
    'enableMinimumEncryptionConfiguration': obj.enableMinimumEncryptionConfiguration,
    'enforceWorkGroupConfiguration': obj.enforceWorkGroupConfiguration,
    'engineVersion': toJson_WorkGroupSpecForProviderConfigurationEngineVersion(obj.engineVersion),
    'executionRole': obj.executionRole,
    'publishCloudWatchMetricsEnabled': obj.publishCloudWatchMetricsEnabled,
    'requesterPaysEnabled': obj.requesterPaysEnabled,
    'resultConfiguration': toJson_WorkGroupSpecForProviderConfigurationResultConfiguration(obj.resultConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkGroupSpecForProviderTags
 */
export interface WorkGroupSpecForProviderTags {
  /**
   * @schema WorkGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema WorkGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderTags(obj: WorkGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkGroupSpecProviderConfigRefPolicy
 */
export interface WorkGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecProviderConfigRefPolicy(obj: WorkGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecPublishConnectionDetailsToConfigRef(obj: WorkGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsToMetadata
 */
export interface WorkGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecPublishConnectionDetailsToMetadata(obj: WorkGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
 *
 * @schema WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration
 */
export interface WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration {
  /**
   * @schema WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration#kmsKey
   */
  readonly kmsKey?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration(obj: WorkGroupSpecForProviderConfigurationCustomerContentEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKey': obj.kmsKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Athena engine version for running queries, or the PySpark engine version for running sessions.
 *
 * @schema WorkGroupSpecForProviderConfigurationEngineVersion
 */
export interface WorkGroupSpecForProviderConfigurationEngineVersion {
  /**
   * @schema WorkGroupSpecForProviderConfigurationEngineVersion#effectiveEngineVersion
   */
  readonly effectiveEngineVersion?: string;

  /**
   * @schema WorkGroupSpecForProviderConfigurationEngineVersion#selectedEngineVersion
   */
  readonly selectedEngineVersion?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfigurationEngineVersion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfigurationEngineVersion(obj: WorkGroupSpecForProviderConfigurationEngineVersion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effectiveEngineVersion': obj.effectiveEngineVersion,
    'selectedEngineVersion': obj.selectedEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
 *
 * @schema WorkGroupSpecForProviderConfigurationResultConfiguration
 */
export interface WorkGroupSpecForProviderConfigurationResultConfiguration {
  /**
   * Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the x-amz-acl request header. For more information about S3 Object Ownership, see Object Ownership settings (https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview) in the Amazon S3 User Guide.
   *
   * @schema WorkGroupSpecForProviderConfigurationResultConfiguration#aclConfiguration
   */
  readonly aclConfiguration?: WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration;

  /**
   * If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
   *
   * @schema WorkGroupSpecForProviderConfigurationResultConfiguration#encryptionConfiguration
   */
  readonly encryptionConfiguration?: WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration;

  /**
   * @schema WorkGroupSpecForProviderConfigurationResultConfiguration#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * @schema WorkGroupSpecForProviderConfigurationResultConfiguration#outputLocation
   */
  readonly outputLocation?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfigurationResultConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfigurationResultConfiguration(obj: WorkGroupSpecForProviderConfigurationResultConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aclConfiguration': toJson_WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration(obj.aclConfiguration),
    'encryptionConfiguration': toJson_WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration(obj.encryptionConfiguration),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'outputLocation': obj.outputLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkGroupSpecProviderConfigRefPolicyResolution
 */
export enum WorkGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkGroupSpecProviderConfigRefPolicyResolve
 */
export enum WorkGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the x-amz-acl request header. For more information about S3 Object Ownership, see Object Ownership settings (https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview) in the Amazon S3 User Guide.
 *
 * @schema WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration
 */
export interface WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration {
  /**
   * @schema WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration#s3ACLOption
   */
  readonly s3AclOption?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration(obj: WorkGroupSpecForProviderConfigurationResultConfigurationAclConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3ACLOption': obj.s3AclOption,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
 *
 * @schema WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration
 */
export interface WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration {
  /**
   * @schema WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#encryptionOption
   */
  readonly encryptionOption?: string;

  /**
   * @schema WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#kmsKey
   */
  readonly kmsKey?: string;

}

/**
 * Converts an object of type 'WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration(obj: WorkGroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionOption': obj.encryptionOption,
    'kmsKey': obj.kmsKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

