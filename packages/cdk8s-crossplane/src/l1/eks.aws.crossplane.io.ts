// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Addon is the Schema for the Addons API
 *
 * @schema Addon
 */
export class Addon extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Addon"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1alpha1',
    kind: 'Addon',
  }

  /**
   * Renders a Kubernetes manifest for "Addon".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddonProps): any {
    return {
      ...Addon.GVK,
      ...toJson_AddonProps(props),
    };
  }

  /**
   * Defines a "Addon" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddonProps) {
    super(scope, id, {
      ...Addon.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Addon.GVK,
      ...toJson_AddonProps(resolved),
    };
  }
}

/**
 * Addon is the Schema for the Addons API
 *
 * @schema Addon
 */
export interface AddonProps {
  /**
   * @schema Addon#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddonSpec defines the desired state of Addon
   *
   * @schema Addon#spec
   */
  readonly spec: AddonSpec;

}

/**
 * Converts an object of type 'AddonProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonProps(obj: AddonProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddonSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddonSpec defines the desired state of Addon
 *
 * @schema AddonSpec
 */
export interface AddonSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AddonSpec#deletionPolicy
   */
  readonly deletionPolicy?: AddonSpecDeletionPolicy;

  /**
   * AddonParameters defines the desired state of Addon
   *
   * @schema AddonSpec#forProvider
   */
  readonly forProvider: AddonSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AddonSpec#managementPolicies
   */
  readonly managementPolicies?: AddonSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AddonSpec#providerConfigRef
   */
  readonly providerConfigRef?: AddonSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AddonSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AddonSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AddonSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AddonSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AddonSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpec(obj: AddonSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AddonSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AddonSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AddonSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AddonSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AddonSpecDeletionPolicy
 */
export enum AddonSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AddonParameters defines the desired state of Addon
 *
 * @schema AddonSpecForProvider
 */
export interface AddonSpecForProvider {
  /**
   * The name of the add-on. The name must match one of the names that DescribeAddonVersions (https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html) returns.
   *
   * @schema AddonSpecForProvider#addonName
   */
  readonly addonName: string;

  /**
   * The version of the add-on. The version must match one of the versions returned by DescribeAddonVersions (https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html).
   *
   * @schema AddonSpecForProvider#addonVersion
   */
  readonly addonVersion?: string;

  /**
   * The name of the cluster to create the add-on for.
   *
   * @schema AddonSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
   *
   * @schema AddonSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: AddonSpecForProviderClusterNameRef;

  /**
   * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
   *
   * @schema AddonSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: AddonSpecForProviderClusterNameSelector;

  /**
   * The set of configuration values for the add-on that's created. The values that you provide are validated against the schema in DescribeAddonConfiguration (https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonConfiguration.html).
   *
   * @schema AddonSpecForProvider#configurationValues
   */
  readonly configurationValues?: string;

  /**
   * Region is which region the Addon will be created.
   *
   * @schema AddonSpecForProvider#region
   */
  readonly region: string;

  /**
   * How to resolve field value conflicts for an Amazon EKS add-on. Conflicts are handled based on the value you choose:
   * * None – If the self-managed version of the add-on is installed on your cluster, Amazon EKS doesn't change the value. Creation of the add-on might fail.
   * * Overwrite – If the self-managed version of the add-on is installed on your cluster and the Amazon EKS default value is different than the existing value, Amazon EKS changes the value to the Amazon EKS default value.
   * * Preserve – Not supported. You can set this value when updating an add-on though. For more information, see UpdateAddon (https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html).
   * If you don't currently have the self-managed version of the add-on installed on your cluster, the Amazon EKS add-on is installed. Amazon EKS sets all values to default values, regardless of the option that you specify.
   *
   * @schema AddonSpecForProvider#resolveConflicts
   */
  readonly resolveConflicts?: string;

  /**
   * The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see Amazon EKS node IAM role (https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html) in the Amazon EKS User Guide.
   * To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see Enabling IAM roles for service accounts on your cluster (https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html) in the Amazon EKS User Guide.
   *
   * @schema AddonSpecForProvider#serviceAccountRoleARN
   */
  readonly serviceAccountRoleArn?: string;

  /**
   * The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value. You define both.
   *
   * @schema AddonSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AddonSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProvider(obj: AddonSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonName': obj.addonName,
    'addonVersion': obj.addonVersion,
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_AddonSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_AddonSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'configurationValues': obj.configurationValues,
    'region': obj.region,
    'resolveConflicts': obj.resolveConflicts,
    'serviceAccountRoleARN': obj.serviceAccountRoleArn,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AddonSpecManagementPolicies
 */
export enum AddonSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AddonSpecProviderConfigRef
 */
export interface AddonSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecProviderConfigRef#policy
   */
  readonly policy?: AddonSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecProviderConfigRef(obj: AddonSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AddonSpecPublishConnectionDetailsTo
 */
export interface AddonSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AddonSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AddonSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsTo(obj: AddonSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AddonSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AddonSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AddonSpecWriteConnectionSecretToRef
 */
export interface AddonSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AddonSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AddonSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AddonSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecWriteConnectionSecretToRef(obj: AddonSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
 *
 * @schema AddonSpecForProviderClusterNameRef
 */
export interface AddonSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecForProviderClusterNameRef#policy
   */
  readonly policy?: AddonSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameRef(obj: AddonSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
 *
 * @schema AddonSpecForProviderClusterNameSelector
 */
export interface AddonSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AddonSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddonSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddonSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: AddonSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameSelector(obj: AddonSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddonSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddonSpecProviderConfigRefPolicy
 */
export interface AddonSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AddonSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AddonSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecProviderConfigRefPolicy(obj: AddonSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRef
 */
export interface AddonSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AddonSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToConfigRef(obj: AddonSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AddonSpecPublishConnectionDetailsToMetadata
 */
export interface AddonSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToMetadata(obj: AddonSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicy
 */
export interface AddonSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameRefPolicy(obj: AddonSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicy
 */
export interface AddonSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameSelectorPolicy(obj: AddonSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecProviderConfigRefPolicyResolution
 */
export enum AddonSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecProviderConfigRefPolicyResolve
 */
export enum AddonSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AddonSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToConfigRefPolicy(obj: AddonSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicyResolution
 */
export enum AddonSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicyResolve
 */
export enum AddonSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum AddonSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum AddonSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Cluster is a managed resource that represents an AWS Elastic Kubernetes Service cluster.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * A Cluster is a managed resource that represents an AWS Elastic Kubernetes Service cluster.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ClusterSpec defines the desired state of an EKS Cluster.
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ClusterSpec defines the desired state of an EKS Cluster.
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * ClusterParameters define the desired state of an AWS Elastic Kubernetes Service cluster.
   *
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClusterParameters define the desired state of an AWS Elastic Kubernetes Service cluster.
 *
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * The encryption configuration for the cluster.
   *
   * @schema ClusterSpecForProvider#encryptionConfig
   */
  readonly encryptionConfig?: ClusterSpecForProviderEncryptionConfig[];

  /**
   * The Kubernetes network configuration for the cluster.
   *
   * @schema ClusterSpecForProvider#kubernetesNetworkConfig
   */
  readonly kubernetesNetworkConfig?: ClusterSpecForProviderKubernetesNetworkConfig;

  /**
   * Enable or disable exporting the Kubernetes control plane logs for your cluster to CloudWatch Logs. By default, cluster control plane logs aren't exported to CloudWatch Logs. For more information, see Amazon EKS Cluster Control Plane Logs (https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html) in the Amazon EKS User Guide .
   * CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported control plane logs. For more information, see Amazon CloudWatch Pricing (http://aws.amazon.com/cloudwatch/pricing/).
   *
   * @schema ClusterSpecForProvider#logging
   */
  readonly logging?: ClusterSpecForProviderLogging;

  /**
   * An object representing the configuration of your local Amazon EKS cluster on an Amazon Web Services Outpost. Before creating a local cluster on an Outpost, review Creating an Amazon EKS cluster on an Amazon Web Services Outpost (https://docs.aws.amazon.com/eks/latest/userguide/create-cluster-outpost.html) in the Amazon EKS User Guide. This object isn't available for creating Amazon EKS clusters on the Amazon Web Services cloud.
   *
   * @schema ClusterSpecForProvider#outpostConfig
   */
  readonly outpostConfig?: ClusterSpecForProviderOutpostConfig;

  /**
   * Region is the region you'd like your Cluster to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region?: string;

  /**
   * The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see Cluster VPC Considerations (https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html) and Cluster Security Group Considerations (https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html) in the Amazon EKS User Guide. You must specify at least two subnets. You can specify up to five security groups, but we recommend that you use a dedicated security group for your cluster control plane.
   * ResourcesVpcConfig is a required field
   *
   * @schema ClusterSpecForProvider#resourcesVpcConfig
   */
  readonly resourcesVpcConfig: ClusterSpecForProviderResourcesVpcConfig;

  /**
   * The Amazon Resource Name (ARN) of the IAM role that provides permissions for Amazon EKS to make calls to other AWS API operations on your behalf. For more information, see Amazon EKS Service IAM Role (https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html) in the Amazon EKS User Guide .
   * RoleArn is a required field
   *
   * @schema ClusterSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * RoleArnRef is a reference to an IAMRole used to set the RoleArn.
   *
   * @schema ClusterSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ClusterSpecForProviderRoleArnRef;

  /**
   * RoleArnSelector selects references to IAMRole used to set the RoleArn.
   *
   * @schema ClusterSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ClusterSpecForProviderRoleArnSelector;

  /**
   * The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The desired Kubernetes version for your cluster. If you don't specify a value here, the latest version available in Amazon EKS is used. Example: 1.15
   *
   * @schema ClusterSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_ClusterSpecForProviderEncryptionConfig(y)),
    'kubernetesNetworkConfig': toJson_ClusterSpecForProviderKubernetesNetworkConfig(obj.kubernetesNetworkConfig),
    'logging': toJson_ClusterSpecForProviderLogging(obj.logging),
    'outpostConfig': toJson_ClusterSpecForProviderOutpostConfig(obj.outpostConfig),
    'region': obj.region,
    'resourcesVpcConfig': toJson_ClusterSpecForProviderResourcesVpcConfig(obj.resourcesVpcConfig),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ClusterSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ClusterSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EncryptionConfig is the encryption configuration for a cluster.
 *
 * @schema ClusterSpecForProviderEncryptionConfig
 */
export interface ClusterSpecForProviderEncryptionConfig {
  /**
   * AWS Key Management Service (AWS KMS) customer master key (CMK). Either the ARN or the alias can be used.
   *
   * @schema ClusterSpecForProviderEncryptionConfig#provider
   */
  readonly provider: ClusterSpecForProviderEncryptionConfigProvider;

  /**
   * Specifies the resources to be encrypted. The only supported value is "secrets".
   *
   * @schema ClusterSpecForProviderEncryptionConfig#resources
   */
  readonly resources: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionConfig(obj: ClusterSpecForProviderEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': toJson_ClusterSpecForProviderEncryptionConfigProvider(obj.provider),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Kubernetes network configuration for the cluster.
 *
 * @schema ClusterSpecForProviderKubernetesNetworkConfig
 */
export interface ClusterSpecForProviderKubernetesNetworkConfig {
  /**
   * Specify which IP family is used to assign Kubernetes pod and service IP addresses. If you don't specify a value, ipv4 is used by default. You can only specify an IP family when you create a cluster and can't change this value once the cluster is created. If you specify ipv6, the VPC and subnets that you specify for cluster creation must have both IPv4 and IPv6 CIDR blocks assigned to them. You can't specify ipv6 for clusters in China Regions. You can only specify ipv6 for 1.21 and later clusters that use version 1.10.1 or later of the Amazon VPC CNI add-on. If you specify ipv6, then ensure that your VPC meets the requirements listed in the considerations listed in Assigning IPv6 addresses to pods and services (https://docs.aws.amazon.com/eks/latest/userguide/cni-ipv6.html) in the Amazon EKS User Guide. Kubernetes assigns services IPv6 addresses from the unique local address range (fc00::/7). You can't specify a custom IPv6 CIDR block. Pod addresses are assigned from the subnet's IPv6 CIDR.
   *
   * @schema ClusterSpecForProviderKubernetesNetworkConfig#ipFamily
   */
  readonly ipFamily: string;

  /**
   * Don't specify a value if you select ipv6 for ipFamily. The CIDR block to assign Kubernetes service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. The block must meet the following requirements:
   * * Within one of the following private IP address blocks: 10.0.0.0/8, 172.16.0.0/12, or 192.168.0.0/16.
   * * Doesn't overlap with any CIDR block assigned to the VPC that you selected for VPC.
   * * Between /24 and /12.
   * You can only specify a custom CIDR block when you create a cluster and can't change this value once the cluster is created.
   *
   * @schema ClusterSpecForProviderKubernetesNetworkConfig#serviceIpv4Cidr
   */
  readonly serviceIpv4Cidr?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKubernetesNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKubernetesNetworkConfig(obj: ClusterSpecForProviderKubernetesNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipFamily': obj.ipFamily,
    'serviceIpv4Cidr': obj.serviceIpv4Cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable or disable exporting the Kubernetes control plane logs for your cluster to CloudWatch Logs. By default, cluster control plane logs aren't exported to CloudWatch Logs. For more information, see Amazon EKS Cluster Control Plane Logs (https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html) in the Amazon EKS User Guide .
 * CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported control plane logs. For more information, see Amazon CloudWatch Pricing (http://aws.amazon.com/cloudwatch/pricing/).
 *
 * @schema ClusterSpecForProviderLogging
 */
export interface ClusterSpecForProviderLogging {
  /**
   * The cluster control plane logging configuration for your cluster.
   *
   * @schema ClusterSpecForProviderLogging#clusterLogging
   */
  readonly clusterLogging: ClusterSpecForProviderLoggingClusterLogging[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLogging(obj: ClusterSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLogging': obj.clusterLogging?.map(y => toJson_ClusterSpecForProviderLoggingClusterLogging(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object representing the configuration of your local Amazon EKS cluster on an Amazon Web Services Outpost. Before creating a local cluster on an Outpost, review Creating an Amazon EKS cluster on an Amazon Web Services Outpost (https://docs.aws.amazon.com/eks/latest/userguide/create-cluster-outpost.html) in the Amazon EKS User Guide. This object isn't available for creating Amazon EKS clusters on the Amazon Web Services cloud.
 *
 * @schema ClusterSpecForProviderOutpostConfig
 */
export interface ClusterSpecForProviderOutpostConfig {
  /**
   * The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. Choose an instance type based on the number of nodes that your cluster will have. If your cluster will have:
   * * 1–20 nodes, then we recommend specifying a large instance type.
   * * 21–100 nodes, then we recommend specifying an xlarge instance type.
   * * 101–250 nodes, then we recommend specifying a 2xlarge instance type.
   * For a list of the available Amazon EC2 instance types, see Compute and storage in Outposts rack features (http://aws.amazon.com/outposts/rack/features/). The control plane is not automatically scaled by Amazon EKS.
   * This member is required.
   *
   * @schema ClusterSpecForProviderOutpostConfig#controlPlaneInstanceType
   */
  readonly controlPlaneInstanceType: string;

  /**
   * The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. Only a single Outpost ARN is supported.
   * This member is required.
   *
   * @schema ClusterSpecForProviderOutpostConfig#outpostArns
   */
  readonly outpostArns: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderOutpostConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOutpostConfig(obj: ClusterSpecForProviderOutpostConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controlPlaneInstanceType': obj.controlPlaneInstanceType,
    'outpostArns': obj.outpostArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see Cluster VPC Considerations (https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html) and Cluster Security Group Considerations (https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html) in the Amazon EKS User Guide. You must specify at least two subnets. You can specify up to five security groups, but we recommend that you use a dedicated security group for your cluster control plane.
 * ResourcesVpcConfig is a required field
 *
 * @schema ClusterSpecForProviderResourcesVpcConfig
 */
export interface ClusterSpecForProviderResourcesVpcConfig {
  /**
   * Set this value to true to enable private access for your cluster's Kubernetes API server endpoint. If you enable private access, Kubernetes API requests from within your cluster's VPC use the private VPC endpoint. The default value for this parameter is false, which disables private access for your Kubernetes API server. For more information, see Amazon EKS Cluster Endpoint Access Control (https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html) in the Amazon EKS User Guide.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#endpointPrivateAccess
   */
  readonly endpointPrivateAccess?: boolean;

  /**
   * Set this value to false to disable public access for your cluster's Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes API server can receive only requests from within the cluster VPC. The default value for this parameter is true, which enables public access for your Kubernetes API server. For more information, see Amazon EKS Cluster Endpoint Access Control (https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html) in the Amazon EKS User Guide.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#endpointPublicAccess
   */
  readonly endpointPublicAccess?: boolean;

  /**
   * The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that you specify is denied. The default value is 0.0.0.0/0. If you've disabled private endpoint access and you have worker nodes or AWS Fargate pods in the cluster, then ensure that you specify the necessary CIDR blocks. For more information, see Amazon EKS Cluster Endpoint Access Control (https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html) in the Amazon EKS User Guide.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#publicAccessCidrs
   */
  readonly publicAccessCidrs?: string[];

  /**
   * SecurityGroupIDRefs are references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector;

  /**
   * Specify one or more security groups for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane. If you don't specify a security group, the default security group for your VPC is used.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetIDRefs are references to Subnets used to set the SubnetIDs.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs[];

  /**
   * SubnetIDSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector;

  /**
   * Specify subnets for your Amazon EKS worker nodes. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your worker nodes and the Kubernetes control plane.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfig(obj: ClusterSpecForProviderResourcesVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointPrivateAccess': obj.endpointPrivateAccess,
    'endpointPublicAccess': obj.endpointPublicAccess,
    'publicAccessCidrs': obj.publicAccessCidrs?.map(y => y),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleArnRef is a reference to an IAMRole used to set the RoleArn.
 *
 * @schema ClusterSpecForProviderRoleArnRef
 */
export interface ClusterSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnRef(obj: ClusterSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleArnSelector selects references to IAMRole used to set the RoleArn.
 *
 * @schema ClusterSpecForProviderRoleArnSelector
 */
export interface ClusterSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnSelector(obj: ClusterSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWS Key Management Service (AWS KMS) customer master key (CMK). Either the ARN or the alias can be used.
 *
 * @schema ClusterSpecForProviderEncryptionConfigProvider
 */
export interface ClusterSpecForProviderEncryptionConfigProvider {
  /**
   * Amazon Resource Name (ARN) or alias of the customer master key (CMK). The CMK must be symmetric, created in the same region as the cluster, and if the CMK was created in a different account, the user must have access to the CMK. For more information, see Allowing Users in Other Accounts to Use a CMK (https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html) in the AWS Key Management Service Developer Guide.
   *
   * @schema ClusterSpecForProviderEncryptionConfigProvider#keyArn
   */
  readonly keyArn: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionConfigProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionConfigProvider(obj: ClusterSpecForProviderEncryptionConfigProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyArn': obj.keyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogSetup specifies the logging types that are enabled.
 *
 * @schema ClusterSpecForProviderLoggingClusterLogging
 */
export interface ClusterSpecForProviderLoggingClusterLogging {
  /**
   * If a log type is enabled, that log type exports its control plane logs to CloudWatch Logs. If a log type isn't enabled, that log type doesn't export its control plane logs. Each individual log type can be enabled or disabled independently.
   *
   * @schema ClusterSpecForProviderLoggingClusterLogging#enabled
   */
  readonly enabled?: boolean;

  /**
   * The available cluster control plane log types.
   *
   * @schema ClusterSpecForProviderLoggingClusterLogging#types
   */
  readonly types?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingClusterLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingClusterLogging(obj: ClusterSpecForProviderLoggingClusterLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'types': obj.types?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs(obj: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector(obj: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs
 */
export interface ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs(obj: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector
 */
export interface ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector(obj: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicy
 */
export interface ClusterSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnRefPolicy(obj: ClusterSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicy
 */
export interface ClusterSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnSelectorPolicy(obj: ClusterSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy
 */
export interface ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy(obj: ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy
 */
export interface ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy(obj: ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicyResolution
 */
export enum ClusterSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicyResolve
 */
export enum ClusterSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderResourcesVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderResourcesVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderResourcesVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A FargateProfile is a managed resource that represents an AWS Elastic Kubernetes Service FargateProfile. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema FargateProfile
 */
export class FargateProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FargateProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1alpha1',
    kind: 'FargateProfile',
  }

  /**
   * Renders a Kubernetes manifest for "FargateProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FargateProfileProps): any {
    return {
      ...FargateProfile.GVK,
      ...toJson_FargateProfileProps(props),
    };
  }

  /**
   * Defines a "FargateProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FargateProfileProps) {
    super(scope, id, {
      ...FargateProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FargateProfile.GVK,
      ...toJson_FargateProfileProps(resolved),
    };
  }
}

/**
 * A FargateProfile is a managed resource that represents an AWS Elastic Kubernetes Service FargateProfile. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema FargateProfile
 */
export interface FargateProfileProps {
  /**
   * @schema FargateProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A FargateProfileSpec defines the desired state of an EKS FargateProfile.
   *
   * @schema FargateProfile#spec
   */
  readonly spec: FargateProfileSpec;

}

/**
 * Converts an object of type 'FargateProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileProps(obj: FargateProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FargateProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A FargateProfileSpec defines the desired state of an EKS FargateProfile.
 *
 * @schema FargateProfileSpec
 */
export interface FargateProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FargateProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: FargateProfileSpecDeletionPolicy;

  /**
   * FargateProfileParameters define the desired state of an AWS Elastic Kubernetes Service FargateProfile. All fields are immutable as it is not possible to update a Fargate profile.
   *
   * @schema FargateProfileSpec#forProvider
   */
  readonly forProvider: FargateProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FargateProfileSpec#managementPolicies
   */
  readonly managementPolicies?: FargateProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FargateProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: FargateProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FargateProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FargateProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FargateProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FargateProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FargateProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpec(obj: FargateProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FargateProfileSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FargateProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FargateProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FargateProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FargateProfileSpecDeletionPolicy
 */
export enum FargateProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FargateProfileParameters define the desired state of an AWS Elastic Kubernetes Service FargateProfile. All fields are immutable as it is not possible to update a Fargate profile.
 *
 * @schema FargateProfileSpecForProvider
 */
export interface FargateProfileSpecForProvider {
  /**
   * The name of the Amazon EKS cluster to apply the Fargate profile to.
   * ClusterName is a required field
   *
   * @schema FargateProfileSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
   *
   * @schema FargateProfileSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: FargateProfileSpecForProviderClusterNameRef;

  /**
   * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
   *
   * @schema FargateProfileSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: FargateProfileSpecForProviderClusterNameSelector;

  /**
   * The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. For more information, see Pod Execution Role (https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html) in the Amazon EKS User Guide.
   * At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArn
   */
  readonly podExecutionRoleArn?: string;

  /**
   * PodExecutionRoleArnRef is a reference to an IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArnRef
   */
  readonly podExecutionRoleArnRef?: FargateProfileSpecForProviderPodExecutionRoleArnRef;

  /**
   * PodExecutionRoleArnSelector selects references to IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArnSelector
   */
  readonly podExecutionRoleArnSelector?: FargateProfileSpecForProviderPodExecutionRoleArnSelector;

  /**
   * Region is the region you'd like  the FargateProfile to be created in.
   *
   * @schema FargateProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. You may specify up to five selectors in a Fargate profile.
   *
   * @schema FargateProfileSpecForProvider#selectors
   */
  readonly selectors?: FargateProfileSpecForProviderSelectors[];

  /**
   * SubnetRefs are references to Subnets used to set the Subnets.
   *
   * @schema FargateProfileSpecForProvider#subnetRefs
   */
  readonly subnetRefs?: FargateProfileSpecForProviderSubnetRefs[];

  /**
   * SubnetSelector selects references to Subnets used to set the Subnets.
   *
   * @schema FargateProfileSpecForProvider#subnetSelector
   */
  readonly subnetSelector?: FargateProfileSpecForProviderSubnetSelector;

  /**
   * The IDs of subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are accepted for this parameter.
   *
   * @schema FargateProfileSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * The metadata to apply to the Fargate profile to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Fargate profile tags do not propagate to any other resources associated with the Fargate profile, such as the pods that are scheduled with it.
   *
   * @schema FargateProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FargateProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProvider(obj: FargateProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_FargateProfileSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_FargateProfileSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'podExecutionRoleArn': obj.podExecutionRoleArn,
    'podExecutionRoleArnRef': toJson_FargateProfileSpecForProviderPodExecutionRoleArnRef(obj.podExecutionRoleArnRef),
    'podExecutionRoleArnSelector': toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelector(obj.podExecutionRoleArnSelector),
    'region': obj.region,
    'selectors': obj.selectors?.map(y => toJson_FargateProfileSpecForProviderSelectors(y)),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_FargateProfileSpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_FargateProfileSpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FargateProfileSpecManagementPolicies
 */
export enum FargateProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FargateProfileSpecProviderConfigRef
 */
export interface FargateProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecProviderConfigRef#policy
   */
  readonly policy?: FargateProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecProviderConfigRef(obj: FargateProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsTo
 */
export interface FargateProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FargateProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FargateProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsTo(obj: FargateProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FargateProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FargateProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FargateProfileSpecWriteConnectionSecretToRef
 */
export interface FargateProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FargateProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FargateProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FargateProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecWriteConnectionSecretToRef(obj: FargateProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
 *
 * @schema FargateProfileSpecForProviderClusterNameRef
 */
export interface FargateProfileSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderClusterNameRef#policy
   */
  readonly policy?: FargateProfileSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameRef(obj: FargateProfileSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelector
 */
export interface FargateProfileSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameSelector(obj: FargateProfileSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodExecutionRoleArnRef is a reference to an IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef#policy
   */
  readonly policy?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnRef(obj: FargateProfileSpecForProviderPodExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodExecutionRoleArnSelector selects references to IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelector(obj: FargateProfileSpecForProviderPodExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FargateProfileSelector is an object representing an AWS Fargate profile selector.
 *
 * @schema FargateProfileSpecForProviderSelectors
 */
export interface FargateProfileSpecForProviderSelectors {
  /**
   * The Kubernetes labels that the selector should match. A pod must contain all of the labels that are specified in the selector for it to be considered a match.
   *
   * @schema FargateProfileSpecForProviderSelectors#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The Kubernetes namespace that the selector should match.
   *
   * @schema FargateProfileSpecForProviderSelectors#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSelectors(obj: FargateProfileSpecForProviderSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FargateProfileSpecForProviderSubnetRefs
 */
export interface FargateProfileSpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderSubnetRefs#policy
   */
  readonly policy?: FargateProfileSpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetRefs(obj: FargateProfileSpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetSelector selects references to Subnets used to set the Subnets.
 *
 * @schema FargateProfileSpecForProviderSubnetSelector
 */
export interface FargateProfileSpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderSubnetSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetSelector(obj: FargateProfileSpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicy
 */
export interface FargateProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecProviderConfigRefPolicy(obj: FargateProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface FargateProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToConfigRef(obj: FargateProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToMetadata
 */
export interface FargateProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToMetadata(obj: FargateProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicy
 */
export interface FargateProfileSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameRefPolicy(obj: FargateProfileSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy
 */
export interface FargateProfileSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameSelectorPolicy(obj: FargateProfileSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy(obj: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy(obj: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderSubnetRefsPolicy
 */
export interface FargateProfileSpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetRefsPolicy(obj: FargateProfileSpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderSubnetSelectorPolicy
 */
export interface FargateProfileSpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetSelectorPolicy(obj: FargateProfileSpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicyResolution
 */
export enum FargateProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicyResolve
 */
export enum FargateProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicyResolution
 */
export enum FargateProfileSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicyResolve
 */
export enum FargateProfileSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderSubnetRefsPolicyResolution
 */
export enum FargateProfileSpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderSubnetRefsPolicyResolve
 */
export enum FargateProfileSpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderSubnetSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderSubnetSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A FargateProfile is a managed resource that represents an AWS Elastic Kubernetes Service FargateProfile.
 *
 * @schema FargateProfileV1Beta1
 */
export class FargateProfileV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FargateProfileV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1beta1',
    kind: 'FargateProfile',
  }

  /**
   * Renders a Kubernetes manifest for "FargateProfileV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FargateProfileV1Beta1Props): any {
    return {
      ...FargateProfileV1Beta1.GVK,
      ...toJson_FargateProfileV1Beta1Props(props),
    };
  }

  /**
   * Defines a "FargateProfileV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FargateProfileV1Beta1Props) {
    super(scope, id, {
      ...FargateProfileV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FargateProfileV1Beta1.GVK,
      ...toJson_FargateProfileV1Beta1Props(resolved),
    };
  }
}

/**
 * A FargateProfile is a managed resource that represents an AWS Elastic Kubernetes Service FargateProfile.
 *
 * @schema FargateProfileV1Beta1
 */
export interface FargateProfileV1Beta1Props {
  /**
   * @schema FargateProfileV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A FargateProfileSpec defines the desired state of an EKS FargateProfile.
   *
   * @schema FargateProfileV1Beta1#spec
   */
  readonly spec: FargateProfileV1Beta1Spec;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1Props(obj: FargateProfileV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FargateProfileV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A FargateProfileSpec defines the desired state of an EKS FargateProfile.
 *
 * @schema FargateProfileV1Beta1Spec
 */
export interface FargateProfileV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FargateProfileV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: FargateProfileV1Beta1SpecDeletionPolicy;

  /**
   * FargateProfileParameters define the desired state of an AWS Elastic Kubernetes Service FargateProfile. All fields are immutable as it is not possible to update a Fargate profile.
   *
   * @schema FargateProfileV1Beta1Spec#forProvider
   */
  readonly forProvider: FargateProfileV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FargateProfileV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: FargateProfileV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FargateProfileV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: FargateProfileV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FargateProfileV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FargateProfileV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FargateProfileV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FargateProfileV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1Spec(obj: FargateProfileV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FargateProfileV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FargateProfileV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FargateProfileV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FargateProfileV1Beta1SpecDeletionPolicy
 */
export enum FargateProfileV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FargateProfileParameters define the desired state of an AWS Elastic Kubernetes Service FargateProfile. All fields are immutable as it is not possible to update a Fargate profile.
 *
 * @schema FargateProfileV1Beta1SpecForProvider
 */
export interface FargateProfileV1Beta1SpecForProvider {
  /**
   * The name of the Amazon EKS cluster to apply the Fargate profile to.
   * ClusterName is a required field
   *
   * @schema FargateProfileV1Beta1SpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: FargateProfileV1Beta1SpecForProviderClusterNameRef;

  /**
   * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: FargateProfileV1Beta1SpecForProviderClusterNameSelector;

  /**
   * The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. For more information, see Pod Execution Role (https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html) in the Amazon EKS User Guide.
   * At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileV1Beta1SpecForProvider#podExecutionRoleArn
   */
  readonly podExecutionRoleArn?: string;

  /**
   * PodExecutionRoleArnRef is a reference to an IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileV1Beta1SpecForProvider#podExecutionRoleArnRef
   */
  readonly podExecutionRoleArnRef?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef;

  /**
   * PodExecutionRoleArnSelector selects references to IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
   *
   * @schema FargateProfileV1Beta1SpecForProvider#podExecutionRoleArnSelector
   */
  readonly podExecutionRoleArnSelector?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector;

  /**
   * Region is the region you'd like  the FargateProfile to be created in.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. You may specify up to five selectors in a Fargate profile.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#selectors
   */
  readonly selectors?: FargateProfileV1Beta1SpecForProviderSelectors[];

  /**
   * SubnetRefs are references to Subnets used to set the Subnets.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#subnetRefs
   */
  readonly subnetRefs?: FargateProfileV1Beta1SpecForProviderSubnetRefs[];

  /**
   * SubnetSelector selects references to Subnets used to set the Subnets.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#subnetSelector
   */
  readonly subnetSelector?: FargateProfileV1Beta1SpecForProviderSubnetSelector;

  /**
   * The IDs of subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are accepted for this parameter.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * The metadata to apply to the Fargate profile to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Fargate profile tags do not propagate to any other resources associated with the Fargate profile, such as the pods that are scheduled with it.
   *
   * @schema FargateProfileV1Beta1SpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProvider(obj: FargateProfileV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_FargateProfileV1Beta1SpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_FargateProfileV1Beta1SpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'podExecutionRoleArn': obj.podExecutionRoleArn,
    'podExecutionRoleArnRef': toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef(obj.podExecutionRoleArnRef),
    'podExecutionRoleArnSelector': toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector(obj.podExecutionRoleArnSelector),
    'region': obj.region,
    'selectors': obj.selectors?.map(y => toJson_FargateProfileV1Beta1SpecForProviderSelectors(y)),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_FargateProfileV1Beta1SpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_FargateProfileV1Beta1SpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FargateProfileV1Beta1SpecManagementPolicies
 */
export enum FargateProfileV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FargateProfileV1Beta1SpecProviderConfigRef
 */
export interface FargateProfileV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecProviderConfigRef(obj: FargateProfileV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsTo
 */
export interface FargateProfileV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsTo(obj: FargateProfileV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FargateProfileV1Beta1SpecWriteConnectionSecretToRef
 */
export interface FargateProfileV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FargateProfileV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FargateProfileV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecWriteConnectionSecretToRef(obj: FargateProfileV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameRef
 */
export interface FargateProfileV1Beta1SpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameRef#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderClusterNameRef(obj: FargateProfileV1Beta1SpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelector
 */
export interface FargateProfileV1Beta1SpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelector#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderClusterNameSelector(obj: FargateProfileV1Beta1SpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodExecutionRoleArnRef is a reference to an IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef
 */
export interface FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef(obj: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodExecutionRoleArnSelector selects references to IAMRole used to set the PodExecutionRoleArn. At least one of podExecutionRoleArn, podExecutionRoleArnRef or podExecutionRoleArnSelector has to be given
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector
 */
export interface FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector(obj: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FargateProfileSelector is an object representing an AWS Fargate profile selector.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSelectors
 */
export interface FargateProfileV1Beta1SpecForProviderSelectors {
  /**
   * The Kubernetes labels that the selector should match. A pod must contain all of the labels that are specified in the selector for it to be considered a match.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSelectors#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The Kubernetes namespace that the selector should match.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSelectors#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderSelectors(obj: FargateProfileV1Beta1SpecForProviderSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetRefs
 */
export interface FargateProfileV1Beta1SpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetRefs#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderSubnetRefs(obj: FargateProfileV1Beta1SpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetSelector selects references to Subnets used to set the Subnets.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetSelector
 */
export interface FargateProfileV1Beta1SpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetSelector#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderSubnetSelector(obj: FargateProfileV1Beta1SpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileV1Beta1SpecProviderConfigRefPolicy
 */
export interface FargateProfileV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecProviderConfigRefPolicy(obj: FargateProfileV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata(obj: FargateProfileV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy(obj: FargateProfileV1Beta1SpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy(obj: FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy(obj: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy(obj: FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy(obj: FargateProfileV1Beta1SpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy
 */
export interface FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy(obj: FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum FargateProfileV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum FargateProfileV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderPodExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolution
 */
export enum FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolve
 */
export enum FargateProfileV1Beta1SpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FargateProfileV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * An IdentityProviderConfig is a managed resource that represents an AWS Elastic Kubernetes Service IdentityProviderConfig.
 *
 * @schema IdentityProviderConfig
 */
export class IdentityProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1alpha1',
    kind: 'IdentityProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityProviderConfigProps): any {
    return {
      ...IdentityProviderConfig.GVK,
      ...toJson_IdentityProviderConfigProps(props),
    };
  }

  /**
   * Defines a "IdentityProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityProviderConfigProps) {
    super(scope, id, {
      ...IdentityProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityProviderConfig.GVK,
      ...toJson_IdentityProviderConfigProps(resolved),
    };
  }
}

/**
 * An IdentityProviderConfig is a managed resource that represents an AWS Elastic Kubernetes Service IdentityProviderConfig.
 *
 * @schema IdentityProviderConfig
 */
export interface IdentityProviderConfigProps {
  /**
   * @schema IdentityProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A IdentityProviderConfigSpec defines the desired state of an EKS identity provider.
   *
   * @schema IdentityProviderConfig#spec
   */
  readonly spec: IdentityProviderConfigSpec;

}

/**
 * Converts an object of type 'IdentityProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigProps(obj: IdentityProviderConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A IdentityProviderConfigSpec defines the desired state of an EKS identity provider.
 *
 * @schema IdentityProviderConfigSpec
 */
export interface IdentityProviderConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityProviderConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityProviderConfigSpecDeletionPolicy;

  /**
   * IdentityProviderConfigParameters define the desired state of an AWS Elastic Kubernetes Service Identity Provider.
   *
   * @schema IdentityProviderConfigSpec#forProvider
   */
  readonly forProvider: IdentityProviderConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IdentityProviderConfigSpec#managementPolicies
   */
  readonly managementPolicies?: IdentityProviderConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityProviderConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityProviderConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityProviderConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityProviderConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityProviderConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityProviderConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpec(obj: IdentityProviderConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityProviderConfigSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IdentityProviderConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IdentityProviderConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityProviderConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityProviderConfigSpecDeletionPolicy
 */
export enum IdentityProviderConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IdentityProviderConfigParameters define the desired state of an AWS Elastic Kubernetes Service Identity Provider.
 *
 * @schema IdentityProviderConfigSpecForProvider
 */
export interface IdentityProviderConfigSpecForProvider {
  /**
   * The name of the cluster to associate the identity provider with.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: IdentityProviderConfigSpecForProviderClusterNameRef;

  /**
   * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: IdentityProviderConfigSpecForProviderClusterNameSelector;

  /**
   * An object that represents an OpenID Connect (OIDC) identity provider configuration.
   *
   * @schema IdentityProviderConfigSpecForProvider#oidc
   */
  readonly oidc: IdentityProviderConfigSpecForProviderOidc;

  /**
   * Region is the region you'd like the identity provider to be created in.
   *
   * @schema IdentityProviderConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * The metadata to apply to the configuration to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.
   *
   * @schema IdentityProviderConfigSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProvider(obj: IdentityProviderConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_IdentityProviderConfigSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_IdentityProviderConfigSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'oidc': toJson_IdentityProviderConfigSpecForProviderOidc(obj.oidc),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IdentityProviderConfigSpecManagementPolicies
 */
export enum IdentityProviderConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRef
 */
export interface IdentityProviderConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecProviderConfigRef(obj: IdentityProviderConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityProviderConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsTo(obj: IdentityProviderConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef
 */
export interface IdentityProviderConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecWriteConnectionSecretToRef(obj: IdentityProviderConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRef
 */
export interface IdentityProviderConfigSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameRef(obj: IdentityProviderConfigSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelector
 */
export interface IdentityProviderConfigSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameSelector(obj: IdentityProviderConfigSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object that represents an OpenID Connect (OIDC) identity provider configuration.
 *
 * @schema IdentityProviderConfigSpecForProviderOidc
 */
export interface IdentityProviderConfigSpecForProviderOidc {
  /**
   * This is also known as audience. The ID for the client application that makes authentication requests to the OpenID identity provider.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#clientId
   */
  readonly clientId: string;

  /**
   * The JWT claim that the provider uses to return your groups.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#groupsClaim
   */
  readonly groupsClaim?: string;

  /**
   * The prefix that is prepended to group claims to prevent clashes with existing names (such as system: groups). For example, the value oidc: will create group names like oidc:engineering and oidc:infra.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#groupsPrefix
   */
  readonly groupsPrefix?: string;

  /**
   * The URL of the OpenID identity provider that allows the API server to discover public signing keys for verifying tokens. The URL must begin with https:// and should correspond to the iss claim in the provider's OIDC ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. This URL should point to the level below .well-known/openid-configuration and must be publicly accessible over the internet.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#issuerUrl
   */
  readonly issuerUrl: string;

  /**
   * The key value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value. For the maximum number of claims that you can require, see Amazon EKS service quotas (https://docs.aws.amazon.com/eks/latest/userguide/service-quotas.html) in the Amazon EKS User Guide.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#requiredClaims
   */
  readonly requiredClaims?: { [key: string]: string };

  /**
   * The JSON Web Token (JWT) claim to use as the username. The default is sub, which is expected to be a unique identifier of the end user. You can choose other claims, such as email or name, depending on the OpenID identity provider. Claims other than email are prefixed with the issuer URL to prevent naming clashes with other plug-ins.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#usernameClaim
   */
  readonly usernameClaim?: string;

  /**
   * The prefix that is prepended to username claims to prevent clashes with existing names. If you do not provide this field, and username is a value other than email, the prefix defaults to issuerurl#. You can use the value - to disable all prefixing.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#usernamePrefix
   */
  readonly usernamePrefix?: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderOidc(obj: IdentityProviderConfigSpecForProviderOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'groupsClaim': obj.groupsClaim,
    'groupsPrefix': obj.groupsPrefix,
    'issuerUrl': obj.issuerUrl,
    'requiredClaims': ((obj.requiredClaims) === undefined) ? undefined : (Object.entries(obj.requiredClaims).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'usernameClaim': obj.usernameClaim,
    'usernamePrefix': obj.usernamePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicy
 */
export interface IdentityProviderConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecProviderConfigRefPolicy(obj: IdentityProviderConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef(obj: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToMetadata(obj: IdentityProviderConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy
 */
export interface IdentityProviderConfigSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameRefPolicy(obj: IdentityProviderConfigSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy
 */
export interface IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy(obj: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicyResolution
 */
export enum IdentityProviderConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicyResolve
 */
export enum IdentityProviderConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution
 */
export enum IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve
 */
export enum IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A NodeGroup is a managed resource that represents an AWS Elastic Kubernetes Service NodeGroup.
 *
 * @schema NodeGroup
 */
export class NodeGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.crossplane.io/v1alpha1',
    kind: 'NodeGroup',
  }

  /**
   * Renders a Kubernetes manifest for "NodeGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeGroupProps): any {
    return {
      ...NodeGroup.GVK,
      ...toJson_NodeGroupProps(props),
    };
  }

  /**
   * Defines a "NodeGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeGroupProps) {
    super(scope, id, {
      ...NodeGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeGroup.GVK,
      ...toJson_NodeGroupProps(resolved),
    };
  }
}

/**
 * A NodeGroup is a managed resource that represents an AWS Elastic Kubernetes Service NodeGroup.
 *
 * @schema NodeGroup
 */
export interface NodeGroupProps {
  /**
   * @schema NodeGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A NodeGroupSpec defines the desired state of an EKS NodeGroup.
   *
   * @schema NodeGroup#spec
   */
  readonly spec: NodeGroupSpec;

}

/**
 * Converts an object of type 'NodeGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupProps(obj: NodeGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodeGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A NodeGroupSpec defines the desired state of an EKS NodeGroup.
 *
 * @schema NodeGroupSpec
 */
export interface NodeGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodeGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodeGroupSpecDeletionPolicy;

  /**
   * NodeGroupParameters define the desired state of an AWS Elastic Kubernetes Service NodeGroup.
   *
   * @schema NodeGroupSpec#forProvider
   */
  readonly forProvider: NodeGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NodeGroupSpec#managementPolicies
   */
  readonly managementPolicies?: NodeGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NodeGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodeGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NodeGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NodeGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NodeGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodeGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NodeGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpec(obj: NodeGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodeGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NodeGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NodeGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NodeGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodeGroupSpecDeletionPolicy
 */
export enum NodeGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * NodeGroupParameters define the desired state of an AWS Elastic Kubernetes Service NodeGroup.
 *
 * @schema NodeGroupSpecForProvider
 */
export interface NodeGroupSpecForProvider {
  /**
   * The AMI type for your node group. GPU instance can use AL2_x86_64_GPU AMI type, which uses the Amazon EKS-optimized Linux AMI with GPU support. Non-GPU instances can use AL2_x86_64 (default) AMI type, which uses the Amazon EKS-optimized Linux AMI or, BOTTLEROCKET_ARM_64 AMI type, which uses the Amazon Bottlerocket AMI for ARM instances, or BOTTLEROCKET_x86_64 AMI type, which uses the Amazon Bottlerocket AMI fir x86_64 instances.
   *
   * @schema NodeGroupSpecForProvider#amiType
   */
  readonly amiType?: string;

  /**
   * CapacityType for your node group.
   *
   * @schema NodeGroupSpecForProvider#capacityType
   */
  readonly capacityType?: NodeGroupSpecForProviderCapacityType;

  /**
   * The name of the cluster to create the node group in.
   * ClusterName is a required field
   *
   * @schema NodeGroupSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
   *
   * @schema NodeGroupSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: NodeGroupSpecForProviderClusterNameRef;

  /**
   * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
   *
   * @schema NodeGroupSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: NodeGroupSpecForProviderClusterNameSelector;

  /**
   * The root device disk size (in GiB) for your node group instances. The default disk size is 20 GiB.
   *
   * @schema NodeGroupSpecForProvider#diskSize
   */
  readonly diskSize?: number;

  /**
   * The instance type to use for your node group. Currently, you can specify a single instance type for a node group. The default value for this parameter is t3.medium. If you choose a GPU instance type, be sure to specify the AL2_x86_64_GPU with the amiType parameter.
   *
   * @schema NodeGroupSpecForProvider#instanceTypes
   */
  readonly instanceTypes?: string[];

  /**
   * The Kubernetes labels to be applied to the nodes in the node group when they are created.
   *
   * @schema NodeGroupSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * An object representing a node group's launch template specification. If specified, then do not specify instanceTypes, diskSize, or remoteAccess and make sure that the launch template meets the requirements in launchTemplateSpecification.
   *
   * @schema NodeGroupSpecForProvider#launchTemplate
   */
  readonly launchTemplate?: NodeGroupSpecForProviderLaunchTemplate;

  /**
   * The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. For more information, see Amazon EKS Worker Node IAM Role (https://docs.aws.amazon.com/eks/latest/userguide/worker_node_IAM_role.html) in the Amazon EKS User Guide .
   * NodeRole is a required field
   *
   * @schema NodeGroupSpecForProvider#nodeRole
   */
  readonly nodeRole?: string;

  /**
   * NodeRoleRef is a reference to a Cluster used to set the NodeRole.
   *
   * @schema NodeGroupSpecForProvider#nodeRoleRef
   */
  readonly nodeRoleRef?: NodeGroupSpecForProviderNodeRoleRef;

  /**
   * NodeRoleSelector selects references to a Cluster used to set the NodeRole.
   *
   * @schema NodeGroupSpecForProvider#nodeRoleSelector
   */
  readonly nodeRoleSelector?: NodeGroupSpecForProviderNodeRoleSelector;

  /**
   * Region is the region you'd like  the NodeGroup to be created in.
   *
   * @schema NodeGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The AMI version of the Amazon EKS-optimized AMI to use with your node group. By default, the latest available AMI version for the node group's current Kubernetes version is used. For more information, see Amazon EKS-Optimized Linux AMI Versions (https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html) in the Amazon EKS User Guide.
   *
   * @schema NodeGroupSpecForProvider#releaseVersion
   */
  readonly releaseVersion?: string;

  /**
   * The remote access (SSH) configuration to use with your node group.
   *
   * @schema NodeGroupSpecForProvider#remoteAccess
   */
  readonly remoteAccess?: NodeGroupSpecForProviderRemoteAccess;

  /**
   * The scaling configuration details for the Auto Scaling group that is created for your node group.
   *
   * @schema NodeGroupSpecForProvider#scalingConfig
   */
  readonly scalingConfig?: NodeGroupSpecForProviderScalingConfig;

  /**
   * SubnetRefs are references to Subnets used to set the Subnets.
   *
   * @schema NodeGroupSpecForProvider#subnetRefs
   */
  readonly subnetRefs?: NodeGroupSpecForProviderSubnetRefs[];

  /**
   * SubnetSelector selects references to Subnets used to set the Subnets.
   *
   * @schema NodeGroupSpecForProvider#subnetSelector
   */
  readonly subnetSelector?: NodeGroupSpecForProviderSubnetSelector;

  /**
   * The subnets to use for the Auto Scaling group that is created for your node group. These subnets must have the tag key kubernetes.io/cluster/CLUSTER_NAME with a value of shared, where CLUSTER_NAME is replaced with the name of your cluster.
   * Subnets is a required field
   *
   * @schema NodeGroupSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets.
   *
   * @schema NodeGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Kubernetes taints to be applied to the nodes in the node group.
   *
   * @schema NodeGroupSpecForProvider#taints
   */
  readonly taints?: NodeGroupSpecForProviderTaints[];

  /**
   * Specifies details on how the Nodes in this NodeGroup should be updated.
   *
   * @schema NodeGroupSpecForProvider#updateConfig
   */
  readonly updateConfig?: NodeGroupSpecForProviderUpdateConfig;

  /**
   * The Kubernetes version to use for your managed nodes. By default, the Kubernetes version of the cluster is used, and this is the only accepted specified value.
   *
   * @schema NodeGroupSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProvider(obj: NodeGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiType': obj.amiType,
    'capacityType': obj.capacityType,
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_NodeGroupSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_NodeGroupSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'diskSize': obj.diskSize,
    'instanceTypes': obj.instanceTypes?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'launchTemplate': toJson_NodeGroupSpecForProviderLaunchTemplate(obj.launchTemplate),
    'nodeRole': obj.nodeRole,
    'nodeRoleRef': toJson_NodeGroupSpecForProviderNodeRoleRef(obj.nodeRoleRef),
    'nodeRoleSelector': toJson_NodeGroupSpecForProviderNodeRoleSelector(obj.nodeRoleSelector),
    'region': obj.region,
    'releaseVersion': obj.releaseVersion,
    'remoteAccess': toJson_NodeGroupSpecForProviderRemoteAccess(obj.remoteAccess),
    'scalingConfig': toJson_NodeGroupSpecForProviderScalingConfig(obj.scalingConfig),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_NodeGroupSpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_NodeGroupSpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taints': obj.taints?.map(y => toJson_NodeGroupSpecForProviderTaints(y)),
    'updateConfig': toJson_NodeGroupSpecForProviderUpdateConfig(obj.updateConfig),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NodeGroupSpecManagementPolicies
 */
export enum NodeGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NodeGroupSpecProviderConfigRef
 */
export interface NodeGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecProviderConfigRef#policy
   */
  readonly policy?: NodeGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecProviderConfigRef(obj: NodeGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsTo
 */
export interface NodeGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NodeGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NodeGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsTo(obj: NodeGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NodeGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NodeGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NodeGroupSpecWriteConnectionSecretToRef
 */
export interface NodeGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodeGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodeGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NodeGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecWriteConnectionSecretToRef(obj: NodeGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CapacityType for your node group.
 *
 * @schema NodeGroupSpecForProviderCapacityType
 */
export enum NodeGroupSpecForProviderCapacityType {
  /** ON_DEMAND */
  ON_UNDERSCORE_DEMAND = "ON_DEMAND",
  /** SPOT */
  SPOT = "SPOT",
}

/**
 * ClusterNameRef is a reference to a Cluster used to set the ClusterName.
 *
 * @schema NodeGroupSpecForProviderClusterNameRef
 */
export interface NodeGroupSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderClusterNameRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameRef(obj: NodeGroupSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterNameSelector selects references to a Cluster used to set the ClusterName.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelector
 */
export interface NodeGroupSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameSelector(obj: NodeGroupSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An object representing a node group's launch template specification. If specified, then do not specify instanceTypes, diskSize, or remoteAccess and make sure that the launch template meets the requirements in launchTemplateSpecification.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplate
 */
export interface NodeGroupSpecForProviderLaunchTemplate {
  /**
   * The ID of the launch template.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#id
   */
  readonly id?: string;

  /**
   * The name of the launch template.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#name
   */
  readonly name?: string;

  /**
   * NameRef is a reference to a LaunchTemplate used to set the Name.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#nameRef
   */
  readonly nameRef?: NodeGroupSpecForProviderLaunchTemplateNameRef;

  /**
   * NameSelector selects references to a LaunchTemplate used to set the Name.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#nameSelector
   */
  readonly nameSelector?: NodeGroupSpecForProviderLaunchTemplateNameSelector;

  /**
   * The version of the launch template to use. If no version is specified, then the template's default version is used.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#version
   */
  readonly version?: string;

  /**
   * VersionRef is a reference to a LaunchTemplateVersion used to set the Version.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#versionRef
   */
  readonly versionRef?: NodeGroupSpecForProviderLaunchTemplateVersionRef;

  /**
   * VersionSelector selects references to a LaunchTemplateVersion used to set the Version.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#versionSelector
   */
  readonly versionSelector?: NodeGroupSpecForProviderLaunchTemplateVersionSelector;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplate(obj: NodeGroupSpecForProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
    'nameRef': toJson_NodeGroupSpecForProviderLaunchTemplateNameRef(obj.nameRef),
    'nameSelector': toJson_NodeGroupSpecForProviderLaunchTemplateNameSelector(obj.nameSelector),
    'version': obj.version,
    'versionRef': toJson_NodeGroupSpecForProviderLaunchTemplateVersionRef(obj.versionRef),
    'versionSelector': toJson_NodeGroupSpecForProviderLaunchTemplateVersionSelector(obj.versionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeRoleRef is a reference to a Cluster used to set the NodeRole.
 *
 * @schema NodeGroupSpecForProviderNodeRoleRef
 */
export interface NodeGroupSpecForProviderNodeRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderNodeRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderNodeRoleRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderNodeRoleRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleRef(obj: NodeGroupSpecForProviderNodeRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderNodeRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeRoleSelector selects references to a Cluster used to set the NodeRole.
 *
 * @schema NodeGroupSpecForProviderNodeRoleSelector
 */
export interface NodeGroupSpecForProviderNodeRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderNodeRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderNodeRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderNodeRoleSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderNodeRoleSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleSelector(obj: NodeGroupSpecForProviderNodeRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderNodeRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The remote access (SSH) configuration to use with your node group.
 *
 * @schema NodeGroupSpecForProviderRemoteAccess
 */
export interface NodeGroupSpecForProviderRemoteAccess {
  /**
   * The Amazon EC2 SSH key that provides access for SSH communication with the worker nodes in the managed node group. For more information, see Amazon EC2 Key Pairs (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html) in the Amazon Elastic Compute Cloud User Guide for Linux Instances.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#ec2SSHKey
   */
  readonly ec2SshKey?: string;

  /**
   * SourceSecurityGroupRefs are references to SecurityGroups used to set the SourceSecurityGroups.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroupRefs
   */
  readonly sourceSecurityGroupRefs?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs[];

  /**
   * SourceSecurityGroupSelector selects references to SecurityGroups used to set the SourceSecurityGroups.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroupSelector
   */
  readonly sourceSecurityGroupSelector?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector;

  /**
   * The security groups that are allowed SSH access (port 22) to the worker nodes. If you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0). For more information, see Security Groups for Your VPC (https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon Virtual Private Cloud User Guide.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroups
   */
  readonly sourceSecurityGroups?: string[];

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccess(obj: NodeGroupSpecForProviderRemoteAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2SSHKey': obj.ec2SshKey,
    'sourceSecurityGroupRefs': obj.sourceSecurityGroupRefs?.map(y => toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs(y)),
    'sourceSecurityGroupSelector': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector(obj.sourceSecurityGroupSelector),
    'sourceSecurityGroups': obj.sourceSecurityGroups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The scaling configuration details for the Auto Scaling group that is created for your node group.
 *
 * @schema NodeGroupSpecForProviderScalingConfig
 */
export interface NodeGroupSpecForProviderScalingConfig {
  /**
   * The current number of worker nodes that the managed node group should maintain. This value should be left unset if another controller, such as cluster-autoscaler, is expected to manage the desired size of the node group. If not set, the initial desired size will be the configured minimum size of the node group.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#desiredSize
   */
  readonly desiredSize?: number;

  /**
   * The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#maxSize
   */
  readonly maxSize?: number;

  /**
   * The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than zero.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#minSize
   */
  readonly minSize?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderScalingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderScalingConfig(obj: NodeGroupSpecForProviderScalingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredSize': obj.desiredSize,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema NodeGroupSpecForProviderSubnetRefs
 */
export interface NodeGroupSpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderSubnetRefs#policy
   */
  readonly policy?: NodeGroupSpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetRefs(obj: NodeGroupSpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetSelector selects references to Subnets used to set the Subnets.
 *
 * @schema NodeGroupSpecForProviderSubnetSelector
 */
export interface NodeGroupSpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderSubnetSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetSelector(obj: NodeGroupSpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Taint is a property that allows a node to repel a set of pods.
 *
 * @schema NodeGroupSpecForProviderTaints
 */
export interface NodeGroupSpecForProviderTaints {
  /**
   * The effect of the taint.
   *
   * @schema NodeGroupSpecForProviderTaints#effect
   */
  readonly effect: NodeGroupSpecForProviderTaintsEffect;

  /**
   * The key of the taint.
   *
   * @schema NodeGroupSpecForProviderTaints#key
   */
  readonly key?: string;

  /**
   * The value of the taint.
   *
   * @schema NodeGroupSpecForProviderTaints#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderTaints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderTaints(obj: NodeGroupSpecForProviderTaints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies details on how the Nodes in this NodeGroup should be updated.
 *
 * @schema NodeGroupSpecForProviderUpdateConfig
 */
export interface NodeGroupSpecForProviderUpdateConfig {
  /**
   * Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether any pods are running on the node.
   *
   * @schema NodeGroupSpecForProviderUpdateConfig#force
   */
  readonly force?: boolean;

  /**
   * The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or maxUnavailablePercentage is required to have a value, but not both.
   *
   * @schema NodeGroupSpecForProviderUpdateConfig#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value, but not both.
   *
   * @schema NodeGroupSpecForProviderUpdateConfig#maxUnavailablePercentage
   */
  readonly maxUnavailablePercentage?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderUpdateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderUpdateConfig(obj: NodeGroupSpecForProviderUpdateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': obj.force,
    'maxUnavailable': obj.maxUnavailable,
    'maxUnavailablePercentage': obj.maxUnavailablePercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicy
 */
export interface NodeGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecProviderConfigRefPolicy(obj: NodeGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface NodeGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToConfigRef(obj: NodeGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToMetadata
 */
export interface NodeGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToMetadata(obj: NodeGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicy
 */
export interface NodeGroupSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameRefPolicy(obj: NodeGroupSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy
 */
export interface NodeGroupSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameSelectorPolicy(obj: NodeGroupSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NameRef is a reference to a LaunchTemplate used to set the Name.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameRef
 */
export interface NodeGroupSpecForProviderLaunchTemplateNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderLaunchTemplateNameRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateNameRef(obj: NodeGroupSpecForProviderLaunchTemplateNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderLaunchTemplateNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NameSelector selects references to a LaunchTemplate used to set the Name.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameSelector
 */
export interface NodeGroupSpecForProviderLaunchTemplateNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateNameSelector(obj: NodeGroupSpecForProviderLaunchTemplateNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VersionRef is a reference to a LaunchTemplateVersion used to set the Version.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionRef
 */
export interface NodeGroupSpecForProviderLaunchTemplateVersionRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateVersionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateVersionRef(obj: NodeGroupSpecForProviderLaunchTemplateVersionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VersionSelector selects references to a LaunchTemplateVersion used to set the Version.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelector
 */
export interface NodeGroupSpecForProviderLaunchTemplateVersionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateVersionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateVersionSelector(obj: NodeGroupSpecForProviderLaunchTemplateVersionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderNodeRoleRefPolicy
 */
export interface NodeGroupSpecForProviderNodeRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderNodeRoleRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderNodeRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderNodeRoleRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderNodeRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleRefPolicy(obj: NodeGroupSpecForProviderNodeRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderNodeRoleSelectorPolicy
 */
export interface NodeGroupSpecForProviderNodeRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderNodeRoleSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderNodeRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderNodeRoleSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderNodeRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleSelectorPolicy(obj: NodeGroupSpecForProviderNodeRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs#policy
   */
  readonly policy?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceSecurityGroupSelector selects references to SecurityGroups used to set the SourceSecurityGroups.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderSubnetRefsPolicy
 */
export interface NodeGroupSpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetRefsPolicy(obj: NodeGroupSpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderSubnetSelectorPolicy
 */
export interface NodeGroupSpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetSelectorPolicy(obj: NodeGroupSpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect of the taint.
 *
 * @schema NodeGroupSpecForProviderTaintsEffect
 */
export enum NodeGroupSpecForProviderTaintsEffect {
  /** NO_SCHEDULE */
  NO_UNDERSCORE_SCHEDULE = "NO_SCHEDULE",
  /** NO_EXECUTE */
  NO_UNDERSCORE_EXECUTE = "NO_EXECUTE",
  /** PREFER_NO_SCHEDULE */
  PREFER_UNDERSCORE_NO_UNDERSCORE_SCHEDULE = "PREFER_NO_SCHEDULE",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicyResolution
 */
export enum NodeGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicyResolve
 */
export enum NodeGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicyResolution
 */
export enum NodeGroupSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicyResolve
 */
export enum NodeGroupSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameRefPolicy
 */
export interface NodeGroupSpecForProviderLaunchTemplateNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateNameRefPolicy(obj: NodeGroupSpecForProviderLaunchTemplateNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy
 */
export interface NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy(obj: NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy
 */
export interface NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy(obj: NodeGroupSpecForProviderLaunchTemplateVersionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy
 */
export interface NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy(obj: NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderNodeRoleRefPolicyResolution
 */
export enum NodeGroupSpecForProviderNodeRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderNodeRoleRefPolicyResolve
 */
export enum NodeGroupSpecForProviderNodeRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderNodeRoleSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderNodeRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderNodeRoleSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderNodeRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderSubnetRefsPolicyResolution
 */
export enum NodeGroupSpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderSubnetRefsPolicyResolve
 */
export enum NodeGroupSpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderSubnetSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderSubnetSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolution
 */
export enum NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolve
 */
export enum NodeGroupSpecForProviderLaunchTemplateNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderLaunchTemplateNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolution
 */
export enum NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolve
 */
export enum NodeGroupSpecForProviderLaunchTemplateVersionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderLaunchTemplateVersionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolution
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolve
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

