// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Accelerator is the Schema for the Accelerators API
 *
 * @schema Accelerator
 */
export class Accelerator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Accelerator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.crossplane.io/v1alpha1',
    kind: 'Accelerator',
  }

  /**
   * Renders a Kubernetes manifest for "Accelerator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AcceleratorProps): any {
    return {
      ...Accelerator.GVK,
      ...toJson_AcceleratorProps(props),
    };
  }

  /**
   * Defines a "Accelerator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AcceleratorProps) {
    super(scope, id, {
      ...Accelerator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Accelerator.GVK,
      ...toJson_AcceleratorProps(resolved),
    };
  }
}

/**
 * Accelerator is the Schema for the Accelerators API
 *
 * @schema Accelerator
 */
export interface AcceleratorProps {
  /**
   * @schema Accelerator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AcceleratorSpec defines the desired state of Accelerator
   *
   * @schema Accelerator#spec
   */
  readonly spec: AcceleratorSpec;

}

/**
 * Converts an object of type 'AcceleratorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorProps(obj: AcceleratorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AcceleratorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AcceleratorSpec defines the desired state of Accelerator
 *
 * @schema AcceleratorSpec
 */
export interface AcceleratorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AcceleratorSpec#deletionPolicy
   */
  readonly deletionPolicy?: AcceleratorSpecDeletionPolicy;

  /**
   * AcceleratorParameters defines the desired state of Accelerator
   *
   * @schema AcceleratorSpec#forProvider
   */
  readonly forProvider: AcceleratorSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AcceleratorSpec#managementPolicies
   */
  readonly managementPolicies?: AcceleratorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AcceleratorSpec#providerConfigRef
   */
  readonly providerConfigRef?: AcceleratorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AcceleratorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AcceleratorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AcceleratorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AcceleratorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AcceleratorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpec(obj: AcceleratorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AcceleratorSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AcceleratorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AcceleratorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AcceleratorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AcceleratorSpecDeletionPolicy
 */
export enum AcceleratorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AcceleratorParameters defines the desired state of Accelerator
 *
 * @schema AcceleratorSpecForProvider
 */
export interface AcceleratorSpecForProvider {
  /**
   * Indicates whether an accelerator is enabled. The value is true or false. The default value is true.
   * If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
   *
   * @schema AcceleratorSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
   *
   * @schema AcceleratorSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator.
   * After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability.
   * You can specify one or two addresses, separated by a space. Do not include the /32 suffix.
   * Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses.
   * For more information, see Bring your own IP addresses (BYOIP) (https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
   *
   * @schema AcceleratorSpecForProvider#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
   *
   * @schema AcceleratorSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the Accelerator will be created.
   *
   * @schema AcceleratorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Create tags for an accelerator.
   * For more information, see Tagging in Global Accelerator (https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
   *
   * @schema AcceleratorSpecForProvider#tags
   */
  readonly tags?: AcceleratorSpecForProviderTags[];

}

/**
 * Converts an object of type 'AcceleratorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecForProvider(obj: AcceleratorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'ipAddressType': obj.ipAddressType,
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_AcceleratorSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AcceleratorSpecManagementPolicies
 */
export enum AcceleratorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AcceleratorSpecProviderConfigRef
 */
export interface AcceleratorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AcceleratorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AcceleratorSpecProviderConfigRef#policy
   */
  readonly policy?: AcceleratorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderConfigRef(obj: AcceleratorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AcceleratorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsTo
 */
export interface AcceleratorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AcceleratorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AcceleratorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsTo(obj: AcceleratorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AcceleratorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AcceleratorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AcceleratorSpecWriteConnectionSecretToRef
 */
export interface AcceleratorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AcceleratorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AcceleratorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AcceleratorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecWriteConnectionSecretToRef(obj: AcceleratorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AcceleratorSpecForProviderTags
 */
export interface AcceleratorSpecForProviderTags {
  /**
   * @schema AcceleratorSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema AcceleratorSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AcceleratorSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecForProviderTags(obj: AcceleratorSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicy
 */
export interface AcceleratorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AcceleratorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AcceleratorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AcceleratorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AcceleratorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderConfigRefPolicy(obj: AcceleratorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef
 */
export interface AcceleratorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToConfigRef(obj: AcceleratorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToMetadata
 */
export interface AcceleratorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToMetadata(obj: AcceleratorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicyResolution
 */
export enum AcceleratorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicyResolve
 */
export enum AcceleratorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy(obj: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EndpointGroup is the Schema for the EndpointGroups API
 *
 * @schema EndpointGroup
 */
export class EndpointGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EndpointGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.crossplane.io/v1alpha1',
    kind: 'EndpointGroup',
  }

  /**
   * Renders a Kubernetes manifest for "EndpointGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointGroupProps): any {
    return {
      ...EndpointGroup.GVK,
      ...toJson_EndpointGroupProps(props),
    };
  }

  /**
   * Defines a "EndpointGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointGroupProps) {
    super(scope, id, {
      ...EndpointGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EndpointGroup.GVK,
      ...toJson_EndpointGroupProps(resolved),
    };
  }
}

/**
 * EndpointGroup is the Schema for the EndpointGroups API
 *
 * @schema EndpointGroup
 */
export interface EndpointGroupProps {
  /**
   * @schema EndpointGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointGroupSpec defines the desired state of EndpointGroup
   *
   * @schema EndpointGroup#spec
   */
  readonly spec: EndpointGroupSpec;

}

/**
 * Converts an object of type 'EndpointGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupProps(obj: EndpointGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointGroupSpec defines the desired state of EndpointGroup
 *
 * @schema EndpointGroupSpec
 */
export interface EndpointGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointGroupSpecDeletionPolicy;

  /**
   * EndpointGroupParameters defines the desired state of EndpointGroup
   *
   * @schema EndpointGroupSpec#forProvider
   */
  readonly forProvider: EndpointGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EndpointGroupSpec#managementPolicies
   */
  readonly managementPolicies?: EndpointGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpec(obj: EndpointGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EndpointGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EndpointGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointGroupSpecDeletionPolicy
 */
export enum EndpointGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * EndpointGroupParameters defines the desired state of EndpointGroup
 *
 * @schema EndpointGroupSpecForProvider
 */
export interface EndpointGroupSpecForProvider {
  /**
   * The list of endpoint objects.
   *
   * @schema EndpointGroupSpecForProvider#endpointConfigurations
   */
  readonly endpointConfigurations?: EndpointGroupSpecForProviderEndpointConfigurations[];

  /**
   * The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
   *
   * @schema EndpointGroupSpecForProvider#endpointGroupRegion
   */
  readonly endpointGroupRegion: string;

  /**
   * The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckIntervalSeconds
   */
  readonly healthCheckIntervalSeconds?: number;

  /**
   * If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
   *
   * @schema EndpointGroupSpecForProvider#healthCheckPath
   */
  readonly healthCheckPath?: string;

  /**
   * The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckPort
   */
  readonly healthCheckPort?: number;

  /**
   * The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckProtocol
   */
  readonly healthCheckProtocol?: string;

  /**
   * ListenerArn is the ARN for the Listener.
   *
   * @schema EndpointGroupSpecForProvider#listenerArn
   */
  readonly listenerArn?: string;

  /**
   * ListenerArnRef is a reference to an ARN used to set the ListenerArn.
   *
   * @schema EndpointGroupSpecForProvider#listenerArnRef
   */
  readonly listenerArnRef?: EndpointGroupSpecForProviderListenerArnRef;

  /**
   * ListenerArnSelector selects references to Listener used to set the Arn.
   *
   * @schema EndpointGroupSpecForProvider#listenerArnSelector
   */
  readonly listenerArnSelector?: EndpointGroupSpecForProviderListenerArnSelector;

  /**
   * Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints.
   * For more information, see Overriding listener ports (https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
   *
   * @schema EndpointGroupSpecForProvider#portOverrides
   */
  readonly portOverrides?: EndpointGroupSpecForProviderPortOverrides[];

  /**
   * Region is which region the EndpointGroup will be created.
   *
   * @schema EndpointGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
   *
   * @schema EndpointGroupSpecForProvider#thresholdCount
   */
  readonly thresholdCount?: number;

  /**
   * The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener.
   * Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing.
   * The default value is 100.
   *
   * @schema EndpointGroupSpecForProvider#trafficDialPercentage
   */
  readonly trafficDialPercentage?: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProvider(obj: EndpointGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointConfigurations': obj.endpointConfigurations?.map(y => toJson_EndpointGroupSpecForProviderEndpointConfigurations(y)),
    'endpointGroupRegion': obj.endpointGroupRegion,
    'healthCheckIntervalSeconds': obj.healthCheckIntervalSeconds,
    'healthCheckPath': obj.healthCheckPath,
    'healthCheckPort': obj.healthCheckPort,
    'healthCheckProtocol': obj.healthCheckProtocol,
    'listenerArn': obj.listenerArn,
    'listenerArnRef': toJson_EndpointGroupSpecForProviderListenerArnRef(obj.listenerArnRef),
    'listenerArnSelector': toJson_EndpointGroupSpecForProviderListenerArnSelector(obj.listenerArnSelector),
    'portOverrides': obj.portOverrides?.map(y => toJson_EndpointGroupSpecForProviderPortOverrides(y)),
    'region': obj.region,
    'thresholdCount': obj.thresholdCount,
    'trafficDialPercentage': obj.trafficDialPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EndpointGroupSpecManagementPolicies
 */
export enum EndpointGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointGroupSpecProviderConfigRef
 */
export interface EndpointGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderConfigRef(obj: EndpointGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsTo
 */
export interface EndpointGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsTo(obj: EndpointGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointGroupSpecWriteConnectionSecretToRef
 */
export interface EndpointGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecWriteConnectionSecretToRef(obj: EndpointGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointGroupSpecForProviderEndpointConfigurations
 */
export interface EndpointGroupSpecForProviderEndpointConfigurations {
  /**
   * @schema EndpointGroupSpecForProviderEndpointConfigurations#clientIPPreservationEnabled
   */
  readonly clientIpPreservationEnabled?: boolean;

  /**
   * @schema EndpointGroupSpecForProviderEndpointConfigurations#endpointID
   */
  readonly endpointId?: string;

  /**
   * @schema EndpointGroupSpecForProviderEndpointConfigurations#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderEndpointConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderEndpointConfigurations(obj: EndpointGroupSpecForProviderEndpointConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIPPreservationEnabled': obj.clientIpPreservationEnabled,
    'endpointID': obj.endpointId,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerArnRef is a reference to an ARN used to set the ListenerArn.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRef
 */
export interface EndpointGroupSpecForProviderListenerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRef#policy
   */
  readonly policy?: EndpointGroupSpecForProviderListenerArnRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnRef(obj: EndpointGroupSpecForProviderListenerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecForProviderListenerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerArnSelector selects references to Listener used to set the Arn.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelector
 */
export interface EndpointGroupSpecForProviderListenerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#policy
   */
  readonly policy?: EndpointGroupSpecForProviderListenerArnSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnSelector(obj: EndpointGroupSpecForProviderListenerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointGroupSpecForProviderListenerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointGroupSpecForProviderPortOverrides
 */
export interface EndpointGroupSpecForProviderPortOverrides {
  /**
   * @schema EndpointGroupSpecForProviderPortOverrides#endpointPort
   */
  readonly endpointPort?: number;

  /**
   * @schema EndpointGroupSpecForProviderPortOverrides#listenerPort
   */
  readonly listenerPort?: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderPortOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderPortOverrides(obj: EndpointGroupSpecForProviderPortOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointPort': obj.endpointPort,
    'listenerPort': obj.listenerPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicy
 */
export interface EndpointGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderConfigRefPolicy(obj: EndpointGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRef(obj: EndpointGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToMetadata(obj: EndpointGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicy
 */
export interface EndpointGroupSpecForProviderListenerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecForProviderListenerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecForProviderListenerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnRefPolicy(obj: EndpointGroupSpecForProviderListenerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy
 */
export interface EndpointGroupSpecForProviderListenerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnSelectorPolicy(obj: EndpointGroupSpecForProviderListenerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicyResolution
 */
export enum EndpointGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicyResolve
 */
export enum EndpointGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicyResolution
 */
export enum EndpointGroupSpecForProviderListenerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicyResolve
 */
export enum EndpointGroupSpecForProviderListenerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution
 */
export enum EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve
 */
export enum EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Listener is the Schema for the Listeners API
 *
 * @schema Listener
 */
export class Listener extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Listener"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.crossplane.io/v1alpha1',
    kind: 'Listener',
  }

  /**
   * Renders a Kubernetes manifest for "Listener".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ListenerProps): any {
    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(props),
    };
  }

  /**
   * Defines a "Listener" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ListenerProps) {
    super(scope, id, {
      ...Listener.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(resolved),
    };
  }
}

/**
 * Listener is the Schema for the Listeners API
 *
 * @schema Listener
 */
export interface ListenerProps {
  /**
   * @schema Listener#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ListenerSpec defines the desired state of Listener
   *
   * @schema Listener#spec
   */
  readonly spec: ListenerSpec;

}

/**
 * Converts an object of type 'ListenerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerProps(obj: ListenerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ListenerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerSpec defines the desired state of Listener
 *
 * @schema ListenerSpec
 */
export interface ListenerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ListenerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ListenerSpecDeletionPolicy;

  /**
   * ListenerParameters defines the desired state of Listener
   *
   * @schema ListenerSpec#forProvider
   */
  readonly forProvider: ListenerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ListenerSpec#managementPolicies
   */
  readonly managementPolicies?: ListenerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ListenerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ListenerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ListenerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ListenerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ListenerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ListenerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ListenerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpec(obj: ListenerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ListenerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ListenerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ListenerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ListenerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ListenerSpecDeletionPolicy
 */
export enum ListenerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ListenerParameters defines the desired state of Listener
 *
 * @schema ListenerSpecForProvider
 */
export interface ListenerSpecForProvider {
  /**
   * AcceleratorArn is the ARN for the Accelerator.
   *
   * @schema ListenerSpecForProvider#acceleratorArn
   */
  readonly acceleratorArn?: string;

  /**
   * AcceleratorArnRef is a reference to an ARN used to set the AcceleratorArn.
   *
   * @schema ListenerSpecForProvider#acceleratorArnRef
   */
  readonly acceleratorArnRef?: ListenerSpecForProviderAcceleratorArnRef;

  /**
   * AcceleratorArnSelector selects references to Accelerator used to set the Arn.
   *
   * @schema ListenerSpecForProvider#acceleratorArnSelector
   */
  readonly acceleratorArnSelector?: ListenerSpecForProviderAcceleratorArnSelector;

  /**
   * Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint.
   * Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes.
   * If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value.
   * The default value is NONE.
   *
   * @schema ListenerSpecForProvider#clientAffinity
   */
  readonly clientAffinity?: string;

  /**
   * The list of port ranges to support for connections from clients to your accelerator.
   *
   * @schema ListenerSpecForProvider#portRanges
   */
  readonly portRanges: ListenerSpecForProviderPortRanges[];

  /**
   * The protocol for connections from clients to your accelerator.
   *
   * @schema ListenerSpecForProvider#protocol
   */
  readonly protocol: string;

  /**
   * Region is which region the Listener will be created.
   *
   * @schema ListenerSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ListenerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProvider(obj: ListenerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorArn': obj.acceleratorArn,
    'acceleratorArnRef': toJson_ListenerSpecForProviderAcceleratorArnRef(obj.acceleratorArnRef),
    'acceleratorArnSelector': toJson_ListenerSpecForProviderAcceleratorArnSelector(obj.acceleratorArnSelector),
    'clientAffinity': obj.clientAffinity,
    'portRanges': obj.portRanges?.map(y => toJson_ListenerSpecForProviderPortRanges(y)),
    'protocol': obj.protocol,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ListenerSpecManagementPolicies
 */
export enum ListenerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ListenerSpecProviderConfigRef
 */
export interface ListenerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecProviderConfigRef#policy
   */
  readonly policy?: ListenerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRef(obj: ListenerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ListenerSpecPublishConnectionDetailsTo
 */
export interface ListenerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ListenerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ListenerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsTo(obj: ListenerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ListenerSpecWriteConnectionSecretToRef
 */
export interface ListenerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ListenerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecWriteConnectionSecretToRef(obj: ListenerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AcceleratorArnRef is a reference to an ARN used to set the AcceleratorArn.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRef
 */
export interface ListenerSpecForProviderAcceleratorArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderAcceleratorArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnRef(obj: ListenerSpecForProviderAcceleratorArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderAcceleratorArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AcceleratorArnSelector selects references to Accelerator used to set the Arn.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelector
 */
export interface ListenerSpecForProviderAcceleratorArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderAcceleratorArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnSelector(obj: ListenerSpecForProviderAcceleratorArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderAcceleratorArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ListenerSpecForProviderPortRanges
 */
export interface ListenerSpecForProviderPortRanges {
  /**
   * @schema ListenerSpecForProviderPortRanges#fromPort
   */
  readonly fromPort?: number;

  /**
   * @schema ListenerSpecForProviderPortRanges#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'ListenerSpecForProviderPortRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderPortRanges(obj: ListenerSpecForProviderPortRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecProviderConfigRefPolicy
 */
export interface ListenerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRefPolicy(obj: ListenerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRef
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ListenerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj: ListenerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToMetadata
 */
export interface ListenerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj: ListenerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicy
 */
export interface ListenerSpecForProviderAcceleratorArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderAcceleratorArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderAcceleratorArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnRefPolicy(obj: ListenerSpecForProviderAcceleratorArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy
 */
export interface ListenerSpecForProviderAcceleratorArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnSelectorPolicy(obj: ListenerSpecForProviderAcceleratorArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolution
 */
export enum ListenerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolve
 */
export enum ListenerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ListenerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicyResolution
 */
export enum ListenerSpecForProviderAcceleratorArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicyResolve
 */
export enum ListenerSpecForProviderAcceleratorArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

