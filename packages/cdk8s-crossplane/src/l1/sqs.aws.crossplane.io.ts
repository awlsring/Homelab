// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Queue is a managed resource that represents a AWS Simple Queue
 *
 * @schema Queue
 */
export class Queue extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Queue"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sqs.aws.crossplane.io/v1beta1',
    kind: 'Queue',
  }

  /**
   * Renders a Kubernetes manifest for "Queue".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueueProps): any {
    return {
      ...Queue.GVK,
      ...toJson_QueueProps(props),
    };
  }

  /**
   * Defines a "Queue" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueueProps) {
    super(scope, id, {
      ...Queue.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Queue.GVK,
      ...toJson_QueueProps(resolved),
    };
  }
}

/**
 * A Queue is a managed resource that represents a AWS Simple Queue
 *
 * @schema Queue
 */
export interface QueueProps {
  /**
   * @schema Queue#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueueSpec defines the desired state of a Queue.
   *
   * @schema Queue#spec
   */
  readonly spec: QueueSpec;

}

/**
 * Converts an object of type 'QueueProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueProps(obj: QueueProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueueSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueSpec defines the desired state of a Queue.
 *
 * @schema QueueSpec
 */
export interface QueueSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema QueueSpec#deletionPolicy
   */
  readonly deletionPolicy?: QueueSpecDeletionPolicy;

  /**
   * QueueParameters define the desired state of an AWS Queue
   *
   * @schema QueueSpec#forProvider
   */
  readonly forProvider: QueueSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema QueueSpec#managementPolicies
   */
  readonly managementPolicies?: QueueSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueueSpec#providerConfigRef
   */
  readonly providerConfigRef?: QueueSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueueSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueueSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueueSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueueSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueueSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpec(obj: QueueSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueueSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_QueueSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_QueueSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueueSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema QueueSpecDeletionPolicy
 */
export enum QueueSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * QueueParameters define the desired state of an AWS Queue
 *
 * @schema QueueSpecForProvider
 */
export interface QueueSpecForProvider {
  /**
   * ContentBasedDeduplication - Enables content-based deduplication. Valid values: true, false. For more information, see Exactly-Once Processing (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html#FIFO-queues-exactly-once-processing) in the Amazon Simple Queue Service Developer Guide. Every message must have a unique MessageDeduplicationId, You may provide a MessageDeduplicationId explicitly. If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your queue, Amazon SQS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). If you don't provide a MessageDeduplicationId and the queue doesn't have ContentBasedDeduplication set, the action fails with an error. If the queue has ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one. When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered. If you send one message with ContentBasedDeduplication enabled and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.
   *
   * @schema QueueSpecForProvider#contentBasedDeduplication
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * DelaySeconds - The length of time, in seconds, for which the delivery of all messages in the queue is delayed. Valid values: An integer from 0 to 900 (15 minutes). Default: 0.
   *
   * @schema QueueSpecForProvider#delaySeconds
   */
  readonly delaySeconds?: number;

  /**
   * FIFOQueue - Designates a queue as FIFO. Valid values: true, false. If you don't specify the FifoQueue attribute, Amazon SQS creates a standard queue. You can provide this attribute only during queue creation. You can't change it for an existing queue. When you set this attribute, you must also provide the MessageGroupId for your messages explicitly. For more information, see FIFO Queue Logic (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html#FIFO-queues-understanding-logic) in the Amazon Simple Queue Service Developer Guide.
   *
   * @schema QueueSpecForProvider#fifoQueue
   */
  readonly fifoQueue?: boolean;

  /**
   * KMSDataKeyReusePeriodSeconds - The length of time, in seconds, for which Amazon SQS can reuse a data key (https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#data-keys) to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). Default: 300 (5 minutes). A shorter time period provides better security but results in more calls to KMS which might incur charges after Free Tier. For more information, see How Does the Data Key Reuse Period Work? (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work). Applies only to server-side-encryption (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html):
   *
   * @schema QueueSpecForProvider#kmsDataKeyReusePeriodSeconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * KMSMasterKeyID - The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK. For more information, see Key Terms (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-sse-key-terms). While the alias of the AWS-managed CMK for Amazon SQS is always alias/aws/sqs, the alias of a custom CMK can, for example, be alias/MyAlias . For more examples, see KeyId (https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the AWS Key Management Service API Reference. Applies only to server-side-encryption (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html):
   *
   * @schema QueueSpecForProvider#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * A Reference to a named object.
   *
   * @schema QueueSpecForProvider#kmsMasterKeyIdRef
   */
  readonly kmsMasterKeyIdRef?: QueueSpecForProviderKmsMasterKeyIdRef;

  /**
   * A Selector selects an object.
   *
   * @schema QueueSpecForProvider#kmsMasterKeyIdSelector
   */
  readonly kmsMasterKeyIdSelector?: QueueSpecForProviderKmsMasterKeyIdSelector;

  /**
   * MaximumMessageSize is the limit of how many bytes a message can contain before Amazon SQS rejects it. Valid values: An integer from 1,024 bytes (1 KiB) up to 262,144 bytes (256 KiB). Default: 262,144 (256 KiB).
   *
   * @schema QueueSpecForProvider#maximumMessageSize
   */
  readonly maximumMessageSize?: number;

  /**
   * MessageRetentionPeriod - The length of time, in seconds, for which Amazon SQS retains a message. Valid values: An integer representing seconds, from 60 (1 minute) to 1,209,600 (14 days). Default: 345,600 (4 days).
   *
   * @schema QueueSpecForProvider#messageRetentionPeriod
   */
  readonly messageRetentionPeriod?: number;

  /**
   * The queue's policy. A valid AWS policy. For more information about policy structure, see Overview of AWS IAM Policies (https://docs.aws.amazon.com/IAM/latest/UserGuide/PoliciesOverview.html) in the Amazon IAM User Guide.
   *
   * @schema QueueSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * ReceiveMessageWaitTimeSeconds - The length of time, in seconds, for which a ReceiveMessage action waits for a message to arrive. Valid values: an integer from 0 to 20 (seconds). Default: 0.
   *
   * @schema QueueSpecForProvider#receiveMessageWaitTimeSeconds
   */
  readonly receiveMessageWaitTimeSeconds?: number;

  /**
   * RedrivePolicy includes the parameters for the dead-letter queue functionality of the source queue. For more information about the redrive policy and dead-letter queues, see Using Amazon SQS Dead-Letter Queues (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html) in the Amazon Simple Queue Service Developer Guide
   *
   * @schema QueueSpecForProvider#redrivePolicy
   */
  readonly redrivePolicy?: QueueSpecForProviderRedrivePolicy;

  /**
   * Region is the region you'd like your Queue to be created in.
   *
   * @schema QueueSpecForProvider#region
   */
  readonly region: string;

  /**
   * Boolean to enable server-side encryption (SSE) of message content with SQS-owned encryption keys. See Encryption at rest.
   *
   * @schema QueueSpecForProvider#sseEnabled
   */
  readonly sseEnabled?: boolean;

  /**
   * Tags add cost allocation tags to the specified Amazon SQS queue.
   *
   * @schema QueueSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * VisibilityTimeout - The visibility timeout for the queue, in seconds. Valid values: an integer from 0 to 43,200 (12 hours). Default: 30. For more information about the visibility timeout, see Visibility Timeout (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the Amazon Simple Queue Service Developer Guide.
   *
   * @schema QueueSpecForProvider#visibilityTimeout
   */
  readonly visibilityTimeout?: number;

}

/**
 * Converts an object of type 'QueueSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProvider(obj: QueueSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentBasedDeduplication': obj.contentBasedDeduplication,
    'delaySeconds': obj.delaySeconds,
    'fifoQueue': obj.fifoQueue,
    'kmsDataKeyReusePeriodSeconds': obj.kmsDataKeyReusePeriodSeconds,
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'kmsMasterKeyIdRef': toJson_QueueSpecForProviderKmsMasterKeyIdRef(obj.kmsMasterKeyIdRef),
    'kmsMasterKeyIdSelector': toJson_QueueSpecForProviderKmsMasterKeyIdSelector(obj.kmsMasterKeyIdSelector),
    'maximumMessageSize': obj.maximumMessageSize,
    'messageRetentionPeriod': obj.messageRetentionPeriod,
    'policy': obj.policy,
    'receiveMessageWaitTimeSeconds': obj.receiveMessageWaitTimeSeconds,
    'redrivePolicy': toJson_QueueSpecForProviderRedrivePolicy(obj.redrivePolicy),
    'region': obj.region,
    'sseEnabled': obj.sseEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'visibilityTimeout': obj.visibilityTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema QueueSpecManagementPolicies
 */
export enum QueueSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueueSpecProviderConfigRef
 */
export interface QueueSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecProviderConfigRef#policy
   */
  readonly policy?: QueueSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRef(obj: QueueSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueueSpecPublishConnectionDetailsTo
 */
export interface QueueSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueueSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueueSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsTo(obj: QueueSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueueSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueueSpecWriteConnectionSecretToRef
 */
export interface QueueSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueueSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecWriteConnectionSecretToRef(obj: QueueSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdRef
 */
export interface QueueSpecForProviderKmsMasterKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdRef#policy
   */
  readonly policy?: QueueSpecForProviderKmsMasterKeyIdRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderKmsMasterKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderKmsMasterKeyIdRef(obj: QueueSpecForProviderKmsMasterKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecForProviderKmsMasterKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdSelector
 */
export interface QueueSpecForProviderKmsMasterKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdSelector#policy
   */
  readonly policy?: QueueSpecForProviderKmsMasterKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderKmsMasterKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderKmsMasterKeyIdSelector(obj: QueueSpecForProviderKmsMasterKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueSpecForProviderKmsMasterKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RedrivePolicy includes the parameters for the dead-letter queue functionality of the source queue. For more information about the redrive policy and dead-letter queues, see Using Amazon SQS Dead-Letter Queues (https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html) in the Amazon Simple Queue Service Developer Guide
 *
 * @schema QueueSpecForProviderRedrivePolicy
 */
export interface QueueSpecForProviderRedrivePolicy {
  /**
   * The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
   *
   * @schema QueueSpecForProviderRedrivePolicy#deadLetterTargetArn
   */
  readonly deadLetterTargetArn?: string;

  /**
   * DeadLetterTargetARNRef reference a Queue to retrieve its ARN.
   *
   * @schema QueueSpecForProviderRedrivePolicy#deadLetterTargetArnRef
   */
  readonly deadLetterTargetArnRef?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef;

  /**
   * DeadLetterTargetARNSelector selects reference to a Queue to retrieve its ARN
   *
   * @schema QueueSpecForProviderRedrivePolicy#deadLetterTargetArnSelector
   */
  readonly deadLetterTargetArnSelector?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector;

  /**
   * The number of times a message is delivered to the source queue before being moved to the dead-letter queue.
   *
   * @schema QueueSpecForProviderRedrivePolicy#maxReceiveCount
   */
  readonly maxReceiveCount: number;

}

/**
 * Converts an object of type 'QueueSpecForProviderRedrivePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderRedrivePolicy(obj: QueueSpecForProviderRedrivePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deadLetterTargetArn': obj.deadLetterTargetArn,
    'deadLetterTargetArnRef': toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef(obj.deadLetterTargetArnRef),
    'deadLetterTargetArnSelector': toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector(obj.deadLetterTargetArnSelector),
    'maxReceiveCount': obj.maxReceiveCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecProviderConfigRefPolicy
 */
export interface QueueSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRefPolicy(obj: QueueSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRef
 */
export interface QueueSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueueSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj: QueueSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueueSpecPublishConnectionDetailsToMetadata
 */
export interface QueueSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToMetadata(obj: QueueSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdRefPolicy
 */
export interface QueueSpecForProviderKmsMasterKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdRefPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderKmsMasterKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdRefPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderKmsMasterKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderKmsMasterKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderKmsMasterKeyIdRefPolicy(obj: QueueSpecForProviderKmsMasterKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdSelectorPolicy
 */
export interface QueueSpecForProviderKmsMasterKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderKmsMasterKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderKmsMasterKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderKmsMasterKeyIdSelectorPolicy(obj: QueueSpecForProviderKmsMasterKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeadLetterTargetARNRef reference a Queue to retrieve its ARN.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef
 */
export interface QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef#policy
   */
  readonly policy?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef(obj: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeadLetterTargetARNSelector selects reference to a Queue to retrieve its ARN
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector
 */
export interface QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector#policy
   */
  readonly policy?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector(obj: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolution
 */
export enum QueueSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolve
 */
export enum QueueSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueueSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj: QueueSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdRefPolicyResolution
 */
export enum QueueSpecForProviderKmsMasterKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdRefPolicyResolve
 */
export enum QueueSpecForProviderKmsMasterKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolution
 */
export enum QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolve
 */
export enum QueueSpecForProviderKmsMasterKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy
 */
export interface QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy(obj: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy
 */
export interface QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy(obj: QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolution
 */
export enum QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolve
 */
export enum QueueSpecForProviderRedrivePolicyDeadLetterTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolution
 */
export enum QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolve
 */
export enum QueueSpecForProviderRedrivePolicyDeadLetterTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

