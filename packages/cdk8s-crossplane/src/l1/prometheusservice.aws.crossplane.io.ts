// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API
 *
 * @schema AlertManagerDefinition
 */
export class AlertManagerDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertManagerDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'prometheusservice.aws.crossplane.io/v1alpha1',
    kind: 'AlertManagerDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "AlertManagerDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertManagerDefinitionProps): any {
    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(props),
    };
  }

  /**
   * Defines a "AlertManagerDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertManagerDefinitionProps) {
    super(scope, id, {
      ...AlertManagerDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(resolved),
    };
  }
}

/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API
 *
 * @schema AlertManagerDefinition
 */
export interface AlertManagerDefinitionProps {
  /**
   * @schema AlertManagerDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
   *
   * @schema AlertManagerDefinition#spec
   */
  readonly spec: AlertManagerDefinitionSpec;

}

/**
 * Converts an object of type 'AlertManagerDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionProps(obj: AlertManagerDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertManagerDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
 *
 * @schema AlertManagerDefinitionSpec
 */
export interface AlertManagerDefinitionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AlertManagerDefinitionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AlertManagerDefinitionSpecDeletionPolicy;

  /**
   * AlertManagerDefinitionParameters defines the desired state of AlertManagerDefinition
   *
   * @schema AlertManagerDefinitionSpec#forProvider
   */
  readonly forProvider: AlertManagerDefinitionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AlertManagerDefinitionSpec#managementPolicies
   */
  readonly managementPolicies?: AlertManagerDefinitionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AlertManagerDefinitionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AlertManagerDefinitionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AlertManagerDefinitionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AlertManagerDefinitionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AlertManagerDefinitionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AlertManagerDefinitionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpec(obj: AlertManagerDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AlertManagerDefinitionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AlertManagerDefinitionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AlertManagerDefinitionSpecDeletionPolicy
 */
export enum AlertManagerDefinitionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AlertManagerDefinitionParameters defines the desired state of AlertManagerDefinition
 *
 * @schema AlertManagerDefinitionSpecForProvider
 */
export interface AlertManagerDefinitionSpecForProvider {
  /**
   * The alert manager definition data.
   *
   * @schema AlertManagerDefinitionSpecForProvider#data
   */
  readonly data: string;

  /**
   * Region is which region the AlertManagerDefinition will be created.
   *
   * @schema AlertManagerDefinitionSpecForProvider#region
   */
  readonly region: string;

  /**
   * workspaceID is the ID for the Workspace.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * WorkspaceIDRef is a reference to a Workspace used to set the workspaceID.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: AlertManagerDefinitionSpecForProviderWorkspaceIdRef;

  /**
   * WorkspaceIDSelector selects references to Workspace used to set the workspaceID.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProvider(obj: AlertManagerDefinitionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AlertManagerDefinitionSpecManagementPolicies
 */
export enum AlertManagerDefinitionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRef
 */
export interface AlertManagerDefinitionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRef(obj: AlertManagerDefinitionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj: AlertManagerDefinitionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef
 */
export interface AlertManagerDefinitionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj: AlertManagerDefinitionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceIDRef is a reference to a Workspace used to set the workspaceID.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceIDSelector selects references to Workspace used to set the workspaceID.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj: AlertManagerDefinitionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleGroupsNamespace is the Schema for the RuleGroupsNamespaces API
 *
 * @schema RuleGroupsNamespace
 */
export class RuleGroupsNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleGroupsNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'prometheusservice.aws.crossplane.io/v1alpha1',
    kind: 'RuleGroupsNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "RuleGroupsNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleGroupsNamespaceProps): any {
    return {
      ...RuleGroupsNamespace.GVK,
      ...toJson_RuleGroupsNamespaceProps(props),
    };
  }

  /**
   * Defines a "RuleGroupsNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleGroupsNamespaceProps) {
    super(scope, id, {
      ...RuleGroupsNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleGroupsNamespace.GVK,
      ...toJson_RuleGroupsNamespaceProps(resolved),
    };
  }
}

/**
 * RuleGroupsNamespace is the Schema for the RuleGroupsNamespaces API
 *
 * @schema RuleGroupsNamespace
 */
export interface RuleGroupsNamespaceProps {
  /**
   * @schema RuleGroupsNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleGroupsNamespaceSpec defines the desired state of RuleGroupsNamespace
   *
   * @schema RuleGroupsNamespace#spec
   */
  readonly spec: RuleGroupsNamespaceSpec;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceProps(obj: RuleGroupsNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleGroupsNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroupsNamespaceSpec defines the desired state of RuleGroupsNamespace
 *
 * @schema RuleGroupsNamespaceSpec
 */
export interface RuleGroupsNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleGroupsNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleGroupsNamespaceSpecDeletionPolicy;

  /**
   * RuleGroupsNamespaceParameters defines the desired state of RuleGroupsNamespace
   *
   * @schema RuleGroupsNamespaceSpec#forProvider
   */
  readonly forProvider: RuleGroupsNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RuleGroupsNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: RuleGroupsNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleGroupsNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleGroupsNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleGroupsNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleGroupsNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleGroupsNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleGroupsNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpec(obj: RuleGroupsNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleGroupsNamespaceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RuleGroupsNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleGroupsNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleGroupsNamespaceSpecDeletionPolicy
 */
export enum RuleGroupsNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RuleGroupsNamespaceParameters defines the desired state of RuleGroupsNamespace
 *
 * @schema RuleGroupsNamespaceSpecForProvider
 */
export interface RuleGroupsNamespaceSpecForProvider {
  /**
   * The namespace data that define the rule groups.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#data
   */
  readonly data: string;

  /**
   * The rule groups namespace name.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the RuleGroupsNamespace will be created.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Optional, user-provided tags for this rule groups namespace.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * workspaceID is the ID for the Workspace.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * WorkspaceIDRef is a reference to a Workspace used to set the workspaceID.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: RuleGroupsNamespaceSpecForProviderWorkspaceIdRef;

  /**
   * WorkspaceIDSelector selects references to Workspace used to set the workspaceID.
   *
   * @schema RuleGroupsNamespaceSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecForProvider(obj: RuleGroupsNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RuleGroupsNamespaceSpecManagementPolicies
 */
export enum RuleGroupsNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleGroupsNamespaceSpecProviderConfigRef
 */
export interface RuleGroupsNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupsNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupsNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: RuleGroupsNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecProviderConfigRef(obj: RuleGroupsNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupsNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsTo
 */
export interface RuleGroupsNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsTo(obj: RuleGroupsNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleGroupsNamespaceSpecWriteConnectionSecretToRef
 */
export interface RuleGroupsNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleGroupsNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleGroupsNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecWriteConnectionSecretToRef(obj: RuleGroupsNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceIDRef is a reference to a Workspace used to set the workspaceID.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRef
 */
export interface RuleGroupsNamespaceSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdRef(obj: RuleGroupsNamespaceSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceIDSelector selects references to Workspace used to set the workspaceID.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector
 */
export interface RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector(obj: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupsNamespaceSpecProviderConfigRefPolicy
 */
export interface RuleGroupsNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupsNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupsNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupsNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupsNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecProviderConfigRefPolicy(obj: RuleGroupsNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef(obj: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata(obj: RuleGroupsNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy
 */
export interface RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy(obj: RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj: RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupsNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum RuleGroupsNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupsNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum RuleGroupsNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum RuleGroupsNamespaceSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum RuleGroupsNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleGroupsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workspace is the Schema for the Workspaces API
 *
 * @schema Workspace
 */
export class Workspace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workspace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'prometheusservice.aws.crossplane.io/v1alpha1',
    kind: 'Workspace',
  }

  /**
   * Renders a Kubernetes manifest for "Workspace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceProps): any {
    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(props),
    };
  }

  /**
   * Defines a "Workspace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceProps) {
    super(scope, id, {
      ...Workspace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(resolved),
    };
  }
}

/**
 * Workspace is the Schema for the Workspaces API
 *
 * @schema Workspace
 */
export interface WorkspaceProps {
  /**
   * @schema Workspace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceSpec defines the desired state of Workspace
   *
   * @schema Workspace#spec
   */
  readonly spec: WorkspaceSpec;

}

/**
 * Converts an object of type 'WorkspaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceProps(obj: WorkspaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceSpec defines the desired state of Workspace
 *
 * @schema WorkspaceSpec
 */
export interface WorkspaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkspaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceSpecDeletionPolicy;

  /**
   * WorkspaceParameters defines the desired state of Workspace
   *
   * @schema WorkspaceSpec#forProvider
   */
  readonly forProvider: WorkspaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkspaceSpec#managementPolicies
   */
  readonly managementPolicies?: WorkspaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpec(obj: WorkspaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkspaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkspaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkspaceSpecDeletionPolicy
 */
export enum WorkspaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * WorkspaceParameters defines the desired state of Workspace
 *
 * @schema WorkspaceSpecForProvider
 */
export interface WorkspaceSpecForProvider {
  /**
   * An optional user-assigned alias for this workspace. This alias is for user reference and does not need to be unique.
   *
   * @schema WorkspaceSpecForProvider#alias
   */
  readonly alias?: string;

  /**
   * Region is which region the Workspace will be created.
   *
   * @schema WorkspaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Optional, user-provided tags for this workspace.
   *
   * @schema WorkspaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkspaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProvider(obj: WorkspaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkspaceSpecManagementPolicies
 */
export enum WorkspaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceSpecProviderConfigRef
 */
export interface WorkspaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRef(obj: WorkspaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsTo
 */
export interface WorkspaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsTo(obj: WorkspaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceSpecWriteConnectionSecretToRef
 */
export interface WorkspaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecWriteConnectionSecretToRef(obj: WorkspaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicy
 */
export interface WorkspaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRefPolicy(obj: WorkspaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj: WorkspaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj: WorkspaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

