// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CertificateAuthority is a managed resource that represents an AWS CertificateAuthority Manager. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema CertificateAuthority
 */
export class CertificateAuthority extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthority"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.crossplane.io/v1alpha1',
    kind: 'CertificateAuthority',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthority".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityProps): any {
    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthority" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityProps) {
    super(scope, id, {
      ...CertificateAuthority.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(resolved),
    };
  }
}

/**
 * CertificateAuthority is a managed resource that represents an AWS CertificateAuthority Manager. Deprecated: Please use v1beta1 version of this resource.
 *
 * @schema CertificateAuthority
 */
export interface CertificateAuthorityProps {
  /**
   * @schema CertificateAuthority#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthoritySpec defines the desired state of CertificateAuthority
   *
   * @schema CertificateAuthority#spec
   */
  readonly spec: CertificateAuthoritySpec;

}

/**
 * Converts an object of type 'CertificateAuthorityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityProps(obj: CertificateAuthorityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthoritySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthoritySpec defines the desired state of CertificateAuthority
 *
 * @schema CertificateAuthoritySpec
 */
export interface CertificateAuthoritySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthoritySpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthoritySpecDeletionPolicy;

  /**
   * CertificateAuthorityParameters defines the desired state of an AWS CertificateAuthority.
   *
   * @schema CertificateAuthoritySpec#forProvider
   */
  readonly forProvider: CertificateAuthoritySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateAuthoritySpec#managementPolicies
   */
  readonly managementPolicies?: CertificateAuthoritySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthoritySpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthoritySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthoritySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthoritySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthoritySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthoritySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthoritySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpec(obj: CertificateAuthoritySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthoritySpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateAuthoritySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthoritySpecDeletionPolicy
 */
export enum CertificateAuthoritySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateAuthorityParameters defines the desired state of an AWS CertificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProvider
 */
export interface CertificateAuthoritySpecForProvider {
  /**
   * CertificateAuthorityConfiguration to associate with the certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProvider#certificateAuthorityConfiguration
   */
  readonly certificateAuthorityConfiguration: CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration;

  /**
   * The number of days to make a CA restorable after it has been deleted
   *
   * @schema CertificateAuthoritySpecForProvider#permanentDeletionTimeInDays
   */
  readonly permanentDeletionTimeInDays?: number;

  /**
   * Region is the region you'd like your CertificateAuthority to be created in.
   *
   * @schema CertificateAuthoritySpecForProvider#region
   */
  readonly region: string;

  /**
   * RevocationConfiguration to associate with the certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProvider#revocationConfiguration
   */
  readonly revocationConfiguration?: CertificateAuthoritySpecForProviderRevocationConfiguration;

  /**
   * Status of the certificate authority. This value cannot be configured at creation, but can be updated to set a CA to ACTIVE or DISABLED.
   *
   * @schema CertificateAuthoritySpecForProvider#status
   */
  readonly status?: CertificateAuthoritySpecForProviderStatus;

  /**
   * One or more resource tags to associate with the certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProvider#tags
   */
  readonly tags: CertificateAuthoritySpecForProviderTags[];

  /**
   * Type of the certificate authority
   *
   * @schema CertificateAuthoritySpecForProvider#type
   */
  readonly type: CertificateAuthoritySpecForProviderType;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProvider(obj: CertificateAuthoritySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityConfiguration': toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration(obj.certificateAuthorityConfiguration),
    'permanentDeletionTimeInDays': obj.permanentDeletionTimeInDays,
    'region': obj.region,
    'revocationConfiguration': toJson_CertificateAuthoritySpecForProviderRevocationConfiguration(obj.revocationConfiguration),
    'status': obj.status,
    'tags': obj.tags?.map(y => toJson_CertificateAuthoritySpecForProviderTags(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateAuthoritySpecManagementPolicies
 */
export enum CertificateAuthoritySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthoritySpecProviderConfigRef
 */
export interface CertificateAuthoritySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRef(obj: CertificateAuthoritySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsTo
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthoritySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj: CertificateAuthoritySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthoritySpecWriteConnectionSecretToRef
 */
export interface CertificateAuthoritySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj: CertificateAuthoritySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityConfiguration to associate with the certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration
 */
export interface CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration {
  /**
   * Type of the public key algorithm
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#keyAlgorithm
   */
  readonly keyAlgorithm: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationKeyAlgorithm;

  /**
   * Algorithm that private CA uses to sign certificate requests
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#signingAlgorithm
   */
  readonly signingAlgorithm: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSigningAlgorithm;

  /**
   * Subject is information of Certificate Authority
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#subject
   */
  readonly subject: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration(obj: CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyAlgorithm': obj.keyAlgorithm,
    'signingAlgorithm': obj.signingAlgorithm,
    'subject': toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject(obj.subject),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RevocationConfiguration to associate with the certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderRevocationConfiguration
 */
export interface CertificateAuthoritySpecForProviderRevocationConfiguration {
  /**
   * Alias for the CRL distribution point
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#customCname
   */
  readonly customCname?: string;

  /**
   * Boolean value that specifies certificate revocation
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#enabled
   */
  readonly enabled: boolean;

  /**
   * Number of days until a certificate expires
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#expirationInDays
   */
  readonly expirationInDays?: number;

  /**
   * Name of the S3 bucket that contains the CRL
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderRevocationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderRevocationConfiguration(obj: CertificateAuthoritySpecForProviderRevocationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customCname': obj.customCname,
    'enabled': obj.enabled,
    'expirationInDays': obj.expirationInDays,
    's3BucketName': obj.s3BucketName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Status of the certificate authority. This value cannot be configured at creation, but can be updated to set a CA to ACTIVE or DISABLED.
 *
 * @schema CertificateAuthoritySpecForProviderStatus
 */
export enum CertificateAuthoritySpecForProviderStatus {
  /** ACTIVE */
  ACTIVE = "ACTIVE",
  /** DISABLED */
  DISABLED = "DISABLED",
}

/**
 * Tag represents user-provided metadata that can be associated
 *
 * @schema CertificateAuthoritySpecForProviderTags
 */
export interface CertificateAuthoritySpecForProviderTags {
  /**
   * The key name that can be used to look up or retrieve the associated value.
   *
   * @schema CertificateAuthoritySpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value associated with this tag.
   *
   * @schema CertificateAuthoritySpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderTags(obj: CertificateAuthoritySpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the certificate authority
 *
 * @schema CertificateAuthoritySpecForProviderType
 */
export enum CertificateAuthoritySpecForProviderType {
  /** ROOT */
  ROOT = "ROOT",
  /** SUBORDINATE */
  SUBORDINATE = "SUBORDINATE",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicy
 */
export interface CertificateAuthoritySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj: CertificateAuthoritySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj: CertificateAuthoritySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the public key algorithm
 *
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationKeyAlgorithm
 */
export enum CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationKeyAlgorithm {
  /** RSA_2048 */
  RSA_UNDERSCORE_2048 = "RSA_2048",
  /** EC_secp384r1 */
  EC_UNDERSCORE_SECP384R1 = "EC_secp384r1",
  /** EC_prime256v1 */
  EC_UNDERSCORE_PRIME256V1 = "EC_prime256v1",
  /** RSA_4096 */
  RSA_UNDERSCORE_4096 = "RSA_4096",
}

/**
 * Algorithm that private CA uses to sign certificate requests
 *
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSigningAlgorithm
 */
export enum CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSigningAlgorithm {
  /** SHA512WITHECDSA */
  SHA512_WITHECDSA = "SHA512WITHECDSA",
  /** SHA256WITHECDSA */
  SHA256_WITHECDSA = "SHA256WITHECDSA",
  /** SHA384WITHECDSA */
  SHA384_WITHECDSA = "SHA384WITHECDSA",
  /** SHA512WITHRSA */
  SHA512_WITHRSA = "SHA512WITHRSA",
  /** SHA256WITHRSA */
  SHA256_WITHRSA = "SHA256WITHRSA",
  /** SHA384WITHRSA */
  SHA384_WITHRSA = "SHA384WITHRSA",
}

/**
 * Subject is information of Certificate Authority
 *
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject
 */
export interface CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject {
  /**
   * FQDN associated with the certificate subject
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#commonName
   */
  readonly commonName: string;

  /**
   * Two-digit code that specifies the country
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#country
   */
  readonly country: string;

  /**
   * Disambiguating information for the certificate subject.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#distinguishedNameQualifier
   */
  readonly distinguishedNameQualifier?: string;

  /**
   * Typically a qualifier appended to the name of an individual
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#generationQualifier
   */
  readonly generationQualifier?: string;

  /**
   * First name
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#givenName
   */
  readonly givenName?: string;

  /**
   * Concatenation of first letter of the GivenName, Middle name and SurName.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#initials
   */
  readonly initials?: string;

  /**
   * The locality such as a city or town
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#locality
   */
  readonly locality: string;

  /**
   * Organization legal name
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#organization
   */
  readonly organization: string;

  /**
   * Organization's subdivision or unit
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#organizationalUnit
   */
  readonly organizationalUnit: string;

  /**
   * Shortened version of a longer GivenName
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#pseudonym
   */
  readonly pseudonym?: string;

  /**
   * The certificate serial number.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#serialNumber
   */
  readonly serialNumber?: string;

  /**
   * State in which the subject of the certificate is located
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#state
   */
  readonly state: string;

  /**
   * Surname
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#surname
   */
  readonly surname?: string;

  /**
   * Title
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject(obj: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'country': obj.country,
    'distinguishedNameQualifier': obj.distinguishedNameQualifier,
    'generationQualifier': obj.generationQualifier,
    'givenName': obj.givenName,
    'initials': obj.initials,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'pseudonym': obj.pseudonym,
    'serialNumber': obj.serialNumber,
    'state': obj.state,
    'surname': obj.surname,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateAuthority is a managed resource that represents an AWS CertificateAuthority Manager.
 *
 * @schema CertificateAuthorityV1Beta1
 */
export class CertificateAuthorityV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthorityV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.crossplane.io/v1beta1',
    kind: 'CertificateAuthority',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthorityV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityV1Beta1Props): any {
    return {
      ...CertificateAuthorityV1Beta1.GVK,
      ...toJson_CertificateAuthorityV1Beta1Props(props),
    };
  }

  /**
   * Defines a "CertificateAuthorityV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityV1Beta1Props) {
    super(scope, id, {
      ...CertificateAuthorityV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthorityV1Beta1.GVK,
      ...toJson_CertificateAuthorityV1Beta1Props(resolved),
    };
  }
}

/**
 * CertificateAuthority is a managed resource that represents an AWS CertificateAuthority Manager.
 *
 * @schema CertificateAuthorityV1Beta1
 */
export interface CertificateAuthorityV1Beta1Props {
  /**
   * @schema CertificateAuthorityV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthoritySpec defines the desired state of CertificateAuthority
   *
   * @schema CertificateAuthorityV1Beta1#spec
   */
  readonly spec: CertificateAuthorityV1Beta1Spec;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1Props(obj: CertificateAuthorityV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthorityV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthoritySpec defines the desired state of CertificateAuthority
 *
 * @schema CertificateAuthorityV1Beta1Spec
 */
export interface CertificateAuthorityV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthorityV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthorityV1Beta1SpecDeletionPolicy;

  /**
   * CertificateAuthorityParameters defines the desired state of an AWS CertificateAuthority.
   *
   * @schema CertificateAuthorityV1Beta1Spec#forProvider
   */
  readonly forProvider: CertificateAuthorityV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateAuthorityV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: CertificateAuthorityV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthorityV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthorityV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthorityV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthorityV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1Spec(obj: CertificateAuthorityV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthorityV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateAuthorityV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthorityV1Beta1SpecDeletionPolicy
 */
export enum CertificateAuthorityV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateAuthorityParameters defines the desired state of an AWS CertificateAuthority.
 *
 * @schema CertificateAuthorityV1Beta1SpecForProvider
 */
export interface CertificateAuthorityV1Beta1SpecForProvider {
  /**
   * CertificateAuthorityConfiguration to associate with the certificateAuthority.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#certificateAuthorityConfiguration
   */
  readonly certificateAuthorityConfiguration: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration;

  /**
   * The number of days to make a CA restorable after it has been deleted
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#permanentDeletionTimeInDays
   */
  readonly permanentDeletionTimeInDays?: number;

  /**
   * Region is the region you'd like your CertificateAuthority to be created in.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * RevocationConfiguration to associate with the certificateAuthority.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#revocationConfiguration
   */
  readonly revocationConfiguration?: CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration;

  /**
   * Status of the certificate authority. This value cannot be configured at creation, but can be updated to set a CA to ACTIVE or DISABLED.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#status
   */
  readonly status?: CertificateAuthorityV1Beta1SpecForProviderStatus;

  /**
   * One or more resource tags to associate with the certificateAuthority.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#tags
   */
  readonly tags: CertificateAuthorityV1Beta1SpecForProviderTags[];

  /**
   * Type of the certificate authority
   *
   * @schema CertificateAuthorityV1Beta1SpecForProvider#type
   */
  readonly type: CertificateAuthorityV1Beta1SpecForProviderType;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecForProvider(obj: CertificateAuthorityV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityConfiguration': toJson_CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration(obj.certificateAuthorityConfiguration),
    'permanentDeletionTimeInDays': obj.permanentDeletionTimeInDays,
    'region': obj.region,
    'revocationConfiguration': toJson_CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration(obj.revocationConfiguration),
    'status': obj.status,
    'tags': obj.tags?.map(y => toJson_CertificateAuthorityV1Beta1SpecForProviderTags(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateAuthorityV1Beta1SpecManagementPolicies
 */
export enum CertificateAuthorityV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthorityV1Beta1SpecProviderConfigRef
 */
export interface CertificateAuthorityV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecProviderConfigRef(obj: CertificateAuthorityV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo
 */
export interface CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo(obj: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef
 */
export interface CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef(obj: CertificateAuthorityV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityConfiguration to associate with the certificateAuthority.
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration
 */
export interface CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration {
  /**
   * Type of the public key algorithm
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration#keyAlgorithm
   */
  readonly keyAlgorithm: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationKeyAlgorithm;

  /**
   * Algorithm that private CA uses to sign certificate requests
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration#signingAlgorithm
   */
  readonly signingAlgorithm: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSigningAlgorithm;

  /**
   * Subject is information of Certificate Authority
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration#subject
   */
  readonly subject: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration(obj: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyAlgorithm': obj.keyAlgorithm,
    'signingAlgorithm': obj.signingAlgorithm,
    'subject': toJson_CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject(obj.subject),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RevocationConfiguration to associate with the certificateAuthority.
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration
 */
export interface CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration {
  /**
   * Alias for the CRL distribution point
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration#customCname
   */
  readonly customCname?: string;

  /**
   * Boolean value that specifies certificate revocation
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration#enabled
   */
  readonly enabled: boolean;

  /**
   * Number of days until a certificate expires
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration#expirationInDays
   */
  readonly expirationInDays?: number;

  /**
   * Name of the S3 bucket that contains the CRL
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration(obj: CertificateAuthorityV1Beta1SpecForProviderRevocationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customCname': obj.customCname,
    'enabled': obj.enabled,
    'expirationInDays': obj.expirationInDays,
    's3BucketName': obj.s3BucketName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Status of the certificate authority. This value cannot be configured at creation, but can be updated to set a CA to ACTIVE or DISABLED.
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderStatus
 */
export enum CertificateAuthorityV1Beta1SpecForProviderStatus {
  /** ACTIVE */
  ACTIVE = "ACTIVE",
  /** DISABLED */
  DISABLED = "DISABLED",
}

/**
 * Tag represents user-provided metadata that can be associated
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderTags
 */
export interface CertificateAuthorityV1Beta1SpecForProviderTags {
  /**
   * The key name that can be used to look up or retrieve the associated value.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value associated with this tag.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecForProviderTags(obj: CertificateAuthorityV1Beta1SpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the certificate authority
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderType
 */
export enum CertificateAuthorityV1Beta1SpecForProviderType {
  /** ROOT */
  ROOT = "ROOT",
  /** SUBORDINATE */
  SUBORDINATE = "SUBORDINATE",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy
 */
export interface CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy(obj: CertificateAuthorityV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata(obj: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the public key algorithm
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationKeyAlgorithm
 */
export enum CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationKeyAlgorithm {
  /** RSA_2048 */
  RSA_UNDERSCORE_2048 = "RSA_2048",
  /** EC_secp384r1 */
  EC_UNDERSCORE_SECP384R1 = "EC_secp384r1",
  /** EC_prime256v1 */
  EC_UNDERSCORE_PRIME256V1 = "EC_prime256v1",
  /** RSA_4096 */
  RSA_UNDERSCORE_4096 = "RSA_4096",
}

/**
 * Algorithm that private CA uses to sign certificate requests
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSigningAlgorithm
 */
export enum CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSigningAlgorithm {
  /** SHA512WITHECDSA */
  SHA512_WITHECDSA = "SHA512WITHECDSA",
  /** SHA256WITHECDSA */
  SHA256_WITHECDSA = "SHA256WITHECDSA",
  /** SHA384WITHECDSA */
  SHA384_WITHECDSA = "SHA384WITHECDSA",
  /** SHA512WITHRSA */
  SHA512_WITHRSA = "SHA512WITHRSA",
  /** SHA256WITHRSA */
  SHA256_WITHRSA = "SHA256WITHRSA",
  /** SHA384WITHRSA */
  SHA384_WITHRSA = "SHA384WITHRSA",
}

/**
 * Subject is information of Certificate Authority
 *
 * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject
 */
export interface CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject {
  /**
   * FQDN associated with the certificate subject
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#commonName
   */
  readonly commonName: string;

  /**
   * Two-digit code that specifies the country
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#country
   */
  readonly country: string;

  /**
   * Disambiguating information for the certificate subject.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#distinguishedNameQualifier
   */
  readonly distinguishedNameQualifier?: string;

  /**
   * Typically a qualifier appended to the name of an individual
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#generationQualifier
   */
  readonly generationQualifier?: string;

  /**
   * First name
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#givenName
   */
  readonly givenName?: string;

  /**
   * Concatenation of first letter of the GivenName, Middle name and SurName.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#initials
   */
  readonly initials?: string;

  /**
   * The locality such as a city or town
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#locality
   */
  readonly locality: string;

  /**
   * Organization legal name
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#organization
   */
  readonly organization: string;

  /**
   * Organization's subdivision or unit
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#organizationalUnit
   */
  readonly organizationalUnit: string;

  /**
   * Shortened version of a longer GivenName
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#pseudonym
   */
  readonly pseudonym?: string;

  /**
   * The certificate serial number.
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#serialNumber
   */
  readonly serialNumber?: string;

  /**
   * State in which the subject of the certificate is located
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#state
   */
  readonly state: string;

  /**
   * Surname
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#surname
   */
  readonly surname?: string;

  /**
   * Title
   *
   * @schema CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject(obj: CertificateAuthorityV1Beta1SpecForProviderCertificateAuthorityConfigurationSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'country': obj.country,
    'distinguishedNameQualifier': obj.distinguishedNameQualifier,
    'generationQualifier': obj.generationQualifier,
    'givenName': obj.givenName,
    'initials': obj.initials,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'pseudonym': obj.pseudonym,
    'serialNumber': obj.serialNumber,
    'state': obj.state,
    'surname': obj.surname,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthorityV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthorityV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateAuthorityPermission is a managed resource that represents an AWS CertificateAuthorityPermission Manager.
 *
 * @schema CertificateAuthorityPermission
 */
export class CertificateAuthorityPermission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthorityPermission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.crossplane.io/v1alpha1',
    kind: 'CertificateAuthorityPermission',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthorityPermission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityPermissionProps): any {
    return {
      ...CertificateAuthorityPermission.GVK,
      ...toJson_CertificateAuthorityPermissionProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthorityPermission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityPermissionProps) {
    super(scope, id, {
      ...CertificateAuthorityPermission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthorityPermission.GVK,
      ...toJson_CertificateAuthorityPermissionProps(resolved),
    };
  }
}

/**
 * CertificateAuthorityPermission is a managed resource that represents an AWS CertificateAuthorityPermission Manager.
 *
 * @schema CertificateAuthorityPermission
 */
export interface CertificateAuthorityPermissionProps {
  /**
   * @schema CertificateAuthorityPermission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthorityPermissionSpec defines the desired state of CertificateAuthorityPermission
   *
   * @schema CertificateAuthorityPermission#spec
   */
  readonly spec: CertificateAuthorityPermissionSpec;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionProps(obj: CertificateAuthorityPermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthorityPermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityPermissionSpec defines the desired state of CertificateAuthorityPermission
 *
 * @schema CertificateAuthorityPermissionSpec
 */
export interface CertificateAuthorityPermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthorityPermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthorityPermissionSpecDeletionPolicy;

  /**
   * CertificateAuthorityPermissionParameters defines the desired state of an AWS CertificateAuthority.
   *
   * @schema CertificateAuthorityPermissionSpec#forProvider
   */
  readonly forProvider: CertificateAuthorityPermissionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateAuthorityPermissionSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateAuthorityPermissionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthorityPermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthorityPermissionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthorityPermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthorityPermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthorityPermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthorityPermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpec(obj: CertificateAuthorityPermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthorityPermissionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateAuthorityPermissionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthorityPermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthorityPermissionSpecDeletionPolicy
 */
export enum CertificateAuthorityPermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateAuthorityPermissionParameters defines the desired state of an AWS CertificateAuthority.
 *
 * @schema CertificateAuthorityPermissionSpecForProvider
 */
export interface CertificateAuthorityPermissionSpecForProvider {
  /**
   * The actions that the specified AWS service principal can use.
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#actions
   */
  readonly actions?: string[];

  /**
   * The Amazon Resource Name (ARN) of the private certificate authority (CA)that will be used to issue the certificate.
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#certificateAuthorityARN
   */
  readonly certificateAuthorityArn?: string;

  /**
   * CertificateAuthorityARNRef references an CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#certificateAuthorityARNRef
   */
  readonly certificateAuthorityArnRef?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef;

  /**
   * CertificateAuthorityARNSelector selects a reference to an CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#certificateAuthorityARNSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector;

  /**
   * The AWS service or identity that receives the permission. At this time, the only valid principal is acm.amazonaws.com.
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#principal
   */
  readonly principal: string;

  /**
   * Region is the region of CertificateAuthorityPermission.
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Calling Account ID
   *
   * @schema CertificateAuthorityPermissionSpecForProvider#sourceAccount
   */
  readonly sourceAccount?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecForProvider(obj: CertificateAuthorityPermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'certificateAuthorityARN': obj.certificateAuthorityArn,
    'certificateAuthorityARNRef': toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityARNSelector': toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'principal': obj.principal,
    'region': obj.region,
    'sourceAccount': obj.sourceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateAuthorityPermissionSpecManagementPolicies
 */
export enum CertificateAuthorityPermissionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthorityPermissionSpecProviderConfigRef
 */
export interface CertificateAuthorityPermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecProviderConfigRef(obj: CertificateAuthorityPermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsTo
 */
export interface CertificateAuthorityPermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsTo(obj: CertificateAuthorityPermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthorityPermissionSpecWriteConnectionSecretToRef
 */
export interface CertificateAuthorityPermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityPermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityPermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecWriteConnectionSecretToRef(obj: CertificateAuthorityPermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNRef references an CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef(obj: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNSelector selects a reference to an CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector(obj: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionSpecProviderConfigRefPolicy
 */
export interface CertificateAuthorityPermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecProviderConfigRefPolicy(obj: CertificateAuthorityPermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata(obj: CertificateAuthorityPermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthorityPermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateAuthorityPermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthorityPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateAuthorityPermission is a managed resource that represents an AWS CertificateAuthorityPermission Manager.
 *
 * @schema CertificateAuthorityPermissionV1Beta1
 */
export class CertificateAuthorityPermissionV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthorityPermissionV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.crossplane.io/v1beta1',
    kind: 'CertificateAuthorityPermission',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthorityPermissionV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityPermissionV1Beta1Props): any {
    return {
      ...CertificateAuthorityPermissionV1Beta1.GVK,
      ...toJson_CertificateAuthorityPermissionV1Beta1Props(props),
    };
  }

  /**
   * Defines a "CertificateAuthorityPermissionV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityPermissionV1Beta1Props) {
    super(scope, id, {
      ...CertificateAuthorityPermissionV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthorityPermissionV1Beta1.GVK,
      ...toJson_CertificateAuthorityPermissionV1Beta1Props(resolved),
    };
  }
}

/**
 * CertificateAuthorityPermission is a managed resource that represents an AWS CertificateAuthorityPermission Manager.
 *
 * @schema CertificateAuthorityPermissionV1Beta1
 */
export interface CertificateAuthorityPermissionV1Beta1Props {
  /**
   * @schema CertificateAuthorityPermissionV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthorityPermissionSpec defines the desired state of CertificateAuthorityPermission
   *
   * @schema CertificateAuthorityPermissionV1Beta1#spec
   */
  readonly spec: CertificateAuthorityPermissionV1Beta1Spec;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1Props(obj: CertificateAuthorityPermissionV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthorityPermissionV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityPermissionSpec defines the desired state of CertificateAuthorityPermission
 *
 * @schema CertificateAuthorityPermissionV1Beta1Spec
 */
export interface CertificateAuthorityPermissionV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthorityPermissionV1Beta1SpecDeletionPolicy;

  /**
   * CertificateAuthorityPermissionParameters defines the desired state of an AWS CertificateAuthority.
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#forProvider
   */
  readonly forProvider: CertificateAuthorityPermissionV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: CertificateAuthorityPermissionV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthorityPermissionV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1Spec(obj: CertificateAuthorityPermissionV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthorityPermissionV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecDeletionPolicy
 */
export enum CertificateAuthorityPermissionV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * CertificateAuthorityPermissionParameters defines the desired state of an AWS CertificateAuthority.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider
 */
export interface CertificateAuthorityPermissionV1Beta1SpecForProvider {
  /**
   * The actions that the specified AWS service principal can use.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#actions
   */
  readonly actions?: string[];

  /**
   * The Amazon Resource Name (ARN) of the private certificate authority (CA)that will be used to issue the certificate.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#certificateAuthorityARN
   */
  readonly certificateAuthorityArn?: string;

  /**
   * CertificateAuthorityARNRef references an CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#certificateAuthorityARNRef
   */
  readonly certificateAuthorityArnRef?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef;

  /**
   * CertificateAuthorityARNSelector selects a reference to an CertificateAuthority to retrieve its Arn
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#certificateAuthorityARNSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector;

  /**
   * The AWS service or identity that receives the permission. At this time, the only valid principal is acm.amazonaws.com.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#principal
   */
  readonly principal: string;

  /**
   * Region is the region of CertificateAuthorityPermission.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * Calling Account ID
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProvider#sourceAccount
   */
  readonly sourceAccount?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecForProvider(obj: CertificateAuthorityPermissionV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'certificateAuthorityARN': obj.certificateAuthorityArn,
    'certificateAuthorityARNRef': toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityARNSelector': toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'principal': obj.principal,
    'region': obj.region,
    'sourceAccount': obj.sourceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecManagementPolicies
 */
export enum CertificateAuthorityPermissionV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef
 */
export interface CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef(obj: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo
 */
export interface CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo(obj: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef
 */
export interface CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef(obj: CertificateAuthorityPermissionV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNRef references an CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef(obj: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityARNSelector selects a reference to an CertificateAuthority to retrieve its Arn
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector(obj: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy
 */
export interface CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy(obj: CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata(obj: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthorityPermissionV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateAuthorityPermissionV1Beta1SpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthorityPermissionV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

