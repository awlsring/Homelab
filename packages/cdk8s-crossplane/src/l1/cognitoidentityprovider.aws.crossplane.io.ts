// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Group is the Schema for the Groups API
 *
 * @schema Group
 */
export class Group extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Group"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'Group',
  }

  /**
   * Renders a Kubernetes manifest for "Group".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupProps): any {
    return {
      ...Group.GVK,
      ...toJson_GroupProps(props),
    };
  }

  /**
   * Defines a "Group" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupProps) {
    super(scope, id, {
      ...Group.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Group.GVK,
      ...toJson_GroupProps(resolved),
    };
  }
}

/**
 * Group is the Schema for the Groups API
 *
 * @schema Group
 */
export interface GroupProps {
  /**
   * @schema Group#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GroupSpec defines the desired state of Group
   *
   * @schema Group#spec
   */
  readonly spec: GroupSpec;

}

/**
 * Converts an object of type 'GroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupProps(obj: GroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupSpec defines the desired state of Group
 *
 * @schema GroupSpec
 */
export interface GroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupSpecDeletionPolicy;

  /**
   * GroupParameters defines the desired state of Group
   *
   * @schema GroupSpec#forProvider
   */
  readonly forProvider: GroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GroupSpec#managementPolicies
   */
  readonly managementPolicies?: GroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpec(obj: GroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupSpecDeletionPolicy
 */
export enum GroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GroupParameters defines the desired state of Group
 *
 * @schema GroupSpecForProvider
 */
export interface GroupSpecForProvider {
  /**
   * A string containing the description of the group.
   *
   * @schema GroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A non-negative integer value that specifies the precedence of this group relative to the other groups that a user can belong to in the user pool. Zero is the highest precedence value. Groups with lower Precedence values take precedence over groups with higher or null Precedence values. If a user belongs to two or more groups, it is the group with the lowest precedence value whose role ARN is given in the user's tokens for the cognito:roles and cognito:preferred_role claims.
   * Two groups can have the same Precedence value. If this happens, neither group takes precedence over the other. If two groups with the same Precedence have the same role ARN, that role is used in the cognito:preferred_role claim in tokens for users in each group. If the two groups have different role ARNs, the cognito:preferred_role claim isn't set in users' tokens.
   * The default Precedence value is null. The maximum Precedence value is 2^31-1.
   *
   * @schema GroupSpecForProvider#precedence
   */
  readonly precedence?: number;

  /**
   * Region is which region the Group will be created.
   *
   * @schema GroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The role ARN for the group.
   *
   * @schema GroupSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema GroupSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: GroupSpecForProviderRoleArnRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema GroupSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: GroupSpecForProviderRoleArnSelector;

  /**
   * The user pool ID.
   *
   * @schema GroupSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema GroupSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: GroupSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema GroupSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: GroupSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'GroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProvider(obj: GroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'precedence': obj.precedence,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_GroupSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_GroupSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_GroupSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_GroupSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GroupSpecManagementPolicies
 */
export enum GroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GroupSpecProviderConfigRef
 */
export interface GroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecProviderConfigRef#policy
   */
  readonly policy?: GroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRef(obj: GroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GroupSpecPublishConnectionDetailsTo
 */
export interface GroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsTo(obj: GroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GroupSpecWriteConnectionSecretToRef
 */
export interface GroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecWriteConnectionSecretToRef(obj: GroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema GroupSpecForProviderRoleArnRef
 */
export interface GroupSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecForProviderRoleArnRef#policy
   */
  readonly policy?: GroupSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderRoleArnRef(obj: GroupSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema GroupSpecForProviderRoleArnSelector
 */
export interface GroupSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: GroupSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderRoleArnSelector(obj: GroupSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema GroupSpecForProviderUserPoolIdRef
 */
export interface GroupSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: GroupSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderUserPoolIdRef(obj: GroupSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema GroupSpecForProviderUserPoolIdSelector
 */
export interface GroupSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: GroupSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderUserPoolIdSelector(obj: GroupSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecProviderConfigRefPolicy
 */
export interface GroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRefPolicy(obj: GroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj: GroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupSpecPublishConnectionDetailsToMetadata
 */
export interface GroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToMetadata(obj: GroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecForProviderRoleArnRefPolicy
 */
export interface GroupSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderRoleArnRefPolicy(obj: GroupSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupSpecForProviderRoleArnSelectorPolicy
 */
export interface GroupSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderRoleArnSelectorPolicy(obj: GroupSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecForProviderUserPoolIdRefPolicy
 */
export interface GroupSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderUserPoolIdRefPolicy(obj: GroupSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupSpecForProviderUserPoolIdSelectorPolicy
 */
export interface GroupSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderUserPoolIdSelectorPolicy(obj: GroupSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolution
 */
export enum GroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolve
 */
export enum GroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderRoleArnRefPolicyResolution
 */
export enum GroupSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderRoleArnRefPolicyResolve
 */
export enum GroupSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum GroupSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum GroupSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum GroupSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum GroupSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum GroupSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum GroupSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * An GroupUserMembership is a managed resource that represents an AWS Cognito User group membership.
 *
 * @schema GroupUserMembership
 */
export class GroupUserMembership extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GroupUserMembership"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'GroupUserMembership',
  }

  /**
   * Renders a Kubernetes manifest for "GroupUserMembership".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupUserMembershipProps): any {
    return {
      ...GroupUserMembership.GVK,
      ...toJson_GroupUserMembershipProps(props),
    };
  }

  /**
   * Defines a "GroupUserMembership" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupUserMembershipProps) {
    super(scope, id, {
      ...GroupUserMembership.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GroupUserMembership.GVK,
      ...toJson_GroupUserMembershipProps(resolved),
    };
  }
}

/**
 * An GroupUserMembership is a managed resource that represents an AWS Cognito User group membership.
 *
 * @schema GroupUserMembership
 */
export interface GroupUserMembershipProps {
  /**
   * @schema GroupUserMembership#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * An GroupUserMembershipSpec defines the desired state of an GroupUserMembership.
   *
   * @schema GroupUserMembership#spec
   */
  readonly spec: GroupUserMembershipSpec;

}

/**
 * Converts an object of type 'GroupUserMembershipProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipProps(obj: GroupUserMembershipProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupUserMembershipSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An GroupUserMembershipSpec defines the desired state of an GroupUserMembership.
 *
 * @schema GroupUserMembershipSpec
 */
export interface GroupUserMembershipSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupUserMembershipSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupUserMembershipSpecDeletionPolicy;

  /**
   * GroupUserMembershipParameters define the desired state of an AWS GroupUserMembership.
   *
   * @schema GroupUserMembershipSpec#forProvider
   */
  readonly forProvider: GroupUserMembershipSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GroupUserMembershipSpec#managementPolicies
   */
  readonly managementPolicies?: GroupUserMembershipSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GroupUserMembershipSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupUserMembershipSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GroupUserMembershipSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupUserMembershipSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GroupUserMembershipSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupUserMembershipSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupUserMembershipSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpec(obj: GroupUserMembershipSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupUserMembershipSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GroupUserMembershipSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GroupUserMembershipSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupUserMembershipSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupUserMembershipSpecDeletionPolicy
 */
export enum GroupUserMembershipSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GroupUserMembershipParameters define the desired state of an AWS GroupUserMembership.
 *
 * @schema GroupUserMembershipSpecForProvider
 */
export interface GroupUserMembershipSpecForProvider {
  /**
   * Groupname is the Amazon Cognito Group Name (Group) of the Cognito User-Pool group you want to add User to.
   *
   * @schema GroupUserMembershipSpecForProvider#groupname
   */
  readonly groupname?: string;

  /**
   * GroupnameRef references to an Group to retrieve its groupName
   *
   * @schema GroupUserMembershipSpecForProvider#groupnameRef
   */
  readonly groupnameRef?: GroupUserMembershipSpecForProviderGroupnameRef;

  /**
   * GroupnameSelector selects a reference to an Group to retrieve its groupName
   *
   * @schema GroupUserMembershipSpecForProvider#groupnameSelector
   */
  readonly groupnameSelector?: GroupUserMembershipSpecForProviderGroupnameSelector;

  /**
   * Region is which region the Group will be created.
   *
   * @schema GroupUserMembershipSpecForProvider#region
   */
  readonly region: string;

  /**
   * UserPoolID is the Amazon Cognito Group Name (Group) of the Cognito User-Pool group you want to add User to.
   *
   * @schema GroupUserMembershipSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef references to an Group to retrieve its userPoolId
   *
   * @schema GroupUserMembershipSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: GroupUserMembershipSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects a reference to an Group to retrieve its userPoolId
   *
   * @schema GroupUserMembershipSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: GroupUserMembershipSpecForProviderUserPoolIdSelector;

  /**
   * Username presents the name of the User.
   *
   * @schema GroupUserMembershipSpecForProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProvider(obj: GroupUserMembershipSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupname': obj.groupname,
    'groupnameRef': toJson_GroupUserMembershipSpecForProviderGroupnameRef(obj.groupnameRef),
    'groupnameSelector': toJson_GroupUserMembershipSpecForProviderGroupnameSelector(obj.groupnameSelector),
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_GroupUserMembershipSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_GroupUserMembershipSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GroupUserMembershipSpecManagementPolicies
 */
export enum GroupUserMembershipSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GroupUserMembershipSpecProviderConfigRef
 */
export interface GroupUserMembershipSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupUserMembershipSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupUserMembershipSpecProviderConfigRef#policy
   */
  readonly policy?: GroupUserMembershipSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecProviderConfigRef(obj: GroupUserMembershipSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupUserMembershipSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsTo
 */
export interface GroupUserMembershipSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupUserMembershipSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupUserMembershipSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecPublishConnectionDetailsTo(obj: GroupUserMembershipSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupUserMembershipSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupUserMembershipSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GroupUserMembershipSpecWriteConnectionSecretToRef
 */
export interface GroupUserMembershipSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupUserMembershipSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupUserMembershipSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecWriteConnectionSecretToRef(obj: GroupUserMembershipSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupnameRef references to an Group to retrieve its groupName
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameRef
 */
export interface GroupUserMembershipSpecForProviderGroupnameRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameRef#policy
   */
  readonly policy?: GroupUserMembershipSpecForProviderGroupnameRefPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderGroupnameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderGroupnameRef(obj: GroupUserMembershipSpecForProviderGroupnameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupUserMembershipSpecForProviderGroupnameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupnameSelector selects a reference to an Group to retrieve its groupName
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameSelector
 */
export interface GroupUserMembershipSpecForProviderGroupnameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameSelector#policy
   */
  readonly policy?: GroupUserMembershipSpecForProviderGroupnameSelectorPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderGroupnameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderGroupnameSelector(obj: GroupUserMembershipSpecForProviderGroupnameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupUserMembershipSpecForProviderGroupnameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef references to an Group to retrieve its userPoolId
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdRef
 */
export interface GroupUserMembershipSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: GroupUserMembershipSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderUserPoolIdRef(obj: GroupUserMembershipSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupUserMembershipSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects a reference to an Group to retrieve its userPoolId
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdSelector
 */
export interface GroupUserMembershipSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderUserPoolIdSelector(obj: GroupUserMembershipSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupUserMembershipSpecProviderConfigRefPolicy
 */
export interface GroupUserMembershipSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecProviderConfigRefPolicy(obj: GroupUserMembershipSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupUserMembershipSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecPublishConnectionDetailsToConfigRef(obj: GroupUserMembershipSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsToMetadata
 */
export interface GroupUserMembershipSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecPublishConnectionDetailsToMetadata(obj: GroupUserMembershipSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameRefPolicy
 */
export interface GroupUserMembershipSpecForProviderGroupnameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameRefPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecForProviderGroupnameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameRefPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecForProviderGroupnameRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderGroupnameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderGroupnameRefPolicy(obj: GroupUserMembershipSpecForProviderGroupnameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameSelectorPolicy
 */
export interface GroupUserMembershipSpecForProviderGroupnameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameSelectorPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecForProviderGroupnameSelectorPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderGroupnameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderGroupnameSelectorPolicy(obj: GroupUserMembershipSpecForProviderGroupnameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdRefPolicy
 */
export interface GroupUserMembershipSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderUserPoolIdRefPolicy(obj: GroupUserMembershipSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy
 */
export interface GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy(obj: GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecProviderConfigRefPolicyResolution
 */
export enum GroupUserMembershipSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecProviderConfigRefPolicyResolve
 */
export enum GroupUserMembershipSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameRefPolicyResolution
 */
export enum GroupUserMembershipSpecForProviderGroupnameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameRefPolicyResolve
 */
export enum GroupUserMembershipSpecForProviderGroupnameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolution
 */
export enum GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolve
 */
export enum GroupUserMembershipSpecForProviderGroupnameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum GroupUserMembershipSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum GroupUserMembershipSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupUserMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IdentityProvider is the Schema for the IdentityProviders API
 *
 * @schema IdentityProvider
 */
export class IdentityProvider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityProvider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'IdentityProvider',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityProvider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityProviderProps): any {
    return {
      ...IdentityProvider.GVK,
      ...toJson_IdentityProviderProps(props),
    };
  }

  /**
   * Defines a "IdentityProvider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityProviderProps) {
    super(scope, id, {
      ...IdentityProvider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityProvider.GVK,
      ...toJson_IdentityProviderProps(resolved),
    };
  }
}

/**
 * IdentityProvider is the Schema for the IdentityProviders API
 *
 * @schema IdentityProvider
 */
export interface IdentityProviderProps {
  /**
   * @schema IdentityProvider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IdentityProviderSpec defines the desired state of IdentityProvider
   *
   * @schema IdentityProvider#spec
   */
  readonly spec: IdentityProviderSpec;

}

/**
 * Converts an object of type 'IdentityProviderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderProps(obj: IdentityProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IdentityProviderSpec defines the desired state of IdentityProvider
 *
 * @schema IdentityProviderSpec
 */
export interface IdentityProviderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityProviderSpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityProviderSpecDeletionPolicy;

  /**
   * IdentityProviderParameters defines the desired state of IdentityProvider
   *
   * @schema IdentityProviderSpec#forProvider
   */
  readonly forProvider: IdentityProviderSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IdentityProviderSpec#managementPolicies
   */
  readonly managementPolicies?: IdentityProviderSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityProviderSpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityProviderSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityProviderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityProviderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityProviderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityProviderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpec(obj: IdentityProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityProviderSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IdentityProviderSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IdentityProviderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityProviderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityProviderSpecDeletionPolicy
 */
export enum IdentityProviderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IdentityProviderParameters defines the desired state of IdentityProvider
 *
 * @schema IdentityProviderSpecForProvider
 */
export interface IdentityProviderSpecForProvider {
  /**
   * A mapping of IdP attributes to standard and custom user pool attributes.
   *
   * @schema IdentityProviderSpecForProvider#attributeMapping
   */
  readonly attributeMapping?: { [key: string]: string };

  /**
   * A list of IdP identifiers.
   *
   * @schema IdentityProviderSpecForProvider#idpIdentifiers
   */
  readonly idpIdentifiers?: string[];

  /**
   * ProviderDetailsSecretRef contins a reference to a secret containing keys according to ProviderDetails. The following list describes the provider detail keys for each identity provider type.
   * * For Google and Login with Amazon: client_id client_secret authorize_scopes
   * * For Facebook: client_id client_secret authorize_scopes api_version
   * * For Sign in with Apple: client_id team_id key_id private_key authorize_scopes
   * * For OIDC providers: client_id client_secret attributes_request_method oidc_issuer authorize_scopes authorize_url if not available from discovery URL specified by oidc_issuer key token_url if not available from discovery URL specified by oidc_issuer key attributes_url if not available from discovery URL specified by oidc_issuer key jwks_uri if not available from discovery URL specified by oidc_issuer key
   * * For SAML providers: MetadataFile OR MetadataURL IDPSignout optional
   *
   * @schema IdentityProviderSpecForProvider#providerDetailsSecretRef
   */
  readonly providerDetailsSecretRef?: IdentityProviderSpecForProviderProviderDetailsSecretRef;

  /**
   * The IdP type.
   *
   * @schema IdentityProviderSpecForProvider#providerType
   */
  readonly providerType: string;

  /**
   * Region is which region the IdentityProvider will be created.
   *
   * @schema IdentityProviderSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool ID.
   *
   * @schema IdentityProviderSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema IdentityProviderSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: IdentityProviderSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema IdentityProviderSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: IdentityProviderSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProvider(obj: IdentityProviderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeMapping': ((obj.attributeMapping) === undefined) ? undefined : (Object.entries(obj.attributeMapping).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'idpIdentifiers': obj.idpIdentifiers?.map(y => y),
    'providerDetailsSecretRef': toJson_IdentityProviderSpecForProviderProviderDetailsSecretRef(obj.providerDetailsSecretRef),
    'providerType': obj.providerType,
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_IdentityProviderSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_IdentityProviderSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IdentityProviderSpecManagementPolicies
 */
export enum IdentityProviderSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityProviderSpecProviderConfigRef
 */
export interface IdentityProviderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecProviderConfigRef#policy
   */
  readonly policy?: IdentityProviderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderConfigRef(obj: IdentityProviderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsTo
 */
export interface IdentityProviderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityProviderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityProviderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsTo(obj: IdentityProviderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityProviderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityProviderSpecWriteConnectionSecretToRef
 */
export interface IdentityProviderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityProviderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityProviderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecWriteConnectionSecretToRef(obj: IdentityProviderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderDetailsSecretRef contins a reference to a secret containing keys according to ProviderDetails. The following list describes the provider detail keys for each identity provider type.
 * * For Google and Login with Amazon: client_id client_secret authorize_scopes
 * * For Facebook: client_id client_secret authorize_scopes api_version
 * * For Sign in with Apple: client_id team_id key_id private_key authorize_scopes
 * * For OIDC providers: client_id client_secret attributes_request_method oidc_issuer authorize_scopes authorize_url if not available from discovery URL specified by oidc_issuer key token_url if not available from discovery URL specified by oidc_issuer key attributes_url if not available from discovery URL specified by oidc_issuer key jwks_uri if not available from discovery URL specified by oidc_issuer key
 * * For SAML providers: MetadataFile OR MetadataURL IDPSignout optional
 *
 * @schema IdentityProviderSpecForProviderProviderDetailsSecretRef
 */
export interface IdentityProviderSpecForProviderProviderDetailsSecretRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityProviderSpecForProviderProviderDetailsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityProviderSpecForProviderProviderDetailsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderProviderDetailsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderProviderDetailsSecretRef(obj: IdentityProviderSpecForProviderProviderDetailsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRef
 */
export interface IdentityProviderSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: IdentityProviderSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdRef(obj: IdentityProviderSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelector
 */
export interface IdentityProviderSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdSelector(obj: IdentityProviderSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityProviderSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicy
 */
export interface IdentityProviderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderConfigRefPolicy(obj: IdentityProviderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityProviderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRef(obj: IdentityProviderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata
 */
export interface IdentityProviderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToMetadata(obj: IdentityProviderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy
 */
export interface IdentityProviderSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdRefPolicy(obj: IdentityProviderSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy
 */
export interface IdentityProviderSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdSelectorPolicy(obj: IdentityProviderSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicyResolution
 */
export enum IdentityProviderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicyResolve
 */
export enum IdentityProviderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResourceServer is the Schema for the ResourceServers API
 *
 * @schema ResourceServer
 */
export class ResourceServer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourceServer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'ResourceServer',
  }

  /**
   * Renders a Kubernetes manifest for "ResourceServer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceServerProps): any {
    return {
      ...ResourceServer.GVK,
      ...toJson_ResourceServerProps(props),
    };
  }

  /**
   * Defines a "ResourceServer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceServerProps) {
    super(scope, id, {
      ...ResourceServer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourceServer.GVK,
      ...toJson_ResourceServerProps(resolved),
    };
  }
}

/**
 * ResourceServer is the Schema for the ResourceServers API
 *
 * @schema ResourceServer
 */
export interface ResourceServerProps {
  /**
   * @schema ResourceServer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceServerSpec defines the desired state of ResourceServer
   *
   * @schema ResourceServer#spec
   */
  readonly spec: ResourceServerSpec;

}

/**
 * Converts an object of type 'ResourceServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerProps(obj: ResourceServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceServerSpec defines the desired state of ResourceServer
 *
 * @schema ResourceServerSpec
 */
export interface ResourceServerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceServerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceServerSpecDeletionPolicy;

  /**
   * ResourceServerParameters defines the desired state of ResourceServer
   *
   * @schema ResourceServerSpec#forProvider
   */
  readonly forProvider: ResourceServerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResourceServerSpec#managementPolicies
   */
  readonly managementPolicies?: ResourceServerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceServerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceServerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceServerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceServerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceServerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceServerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpec(obj: ResourceServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceServerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResourceServerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResourceServerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceServerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceServerSpecDeletionPolicy
 */
export enum ResourceServerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ResourceServerParameters defines the desired state of ResourceServer
 *
 * @schema ResourceServerSpecForProvider
 */
export interface ResourceServerSpecForProvider {
  /**
   * A unique resource server identifier for the resource server. This could be an HTTPS endpoint where the resource server is located, such as https://my-weather-api.example.com.
   *
   * @schema ResourceServerSpecForProvider#identifier
   */
  readonly identifier: string;

  /**
   * A friendly name for the resource server.
   *
   * @schema ResourceServerSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the ResourceServer will be created.
   *
   * @schema ResourceServerSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of scopes. Each scope is a key-value map with the keys name and description.
   *
   * @schema ResourceServerSpecForProvider#scopes
   */
  readonly scopes?: ResourceServerSpecForProviderScopes[];

  /**
   * The user pool ID for the user pool.
   *
   * @schema ResourceServerSpecForProvider#userPoolID
   */
  readonly userPoolId: string;

  /**
   * The user pool ID.
   *
   * @schema ResourceServerSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema ResourceServerSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: ResourceServerSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema ResourceServerSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: ResourceServerSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'ResourceServerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProvider(obj: ResourceServerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifier': obj.identifier,
    'name': obj.name,
    'region': obj.region,
    'scopes': obj.scopes?.map(y => toJson_ResourceServerSpecForProviderScopes(y)),
    'userPoolID': obj.userPoolId,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_ResourceServerSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_ResourceServerSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResourceServerSpecManagementPolicies
 */
export enum ResourceServerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceServerSpecProviderConfigRef
 */
export interface ResourceServerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceServerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderConfigRef(obj: ResourceServerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsTo
 */
export interface ResourceServerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceServerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceServerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsTo(obj: ResourceServerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceServerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceServerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceServerSpecWriteConnectionSecretToRef
 */
export interface ResourceServerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceServerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceServerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceServerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecWriteConnectionSecretToRef(obj: ResourceServerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResourceServerSpecForProviderScopes
 */
export interface ResourceServerSpecForProviderScopes {
  /**
   * @schema ResourceServerSpecForProviderScopes#scopeDescription
   */
  readonly scopeDescription?: string;

  /**
   * @schema ResourceServerSpecForProviderScopes#scopeName
   */
  readonly scopeName?: string;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderScopes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderScopes(obj: ResourceServerSpecForProviderScopes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scopeDescription': obj.scopeDescription,
    'scopeName': obj.scopeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRef
 */
export interface ResourceServerSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: ResourceServerSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdRef(obj: ResourceServerSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelector
 */
export interface ResourceServerSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: ResourceServerSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdSelector(obj: ResourceServerSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceServerSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicy
 */
export interface ResourceServerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderConfigRefPolicy(obj: ResourceServerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceServerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToConfigRef(obj: ResourceServerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceServerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToMetadata(obj: ResourceServerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy
 */
export interface ResourceServerSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdRefPolicy(obj: ResourceServerSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy
 */
export interface ResourceServerSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdSelectorPolicy(obj: ResourceServerSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicyResolution
 */
export enum ResourceServerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicyResolve
 */
export enum ResourceServerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum ResourceServerSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum ResourceServerSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPool is the Schema for the UserPools API
 *
 * @schema UserPool
 */
export class UserPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'UserPool',
  }

  /**
   * Renders a Kubernetes manifest for "UserPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolProps): any {
    return {
      ...UserPool.GVK,
      ...toJson_UserPoolProps(props),
    };
  }

  /**
   * Defines a "UserPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolProps) {
    super(scope, id, {
      ...UserPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPool.GVK,
      ...toJson_UserPoolProps(resolved),
    };
  }
}

/**
 * UserPool is the Schema for the UserPools API
 *
 * @schema UserPool
 */
export interface UserPoolProps {
  /**
   * @schema UserPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolSpec defines the desired state of UserPool
   *
   * @schema UserPool#spec
   */
  readonly spec: UserPoolSpec;

}

/**
 * Converts an object of type 'UserPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolProps(obj: UserPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolSpec defines the desired state of UserPool
 *
 * @schema UserPoolSpec
 */
export interface UserPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolSpecDeletionPolicy;

  /**
   * UserPoolParameters defines the desired state of UserPool
   *
   * @schema UserPoolSpec#forProvider
   */
  readonly forProvider: UserPoolSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserPoolSpec#managementPolicies
   */
  readonly managementPolicies?: UserPoolSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpec(obj: UserPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserPoolSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserPoolSpecDeletionPolicy
 */
export enum UserPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UserPoolParameters defines the desired state of UserPool
 *
 * @schema UserPoolSpecForProvider
 */
export interface UserPoolSpecForProvider {
  /**
   * The available verified method a user can use to recover their password when they call ForgotPassword. You can use this setting to define a preferred method when a user has more than one method available. With this setting, SMS doesn't qualify for a valid password recovery mechanism if the user also has SMS multi-factor authentication (MFA) activated. In the absence of this setting, Amazon Cognito uses the legacy behavior to determine the recovery method where SMS is preferred through email.
   *
   * @schema UserPoolSpecForProvider#accountRecoverySetting
   */
  readonly accountRecoverySetting?: UserPoolSpecForProviderAccountRecoverySetting;

  /**
   * The configuration for AdminCreateUser requests.
   *
   * @schema UserPoolSpecForProvider#adminCreateUserConfig
   */
  readonly adminCreateUserConfig?: UserPoolSpecForProviderAdminCreateUserConfig;

  /**
   * Attributes supported as an alias for this user pool. Possible values: phone_number, email, or preferred_username.
   *
   * @schema UserPoolSpecForProvider#aliasAttributes
   */
  readonly aliasAttributes?: string[];

  /**
   * The attributes to be auto-verified. Possible values: email, phone_number.
   *
   * @schema UserPoolSpecForProvider#autoVerifiedAttributes
   */
  readonly autoVerifiedAttributes?: string[];

  /**
   * When active, DeletionProtection prevents accidental deletion of your user pool. Before you can delete a user pool that you have protected against deletion, you must deactivate this feature.
   * When you try to delete a protected user pool in a DeleteUserPool API request, Amazon Cognito returns an InvalidParameterException error. To delete a protected user pool, send a new DeleteUserPool request after you deactivate deletion protection in an UpdateUserPool API request.
   *
   * @schema UserPoolSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: string;

  /**
   * The device-remembering configuration for a user pool. A null value indicates that you have deactivated device remembering in your user pool.
   * When you provide a value for any DeviceConfiguration field, you activate the Amazon Cognito device-remembering feature.
   *
   * @schema UserPoolSpecForProvider#deviceConfiguration
   */
  readonly deviceConfiguration?: UserPoolSpecForProviderDeviceConfiguration;

  /**
   * The email configuration of your user pool. The email configuration type sets your preferred sending method, Amazon Web Services Region, and sender for messages from your user pool.
   *
   * @schema UserPoolSpecForProvider#emailConfiguration
   */
  readonly emailConfiguration?: UserPoolSpecForProviderEmailConfiguration;

  /**
   * This parameter is no longer used. See VerificationMessageTemplateType (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_VerificationMessageTemplateType.html).
   *
   * @schema UserPoolSpecForProvider#emailVerificationMessage
   */
  readonly emailVerificationMessage?: string;

  /**
   * This parameter is no longer used. See VerificationMessageTemplateType (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_VerificationMessageTemplateType.html).
   *
   * @schema UserPoolSpecForProvider#emailVerificationSubject
   */
  readonly emailVerificationSubject?: string;

  /**
   * The Lambda trigger configuration information for the new user pool.
   * In a push model, event sources (such as Amazon S3 and custom applications) need permission to invoke a function. So you must make an extra call to add permission for these event sources to invoke your Lambda function.
   * For more information on using the Lambda API to add permission, see AddPermission (https://docs.aws.amazon.com/lambda/latest/dg/API_AddPermission.html).
   * For adding permission using the CLI, see add-permission (https://docs.aws.amazon.com/cli/latest/reference/lambda/add-permission.html).
   *
   * @schema UserPoolSpecForProvider#lambdaConfig
   */
  readonly lambdaConfig?: UserPoolSpecForProviderLambdaConfig;

  /**
   * Specifies MFA configuration details.
   *
   * @schema UserPoolSpecForProvider#mfaConfiguration
   */
  readonly mfaConfiguration?: string;

  /**
   * The policies associated with the new user pool.
   *
   * @schema UserPoolSpecForProvider#policies
   */
  readonly policies?: UserPoolSpecForProviderPolicies;

  /**
   * A string used to name the user pool.
   *
   * @schema UserPoolSpecForProvider#poolName
   */
  readonly poolName: string;

  /**
   * Region is which region the UserPool will be created.
   *
   * @schema UserPoolSpecForProvider#region
   */
  readonly region: string;

  /**
   * An array of schema attributes for the new user pool. These attributes can be standard or custom attributes.
   *
   * @schema UserPoolSpecForProvider#schema
   */
  readonly schema?: UserPoolSpecForProviderSchema[];

  /**
   * A string representing the SMS authentication message.
   *
   * @schema UserPoolSpecForProvider#smsAuthenticationMessage
   */
  readonly smsAuthenticationMessage?: string;

  /**
   * The SMS configuration with the settings that your Amazon Cognito user pool must use to send an SMS message from your Amazon Web Services account through Amazon Simple Notification Service. To send SMS messages with Amazon SNS in the Amazon Web Services Region that you want, the Amazon Cognito user pool uses an Identity and Access Management (IAM) role in your Amazon Web Services account.
   *
   * @schema UserPoolSpecForProvider#smsConfiguration
   */
  readonly smsConfiguration?: UserPoolSpecForProviderSmsConfiguration;

  /**
   * This parameter is no longer used. See VerificationMessageTemplateType (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_VerificationMessageTemplateType.html).
   *
   * @schema UserPoolSpecForProvider#smsVerificationMessage
   */
  readonly smsVerificationMessage?: string;

  /**
   * The software token MFA configuration.
   *
   * @schema UserPoolSpecForProvider#softwareTokenMFAConfiguration
   */
  readonly softwareTokenMfaConfiguration?: UserPoolSpecForProviderSoftwareTokenMfaConfiguration;

  /**
   * The settings for updates to user attributes. These settings include the property AttributesRequireVerificationBeforeUpdate, a user-pool setting that tells Amazon Cognito how to handle changes to the value of your users' email address and phone number attributes. For more information, see Verifying updates to email addresses and phone numbers (https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-email-phone-verification.html#user-pool-settings-verifications-verify-attribute-updates).
   *
   * @schema UserPoolSpecForProvider#userAttributeUpdateSettings
   */
  readonly userAttributeUpdateSettings?: UserPoolSpecForProviderUserAttributeUpdateSettings;

  /**
   * User pool add-ons. Contains settings for activation of advanced security features. To log user security information but take no action, set to AUDIT. To configure automatic security responses to risky traffic to your user pool, set to ENFORCED.
   * For more information, see Adding advanced security to a user pool (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html).
   *
   * @schema UserPoolSpecForProvider#userPoolAddOns
   */
  readonly userPoolAddOns?: UserPoolSpecForProviderUserPoolAddOns;

  /**
   * The tag keys and values to assign to the user pool. A tag is a label that you can use to categorize and manage user pools in different ways, such as by purpose, owner, environment, or other criteria.
   *
   * @schema UserPoolSpecForProvider#userPoolTags
   */
  readonly userPoolTags?: { [key: string]: string };

  /**
   * Specifies whether a user can use an email address or phone number as a username when they sign up.
   *
   * @schema UserPoolSpecForProvider#usernameAttributes
   */
  readonly usernameAttributes?: string[];

  /**
   * Case sensitivity on the username input for the selected sign-in option. When case sensitivity is set to False (case insensitive), users can sign in with any combination of capital and lowercase letters. For example, username, USERNAME, or UserName, or for email, email@example.com or EMaiL@eXamplE.Com. For most use cases, set case sensitivity to False (case insensitive) as a best practice. When usernames and email addresses are case insensitive, Amazon Cognito treats any variation in case as the same user, and prevents a case variation from being assigned to the same attribute for a different user.
   * This configuration is immutable after you set it. For more information, see UsernameConfigurationType (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UsernameConfigurationType.html).
   *
   * @schema UserPoolSpecForProvider#usernameConfiguration
   */
  readonly usernameConfiguration?: UserPoolSpecForProviderUsernameConfiguration;

  /**
   * The template for the verification message that the user sees when the app requests permission to access the user's information.
   *
   * @schema UserPoolSpecForProvider#verificationMessageTemplate
   */
  readonly verificationMessageTemplate?: UserPoolSpecForProviderVerificationMessageTemplate;

}

/**
 * Converts an object of type 'UserPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProvider(obj: UserPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountRecoverySetting': toJson_UserPoolSpecForProviderAccountRecoverySetting(obj.accountRecoverySetting),
    'adminCreateUserConfig': toJson_UserPoolSpecForProviderAdminCreateUserConfig(obj.adminCreateUserConfig),
    'aliasAttributes': obj.aliasAttributes?.map(y => y),
    'autoVerifiedAttributes': obj.autoVerifiedAttributes?.map(y => y),
    'deletionProtection': obj.deletionProtection,
    'deviceConfiguration': toJson_UserPoolSpecForProviderDeviceConfiguration(obj.deviceConfiguration),
    'emailConfiguration': toJson_UserPoolSpecForProviderEmailConfiguration(obj.emailConfiguration),
    'emailVerificationMessage': obj.emailVerificationMessage,
    'emailVerificationSubject': obj.emailVerificationSubject,
    'lambdaConfig': toJson_UserPoolSpecForProviderLambdaConfig(obj.lambdaConfig),
    'mfaConfiguration': obj.mfaConfiguration,
    'policies': toJson_UserPoolSpecForProviderPolicies(obj.policies),
    'poolName': obj.poolName,
    'region': obj.region,
    'schema': obj.schema?.map(y => toJson_UserPoolSpecForProviderSchema(y)),
    'smsAuthenticationMessage': obj.smsAuthenticationMessage,
    'smsConfiguration': toJson_UserPoolSpecForProviderSmsConfiguration(obj.smsConfiguration),
    'smsVerificationMessage': obj.smsVerificationMessage,
    'softwareTokenMFAConfiguration': toJson_UserPoolSpecForProviderSoftwareTokenMfaConfiguration(obj.softwareTokenMfaConfiguration),
    'userAttributeUpdateSettings': toJson_UserPoolSpecForProviderUserAttributeUpdateSettings(obj.userAttributeUpdateSettings),
    'userPoolAddOns': toJson_UserPoolSpecForProviderUserPoolAddOns(obj.userPoolAddOns),
    'userPoolTags': ((obj.userPoolTags) === undefined) ? undefined : (Object.entries(obj.userPoolTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'usernameAttributes': obj.usernameAttributes?.map(y => y),
    'usernameConfiguration': toJson_UserPoolSpecForProviderUsernameConfiguration(obj.usernameConfiguration),
    'verificationMessageTemplate': toJson_UserPoolSpecForProviderVerificationMessageTemplate(obj.verificationMessageTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserPoolSpecManagementPolicies
 */
export enum UserPoolSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolSpecProviderConfigRef
 */
export interface UserPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderConfigRef(obj: UserPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolSpecPublishConnectionDetailsTo
 */
export interface UserPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsTo(obj: UserPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolSpecWriteConnectionSecretToRef
 */
export interface UserPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecWriteConnectionSecretToRef(obj: UserPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The available verified method a user can use to recover their password when they call ForgotPassword. You can use this setting to define a preferred method when a user has more than one method available. With this setting, SMS doesn't qualify for a valid password recovery mechanism if the user also has SMS multi-factor authentication (MFA) activated. In the absence of this setting, Amazon Cognito uses the legacy behavior to determine the recovery method where SMS is preferred through email.
 *
 * @schema UserPoolSpecForProviderAccountRecoverySetting
 */
export interface UserPoolSpecForProviderAccountRecoverySetting {
  /**
   * @schema UserPoolSpecForProviderAccountRecoverySetting#recoveryMechanisms
   */
  readonly recoveryMechanisms?: UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAccountRecoverySetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAccountRecoverySetting(obj: UserPoolSpecForProviderAccountRecoverySetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recoveryMechanisms': obj.recoveryMechanisms?.map(y => toJson_UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for AdminCreateUser requests.
 *
 * @schema UserPoolSpecForProviderAdminCreateUserConfig
 */
export interface UserPoolSpecForProviderAdminCreateUserConfig {
  /**
   * @schema UserPoolSpecForProviderAdminCreateUserConfig#allowAdminCreateUserOnly
   */
  readonly allowAdminCreateUserOnly?: boolean;

  /**
   * The message template structure.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfig#inviteMessageTemplate
   */
  readonly inviteMessageTemplate?: UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAdminCreateUserConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAdminCreateUserConfig(obj: UserPoolSpecForProviderAdminCreateUserConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAdminCreateUserOnly': obj.allowAdminCreateUserOnly,
    'inviteMessageTemplate': toJson_UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate(obj.inviteMessageTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The device-remembering configuration for a user pool. A null value indicates that you have deactivated device remembering in your user pool.
 * When you provide a value for any DeviceConfiguration field, you activate the Amazon Cognito device-remembering feature.
 *
 * @schema UserPoolSpecForProviderDeviceConfiguration
 */
export interface UserPoolSpecForProviderDeviceConfiguration {
  /**
   * @schema UserPoolSpecForProviderDeviceConfiguration#challengeRequiredOnNewDevice
   */
  readonly challengeRequiredOnNewDevice?: boolean;

  /**
   * @schema UserPoolSpecForProviderDeviceConfiguration#deviceOnlyRememberedOnUserPrompt
   */
  readonly deviceOnlyRememberedOnUserPrompt?: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderDeviceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderDeviceConfiguration(obj: UserPoolSpecForProviderDeviceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'challengeRequiredOnNewDevice': obj.challengeRequiredOnNewDevice,
    'deviceOnlyRememberedOnUserPrompt': obj.deviceOnlyRememberedOnUserPrompt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The email configuration of your user pool. The email configuration type sets your preferred sending method, Amazon Web Services Region, and sender for messages from your user pool.
 *
 * @schema UserPoolSpecForProviderEmailConfiguration
 */
export interface UserPoolSpecForProviderEmailConfiguration {
  /**
   * @schema UserPoolSpecForProviderEmailConfiguration#configurationSet
   */
  readonly configurationSet?: string;

  /**
   * @schema UserPoolSpecForProviderEmailConfiguration#emailSendingAccount
   */
  readonly emailSendingAccount?: string;

  /**
   * @schema UserPoolSpecForProviderEmailConfiguration#from
   */
  readonly from?: string;

  /**
   * @schema UserPoolSpecForProviderEmailConfiguration#replyToEmailAddress
   */
  readonly replyToEmailAddress?: string;

  /**
   * @schema UserPoolSpecForProviderEmailConfiguration#sourceARN
   */
  readonly sourceArn?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderEmailConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderEmailConfiguration(obj: UserPoolSpecForProviderEmailConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationSet': obj.configurationSet,
    'emailSendingAccount': obj.emailSendingAccount,
    'from': obj.from,
    'replyToEmailAddress': obj.replyToEmailAddress,
    'sourceARN': obj.sourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Lambda trigger configuration information for the new user pool.
 * In a push model, event sources (such as Amazon S3 and custom applications) need permission to invoke a function. So you must make an extra call to add permission for these event sources to invoke your Lambda function.
 * For more information on using the Lambda API to add permission, see AddPermission (https://docs.aws.amazon.com/lambda/latest/dg/API_AddPermission.html).
 * For adding permission using the CLI, see add-permission (https://docs.aws.amazon.com/cli/latest/reference/lambda/add-permission.html).
 *
 * @schema UserPoolSpecForProviderLambdaConfig
 */
export interface UserPoolSpecForProviderLambdaConfig {
  /**
   * @schema UserPoolSpecForProviderLambdaConfig#createAuthChallenge
   */
  readonly createAuthChallenge?: string;

  /**
   * A custom email sender Lambda configuration type.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#customEmailSender
   */
  readonly customEmailSender?: UserPoolSpecForProviderLambdaConfigCustomEmailSender;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#customMessage
   */
  readonly customMessage?: string;

  /**
   * A custom SMS sender Lambda configuration type.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#customSMSSender
   */
  readonly customSmsSender?: UserPoolSpecForProviderLambdaConfigCustomSmsSender;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#defineAuthChallenge
   */
  readonly defineAuthChallenge?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#postAuthentication
   */
  readonly postAuthentication?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#postConfirmation
   */
  readonly postConfirmation?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#preAuthentication
   */
  readonly preAuthentication?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#preSignUp
   */
  readonly preSignUp?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#preTokenGeneration
   */
  readonly preTokenGeneration?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#userMigration
   */
  readonly userMigration?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfig#verifyAuthChallengeResponse
   */
  readonly verifyAuthChallengeResponse?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfig(obj: UserPoolSpecForProviderLambdaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createAuthChallenge': obj.createAuthChallenge,
    'customEmailSender': toJson_UserPoolSpecForProviderLambdaConfigCustomEmailSender(obj.customEmailSender),
    'customMessage': obj.customMessage,
    'customSMSSender': toJson_UserPoolSpecForProviderLambdaConfigCustomSmsSender(obj.customSmsSender),
    'defineAuthChallenge': obj.defineAuthChallenge,
    'kmsKeyID': obj.kmsKeyId,
    'postAuthentication': obj.postAuthentication,
    'postConfirmation': obj.postConfirmation,
    'preAuthentication': obj.preAuthentication,
    'preSignUp': obj.preSignUp,
    'preTokenGeneration': obj.preTokenGeneration,
    'userMigration': obj.userMigration,
    'verifyAuthChallengeResponse': obj.verifyAuthChallengeResponse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policies associated with the new user pool.
 *
 * @schema UserPoolSpecForProviderPolicies
 */
export interface UserPoolSpecForProviderPolicies {
  /**
   * The password policy type.
   *
   * @schema UserPoolSpecForProviderPolicies#passwordPolicy
   */
  readonly passwordPolicy?: UserPoolSpecForProviderPoliciesPasswordPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderPolicies(obj: UserPoolSpecForProviderPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordPolicy': toJson_UserPoolSpecForProviderPoliciesPasswordPolicy(obj.passwordPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSchema
 */
export interface UserPoolSpecForProviderSchema {
  /**
   * @schema UserPoolSpecForProviderSchema#attributeDataType
   */
  readonly attributeDataType?: string;

  /**
   * @schema UserPoolSpecForProviderSchema#developerOnlyAttribute
   */
  readonly developerOnlyAttribute?: boolean;

  /**
   * @schema UserPoolSpecForProviderSchema#mutable
   */
  readonly mutable?: boolean;

  /**
   * @schema UserPoolSpecForProviderSchema#name
   */
  readonly name?: string;

  /**
   * The minimum and maximum values of an attribute that is of the number data type.
   *
   * @schema UserPoolSpecForProviderSchema#numberAttributeConstraints
   */
  readonly numberAttributeConstraints?: UserPoolSpecForProviderSchemaNumberAttributeConstraints;

  /**
   * @schema UserPoolSpecForProviderSchema#required
   */
  readonly required?: boolean;

  /**
   * The constraints associated with a string attribute.
   *
   * @schema UserPoolSpecForProviderSchema#stringAttributeConstraints
   */
  readonly stringAttributeConstraints?: UserPoolSpecForProviderSchemaStringAttributeConstraints;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchema(obj: UserPoolSpecForProviderSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeDataType': obj.attributeDataType,
    'developerOnlyAttribute': obj.developerOnlyAttribute,
    'mutable': obj.mutable,
    'name': obj.name,
    'numberAttributeConstraints': toJson_UserPoolSpecForProviderSchemaNumberAttributeConstraints(obj.numberAttributeConstraints),
    'required': obj.required,
    'stringAttributeConstraints': toJson_UserPoolSpecForProviderSchemaStringAttributeConstraints(obj.stringAttributeConstraints),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SMS configuration with the settings that your Amazon Cognito user pool must use to send an SMS message from your Amazon Web Services account through Amazon Simple Notification Service. To send SMS messages with Amazon SNS in the Amazon Web Services Region that you want, the Amazon Cognito user pool uses an Identity and Access Management (IAM) role in your Amazon Web Services account.
 *
 * @schema UserPoolSpecForProviderSmsConfiguration
 */
export interface UserPoolSpecForProviderSmsConfiguration {
  /**
   * @schema UserPoolSpecForProviderSmsConfiguration#externalID
   */
  readonly externalId?: string;

  /**
   * @schema UserPoolSpecForProviderSmsConfiguration#snsCallerARN
   */
  readonly snsCallerArn?: string;

  /**
   * @schema UserPoolSpecForProviderSmsConfiguration#snsRegion
   */
  readonly snsRegion?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfiguration(obj: UserPoolSpecForProviderSmsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'snsCallerARN': obj.snsCallerArn,
    'snsRegion': obj.snsRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The software token MFA configuration.
 *
 * @schema UserPoolSpecForProviderSoftwareTokenMfaConfiguration
 */
export interface UserPoolSpecForProviderSoftwareTokenMfaConfiguration {
  /**
   * @schema UserPoolSpecForProviderSoftwareTokenMfaConfiguration#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSoftwareTokenMfaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSoftwareTokenMfaConfiguration(obj: UserPoolSpecForProviderSoftwareTokenMfaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The settings for updates to user attributes. These settings include the property AttributesRequireVerificationBeforeUpdate, a user-pool setting that tells Amazon Cognito how to handle changes to the value of your users' email address and phone number attributes. For more information, see Verifying updates to email addresses and phone numbers (https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-email-phone-verification.html#user-pool-settings-verifications-verify-attribute-updates).
 *
 * @schema UserPoolSpecForProviderUserAttributeUpdateSettings
 */
export interface UserPoolSpecForProviderUserAttributeUpdateSettings {
  /**
   * @schema UserPoolSpecForProviderUserAttributeUpdateSettings#attributesRequireVerificationBeforeUpdate
   */
  readonly attributesRequireVerificationBeforeUpdate?: string[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUserAttributeUpdateSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUserAttributeUpdateSettings(obj: UserPoolSpecForProviderUserAttributeUpdateSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributesRequireVerificationBeforeUpdate': obj.attributesRequireVerificationBeforeUpdate?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * User pool add-ons. Contains settings for activation of advanced security features. To log user security information but take no action, set to AUDIT. To configure automatic security responses to risky traffic to your user pool, set to ENFORCED.
 * For more information, see Adding advanced security to a user pool (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html).
 *
 * @schema UserPoolSpecForProviderUserPoolAddOns
 */
export interface UserPoolSpecForProviderUserPoolAddOns {
  /**
   * @schema UserPoolSpecForProviderUserPoolAddOns#advancedSecurityMode
   */
  readonly advancedSecurityMode?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUserPoolAddOns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUserPoolAddOns(obj: UserPoolSpecForProviderUserPoolAddOns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedSecurityMode': obj.advancedSecurityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Case sensitivity on the username input for the selected sign-in option. When case sensitivity is set to False (case insensitive), users can sign in with any combination of capital and lowercase letters. For example, username, USERNAME, or UserName, or for email, email@example.com or EMaiL@eXamplE.Com. For most use cases, set case sensitivity to False (case insensitive) as a best practice. When usernames and email addresses are case insensitive, Amazon Cognito treats any variation in case as the same user, and prevents a case variation from being assigned to the same attribute for a different user.
 * This configuration is immutable after you set it. For more information, see UsernameConfigurationType (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UsernameConfigurationType.html).
 *
 * @schema UserPoolSpecForProviderUsernameConfiguration
 */
export interface UserPoolSpecForProviderUsernameConfiguration {
  /**
   * @schema UserPoolSpecForProviderUsernameConfiguration#caseSensitive
   */
  readonly caseSensitive?: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUsernameConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUsernameConfiguration(obj: UserPoolSpecForProviderUsernameConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caseSensitive': obj.caseSensitive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The template for the verification message that the user sees when the app requests permission to access the user's information.
 *
 * @schema UserPoolSpecForProviderVerificationMessageTemplate
 */
export interface UserPoolSpecForProviderVerificationMessageTemplate {
  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#defaultEmailOption
   */
  readonly defaultEmailOption?: string;

  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailMessage
   */
  readonly emailMessage?: string;

  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailMessageByLink
   */
  readonly emailMessageByLink?: string;

  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailSubject
   */
  readonly emailSubject?: string;

  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailSubjectByLink
   */
  readonly emailSubjectByLink?: string;

  /**
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#smsMessage
   */
  readonly smsMessage?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderVerificationMessageTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderVerificationMessageTemplate(obj: UserPoolSpecForProviderVerificationMessageTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultEmailOption': obj.defaultEmailOption,
    'emailMessage': obj.emailMessage,
    'emailMessageByLink': obj.emailMessageByLink,
    'emailSubject': obj.emailSubject,
    'emailSubjectByLink': obj.emailSubjectByLink,
    'smsMessage': obj.smsMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecProviderConfigRefPolicy
 */
export interface UserPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderConfigRefPolicy(obj: UserPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToConfigRef(obj: UserPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToMetadata(obj: UserPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms
 */
export interface UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms {
  /**
   * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms#name
   */
  readonly name?: string;

  /**
   * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms#priority
   */
  readonly priority?: number;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms(obj: UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanisms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The message template structure.
 *
 * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate
 */
export interface UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate {
  /**
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#emailMessage
   */
  readonly emailMessage?: string;

  /**
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#emailSubject
   */
  readonly emailSubject?: string;

  /**
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#sMSMessage
   */
  readonly sMsMessage?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate(obj: UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'emailMessage': obj.emailMessage,
    'emailSubject': obj.emailSubject,
    'sMSMessage': obj.sMsMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A custom email sender Lambda configuration type.
 *
 * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender
 */
export interface UserPoolSpecForProviderLambdaConfigCustomEmailSender {
  /**
   * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender#lambdaARN
   */
  readonly lambdaArn?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender#lambdaVersion
   */
  readonly lambdaVersion?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfigCustomEmailSender' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfigCustomEmailSender(obj: UserPoolSpecForProviderLambdaConfigCustomEmailSender | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaARN': obj.lambdaArn,
    'lambdaVersion': obj.lambdaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A custom SMS sender Lambda configuration type.
 *
 * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender
 */
export interface UserPoolSpecForProviderLambdaConfigCustomSmsSender {
  /**
   * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender#lambdaARN
   */
  readonly lambdaArn?: string;

  /**
   * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender#lambdaVersion
   */
  readonly lambdaVersion?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfigCustomSmsSender' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfigCustomSmsSender(obj: UserPoolSpecForProviderLambdaConfigCustomSmsSender | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaARN': obj.lambdaArn,
    'lambdaVersion': obj.lambdaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password policy type.
 *
 * @schema UserPoolSpecForProviderPoliciesPasswordPolicy
 */
export interface UserPoolSpecForProviderPoliciesPasswordPolicy {
  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#minimumLength
   */
  readonly minimumLength?: number;

  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#requireLowercase
   */
  readonly requireLowercase?: boolean;

  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#requireNumbers
   */
  readonly requireNumbers?: boolean;

  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#requireSymbols
   */
  readonly requireSymbols?: boolean;

  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#requireUppercase
   */
  readonly requireUppercase?: boolean;

  /**
   * @schema UserPoolSpecForProviderPoliciesPasswordPolicy#temporaryPasswordValidityDays
   */
  readonly temporaryPasswordValidityDays?: number;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderPoliciesPasswordPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderPoliciesPasswordPolicy(obj: UserPoolSpecForProviderPoliciesPasswordPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumLength': obj.minimumLength,
    'requireLowercase': obj.requireLowercase,
    'requireNumbers': obj.requireNumbers,
    'requireSymbols': obj.requireSymbols,
    'requireUppercase': obj.requireUppercase,
    'temporaryPasswordValidityDays': obj.temporaryPasswordValidityDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The minimum and maximum values of an attribute that is of the number data type.
 *
 * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints
 */
export interface UserPoolSpecForProviderSchemaNumberAttributeConstraints {
  /**
   * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints#maxValue
   */
  readonly maxValue?: string;

  /**
   * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints#minValue
   */
  readonly minValue?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchemaNumberAttributeConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchemaNumberAttributeConstraints(obj: UserPoolSpecForProviderSchemaNumberAttributeConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxValue': obj.maxValue,
    'minValue': obj.minValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The constraints associated with a string attribute.
 *
 * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints
 */
export interface UserPoolSpecForProviderSchemaStringAttributeConstraints {
  /**
   * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints#maxLength
   */
  readonly maxLength?: string;

  /**
   * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints#minLength
   */
  readonly minLength?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchemaStringAttributeConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchemaStringAttributeConstraints(obj: UserPoolSpecForProviderSchemaStringAttributeConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxLength': obj.maxLength,
    'minLength': obj.minLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPoolClient is the Schema for the UserPoolClients API
 *
 * @schema UserPoolClient
 */
export class UserPoolClient extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPoolClient"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'UserPoolClient',
  }

  /**
   * Renders a Kubernetes manifest for "UserPoolClient".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolClientProps): any {
    return {
      ...UserPoolClient.GVK,
      ...toJson_UserPoolClientProps(props),
    };
  }

  /**
   * Defines a "UserPoolClient" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolClientProps) {
    super(scope, id, {
      ...UserPoolClient.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPoolClient.GVK,
      ...toJson_UserPoolClientProps(resolved),
    };
  }
}

/**
 * UserPoolClient is the Schema for the UserPoolClients API
 *
 * @schema UserPoolClient
 */
export interface UserPoolClientProps {
  /**
   * @schema UserPoolClient#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolClientSpec defines the desired state of UserPoolClient
   *
   * @schema UserPoolClient#spec
   */
  readonly spec: UserPoolClientSpec;

}

/**
 * Converts an object of type 'UserPoolClientProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientProps(obj: UserPoolClientProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolClientSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolClientSpec defines the desired state of UserPoolClient
 *
 * @schema UserPoolClientSpec
 */
export interface UserPoolClientSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserPoolClientSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolClientSpecDeletionPolicy;

  /**
   * UserPoolClientParameters defines the desired state of UserPoolClient
   *
   * @schema UserPoolClientSpec#forProvider
   */
  readonly forProvider: UserPoolClientSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserPoolClientSpec#managementPolicies
   */
  readonly managementPolicies?: UserPoolClientSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolClientSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolClientSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolClientSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolClientSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolClientSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolClientSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolClientSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpec(obj: UserPoolClientSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolClientSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserPoolClientSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserPoolClientSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolClientSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserPoolClientSpecDeletionPolicy
 */
export enum UserPoolClientSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UserPoolClientParameters defines the desired state of UserPoolClient
 *
 * @schema UserPoolClientSpecForProvider
 */
export interface UserPoolClientSpecForProvider {
  /**
   * The access token time limit. After this limit expires, your user can't use their access token. To specify the time unit for AccessTokenValidity as seconds, minutes, hours, or days, set a TokenValidityUnits value in your API request.
   * For example, when you set AccessTokenValidity to 10 and TokenValidityUnits to hours, your user can authorize access with their access token for 10 hours.
   * The default time unit for AccessTokenValidity in an API request is hours. Valid range is displayed below in seconds.
   * If you don't specify otherwise in the configuration of your app client, your access tokens are valid for one hour.
   *
   * @schema UserPoolClientSpecForProvider#accessTokenValidity
   */
  readonly accessTokenValidity?: number;

  /**
   * The allowed OAuth flows.
   * code
   * Use a code grant flow, which provides an authorization code as the response. This code can be exchanged for access tokens with the /oauth2/token endpoint.
   * implicit
   * Issue the access token (and, optionally, ID token, based on scopes) directly to your user.
   * client_credentials
   * Issue the access token from the /oauth2/token endpoint directly to a non-person user using a combination of the client ID and client secret.
   *
   * @schema UserPoolClientSpecForProvider#allowedOAuthFlows
   */
  readonly allowedOAuthFlows?: string[];

  /**
   * Set to true to use OAuth 2.0 features in your user pool app client.
   * AllowedOAuthFlowsUserPoolClient must be true before you can configure the following features in your app client.
   * * CallBackURLs: Callback URLs.
   * * LogoutURLs: Sign-out redirect URLs.
   * * AllowedOAuthScopes: OAuth 2.0 scopes.
   * * AllowedOAuthFlows: Support for authorization code, implicit, and client credentials OAuth 2.0 grants.
   * To use OAuth 2.0 features, configure one of these features in the Amazon Cognito console or set AllowedOAuthFlowsUserPoolClient to true in a CreateUserPoolClient or UpdateUserPoolClient API request. If you don't set a value for AllowedOAuthFlowsUserPoolClient in a request with the CLI or SDKs, it defaults to false.
   *
   * @schema UserPoolClientSpecForProvider#allowedOAuthFlowsUserPoolClient
   */
  readonly allowedOAuthFlowsUserPoolClient?: boolean;

  /**
   * The allowed OAuth scopes. Possible values provided by OAuth are phone, email, openid, and profile. Possible values provided by Amazon Web Services are aws.cognito.signin.user.admin. Custom scopes created in Resource Servers are also supported.
   *
   * @schema UserPoolClientSpecForProvider#allowedOAuthScopes
   */
  readonly allowedOAuthScopes?: string[];

  /**
   * The user pool analytics configuration for collecting metrics and sending them to your Amazon Pinpoint campaign.
   * In Amazon Web Services Regions where Amazon Pinpoint isn't available, user pools only support sending events to Amazon Pinpoint projects in Amazon Web Services Region us-east-1. In Regions where Amazon Pinpoint is available, user pools support sending events to Amazon Pinpoint projects within that same Region.
   *
   * @schema UserPoolClientSpecForProvider#analyticsConfiguration
   */
  readonly analyticsConfiguration?: UserPoolClientSpecForProviderAnalyticsConfiguration;

  /**
   * Amazon Cognito creates a session token for each API request in an authentication flow. AuthSessionValidity is the duration, in minutes, of that session token. Your user pool native user must respond to each authentication challenge before the session expires.
   *
   * @schema UserPoolClientSpecForProvider#authSessionValidity
   */
  readonly authSessionValidity?: number;

  /**
   * A list of allowed redirect (callback) URLs for the IdPs.
   * A redirect URI must:
   * * Be an absolute URI.
   * * Be registered with the authorization server.
   * * Not include a fragment component.
   * See OAuth 2.0 - Redirection Endpoint (https://tools.ietf.org/html/rfc6749#section-3.1.2).
   * Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing purposes only.
   * App callback URLs such as myapp://example are also supported.
   *
   * @schema UserPoolClientSpecForProvider#callbackURLs
   */
  readonly callbackUrLs?: string[];

  /**
   * The client name for the user pool client you would like to create.
   *
   * @schema UserPoolClientSpecForProvider#clientName
   */
  readonly clientName: string;

  /**
   * The default redirect URI. Must be in the CallbackURLs list.
   * A redirect URI must:
   * * Be an absolute URI.
   * * Be registered with the authorization server.
   * * Not include a fragment component.
   * See OAuth 2.0 - Redirection Endpoint (https://tools.ietf.org/html/rfc6749#section-3.1.2).
   * Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing purposes only.
   * App callback URLs such as myapp://example are also supported.
   *
   * @schema UserPoolClientSpecForProvider#defaultRedirectURI
   */
  readonly defaultRedirectUri?: string;

  /**
   * Activates the propagation of additional user context data. For more information about propagation of user context data, see Adding advanced security to a user pool (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html). If you dont include this parameter, you can't send device fingerprint information, including source IP address, to Amazon Cognito advanced security. You can only activate EnablePropagateAdditionalUserContextData in an app client that has a client secret.
   *
   * @schema UserPoolClientSpecForProvider#enablePropagateAdditionalUserContextData
   */
  readonly enablePropagateAdditionalUserContextData?: boolean;

  /**
   * Activates or deactivates token revocation. For more information about revoking tokens, see RevokeToken (https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_RevokeToken.html).
   * If you don't include this parameter, token revocation is automatically activated for the new user pool client.
   *
   * @schema UserPoolClientSpecForProvider#enableTokenRevocation
   */
  readonly enableTokenRevocation?: boolean;

  /**
   * The authentication flows that you want your user pool client to support. For each app client in your user pool, you can sign in your users with any combination of one or more flows, including with a user name and Secure Remote Password (SRP), a user name and password, or a custom authentication process that you define with Lambda functions.
   * If you don't specify a value for ExplicitAuthFlows, your user client supports ALLOW_REFRESH_TOKEN_AUTH, ALLOW_USER_SRP_AUTH, and ALLOW_CUSTOM_AUTH.
   * Valid values include:
   * * ALLOW_ADMIN_USER_PASSWORD_AUTH: Enable admin based user password authentication flow ADMIN_USER_PASSWORD_AUTH. This setting replaces the ADMIN_NO_SRP_AUTH setting. With this authentication flow, your app passes a user name and password to Amazon Cognito in the request, instead of using the Secure Remote Password (SRP) protocol to securely transmit the password.
   * * ALLOW_CUSTOM_AUTH: Enable Lambda trigger based authentication.
   * * ALLOW_USER_PASSWORD_AUTH: Enable user password-based authentication. In this flow, Amazon Cognito receives the password in the request instead of using the SRP protocol to verify passwords.
   * * ALLOW_USER_SRP_AUTH: Enable SRP-based authentication.
   * * ALLOW_REFRESH_TOKEN_AUTH: Enable authflow to refresh tokens.
   * In some environments, you will see the values ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY, or USER_PASSWORD_AUTH. You can't assign these legacy ExplicitAuthFlows values to user pool clients at the same time as values that begin with ALLOW_, like ALLOW_USER_SRP_AUTH.
   *
   * @schema UserPoolClientSpecForProvider#explicitAuthFlows
   */
  readonly explicitAuthFlows?: string[];

  /**
   * Boolean to specify whether you want to generate a secret for the user pool client being created.
   *
   * @schema UserPoolClientSpecForProvider#generateSecret
   */
  readonly generateSecret?: boolean;

  /**
   * The ID token time limit. After this limit expires, your user can't use their ID token. To specify the time unit for IdTokenValidity as seconds, minutes, hours, or days, set a TokenValidityUnits value in your API request.
   * For example, when you set IdTokenValidity as 10 and TokenValidityUnits as hours, your user can authenticate their session with their ID token for 10 hours.
   * The default time unit for IdTokenValidity in an API request is hours. Valid range is displayed below in seconds.
   * If you don't specify otherwise in the configuration of your app client, your ID tokens are valid for one hour.
   *
   * @schema UserPoolClientSpecForProvider#idTokenValidity
   */
  readonly idTokenValidity?: number;

  /**
   * A list of allowed logout URLs for the IdPs.
   *
   * @schema UserPoolClientSpecForProvider#logoutURLs
   */
  readonly logoutUrLs?: string[];

  /**
   * Errors and responses that you want Amazon Cognito APIs to return during authentication, account confirmation, and password recovery when the user doesn't exist in the user pool. When set to ENABLED and the user doesn't exist, authentication returns an error indicating either the username or password was incorrect. Account confirmation and password recovery return a response indicating a code was sent to a simulated destination. When set to LEGACY, those APIs return a UserNotFoundException exception if the user doesn't exist in the user pool.
   * Valid values include:
   * * ENABLED - This prevents user existence-related errors.
   * * LEGACY - This represents the early behavior of Amazon Cognito where user existence related errors aren't prevented.
   *
   * @schema UserPoolClientSpecForProvider#preventUserExistenceErrors
   */
  readonly preventUserExistenceErrors?: string;

  /**
   * The read attributes.
   *
   * @schema UserPoolClientSpecForProvider#readAttributes
   */
  readonly readAttributes?: string[];

  /**
   * The refresh token time limit. After this limit expires, your user can't use their refresh token. To specify the time unit for RefreshTokenValidity as seconds, minutes, hours, or days, set a TokenValidityUnits value in your API request.
   * For example, when you set RefreshTokenValidity as 10 and TokenValidityUnits as days, your user can refresh their session and retrieve new access and ID tokens for 10 days.
   * The default time unit for RefreshTokenValidity in an API request is days. You can't set RefreshTokenValidity to 0. If you do, Amazon Cognito overrides the value with the default value of 30 days. Valid range is displayed below in seconds.
   * If you don't specify otherwise in the configuration of your app client, your refresh tokens are valid for 30 days.
   *
   * @schema UserPoolClientSpecForProvider#refreshTokenValidity
   */
  readonly refreshTokenValidity?: number;

  /**
   * Region is which region the UserPoolClient will be created.
   *
   * @schema UserPoolClientSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of provider names for the identity providers (IdPs) that are supported on this client. The following are supported: COGNITO, Facebook, Google, SignInWithApple, and LoginWithAmazon. You can also specify the names that you configured for the SAML and OIDC IdPs in your user pool, for example MySAMLIdP or MyOIDCIdP.
   *
   * @schema UserPoolClientSpecForProvider#supportedIdentityProviders
   */
  readonly supportedIdentityProviders?: string[];

  /**
   * The units in which the validity times are represented. The default unit for RefreshToken is days, and default for ID and access tokens are hours.
   *
   * @schema UserPoolClientSpecForProvider#tokenValidityUnits
   */
  readonly tokenValidityUnits?: UserPoolClientSpecForProviderTokenValidityUnits;

  /**
   * The user pool ID.
   *
   * @schema UserPoolClientSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema UserPoolClientSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserPoolClientSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema UserPoolClientSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserPoolClientSpecForProviderUserPoolIdSelector;

  /**
   * The user pool attributes that the app client can write to.
   * If your app client allows users to sign in through an IdP, this array must include all attributes that you have mapped to IdP attributes. Amazon Cognito updates mapped attributes when users sign in to your application through an IdP. If your app client does not have write access to a mapped attribute, Amazon Cognito throws an error when it tries to update the attribute. For more information, see Specifying IdP Attribute Mappings for Your user pool (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-specifying-attribute-mapping.html).
   *
   * @schema UserPoolClientSpecForProvider#writeAttributes
   */
  readonly writeAttributes?: string[];

}

/**
 * Converts an object of type 'UserPoolClientSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProvider(obj: UserPoolClientSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenValidity': obj.accessTokenValidity,
    'allowedOAuthFlows': obj.allowedOAuthFlows?.map(y => y),
    'allowedOAuthFlowsUserPoolClient': obj.allowedOAuthFlowsUserPoolClient,
    'allowedOAuthScopes': obj.allowedOAuthScopes?.map(y => y),
    'analyticsConfiguration': toJson_UserPoolClientSpecForProviderAnalyticsConfiguration(obj.analyticsConfiguration),
    'authSessionValidity': obj.authSessionValidity,
    'callbackURLs': obj.callbackUrLs?.map(y => y),
    'clientName': obj.clientName,
    'defaultRedirectURI': obj.defaultRedirectUri,
    'enablePropagateAdditionalUserContextData': obj.enablePropagateAdditionalUserContextData,
    'enableTokenRevocation': obj.enableTokenRevocation,
    'explicitAuthFlows': obj.explicitAuthFlows?.map(y => y),
    'generateSecret': obj.generateSecret,
    'idTokenValidity': obj.idTokenValidity,
    'logoutURLs': obj.logoutUrLs?.map(y => y),
    'preventUserExistenceErrors': obj.preventUserExistenceErrors,
    'readAttributes': obj.readAttributes?.map(y => y),
    'refreshTokenValidity': obj.refreshTokenValidity,
    'region': obj.region,
    'supportedIdentityProviders': obj.supportedIdentityProviders?.map(y => y),
    'tokenValidityUnits': toJson_UserPoolClientSpecForProviderTokenValidityUnits(obj.tokenValidityUnits),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserPoolClientSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserPoolClientSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
    'writeAttributes': obj.writeAttributes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserPoolClientSpecManagementPolicies
 */
export enum UserPoolClientSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolClientSpecProviderConfigRef
 */
export interface UserPoolClientSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolClientSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderConfigRef(obj: UserPoolClientSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsTo
 */
export interface UserPoolClientSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolClientSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolClientSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsTo(obj: UserPoolClientSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolClientSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolClientSpecWriteConnectionSecretToRef
 */
export interface UserPoolClientSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolClientSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolClientSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecWriteConnectionSecretToRef(obj: UserPoolClientSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The user pool analytics configuration for collecting metrics and sending them to your Amazon Pinpoint campaign.
 * In Amazon Web Services Regions where Amazon Pinpoint isn't available, user pools only support sending events to Amazon Pinpoint projects in Amazon Web Services Region us-east-1. In Regions where Amazon Pinpoint is available, user pools support sending events to Amazon Pinpoint projects within that same Region.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfiguration
 */
export interface UserPoolClientSpecForProviderAnalyticsConfiguration {
  /**
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationARN
   */
  readonly applicationArn?: string;

  /**
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationID
   */
  readonly applicationId?: string;

  /**
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#externalID
   */
  readonly externalId?: string;

  /**
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#roleARN
   */
  readonly roleArn?: string;

  /**
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#userDataShared
   */
  readonly userDataShared?: boolean;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfiguration(obj: UserPoolClientSpecForProviderAnalyticsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationARN': obj.applicationArn,
    'applicationID': obj.applicationId,
    'externalID': obj.externalId,
    'roleARN': obj.roleArn,
    'userDataShared': obj.userDataShared,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The units in which the validity times are represented. The default unit for RefreshToken is days, and default for ID and access tokens are hours.
 *
 * @schema UserPoolClientSpecForProviderTokenValidityUnits
 */
export interface UserPoolClientSpecForProviderTokenValidityUnits {
  /**
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#accessToken
   */
  readonly accessToken?: string;

  /**
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#idToken
   */
  readonly idToken?: string;

  /**
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#refreshToken
   */
  readonly refreshToken?: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderTokenValidityUnits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderTokenValidityUnits(obj: UserPoolClientSpecForProviderTokenValidityUnits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': obj.accessToken,
    'idToken': obj.idToken,
    'refreshToken': obj.refreshToken,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRef
 */
export interface UserPoolClientSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserPoolClientSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdRef(obj: UserPoolClientSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelector
 */
export interface UserPoolClientSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdSelector(obj: UserPoolClientSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolClientSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicy
 */
export interface UserPoolClientSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderConfigRefPolicy(obj: UserPoolClientSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolClientSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRef(obj: UserPoolClientSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolClientSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToMetadata(obj: UserPoolClientSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy
 */
export interface UserPoolClientSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdRefPolicy(obj: UserPoolClientSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserPoolClientSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdSelectorPolicy(obj: UserPoolClientSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolClientSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolClientSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPoolDomain is the Schema for the UserPoolDomains API
 *
 * @schema UserPoolDomain
 */
export class UserPoolDomain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPoolDomain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentityprovider.aws.crossplane.io/v1alpha1',
    kind: 'UserPoolDomain',
  }

  /**
   * Renders a Kubernetes manifest for "UserPoolDomain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolDomainProps): any {
    return {
      ...UserPoolDomain.GVK,
      ...toJson_UserPoolDomainProps(props),
    };
  }

  /**
   * Defines a "UserPoolDomain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolDomainProps) {
    super(scope, id, {
      ...UserPoolDomain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPoolDomain.GVK,
      ...toJson_UserPoolDomainProps(resolved),
    };
  }
}

/**
 * UserPoolDomain is the Schema for the UserPoolDomains API
 *
 * @schema UserPoolDomain
 */
export interface UserPoolDomainProps {
  /**
   * @schema UserPoolDomain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolDomainSpec defines the desired state of UserPoolDomain
   *
   * @schema UserPoolDomain#spec
   */
  readonly spec: UserPoolDomainSpec;

}

/**
 * Converts an object of type 'UserPoolDomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainProps(obj: UserPoolDomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolDomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolDomainSpec defines the desired state of UserPoolDomain
 *
 * @schema UserPoolDomainSpec
 */
export interface UserPoolDomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserPoolDomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolDomainSpecDeletionPolicy;

  /**
   * UserPoolDomainParameters defines the desired state of UserPoolDomain
   *
   * @schema UserPoolDomainSpec#forProvider
   */
  readonly forProvider: UserPoolDomainSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserPoolDomainSpec#managementPolicies
   */
  readonly managementPolicies?: UserPoolDomainSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolDomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolDomainSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolDomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolDomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolDomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolDomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolDomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpec(obj: UserPoolDomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolDomainSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserPoolDomainSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserPoolDomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolDomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserPoolDomainSpecDeletionPolicy
 */
export enum UserPoolDomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * UserPoolDomainParameters defines the desired state of UserPoolDomain
 *
 * @schema UserPoolDomainSpecForProvider
 */
export interface UserPoolDomainSpecForProvider {
  /**
   * The configuration for a custom domain that hosts the sign-up and sign-in webpages for your application.
   * Provide this parameter only if you want to use a custom domain for your user pool. Otherwise, you can exclude this parameter and use the Amazon Cognito hosted domain instead.
   * For more information about the hosted domain and custom domains, see Configuring a User Pool Domain (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-assign-domain.html).
   *
   * @schema UserPoolDomainSpecForProvider#customDomainConfig
   */
  readonly customDomainConfig?: UserPoolDomainSpecForProviderCustomDomainConfig;

  /**
   * Region is which region the UserPoolDomain will be created.
   *
   * @schema UserPoolDomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool ID.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * UserPoolIDRef is a reference to an server instance.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserPoolDomainSpecForProviderUserPoolIdRef;

  /**
   * UserPoolIDSelector selects references to an server instance.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserPoolDomainSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProvider(obj: UserPoolDomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customDomainConfig': toJson_UserPoolDomainSpecForProviderCustomDomainConfig(obj.customDomainConfig),
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserPoolDomainSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserPoolDomainSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserPoolDomainSpecManagementPolicies
 */
export enum UserPoolDomainSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolDomainSpecProviderConfigRef
 */
export interface UserPoolDomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolDomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderConfigRef(obj: UserPoolDomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsTo
 */
export interface UserPoolDomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolDomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolDomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsTo(obj: UserPoolDomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolDomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolDomainSpecWriteConnectionSecretToRef
 */
export interface UserPoolDomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolDomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolDomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecWriteConnectionSecretToRef(obj: UserPoolDomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for a custom domain that hosts the sign-up and sign-in webpages for your application.
 * Provide this parameter only if you want to use a custom domain for your user pool. Otherwise, you can exclude this parameter and use the Amazon Cognito hosted domain instead.
 * For more information about the hosted domain and custom domains, see Configuring a User Pool Domain (https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-assign-domain.html).
 *
 * @schema UserPoolDomainSpecForProviderCustomDomainConfig
 */
export interface UserPoolDomainSpecForProviderCustomDomainConfig {
  /**
   * @schema UserPoolDomainSpecForProviderCustomDomainConfig#certificateARN
   */
  readonly certificateArn?: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderCustomDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderCustomDomainConfig(obj: UserPoolDomainSpecForProviderCustomDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateARN': obj.certificateArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDRef is a reference to an server instance.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRef
 */
export interface UserPoolDomainSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdRef(obj: UserPoolDomainSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolIDSelector selects references to an server instance.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelector
 */
export interface UserPoolDomainSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdSelector(obj: UserPoolDomainSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicy
 */
export interface UserPoolDomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderConfigRefPolicy(obj: UserPoolDomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRef(obj: UserPoolDomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToMetadata(obj: UserPoolDomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy
 */
export interface UserPoolDomainSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdRefPolicy(obj: UserPoolDomainSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy(obj: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolDomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolDomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

