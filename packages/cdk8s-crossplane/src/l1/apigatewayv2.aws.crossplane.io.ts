// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * API is the Schema for the APIS API
 *
 * @schema API
 */
export class Api extends ApiObject {
  /**
   * Returns the apiVersion and kind for "API"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'API',
  }

  /**
   * Renders a Kubernetes manifest for "API".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiProps): any {
    return {
      ...Api.GVK,
      ...toJson_ApiProps(props),
    };
  }

  /**
   * Defines a "API" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiProps) {
    super(scope, id, {
      ...Api.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Api.GVK,
      ...toJson_ApiProps(resolved),
    };
  }
}

/**
 * API is the Schema for the APIS API
 *
 * @schema API
 */
export interface ApiProps {
  /**
   * @schema API#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APISpec defines the desired state of API
   *
   * @schema API#spec
   */
  readonly spec: ApiSpec;

}

/**
 * Converts an object of type 'ApiProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiProps(obj: ApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISpec defines the desired state of API
 *
 * @schema ApiSpec
 */
export interface ApiSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiSpecDeletionPolicy;

  /**
   * APIParameters defines the desired state of API
   *
   * @schema ApiSpec#forProvider
   */
  readonly forProvider: ApiSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApiSpec#managementPolicies
   */
  readonly managementPolicies?: ApiSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpec(obj: ApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApiSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApiSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiSpecDeletionPolicy
 */
export enum ApiSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * APIParameters defines the desired state of API
 *
 * @schema ApiSpecForProvider
 */
export interface ApiSpecForProvider {
  /**
   * @schema ApiSpecForProvider#apiKeySelectionExpression
   */
  readonly apiKeySelectionExpression?: string;

  /**
   * @schema ApiSpecForProvider#corsConfiguration
   */
  readonly corsConfiguration?: ApiSpecForProviderCorsConfiguration;

  /**
   * @schema ApiSpecForProvider#credentialsARN
   */
  readonly credentialsArn?: string;

  /**
   * @schema ApiSpecForProvider#description
   */
  readonly description?: string;

  /**
   * @schema ApiSpecForProvider#disableExecuteAPIEndpoint
   */
  readonly disableExecuteApiEndpoint?: boolean;

  /**
   * @schema ApiSpecForProvider#disableSchemaValidation
   */
  readonly disableSchemaValidation?: boolean;

  /**
   * @schema ApiSpecForProvider#name
   */
  readonly name: string;

  /**
   * @schema ApiSpecForProvider#protocolType
   */
  readonly protocolType: string;

  /**
   * Region is which region the API will be created.
   *
   * @schema ApiSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema ApiSpecForProvider#routeKey
   */
  readonly routeKey?: string;

  /**
   * @schema ApiSpecForProvider#routeSelectionExpression
   */
  readonly routeSelectionExpression?: string;

  /**
   * @schema ApiSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * @schema ApiSpecForProvider#target
   */
  readonly target?: string;

  /**
   * @schema ApiSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApiSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecForProvider(obj: ApiSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySelectionExpression': obj.apiKeySelectionExpression,
    'corsConfiguration': toJson_ApiSpecForProviderCorsConfiguration(obj.corsConfiguration),
    'credentialsARN': obj.credentialsArn,
    'description': obj.description,
    'disableExecuteAPIEndpoint': obj.disableExecuteApiEndpoint,
    'disableSchemaValidation': obj.disableSchemaValidation,
    'name': obj.name,
    'protocolType': obj.protocolType,
    'region': obj.region,
    'routeKey': obj.routeKey,
    'routeSelectionExpression': obj.routeSelectionExpression,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'target': obj.target,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApiSpecManagementPolicies
 */
export enum ApiSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiSpecProviderConfigRef
 */
export interface ApiSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiSpecProviderConfigRef#policy
   */
  readonly policy?: ApiSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderConfigRef(obj: ApiSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiSpecPublishConnectionDetailsTo
 */
export interface ApiSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsTo(obj: ApiSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiSpecWriteConnectionSecretToRef
 */
export interface ApiSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecWriteConnectionSecretToRef(obj: ApiSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApiSpecForProviderCorsConfiguration
 */
export interface ApiSpecForProviderCorsConfiguration {
  /**
   * @schema ApiSpecForProviderCorsConfiguration#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Represents a collection of allowed headers. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Represents a collection of methods. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Represents a collection of origins. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * Represents a collection of allowed headers. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProviderCorsConfiguration#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * An integer with a value between -1 and 86400. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProviderCorsConfiguration#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ApiSpecForProviderCorsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecForProviderCorsConfiguration(obj: ApiSpecForProviderCorsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiSpecProviderConfigRefPolicy
 */
export interface ApiSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderConfigRefPolicy(obj: ApiSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToConfigRef(obj: ApiSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiSpecPublishConnectionDetailsToMetadata
 */
export interface ApiSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToMetadata(obj: ApiSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiSpecProviderConfigRefPolicyResolution
 */
export enum ApiSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiSpecProviderConfigRefPolicyResolve
 */
export enum ApiSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * APIMapping is the Schema for the APIMappings API
 *
 * @schema APIMapping
 */
export class ApiMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'APIMapping',
  }

  /**
   * Renders a Kubernetes manifest for "APIMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiMappingProps): any {
    return {
      ...ApiMapping.GVK,
      ...toJson_ApiMappingProps(props),
    };
  }

  /**
   * Defines a "APIMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiMappingProps) {
    super(scope, id, {
      ...ApiMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiMapping.GVK,
      ...toJson_ApiMappingProps(resolved),
    };
  }
}

/**
 * APIMapping is the Schema for the APIMappings API
 *
 * @schema APIMapping
 */
export interface ApiMappingProps {
  /**
   * @schema APIMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIMappingSpec defines the desired state of APIMapping
   *
   * @schema APIMapping#spec
   */
  readonly spec: ApiMappingSpec;

}

/**
 * Converts an object of type 'ApiMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingProps(obj: ApiMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIMappingSpec defines the desired state of APIMapping
 *
 * @schema ApiMappingSpec
 */
export interface ApiMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiMappingSpecDeletionPolicy;

  /**
   * APIMappingParameters defines the desired state of APIMapping
   *
   * @schema ApiMappingSpec#forProvider
   */
  readonly forProvider: ApiMappingSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApiMappingSpec#managementPolicies
   */
  readonly managementPolicies?: ApiMappingSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiMappingSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpec(obj: ApiMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiMappingSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApiMappingSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApiMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiMappingSpecDeletionPolicy
 */
export enum ApiMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * APIMappingParameters defines the desired state of APIMapping
 *
 * @schema ApiMappingSpecForProvider
 */
export interface ApiMappingSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema ApiMappingSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema ApiMappingSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ApiMappingSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema ApiMappingSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ApiMappingSpecForProviderApiIdSelector;

  /**
   * @schema ApiMappingSpecForProvider#apiMappingKey
   */
  readonly apiMappingKey?: string;

  /**
   * DomainName is the DomainName for the DomainName.
   *
   * @schema ApiMappingSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * DomainNameRef is a reference to a DomainName used to set the DomainName.
   *
   * @schema ApiMappingSpecForProvider#domainNameRef
   */
  readonly domainNameRef?: ApiMappingSpecForProviderDomainNameRef;

  /**
   * DomainNameSelector selects references to DomainName used to set the DomainName.
   *
   * @schema ApiMappingSpecForProvider#domainNameSelector
   */
  readonly domainNameSelector?: ApiMappingSpecForProviderDomainNameSelector;

  /**
   * Region is which region the APIMapping will be created.
   *
   * @schema ApiMappingSpecForProvider#region
   */
  readonly region: string;

  /**
   * Stage is the name for the Stage.
   *
   * @schema ApiMappingSpecForProvider#stage
   */
  readonly stage?: string;

  /**
   * StageDRef is a reference to an Stage used to set the Stage.
   *
   * @schema ApiMappingSpecForProvider#stageRef
   */
  readonly stageRef?: ApiMappingSpecForProviderStageRef;

  /**
   * StageSelector selects references to Stage used to set the Stage.
   *
   * @schema ApiMappingSpecForProvider#stageSelector
   */
  readonly stageSelector?: ApiMappingSpecForProviderStageSelector;

}

/**
 * Converts an object of type 'ApiMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProvider(obj: ApiMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ApiMappingSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ApiMappingSpecForProviderApiIdSelector(obj.apiIdSelector),
    'apiMappingKey': obj.apiMappingKey,
    'domainName': obj.domainName,
    'domainNameRef': toJson_ApiMappingSpecForProviderDomainNameRef(obj.domainNameRef),
    'domainNameSelector': toJson_ApiMappingSpecForProviderDomainNameSelector(obj.domainNameSelector),
    'region': obj.region,
    'stage': obj.stage,
    'stageRef': toJson_ApiMappingSpecForProviderStageRef(obj.stageRef),
    'stageSelector': toJson_ApiMappingSpecForProviderStageSelector(obj.stageSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApiMappingSpecManagementPolicies
 */
export enum ApiMappingSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiMappingSpecProviderConfigRef
 */
export interface ApiMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecProviderConfigRef#policy
   */
  readonly policy?: ApiMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderConfigRef(obj: ApiMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsTo
 */
export interface ApiMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsTo(obj: ApiMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiMappingSpecWriteConnectionSecretToRef
 */
export interface ApiMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecWriteConnectionSecretToRef(obj: ApiMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema ApiMappingSpecForProviderApiIdRef
 */
export interface ApiMappingSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderApiIdRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdRef(obj: ApiMappingSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema ApiMappingSpecForProviderApiIdSelector
 */
export interface ApiMappingSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdSelector(obj: ApiMappingSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameRef is a reference to a DomainName used to set the DomainName.
 *
 * @schema ApiMappingSpecForProviderDomainNameRef
 */
export interface ApiMappingSpecForProviderDomainNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderDomainNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderDomainNameRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderDomainNameRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameRef(obj: ApiMappingSpecForProviderDomainNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderDomainNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameSelector selects references to DomainName used to set the DomainName.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelector
 */
export interface ApiMappingSpecForProviderDomainNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderDomainNameSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameSelector(obj: ApiMappingSpecForProviderDomainNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderDomainNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageDRef is a reference to an Stage used to set the Stage.
 *
 * @schema ApiMappingSpecForProviderStageRef
 */
export interface ApiMappingSpecForProviderStageRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderStageRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderStageRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderStageRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageRef(obj: ApiMappingSpecForProviderStageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderStageRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageSelector selects references to Stage used to set the Stage.
 *
 * @schema ApiMappingSpecForProviderStageSelector
 */
export interface ApiMappingSpecForProviderStageSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderStageSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderStageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderStageSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderStageSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageSelector(obj: ApiMappingSpecForProviderStageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderStageSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicy
 */
export interface ApiMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderConfigRefPolicy(obj: ApiMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToConfigRef(obj: ApiMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToMetadata
 */
export interface ApiMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToMetadata(obj: ApiMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicy
 */
export interface ApiMappingSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdRefPolicy(obj: ApiMappingSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicy
 */
export interface ApiMappingSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdSelectorPolicy(obj: ApiMappingSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicy
 */
export interface ApiMappingSpecForProviderDomainNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderDomainNameRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderDomainNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderDomainNameRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderDomainNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameRefPolicy(obj: ApiMappingSpecForProviderDomainNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy
 */
export interface ApiMappingSpecForProviderDomainNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderDomainNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderDomainNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameSelectorPolicy(obj: ApiMappingSpecForProviderDomainNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicy
 */
export interface ApiMappingSpecForProviderStageRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderStageRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderStageRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderStageRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderStageRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageRefPolicy(obj: ApiMappingSpecForProviderStageRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicy
 */
export interface ApiMappingSpecForProviderStageSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderStageSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderStageSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderStageSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderStageSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageSelectorPolicy(obj: ApiMappingSpecForProviderStageSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicyResolution
 */
export enum ApiMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicyResolve
 */
export enum ApiMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicyResolution
 */
export enum ApiMappingSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicyResolve
 */
export enum ApiMappingSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicyResolution
 */
export enum ApiMappingSpecForProviderDomainNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicyResolve
 */
export enum ApiMappingSpecForProviderDomainNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderDomainNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderDomainNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicyResolution
 */
export enum ApiMappingSpecForProviderStageRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicyResolve
 */
export enum ApiMappingSpecForProviderStageRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderStageSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderStageSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Authorizer is the Schema for the Authorizers API
 *
 * @schema Authorizer
 */
export class Authorizer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Authorizer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Authorizer',
  }

  /**
   * Renders a Kubernetes manifest for "Authorizer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AuthorizerProps): any {
    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(props),
    };
  }

  /**
   * Defines a "Authorizer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AuthorizerProps) {
    super(scope, id, {
      ...Authorizer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(resolved),
    };
  }
}

/**
 * Authorizer is the Schema for the Authorizers API
 *
 * @schema Authorizer
 */
export interface AuthorizerProps {
  /**
   * @schema Authorizer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AuthorizerSpec defines the desired state of Authorizer
   *
   * @schema Authorizer#spec
   */
  readonly spec: AuthorizerSpec;

}

/**
 * Converts an object of type 'AuthorizerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerProps(obj: AuthorizerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AuthorizerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerSpec defines the desired state of Authorizer
 *
 * @schema AuthorizerSpec
 */
export interface AuthorizerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AuthorizerSpecDeletionPolicy;

  /**
   * AuthorizerParameters defines the desired state of Authorizer
   *
   * @schema AuthorizerSpec#forProvider
   */
  readonly forProvider: AuthorizerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AuthorizerSpec#managementPolicies
   */
  readonly managementPolicies?: AuthorizerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AuthorizerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AuthorizerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AuthorizerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AuthorizerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AuthorizerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AuthorizerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AuthorizerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpec(obj: AuthorizerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AuthorizerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AuthorizerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AuthorizerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AuthorizerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecDeletionPolicy
 */
export enum AuthorizerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AuthorizerParameters defines the desired state of Authorizer
 *
 * @schema AuthorizerSpecForProvider
 */
export interface AuthorizerSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema AuthorizerSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema AuthorizerSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: AuthorizerSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema AuthorizerSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: AuthorizerSpecForProviderApiIdSelector;

  /**
   * @schema AuthorizerSpecForProvider#authorizerCredentialsARN
   */
  readonly authorizerCredentialsArn?: string;

  /**
   * @schema AuthorizerSpecForProvider#authorizerPayloadFormatVersion
   */
  readonly authorizerPayloadFormatVersion?: string;

  /**
   * @schema AuthorizerSpecForProvider#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * @schema AuthorizerSpecForProvider#authorizerType
   */
  readonly authorizerType: string;

  /**
   * @schema AuthorizerSpecForProvider#authorizerURI
   */
  readonly authorizerUri?: string;

  /**
   * @schema AuthorizerSpecForProvider#enableSimpleResponses
   */
  readonly enableSimpleResponses?: boolean;

  /**
   * @schema AuthorizerSpecForProvider#identitySource
   */
  readonly identitySource: string[];

  /**
   * @schema AuthorizerSpecForProvider#identityValidationExpression
   */
  readonly identityValidationExpression?: string;

  /**
   * @schema AuthorizerSpecForProvider#jwtConfiguration
   */
  readonly jwtConfiguration?: AuthorizerSpecForProviderJwtConfiguration;

  /**
   * @schema AuthorizerSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the Authorizer will be created.
   *
   * @schema AuthorizerSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProvider(obj: AuthorizerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_AuthorizerSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_AuthorizerSpecForProviderApiIdSelector(obj.apiIdSelector),
    'authorizerCredentialsARN': obj.authorizerCredentialsArn,
    'authorizerPayloadFormatVersion': obj.authorizerPayloadFormatVersion,
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerType': obj.authorizerType,
    'authorizerURI': obj.authorizerUri,
    'enableSimpleResponses': obj.enableSimpleResponses,
    'identitySource': obj.identitySource?.map(y => y),
    'identityValidationExpression': obj.identityValidationExpression,
    'jwtConfiguration': toJson_AuthorizerSpecForProviderJwtConfiguration(obj.jwtConfiguration),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AuthorizerSpecManagementPolicies
 */
export enum AuthorizerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AuthorizerSpecProviderConfigRef
 */
export interface AuthorizerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderConfigRef#policy
   */
  readonly policy?: AuthorizerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRef(obj: AuthorizerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsTo
 */
export interface AuthorizerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AuthorizerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AuthorizerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsTo(obj: AuthorizerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AuthorizerSpecWriteConnectionSecretToRef
 */
export interface AuthorizerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AuthorizerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecWriteConnectionSecretToRef(obj: AuthorizerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema AuthorizerSpecForProviderApiIdRef
 */
export interface AuthorizerSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderApiIdRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdRef(obj: AuthorizerSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema AuthorizerSpecForProviderApiIdSelector
 */
export interface AuthorizerSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdSelector(obj: AuthorizerSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AuthorizerSpecForProviderJwtConfiguration
 */
export interface AuthorizerSpecForProviderJwtConfiguration {
  /**
   * @schema AuthorizerSpecForProviderJwtConfiguration#audience
   */
  readonly audience?: string[];

  /**
   * A string representation of a URI with a length between [1-2048].
   *
   * @schema AuthorizerSpecForProviderJwtConfiguration#issuer
   */
  readonly issuer?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderJwtConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderJwtConfiguration(obj: AuthorizerSpecForProviderJwtConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience?.map(y => y),
    'issuer': obj.issuer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicy
 */
export interface AuthorizerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRefPolicy(obj: AuthorizerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj: AuthorizerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToMetadata
 */
export interface AuthorizerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj: AuthorizerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicy
 */
export interface AuthorizerSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdRefPolicy(obj: AuthorizerSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicy
 */
export interface AuthorizerSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdSelectorPolicy(obj: AuthorizerSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolution
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolve
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicyResolution
 */
export enum AuthorizerSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicyResolve
 */
export enum AuthorizerSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Deployment is the Schema for the Deployments API
 *
 * @schema Deployment
 */
export class Deployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Deployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Deployment',
  }

  /**
   * Renders a Kubernetes manifest for "Deployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentProps): any {
    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(props),
    };
  }

  /**
   * Defines a "Deployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentProps) {
    super(scope, id, {
      ...Deployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(resolved),
    };
  }
}

/**
 * Deployment is the Schema for the Deployments API
 *
 * @schema Deployment
 */
export interface DeploymentProps {
  /**
   * @schema Deployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentSpec defines the desired state of Deployment
   *
   * @schema Deployment#spec
   */
  readonly spec: DeploymentSpec;

}

/**
 * Converts an object of type 'DeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentProps(obj: DeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentSpec defines the desired state of Deployment
 *
 * @schema DeploymentSpec
 */
export interface DeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentSpecDeletionPolicy;

  /**
   * DeploymentParameters defines the desired state of Deployment
   *
   * @schema DeploymentSpec#forProvider
   */
  readonly forProvider: DeploymentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeploymentSpec#managementPolicies
   */
  readonly managementPolicies?: DeploymentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpec(obj: DeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecDeletionPolicy
 */
export enum DeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DeploymentParameters defines the desired state of Deployment
 *
 * @schema DeploymentSpecForProvider
 */
export interface DeploymentSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema DeploymentSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema DeploymentSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: DeploymentSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema DeploymentSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: DeploymentSpecForProviderApiIdSelector;

  /**
   * @schema DeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is which region the Deployment will be created.
   *
   * @schema DeploymentSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema DeploymentSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * StageNameRef is a reference to an Stage used to set the StageName.
   *
   * @schema DeploymentSpecForProvider#stageNameRef
   */
  readonly stageNameRef?: DeploymentSpecForProviderStageNameRef;

  /**
   * StageNameSelector selects references to Stage used to set the StageName.
   *
   * @schema DeploymentSpecForProvider#stageNameSelector
   */
  readonly stageNameSelector?: DeploymentSpecForProviderStageNameSelector;

}

/**
 * Converts an object of type 'DeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProvider(obj: DeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_DeploymentSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_DeploymentSpecForProviderApiIdSelector(obj.apiIdSelector),
    'description': obj.description,
    'region': obj.region,
    'stageName': obj.stageName,
    'stageNameRef': toJson_DeploymentSpecForProviderStageNameRef(obj.stageNameRef),
    'stageNameSelector': toJson_DeploymentSpecForProviderStageNameSelector(obj.stageNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeploymentSpecManagementPolicies
 */
export enum DeploymentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentSpecProviderConfigRef
 */
export interface DeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRef(obj: DeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentSpecPublishConnectionDetailsTo
 */
export interface DeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsTo(obj: DeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentSpecWriteConnectionSecretToRef
 */
export interface DeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecWriteConnectionSecretToRef(obj: DeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema DeploymentSpecForProviderApiIdRef
 */
export interface DeploymentSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderApiIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdRef(obj: DeploymentSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema DeploymentSpecForProviderApiIdSelector
 */
export interface DeploymentSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdSelector(obj: DeploymentSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageNameRef is a reference to an Stage used to set the StageName.
 *
 * @schema DeploymentSpecForProviderStageNameRef
 */
export interface DeploymentSpecForProviderStageNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderStageNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderStageNameRef#policy
   */
  readonly policy?: DeploymentSpecForProviderStageNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderStageNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderStageNameRef(obj: DeploymentSpecForProviderStageNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderStageNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageNameSelector selects references to Stage used to set the StageName.
 *
 * @schema DeploymentSpecForProviderStageNameSelector
 */
export interface DeploymentSpecForProviderStageNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderStageNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderStageNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderStageNameSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderStageNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderStageNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderStageNameSelector(obj: DeploymentSpecForProviderStageNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderStageNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderConfigRefPolicy
 */
export interface DeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRefPolicy(obj: DeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj: DeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj: DeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicy
 */
export interface DeploymentSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdRefPolicy(obj: DeploymentSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicy
 */
export interface DeploymentSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdSelectorPolicy(obj: DeploymentSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderStageNameRefPolicy
 */
export interface DeploymentSpecForProviderStageNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderStageNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderStageNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderStageNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderStageNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderStageNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderStageNameRefPolicy(obj: DeploymentSpecForProviderStageNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderStageNameSelectorPolicy
 */
export interface DeploymentSpecForProviderStageNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderStageNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderStageNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderStageNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderStageNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderStageNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderStageNameSelectorPolicy(obj: DeploymentSpecForProviderStageNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderStageNameRefPolicyResolution
 */
export enum DeploymentSpecForProviderStageNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderStageNameRefPolicyResolve
 */
export enum DeploymentSpecForProviderStageNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderStageNameSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderStageNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderStageNameSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderStageNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainName is the Schema for the DomainNames API
 *
 * @schema DomainName
 */
export class DomainName extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainName"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'DomainName',
  }

  /**
   * Renders a Kubernetes manifest for "DomainName".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainNameProps): any {
    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(props),
    };
  }

  /**
   * Defines a "DomainName" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainNameProps) {
    super(scope, id, {
      ...DomainName.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(resolved),
    };
  }
}

/**
 * DomainName is the Schema for the DomainNames API
 *
 * @schema DomainName
 */
export interface DomainNameProps {
  /**
   * @schema DomainName#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainNameSpec defines the desired state of DomainName
   *
   * @schema DomainName#spec
   */
  readonly spec: DomainNameSpec;

}

/**
 * Converts an object of type 'DomainNameProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameProps(obj: DomainNameProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainNameSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameSpec defines the desired state of DomainName
 *
 * @schema DomainNameSpec
 */
export interface DomainNameSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainNameSpecDeletionPolicy;

  /**
   * DomainNameParameters defines the desired state of DomainName
   *
   * @schema DomainNameSpec#forProvider
   */
  readonly forProvider: DomainNameSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainNameSpec#managementPolicies
   */
  readonly managementPolicies?: DomainNameSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainNameSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainNameSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainNameSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainNameSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainNameSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainNameSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainNameSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpec(obj: DomainNameSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainNameSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainNameSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainNameSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainNameSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecDeletionPolicy
 */
export enum DomainNameSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DomainNameParameters defines the desired state of DomainName
 *
 * @schema DomainNameSpecForProvider
 */
export interface DomainNameSpecForProvider {
  /**
   * @schema DomainNameSpecForProvider#domainNameConfigurations
   */
  readonly domainNameConfigurations?: DomainNameSpecForProviderDomainNameConfigurations[];

  /**
   * @schema DomainNameSpecForProvider#mutualTLSAuthentication
   */
  readonly mutualTlsAuthentication?: DomainNameSpecForProviderMutualTlsAuthentication;

  /**
   * Region is which region the DomainName will be created.
   *
   * @schema DomainNameSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema DomainNameSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DomainNameSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProvider(obj: DomainNameSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainNameConfigurations': obj.domainNameConfigurations?.map(y => toJson_DomainNameSpecForProviderDomainNameConfigurations(y)),
    'mutualTLSAuthentication': toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj.mutualTlsAuthentication),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainNameSpecManagementPolicies
 */
export enum DomainNameSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainNameSpecProviderConfigRef
 */
export interface DomainNameSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderConfigRef#policy
   */
  readonly policy?: DomainNameSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRef(obj: DomainNameSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainNameSpecPublishConnectionDetailsTo
 */
export interface DomainNameSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainNameSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainNameSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsTo(obj: DomainNameSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainNameSpecWriteConnectionSecretToRef
 */
export interface DomainNameSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainNameSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecWriteConnectionSecretToRef(obj: DomainNameSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderDomainNameConfigurations
 */
export interface DomainNameSpecForProviderDomainNameConfigurations {
  /**
   * @schema DomainNameSpecForProviderDomainNameConfigurations#apiGatewayDomainName
   */
  readonly apiGatewayDomainName?: string;

  /**
   * Represents an Amazon Resource Name (ARN).
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#certificateARN
   */
  readonly certificateArn?: string;

  /**
   * A string with a length between [1-128].
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#certificateName
   */
  readonly certificateName?: string;

  /**
   * @schema DomainNameSpecForProviderDomainNameConfigurations#certificateUploadDate
   */
  readonly certificateUploadDate?: Date;

  /**
   * The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#domainNameStatus
   */
  readonly domainNameStatus?: string;

  /**
   * @schema DomainNameSpecForProviderDomainNameConfigurations#domainNameStatusMessage
   */
  readonly domainNameStatusMessage?: string;

  /**
   * Represents an endpoint type.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#endpointType
   */
  readonly endpointType?: string;

  /**
   * @schema DomainNameSpecForProviderDomainNameConfigurations#hostedZoneID
   */
  readonly hostedZoneId?: string;

  /**
   * Represents an Amazon Resource Name (ARN).
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#ownershipVerificationCertificateARN
   */
  readonly ownershipVerificationCertificateArn?: string;

  /**
   * The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurations#securityPolicy
   */
  readonly securityPolicy?: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfigurations(obj: DomainNameSpecForProviderDomainNameConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGatewayDomainName': obj.apiGatewayDomainName,
    'certificateARN': obj.certificateArn,
    'certificateName': obj.certificateName,
    'certificateUploadDate': obj.certificateUploadDate?.toISOString(),
    'domainNameStatus': obj.domainNameStatus,
    'domainNameStatusMessage': obj.domainNameStatusMessage,
    'endpointType': obj.endpointType,
    'hostedZoneID': obj.hostedZoneId,
    'ownershipVerificationCertificateARN': obj.ownershipVerificationCertificateArn,
    'securityPolicy': obj.securityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderMutualTlsAuthentication
 */
export interface DomainNameSpecForProviderMutualTlsAuthentication {
  /**
   * A string representation of a URI with a length between [1-2048].
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreURI
   */
  readonly truststoreUri?: string;

  /**
   * A string with a length between [1-64].
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreVersion
   */
  readonly truststoreVersion?: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderMutualTlsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj: DomainNameSpecForProviderMutualTlsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'truststoreURI': obj.truststoreUri,
    'truststoreVersion': obj.truststoreVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderConfigRefPolicy
 */
export interface DomainNameSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRefPolicy(obj: DomainNameSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj: DomainNameSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToMetadata
 */
export interface DomainNameSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj: DomainNameSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolution
 */
export enum DomainNameSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolve
 */
export enum DomainNameSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Integration is the Schema for the Integrations API
 *
 * @schema Integration
 */
export class Integration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Integration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Integration',
  }

  /**
   * Renders a Kubernetes manifest for "Integration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationProps): any {
    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(props),
    };
  }

  /**
   * Defines a "Integration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationProps) {
    super(scope, id, {
      ...Integration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(resolved),
    };
  }
}

/**
 * Integration is the Schema for the Integrations API
 *
 * @schema Integration
 */
export interface IntegrationProps {
  /**
   * @schema Integration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationSpec defines the desired state of Integration
   *
   * @schema Integration#spec
   */
  readonly spec: IntegrationSpec;

}

/**
 * Converts an object of type 'IntegrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationProps(obj: IntegrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationSpec defines the desired state of Integration
 *
 * @schema IntegrationSpec
 */
export interface IntegrationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationSpecDeletionPolicy;

  /**
   * IntegrationParameters defines the desired state of Integration
   *
   * @schema IntegrationSpec#forProvider
   */
  readonly forProvider: IntegrationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IntegrationSpec#managementPolicies
   */
  readonly managementPolicies?: IntegrationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpec(obj: IntegrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IntegrationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IntegrationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecDeletionPolicy
 */
export enum IntegrationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IntegrationParameters defines the desired state of Integration
 *
 * @schema IntegrationSpecForProvider
 */
export interface IntegrationSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema IntegrationSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema IntegrationSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: IntegrationSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema IntegrationSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: IntegrationSpecForProviderApiIdSelector;

  /**
   * @schema IntegrationSpecForProvider#connectionID
   */
  readonly connectionId?: string;

  /**
   * @schema IntegrationSpecForProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   * @schema IntegrationSpecForProvider#contentHandlingStrategy
   */
  readonly contentHandlingStrategy?: string;

  /**
   * @schema IntegrationSpecForProvider#credentialsARN
   */
  readonly credentialsArn?: string;

  /**
   * @schema IntegrationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * @schema IntegrationSpecForProvider#integrationMethod
   */
  readonly integrationMethod?: string;

  /**
   * @schema IntegrationSpecForProvider#integrationSubtype
   */
  readonly integrationSubtype?: string;

  /**
   * @schema IntegrationSpecForProvider#integrationType
   */
  readonly integrationType: string;

  /**
   * @schema IntegrationSpecForProvider#integrationURI
   */
  readonly integrationUri?: string;

  /**
   * @schema IntegrationSpecForProvider#passthroughBehavior
   */
  readonly passthroughBehavior?: string;

  /**
   * @schema IntegrationSpecForProvider#payloadFormatVersion
   */
  readonly payloadFormatVersion?: string;

  /**
   * Region is which region the Integration will be created.
   *
   * @schema IntegrationSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema IntegrationSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: string };

  /**
   * @schema IntegrationSpecForProvider#requestTemplates
   */
  readonly requestTemplates?: { [key: string]: string };

  /**
   * Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599.
   *
   * @schema IntegrationSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: IntegrationSpecForProviderResponseParameters };

  /**
   * @schema IntegrationSpecForProvider#templateSelectionExpression
   */
  readonly templateSelectionExpression?: string;

  /**
   * @schema IntegrationSpecForProvider#timeoutInMillis
   */
  readonly timeoutInMillis?: number;

  /**
   * @schema IntegrationSpecForProvider#tlsConfig
   */
  readonly tlsConfig?: IntegrationSpecForProviderTlsConfig;

}

/**
 * Converts an object of type 'IntegrationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProvider(obj: IntegrationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_IntegrationSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_IntegrationSpecForProviderApiIdSelector(obj.apiIdSelector),
    'connectionID': obj.connectionId,
    'connectionType': obj.connectionType,
    'contentHandlingStrategy': obj.contentHandlingStrategy,
    'credentialsARN': obj.credentialsArn,
    'description': obj.description,
    'integrationMethod': obj.integrationMethod,
    'integrationSubtype': obj.integrationSubtype,
    'integrationType': obj.integrationType,
    'integrationURI': obj.integrationUri,
    'passthroughBehavior': obj.passthroughBehavior,
    'payloadFormatVersion': obj.payloadFormatVersion,
    'region': obj.region,
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestTemplates': ((obj.requestTemplates) === undefined) ? undefined : (Object.entries(obj.requestTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_IntegrationSpecForProviderResponseParameters(i[1]) }), {})),
    'templateSelectionExpression': obj.templateSelectionExpression,
    'timeoutInMillis': obj.timeoutInMillis,
    'tlsConfig': toJson_IntegrationSpecForProviderTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IntegrationSpecManagementPolicies
 */
export enum IntegrationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationSpecProviderConfigRef
 */
export interface IntegrationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRef(obj: IntegrationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationSpecPublishConnectionDetailsTo
 */
export interface IntegrationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsTo(obj: IntegrationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationSpecWriteConnectionSecretToRef
 */
export interface IntegrationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecWriteConnectionSecretToRef(obj: IntegrationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema IntegrationSpecForProviderApiIdRef
 */
export interface IntegrationSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderApiIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdRef(obj: IntegrationSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema IntegrationSpecForProviderApiIdSelector
 */
export interface IntegrationSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdSelector(obj: IntegrationSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseParameter represents a single response parameter transform operation.
 *
 * @schema IntegrationSpecForProviderResponseParameters
 */
export interface IntegrationSpecForProviderResponseParameters {
  /**
   * HeaderEntries is the array of header changes you'd like to make. For details, see Transforming API responses in https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html
   *
   * @schema IntegrationSpecForProviderResponseParameters#headerEntry
   */
  readonly headerEntry?: IntegrationSpecForProviderResponseParametersHeaderEntry[];

  /**
   * OverwriteStatusCode is the status code you'd like the response to have, overwriting the one in the original response. For details, see Transforming API responses in https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html
   *
   * @schema IntegrationSpecForProviderResponseParameters#overwriteStatusCodeEntry
   */
  readonly overwriteStatusCodeEntry?: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResponseParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResponseParameters(obj: IntegrationSpecForProviderResponseParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerEntry': obj.headerEntry?.map(y => toJson_IntegrationSpecForProviderResponseParametersHeaderEntry(y)),
    'overwriteStatusCodeEntry': obj.overwriteStatusCodeEntry,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecForProviderTlsConfig
 */
export interface IntegrationSpecForProviderTlsConfig {
  /**
   * A string with a length between [1-512].
   *
   * @schema IntegrationSpecForProviderTlsConfig#serverNameToVerify
   */
  readonly serverNameToVerify?: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderTlsConfig(obj: IntegrationSpecForProviderTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serverNameToVerify': obj.serverNameToVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderConfigRefPolicy
 */
export interface IntegrationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRefPolicy(obj: IntegrationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj: IntegrationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj: IntegrationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicy
 */
export interface IntegrationSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdRefPolicy(obj: IntegrationSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicy
 */
export interface IntegrationSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdSelectorPolicy(obj: IntegrationSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderEntry can be used to represent a single header transform.
 *
 * @schema IntegrationSpecForProviderResponseParametersHeaderEntry
 */
export interface IntegrationSpecForProviderResponseParametersHeaderEntry {
  /**
   * Name is the name of the header.
   *
   * @schema IntegrationSpecForProviderResponseParametersHeaderEntry#name
   */
  readonly name: string;

  /**
   * Operation is what you'd like to do with given header. Only append, overwrite and remove values are supported.
   *
   * @schema IntegrationSpecForProviderResponseParametersHeaderEntry#operation
   */
  readonly operation: IntegrationSpecForProviderResponseParametersHeaderEntryOperation;

  /**
   * Value is the new value.
   *
   * @schema IntegrationSpecForProviderResponseParametersHeaderEntry#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResponseParametersHeaderEntry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResponseParametersHeaderEntry(obj: IntegrationSpecForProviderResponseParametersHeaderEntry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'operation': obj.operation,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Operation is what you'd like to do with given header. Only append, overwrite and remove values are supported.
 *
 * @schema IntegrationSpecForProviderResponseParametersHeaderEntryOperation
 */
export enum IntegrationSpecForProviderResponseParametersHeaderEntryOperation {
  /** append */
  APPEND = "append",
  /** overwrite */
  OVERWRITE = "overwrite",
  /** remove */
  REMOVE = "remove",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IntegrationResponse is the Schema for the IntegrationResponses API
 *
 * @schema IntegrationResponse
 */
export class IntegrationResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IntegrationResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'IntegrationResponse',
  }

  /**
   * Renders a Kubernetes manifest for "IntegrationResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationResponseProps): any {
    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(props),
    };
  }

  /**
   * Defines a "IntegrationResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationResponseProps) {
    super(scope, id, {
      ...IntegrationResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(resolved),
    };
  }
}

/**
 * IntegrationResponse is the Schema for the IntegrationResponses API
 *
 * @schema IntegrationResponse
 */
export interface IntegrationResponseProps {
  /**
   * @schema IntegrationResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationResponseSpec defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponse#spec
   */
  readonly spec: IntegrationResponseSpec;

}

/**
 * Converts an object of type 'IntegrationResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseProps(obj: IntegrationResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationResponseSpec defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpec
 */
export interface IntegrationResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationResponseSpecDeletionPolicy;

  /**
   * IntegrationResponseParameters defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponseSpec#forProvider
   */
  readonly forProvider: IntegrationResponseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IntegrationResponseSpec#managementPolicies
   */
  readonly managementPolicies?: IntegrationResponseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationResponseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpec(obj: IntegrationResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationResponseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IntegrationResponseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecDeletionPolicy
 */
export enum IntegrationResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * IntegrationResponseParameters defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpecForProvider
 */
export interface IntegrationResponseSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema IntegrationResponseSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema IntegrationResponseSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: IntegrationResponseSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema IntegrationResponseSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: IntegrationResponseSpecForProviderApiIdSelector;

  /**
   * @schema IntegrationResponseSpecForProvider#contentHandlingStrategy
   */
  readonly contentHandlingStrategy?: string;

  /**
   * IntegrationID is the ID for the Integration.
   *
   * @schema IntegrationResponseSpecForProvider#integrationId
   */
  readonly integrationId?: string;

  /**
   * IntegrationIDRef is a reference to an Integration used to set the IntegrationID.
   *
   * @schema IntegrationResponseSpecForProvider#integrationIdRef
   */
  readonly integrationIdRef?: IntegrationResponseSpecForProviderIntegrationIdRef;

  /**
   * IntegrationIDSelector selects references to Integration used to set the IntegrationID.
   *
   * @schema IntegrationResponseSpecForProvider#integrationIdSelector
   */
  readonly integrationIdSelector?: IntegrationResponseSpecForProviderIntegrationIdSelector;

  /**
   * @schema IntegrationResponseSpecForProvider#integrationResponseKey
   */
  readonly integrationResponseKey: string;

  /**
   * Region is which region the IntegrationResponse will be created.
   *
   * @schema IntegrationResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema IntegrationResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: string };

  /**
   * @schema IntegrationResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * @schema IntegrationResponseSpecForProvider#templateSelectionExpression
   */
  readonly templateSelectionExpression?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProvider(obj: IntegrationResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_IntegrationResponseSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_IntegrationResponseSpecForProviderApiIdSelector(obj.apiIdSelector),
    'contentHandlingStrategy': obj.contentHandlingStrategy,
    'integrationId': obj.integrationId,
    'integrationIdRef': toJson_IntegrationResponseSpecForProviderIntegrationIdRef(obj.integrationIdRef),
    'integrationIdSelector': toJson_IntegrationResponseSpecForProviderIntegrationIdSelector(obj.integrationIdSelector),
    'integrationResponseKey': obj.integrationResponseKey,
    'region': obj.region,
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateSelectionExpression': obj.templateSelectionExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IntegrationResponseSpecManagementPolicies
 */
export enum IntegrationResponseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationResponseSpecProviderConfigRef
 */
export interface IntegrationResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRef(obj: IntegrationResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsTo
 */
export interface IntegrationResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj: IntegrationResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationResponseSpecWriteConnectionSecretToRef
 */
export interface IntegrationResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj: IntegrationResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRef
 */
export interface IntegrationResponseSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdRef(obj: IntegrationResponseSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelector
 */
export interface IntegrationResponseSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdSelector(obj: IntegrationResponseSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationIDRef is a reference to an Integration used to set the IntegrationID.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRef
 */
export interface IntegrationResponseSpecForProviderIntegrationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderIntegrationIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdRef(obj: IntegrationResponseSpecForProviderIntegrationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderIntegrationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationIDSelector selects references to Integration used to set the IntegrationID.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelector
 */
export interface IntegrationResponseSpecForProviderIntegrationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdSelector(obj: IntegrationResponseSpecForProviderIntegrationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicy
 */
export interface IntegrationResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj: IntegrationResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj: IntegrationResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdRefPolicy(obj: IntegrationResponseSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdSelectorPolicy(obj: IntegrationResponseSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderIntegrationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdRefPolicy(obj: IntegrationResponseSpecForProviderIntegrationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy(obj: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Model is the Schema for the Models API
 *
 * @schema Model
 */
export class Model extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Model"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Model',
  }

  /**
   * Renders a Kubernetes manifest for "Model".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelProps): any {
    return {
      ...Model.GVK,
      ...toJson_ModelProps(props),
    };
  }

  /**
   * Defines a "Model" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelProps) {
    super(scope, id, {
      ...Model.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Model.GVK,
      ...toJson_ModelProps(resolved),
    };
  }
}

/**
 * Model is the Schema for the Models API
 *
 * @schema Model
 */
export interface ModelProps {
  /**
   * @schema Model#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelSpec defines the desired state of Model
   *
   * @schema Model#spec
   */
  readonly spec: ModelSpec;

}

/**
 * Converts an object of type 'ModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelProps(obj: ModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelSpec defines the desired state of Model
 *
 * @schema ModelSpec
 */
export interface ModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelSpecDeletionPolicy;

  /**
   * ModelParameters defines the desired state of Model
   *
   * @schema ModelSpec#forProvider
   */
  readonly forProvider: ModelSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ModelSpec#managementPolicies
   */
  readonly managementPolicies?: ModelSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpec(obj: ModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ModelSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecDeletionPolicy
 */
export enum ModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ModelParameters defines the desired state of Model
 *
 * @schema ModelSpecForProvider
 */
export interface ModelSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema ModelSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema ModelSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ModelSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema ModelSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ModelSpecForProviderApiIdSelector;

  /**
   * @schema ModelSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * @schema ModelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * @schema ModelSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the Model will be created.
   *
   * @schema ModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema ModelSpecForProvider#schema
   */
  readonly schema: string;

}

/**
 * Converts an object of type 'ModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProvider(obj: ModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ModelSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ModelSpecForProviderApiIdSelector(obj.apiIdSelector),
    'contentType': obj.contentType,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ModelSpecManagementPolicies
 */
export enum ModelSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelSpecProviderConfigRef
 */
export interface ModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderConfigRef#policy
   */
  readonly policy?: ModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRef(obj: ModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelSpecPublishConnectionDetailsTo
 */
export interface ModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsTo(obj: ModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelSpecWriteConnectionSecretToRef
 */
export interface ModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecWriteConnectionSecretToRef(obj: ModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema ModelSpecForProviderApiIdRef
 */
export interface ModelSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecForProviderApiIdRef#policy
   */
  readonly policy?: ModelSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdRef(obj: ModelSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema ModelSpecForProviderApiIdSelector
 */
export interface ModelSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ModelSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdSelector(obj: ModelSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderConfigRefPolicy
 */
export interface ModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRefPolicy(obj: ModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj: ModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelSpecPublishConnectionDetailsToMetadata
 */
export interface ModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToMetadata(obj: ModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecForProviderApiIdRefPolicy
 */
export interface ModelSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdRefPolicy(obj: ModelSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicy
 */
export interface ModelSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdSelectorPolicy(obj: ModelSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolution
 */
export enum ModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolve
 */
export enum ModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderApiIdRefPolicyResolution
 */
export enum ModelSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderApiIdRefPolicyResolve
 */
export enum ModelSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ModelSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ModelSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Route is the Schema for the Routes API
 *
 * @schema Route
 */
export class Route extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Route"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Route',
  }

  /**
   * Renders a Kubernetes manifest for "Route".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteProps): any {
    return {
      ...Route.GVK,
      ...toJson_RouteProps(props),
    };
  }

  /**
   * Defines a "Route" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteProps) {
    super(scope, id, {
      ...Route.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route.GVK,
      ...toJson_RouteProps(resolved),
    };
  }
}

/**
 * Route is the Schema for the Routes API
 *
 * @schema Route
 */
export interface RouteProps {
  /**
   * @schema Route#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteSpec defines the desired state of Route
   *
   * @schema Route#spec
   */
  readonly spec: RouteSpec;

}

/**
 * Converts an object of type 'RouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteProps(obj: RouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteSpec defines the desired state of Route
 *
 * @schema RouteSpec
 */
export interface RouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteSpecDeletionPolicy;

  /**
   * RouteParameters defines the desired state of Route
   *
   * @schema RouteSpec#forProvider
   */
  readonly forProvider: RouteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteSpec#managementPolicies
   */
  readonly managementPolicies?: RouteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpec(obj: RouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteSpecDeletionPolicy
 */
export enum RouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RouteParameters defines the desired state of Route
 *
 * @schema RouteSpecForProvider
 */
export interface RouteSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema RouteSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema RouteSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: RouteSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema RouteSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: RouteSpecForProviderApiIdSelector;

  /**
   * @schema RouteSpecForProvider#apiKeyRequired
   */
  readonly apiKeyRequired?: boolean;

  /**
   * @schema RouteSpecForProvider#authorizationScopes
   */
  readonly authorizationScopes?: string[];

  /**
   * @schema RouteSpecForProvider#authorizationType
   */
  readonly authorizationType?: string;

  /**
   * @schema RouteSpecForProvider#authorizerID
   */
  readonly authorizerId?: string;

  /**
   * AuthorizerIDRef is a reference to an Authorizer used to set the AuthorizerID.
   *
   * @schema RouteSpecForProvider#authorizerIDRef
   */
  readonly authorizerIdRef?: RouteSpecForProviderAuthorizerIdRef;

  /**
   * AuthorizerIDSelector selects references to Authorizer used to set the AuthorizerID.
   *
   * @schema RouteSpecForProvider#authorizerIDSelector
   */
  readonly authorizerIdSelector?: RouteSpecForProviderAuthorizerIdSelector;

  /**
   * @schema RouteSpecForProvider#modelSelectionExpression
   */
  readonly modelSelectionExpression?: string;

  /**
   * @schema RouteSpecForProvider#operationName
   */
  readonly operationName?: string;

  /**
   * Region is which region the Route will be created.
   *
   * @schema RouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema RouteSpecForProvider#requestModels
   */
  readonly requestModels?: { [key: string]: string };

  /**
   * @schema RouteSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: RouteSpecForProviderRequestParameters };

  /**
   * @schema RouteSpecForProvider#routeKey
   */
  readonly routeKey: string;

  /**
   * @schema RouteSpecForProvider#routeResponseSelectionExpression
   */
  readonly routeResponseSelectionExpression?: string;

  /**
   * Target for the route, of the form integrations/IntegrationID, where IntegrationID is the identifier of an AWS API Gateway Integration
   *
   * @schema RouteSpecForProvider#target
   */
  readonly target?: string;

  /**
   * TargetRef is a reference to an Integration ID
   *
   * @schema RouteSpecForProvider#targetRef
   */
  readonly targetRef?: RouteSpecForProviderTargetRef;

  /**
   * TargetSelector is a selector for an Integration ID
   *
   * @schema RouteSpecForProvider#targetSelector
   */
  readonly targetSelector?: RouteSpecForProviderTargetSelector;

}

/**
 * Converts an object of type 'RouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProvider(obj: RouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_RouteSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_RouteSpecForProviderApiIdSelector(obj.apiIdSelector),
    'apiKeyRequired': obj.apiKeyRequired,
    'authorizationScopes': obj.authorizationScopes?.map(y => y),
    'authorizationType': obj.authorizationType,
    'authorizerID': obj.authorizerId,
    'authorizerIDRef': toJson_RouteSpecForProviderAuthorizerIdRef(obj.authorizerIdRef),
    'authorizerIDSelector': toJson_RouteSpecForProviderAuthorizerIdSelector(obj.authorizerIdSelector),
    'modelSelectionExpression': obj.modelSelectionExpression,
    'operationName': obj.operationName,
    'region': obj.region,
    'requestModels': ((obj.requestModels) === undefined) ? undefined : (Object.entries(obj.requestModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_RouteSpecForProviderRequestParameters(i[1]) }), {})),
    'routeKey': obj.routeKey,
    'routeResponseSelectionExpression': obj.routeResponseSelectionExpression,
    'target': obj.target,
    'targetRef': toJson_RouteSpecForProviderTargetRef(obj.targetRef),
    'targetSelector': toJson_RouteSpecForProviderTargetSelector(obj.targetSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteSpecManagementPolicies
 */
export enum RouteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteSpecProviderConfigRef
 */
export interface RouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecProviderConfigRef#policy
   */
  readonly policy?: RouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRef(obj: RouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteSpecPublishConnectionDetailsTo
 */
export interface RouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsTo(obj: RouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteSpecWriteConnectionSecretToRef
 */
export interface RouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecWriteConnectionSecretToRef(obj: RouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema RouteSpecForProviderApiIdRef
 */
export interface RouteSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderApiIdRef#policy
   */
  readonly policy?: RouteSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdRef(obj: RouteSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema RouteSpecForProviderApiIdSelector
 */
export interface RouteSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderApiIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdSelector(obj: RouteSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerIDRef is a reference to an Authorizer used to set the AuthorizerID.
 *
 * @schema RouteSpecForProviderAuthorizerIdRef
 */
export interface RouteSpecForProviderAuthorizerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderAuthorizerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderAuthorizerIdRef#policy
   */
  readonly policy?: RouteSpecForProviderAuthorizerIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdRef(obj: RouteSpecForProviderAuthorizerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderAuthorizerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerIDSelector selects references to Authorizer used to set the AuthorizerID.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelector
 */
export interface RouteSpecForProviderAuthorizerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderAuthorizerIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdSelector(obj: RouteSpecForProviderAuthorizerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderAuthorizerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderRequestParameters
 */
export interface RouteSpecForProviderRequestParameters {
  /**
   * @schema RouteSpecForProviderRequestParameters#required
   */
  readonly required?: boolean;

}

/**
 * Converts an object of type 'RouteSpecForProviderRequestParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRequestParameters(obj: RouteSpecForProviderRequestParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'required': obj.required,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetRef is a reference to an Integration ID
 *
 * @schema RouteSpecForProviderTargetRef
 */
export interface RouteSpecForProviderTargetRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderTargetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderTargetRef#policy
   */
  readonly policy?: RouteSpecForProviderTargetRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetRef(obj: RouteSpecForProviderTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderTargetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetSelector is a selector for an Integration ID
 *
 * @schema RouteSpecForProviderTargetSelector
 */
export interface RouteSpecForProviderTargetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderTargetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderTargetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderTargetSelector#policy
   */
  readonly policy?: RouteSpecForProviderTargetSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetSelector(obj: RouteSpecForProviderTargetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderTargetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecProviderConfigRefPolicy
 */
export interface RouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRefPolicy(obj: RouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj: RouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteSpecPublishConnectionDetailsToMetadata
 */
export interface RouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToMetadata(obj: RouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderApiIdRefPolicy
 */
export interface RouteSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdRefPolicy(obj: RouteSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicy
 */
export interface RouteSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdSelectorPolicy(obj: RouteSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicy
 */
export interface RouteSpecForProviderAuthorizerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderAuthorizerIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderAuthorizerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderAuthorizerIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderAuthorizerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdRefPolicy(obj: RouteSpecForProviderAuthorizerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy
 */
export interface RouteSpecForProviderAuthorizerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderAuthorizerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderAuthorizerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdSelectorPolicy(obj: RouteSpecForProviderAuthorizerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderTargetRefPolicy
 */
export interface RouteSpecForProviderTargetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTargetRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTargetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTargetRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTargetRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetRefPolicy(obj: RouteSpecForProviderTargetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicy
 */
export interface RouteSpecForProviderTargetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTargetSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTargetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTargetSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTargetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetSelectorPolicy(obj: RouteSpecForProviderTargetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolution
 */
export enum RouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolve
 */
export enum RouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderApiIdRefPolicyResolution
 */
export enum RouteSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderApiIdRefPolicyResolve
 */
export enum RouteSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicyResolution
 */
export enum RouteSpecForProviderAuthorizerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicyResolve
 */
export enum RouteSpecForProviderAuthorizerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderAuthorizerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderAuthorizerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTargetRefPolicyResolution
 */
export enum RouteSpecForProviderTargetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTargetRefPolicyResolve
 */
export enum RouteSpecForProviderTargetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicyResolution
 */
export enum RouteSpecForProviderTargetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicyResolve
 */
export enum RouteSpecForProviderTargetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RouteResponse is the Schema for the RouteResponses API
 *
 * @schema RouteResponse
 */
export class RouteResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RouteResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'RouteResponse',
  }

  /**
   * Renders a Kubernetes manifest for "RouteResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteResponseProps): any {
    return {
      ...RouteResponse.GVK,
      ...toJson_RouteResponseProps(props),
    };
  }

  /**
   * Defines a "RouteResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteResponseProps) {
    super(scope, id, {
      ...RouteResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RouteResponse.GVK,
      ...toJson_RouteResponseProps(resolved),
    };
  }
}

/**
 * RouteResponse is the Schema for the RouteResponses API
 *
 * @schema RouteResponse
 */
export interface RouteResponseProps {
  /**
   * @schema RouteResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteResponseSpec defines the desired state of RouteResponse
   *
   * @schema RouteResponse#spec
   */
  readonly spec: RouteResponseSpec;

}

/**
 * Converts an object of type 'RouteResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseProps(obj: RouteResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteResponseSpec defines the desired state of RouteResponse
 *
 * @schema RouteResponseSpec
 */
export interface RouteResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteResponseSpecDeletionPolicy;

  /**
   * RouteResponseParameters defines the desired state of RouteResponse
   *
   * @schema RouteResponseSpec#forProvider
   */
  readonly forProvider: RouteResponseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteResponseSpec#managementPolicies
   */
  readonly managementPolicies?: RouteResponseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteResponseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpec(obj: RouteResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteResponseSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteResponseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteResponseSpecDeletionPolicy
 */
export enum RouteResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RouteResponseParameters defines the desired state of RouteResponse
 *
 * @schema RouteResponseSpecForProvider
 */
export interface RouteResponseSpecForProvider {
  /**
   * APIID is the ID for the API.
   *
   * @schema RouteResponseSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema RouteResponseSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: RouteResponseSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema RouteResponseSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: RouteResponseSpecForProviderApiIdSelector;

  /**
   * @schema RouteResponseSpecForProvider#modelSelectionExpression
   */
  readonly modelSelectionExpression?: string;

  /**
   * Region is which region the RouteResponse will be created.
   *
   * @schema RouteResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema RouteResponseSpecForProvider#responseModels
   */
  readonly responseModels?: { [key: string]: string };

  /**
   * @schema RouteResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: RouteResponseSpecForProviderResponseParameters };

  /**
   * RouteID is the ID for the Route.
   *
   * @schema RouteResponseSpecForProvider#routeId
   */
  readonly routeId?: string;

  /**
   * RouteIDRef is a reference to an Route used to set the RouteID.
   *
   * @schema RouteResponseSpecForProvider#routeIdRef
   */
  readonly routeIdRef?: RouteResponseSpecForProviderRouteIdRef;

  /**
   * RouteIDSelector selects references to Route used to set the RouteID.
   *
   * @schema RouteResponseSpecForProvider#routeIdSelector
   */
  readonly routeIdSelector?: RouteResponseSpecForProviderRouteIdSelector;

  /**
   * @schema RouteResponseSpecForProvider#routeResponseKey
   */
  readonly routeResponseKey: string;

}

/**
 * Converts an object of type 'RouteResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProvider(obj: RouteResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_RouteResponseSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_RouteResponseSpecForProviderApiIdSelector(obj.apiIdSelector),
    'modelSelectionExpression': obj.modelSelectionExpression,
    'region': obj.region,
    'responseModels': ((obj.responseModels) === undefined) ? undefined : (Object.entries(obj.responseModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_RouteResponseSpecForProviderResponseParameters(i[1]) }), {})),
    'routeId': obj.routeId,
    'routeIdRef': toJson_RouteResponseSpecForProviderRouteIdRef(obj.routeIdRef),
    'routeIdSelector': toJson_RouteResponseSpecForProviderRouteIdSelector(obj.routeIdSelector),
    'routeResponseKey': obj.routeResponseKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteResponseSpecManagementPolicies
 */
export enum RouteResponseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteResponseSpecProviderConfigRef
 */
export interface RouteResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecProviderConfigRef#policy
   */
  readonly policy?: RouteResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderConfigRef(obj: RouteResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsTo
 */
export interface RouteResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsTo(obj: RouteResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteResponseSpecWriteConnectionSecretToRef
 */
export interface RouteResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecWriteConnectionSecretToRef(obj: RouteResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema RouteResponseSpecForProviderApiIdRef
 */
export interface RouteResponseSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecForProviderApiIdRef#policy
   */
  readonly policy?: RouteResponseSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdRef(obj: RouteResponseSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema RouteResponseSpecForProviderApiIdSelector
 */
export interface RouteResponseSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#policy
   */
  readonly policy?: RouteResponseSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdSelector(obj: RouteResponseSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteResponseSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteResponseSpecForProviderResponseParameters
 */
export interface RouteResponseSpecForProviderResponseParameters {
  /**
   * @schema RouteResponseSpecForProviderResponseParameters#required
   */
  readonly required?: boolean;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderResponseParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderResponseParameters(obj: RouteResponseSpecForProviderResponseParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'required': obj.required,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteIDRef is a reference to an Route used to set the RouteID.
 *
 * @schema RouteResponseSpecForProviderRouteIdRef
 */
export interface RouteResponseSpecForProviderRouteIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecForProviderRouteIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecForProviderRouteIdRef#policy
   */
  readonly policy?: RouteResponseSpecForProviderRouteIdRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdRef(obj: RouteResponseSpecForProviderRouteIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecForProviderRouteIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteIDSelector selects references to Route used to set the RouteID.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelector
 */
export interface RouteResponseSpecForProviderRouteIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#policy
   */
  readonly policy?: RouteResponseSpecForProviderRouteIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdSelector(obj: RouteResponseSpecForProviderRouteIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteResponseSpecForProviderRouteIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicy
 */
export interface RouteResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderConfigRefPolicy(obj: RouteResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToConfigRef(obj: RouteResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToMetadata
 */
export interface RouteResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToMetadata(obj: RouteResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicy
 */
export interface RouteResponseSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdRefPolicy(obj: RouteResponseSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicy
 */
export interface RouteResponseSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdSelectorPolicy(obj: RouteResponseSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicy
 */
export interface RouteResponseSpecForProviderRouteIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderRouteIdRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderRouteIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderRouteIdRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderRouteIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdRefPolicy(obj: RouteResponseSpecForProviderRouteIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy
 */
export interface RouteResponseSpecForProviderRouteIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderRouteIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderRouteIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdSelectorPolicy(obj: RouteResponseSpecForProviderRouteIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicyResolution
 */
export enum RouteResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicyResolve
 */
export enum RouteResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicyResolution
 */
export enum RouteResponseSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicyResolve
 */
export enum RouteResponseSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicyResolution
 */
export enum RouteResponseSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicyResolve
 */
export enum RouteResponseSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicyResolution
 */
export enum RouteResponseSpecForProviderRouteIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicyResolve
 */
export enum RouteResponseSpecForProviderRouteIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicyResolution
 */
export enum RouteResponseSpecForProviderRouteIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicyResolve
 */
export enum RouteResponseSpecForProviderRouteIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stage is the Schema for the Stages API
 *
 * @schema Stage
 */
export class Stage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'Stage',
  }

  /**
   * Renders a Kubernetes manifest for "Stage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StageProps): any {
    return {
      ...Stage.GVK,
      ...toJson_StageProps(props),
    };
  }

  /**
   * Defines a "Stage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StageProps) {
    super(scope, id, {
      ...Stage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stage.GVK,
      ...toJson_StageProps(resolved),
    };
  }
}

/**
 * Stage is the Schema for the Stages API
 *
 * @schema Stage
 */
export interface StageProps {
  /**
   * @schema Stage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StageSpec defines the desired state of Stage
   *
   * @schema Stage#spec
   */
  readonly spec: StageSpec;

}

/**
 * Converts an object of type 'StageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageProps(obj: StageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageSpec defines the desired state of Stage
 *
 * @schema StageSpec
 */
export interface StageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#deletionPolicy
   */
  readonly deletionPolicy?: StageSpecDeletionPolicy;

  /**
   * StageParameters defines the desired state of Stage
   *
   * @schema StageSpec#forProvider
   */
  readonly forProvider: StageSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StageSpec#managementPolicies
   */
  readonly managementPolicies?: StageSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StageSpec#providerConfigRef
   */
  readonly providerConfigRef?: StageSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpec(obj: StageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StageSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StageSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecDeletionPolicy
 */
export enum StageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * StageParameters defines the desired state of Stage
 *
 * @schema StageSpecForProvider
 */
export interface StageSpecForProvider {
  /**
   * @schema StageSpecForProvider#accessLogSettings
   */
  readonly accessLogSettings?: StageSpecForProviderAccessLogSettings;

  /**
   * APIID is the ID for the API.
   *
   * @schema StageSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * APIIDRef is a reference to an API used to set the APIID.
   *
   * @schema StageSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: StageSpecForProviderApiIdRef;

  /**
   * APIIDSelector selects references to API used to set the APIID.
   *
   * @schema StageSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: StageSpecForProviderApiIdSelector;

  /**
   * @schema StageSpecForProvider#autoDeploy
   */
  readonly autoDeploy?: boolean;

  /**
   * @schema StageSpecForProvider#clientCertificateID
   */
  readonly clientCertificateId?: string;

  /**
   * @schema StageSpecForProvider#defaultRouteSettings
   */
  readonly defaultRouteSettings?: StageSpecForProviderDefaultRouteSettings;

  /**
   * @schema StageSpecForProvider#deploymentID
   */
  readonly deploymentId?: string;

  /**
   * @schema StageSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is which region the Stage will be created.
   *
   * @schema StageSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema StageSpecForProvider#routeSettings
   */
  readonly routeSettings?: { [key: string]: StageSpecForProviderRouteSettings };

  /**
   * @schema StageSpecForProvider#stageVariables
   */
  readonly stageVariables?: { [key: string]: string };

  /**
   * @schema StageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProvider(obj: StageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogSettings': toJson_StageSpecForProviderAccessLogSettings(obj.accessLogSettings),
    'apiId': obj.apiId,
    'apiIdRef': toJson_StageSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_StageSpecForProviderApiIdSelector(obj.apiIdSelector),
    'autoDeploy': obj.autoDeploy,
    'clientCertificateID': obj.clientCertificateId,
    'defaultRouteSettings': toJson_StageSpecForProviderDefaultRouteSettings(obj.defaultRouteSettings),
    'deploymentID': obj.deploymentId,
    'description': obj.description,
    'region': obj.region,
    'routeSettings': ((obj.routeSettings) === undefined) ? undefined : (Object.entries(obj.routeSettings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_StageSpecForProviderRouteSettings(i[1]) }), {})),
    'stageVariables': ((obj.stageVariables) === undefined) ? undefined : (Object.entries(obj.stageVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StageSpecManagementPolicies
 */
export enum StageSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StageSpecProviderConfigRef
 */
export interface StageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderConfigRef#policy
   */
  readonly policy?: StageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRef(obj: StageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StageSpecPublishConnectionDetailsTo
 */
export interface StageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsTo(obj: StageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StageSpecWriteConnectionSecretToRef
 */
export interface StageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecWriteConnectionSecretToRef(obj: StageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderAccessLogSettings
 */
export interface StageSpecForProviderAccessLogSettings {
  /**
   * Represents an Amazon Resource Name (ARN).
   *
   * @schema StageSpecForProviderAccessLogSettings#destinationARN
   */
  readonly destinationArn?: string;

  /**
   * A string with a length between [1-1024].
   *
   * @schema StageSpecForProviderAccessLogSettings#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'StageSpecForProviderAccessLogSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderAccessLogSettings(obj: StageSpecForProviderAccessLogSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationARN': obj.destinationArn,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDRef is a reference to an API used to set the APIID.
 *
 * @schema StageSpecForProviderApiIdRef
 */
export interface StageSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderApiIdRef#policy
   */
  readonly policy?: StageSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdRef(obj: StageSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIIDSelector selects references to API used to set the APIID.
 *
 * @schema StageSpecForProviderApiIdSelector
 */
export interface StageSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderApiIdSelector#policy
   */
  readonly policy?: StageSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdSelector(obj: StageSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderDefaultRouteSettings
 */
export interface StageSpecForProviderDefaultRouteSettings {
  /**
   * @schema StageSpecForProviderDefaultRouteSettings#dataTraceEnabled
   */
  readonly dataTraceEnabled?: boolean;

  /**
   * @schema StageSpecForProviderDefaultRouteSettings#detailedMetricsEnabled
   */
  readonly detailedMetricsEnabled?: boolean;

  /**
   * The logging level.
   *
   * @schema StageSpecForProviderDefaultRouteSettings#loggingLevel
   */
  readonly loggingLevel?: string;

  /**
   * @schema StageSpecForProviderDefaultRouteSettings#throttlingBurstLimit
   */
  readonly throttlingBurstLimit?: number;

  /**
   * @schema StageSpecForProviderDefaultRouteSettings#throttlingRateLimit
   */
  readonly throttlingRateLimit?: number;

}

/**
 * Converts an object of type 'StageSpecForProviderDefaultRouteSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDefaultRouteSettings(obj: StageSpecForProviderDefaultRouteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataTraceEnabled': obj.dataTraceEnabled,
    'detailedMetricsEnabled': obj.detailedMetricsEnabled,
    'loggingLevel': obj.loggingLevel,
    'throttlingBurstLimit': obj.throttlingBurstLimit,
    'throttlingRateLimit': obj.throttlingRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderRouteSettings
 */
export interface StageSpecForProviderRouteSettings {
  /**
   * @schema StageSpecForProviderRouteSettings#dataTraceEnabled
   */
  readonly dataTraceEnabled?: boolean;

  /**
   * @schema StageSpecForProviderRouteSettings#detailedMetricsEnabled
   */
  readonly detailedMetricsEnabled?: boolean;

  /**
   * The logging level.
   *
   * @schema StageSpecForProviderRouteSettings#loggingLevel
   */
  readonly loggingLevel?: string;

  /**
   * @schema StageSpecForProviderRouteSettings#throttlingBurstLimit
   */
  readonly throttlingBurstLimit?: number;

  /**
   * @schema StageSpecForProviderRouteSettings#throttlingRateLimit
   */
  readonly throttlingRateLimit?: number;

}

/**
 * Converts an object of type 'StageSpecForProviderRouteSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRouteSettings(obj: StageSpecForProviderRouteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataTraceEnabled': obj.dataTraceEnabled,
    'detailedMetricsEnabled': obj.detailedMetricsEnabled,
    'loggingLevel': obj.loggingLevel,
    'throttlingBurstLimit': obj.throttlingBurstLimit,
    'throttlingRateLimit': obj.throttlingRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderConfigRefPolicy
 */
export interface StageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRefPolicy(obj: StageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRef
 */
export interface StageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRef(obj: StageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StageSpecPublishConnectionDetailsToMetadata
 */
export interface StageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToMetadata(obj: StageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderApiIdRefPolicy
 */
export interface StageSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdRefPolicy(obj: StageSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicy
 */
export interface StageSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdSelectorPolicy(obj: StageSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderConfigRefPolicyResolution
 */
export enum StageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderConfigRefPolicyResolve
 */
export enum StageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj: StageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderApiIdRefPolicyResolution
 */
export enum StageSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderApiIdRefPolicyResolve
 */
export enum StageSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicyResolution
 */
export enum StageSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicyResolve
 */
export enum StageSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLink
 */
export class VpcLink extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCLink"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1alpha1',
    kind: 'VPCLink',
  }

  /**
   * Renders a Kubernetes manifest for "VPCLink".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcLinkProps): any {
    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(props),
    };
  }

  /**
   * Defines a "VPCLink" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcLinkProps) {
    super(scope, id, {
      ...VpcLink.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(resolved),
    };
  }
}

/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLink
 */
export interface VpcLinkProps {
  /**
   * @schema VPCLink#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCLinkSpec defines the desired state of VPCLink
   *
   * @schema VPCLink#spec
   */
  readonly spec: VpcLinkSpec;

}

/**
 * Converts an object of type 'VpcLinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkProps(obj: VpcLinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcLinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCLinkSpec defines the desired state of VPCLink
 *
 * @schema VpcLinkSpec
 */
export interface VpcLinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcLinkSpecDeletionPolicy;

  /**
   * VPCLinkParameters defines the desired state of VPCLink
   *
   * @schema VpcLinkSpec#forProvider
   */
  readonly forProvider: VpcLinkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcLinkSpec#managementPolicies
   */
  readonly managementPolicies?: VpcLinkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcLinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcLinkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcLinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcLinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcLinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcLinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcLinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpec(obj: VpcLinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcLinkSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcLinkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcLinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcLinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecDeletionPolicy
 */
export enum VpcLinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCLinkParameters defines the desired state of VPCLink
 *
 * @schema VpcLinkSpecForProvider
 */
export interface VpcLinkSpecForProvider {
  /**
   * @schema VpcLinkSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the VPCLink will be created.
   *
   * @schema VpcLinkSpecForProvider#region
   */
  readonly region: string;

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: VpcLinkSpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: VpcLinkSpecForProviderSecurityGroupIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcLinkSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: VpcLinkSpecForProviderSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcLinkSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: VpcLinkSpecForProviderSubnetIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema VpcLinkSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * @schema VpcLinkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VpcLinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProvider(obj: VpcLinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_VpcLinkSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_VpcLinkSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_VpcLinkSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_VpcLinkSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcLinkSpecManagementPolicies
 */
export enum VpcLinkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcLinkSpecProviderConfigRef
 */
export interface VpcLinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderConfigRef#policy
   */
  readonly policy?: VpcLinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRef(obj: VpcLinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsTo
 */
export interface VpcLinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcLinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcLinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsTo(obj: VpcLinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcLinkSpecWriteConnectionSecretToRef
 */
export interface VpcLinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcLinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecWriteConnectionSecretToRef(obj: VpcLinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefs
 */
export interface VpcLinkSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdRefs(obj: VpcLinkSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelector
 */
export interface VpcLinkSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdSelector(obj: VpcLinkSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefs
 */
export interface VpcLinkSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: VpcLinkSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdRefs(obj: VpcLinkSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelector
 */
export interface VpcLinkSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: VpcLinkSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdSelector(obj: VpcLinkSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicy
 */
export interface VpcLinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRefPolicy(obj: VpcLinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj: VpcLinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToMetadata
 */
export interface VpcLinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj: VpcLinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface VpcLinkSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdRefsPolicy(obj: VpcLinkSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy(obj: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy
 */
export interface VpcLinkSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdRefsPolicy(obj: VpcLinkSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy
 */
export interface VpcLinkSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdSelectorPolicy(obj: VpcLinkSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolution
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolve
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum VpcLinkSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum VpcLinkSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLinkV1Beta1
 */
export class VpcLinkV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCLinkV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.crossplane.io/v1beta1',
    kind: 'VPCLink',
  }

  /**
   * Renders a Kubernetes manifest for "VPCLinkV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcLinkV1Beta1Props): any {
    return {
      ...VpcLinkV1Beta1.GVK,
      ...toJson_VpcLinkV1Beta1Props(props),
    };
  }

  /**
   * Defines a "VPCLinkV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcLinkV1Beta1Props) {
    super(scope, id, {
      ...VpcLinkV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcLinkV1Beta1.GVK,
      ...toJson_VpcLinkV1Beta1Props(resolved),
    };
  }
}

/**
 * VPCLink is the Schema for the VPCLinks API
 *
 * @schema VPCLinkV1Beta1
 */
export interface VpcLinkV1Beta1Props {
  /**
   * @schema VPCLinkV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCLinkSpec defines the desired state of VPCLink
   *
   * @schema VPCLinkV1Beta1#spec
   */
  readonly spec: VpcLinkV1Beta1Spec;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1Props(obj: VpcLinkV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcLinkV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCLinkSpec defines the desired state of VPCLink
 *
 * @schema VpcLinkV1Beta1Spec
 */
export interface VpcLinkV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: VpcLinkV1Beta1SpecDeletionPolicy;

  /**
   * VPCLinkParameters defines the desired state of VPCLink
   *
   * @schema VpcLinkV1Beta1Spec#forProvider
   */
  readonly forProvider: VpcLinkV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcLinkV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: VpcLinkV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcLinkV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: VpcLinkV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcLinkV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcLinkV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcLinkV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcLinkV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1Spec(obj: VpcLinkV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcLinkV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcLinkV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcLinkV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkV1Beta1SpecDeletionPolicy
 */
export enum VpcLinkV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * VPCLinkParameters defines the desired state of VPCLink
 *
 * @schema VpcLinkV1Beta1SpecForProvider
 */
export interface VpcLinkV1Beta1SpecForProvider {
  /**
   * @schema VpcLinkV1Beta1SpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the VPCLink will be created.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: VpcLinkV1Beta1SpecForProviderSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: VpcLinkV1Beta1SpecForProviderSubnetIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema VpcLinkV1Beta1SpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * @schema VpcLinkV1Beta1SpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProvider(obj: VpcLinkV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_VpcLinkV1Beta1SpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_VpcLinkV1Beta1SpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcLinkV1Beta1SpecManagementPolicies
 */
export enum VpcLinkV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcLinkV1Beta1SpecProviderConfigRef
 */
export interface VpcLinkV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecProviderConfigRef(obj: VpcLinkV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsTo
 */
export interface VpcLinkV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsTo(obj: VpcLinkV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcLinkV1Beta1SpecWriteConnectionSecretToRef
 */
export interface VpcLinkV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcLinkV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcLinkV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecWriteConnectionSecretToRef(obj: VpcLinkV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs
 */
export interface VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs(obj: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector
 */
export interface VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector(obj: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefs
 */
export interface VpcLinkV1Beta1SpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSubnetIdRefs(obj: VpcLinkV1Beta1SpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelector
 */
export interface VpcLinkV1Beta1SpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSubnetIdSelector(obj: VpcLinkV1Beta1SpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkV1Beta1SpecProviderConfigRefPolicy
 */
export interface VpcLinkV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecProviderConfigRefPolicy(obj: VpcLinkV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata(obj: VpcLinkV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy
 */
export interface VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy(obj: VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy(obj: VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy
 */
export interface VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy(obj: VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy
 */
export interface VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy(obj: VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum VpcLinkV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum VpcLinkV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum VpcLinkV1Beta1SpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum VpcLinkV1Beta1SpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolution
 */
export enum VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolve
 */
export enum VpcLinkV1Beta1SpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum VpcLinkV1Beta1SpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcLinkV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

