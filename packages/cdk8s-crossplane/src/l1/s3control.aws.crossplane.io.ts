// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessPoint is the Schema for the AccessPoints API
 *
 * @schema AccessPoint
 */
export class AccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.crossplane.io/v1alpha1',
    kind: 'AccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPointProps): any {
    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(props),
    };
  }

  /**
   * Defines a "AccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPointProps) {
    super(scope, id, {
      ...AccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(resolved),
    };
  }
}

/**
 * AccessPoint is the Schema for the AccessPoints API
 *
 * @schema AccessPoint
 */
export interface AccessPointProps {
  /**
   * @schema AccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPointSpec defines the desired state of AccessPoint
   *
   * @schema AccessPoint#spec
   */
  readonly spec: AccessPointSpec;

}

/**
 * Converts an object of type 'AccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointProps(obj: AccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPointSpec defines the desired state of AccessPoint
 *
 * @schema AccessPointSpec
 */
export interface AccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPointSpecDeletionPolicy;

  /**
   * AccessPointParameters defines the desired state of AccessPoint
   *
   * @schema AccessPointSpec#forProvider
   */
  readonly forProvider: AccessPointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessPointSpec#managementPolicies
   */
  readonly managementPolicies?: AccessPointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpec(obj: AccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPointSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointSpecDeletionPolicy
 */
export enum AccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AccessPointParameters defines the desired state of AccessPoint
 *
 * @schema AccessPointSpecForProvider
 */
export interface AccessPointSpecForProvider {
  /**
   * The Amazon Web Services account ID for the account that owns the specified access point.
   *
   * @schema AccessPointSpecForProvider#accountID
   */
  readonly accountId: string;

  /**
   * The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
   *
   * @schema AccessPointSpecForProvider#bucketAccountID
   */
  readonly bucketAccountId?: string;

  /**
   * BucketName is the name of the Bucket for AccessPoint
   *
   * @schema AccessPointSpecForProvider#bucketName
   */
  readonly bucketName?: string;

  /**
   * BucketNameRef is a reference to a Bucket used to set the BucketName
   *
   * @schema AccessPointSpecForProvider#bucketNameRef
   */
  readonly bucketNameRef?: AccessPointSpecForProviderBucketNameRef;

  /**
   * BucketNameSelector selects a references to used to set the BucketName
   *
   * @schema AccessPointSpecForProvider#bucketNameSelector
   */
  readonly bucketNameSelector?: AccessPointSpecForProviderBucketNameSelector;

  /**
   * The policy that you want to apply to the specified access point. For more information about access point policies, see Managing data access with Amazon S3 access points (https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html) in the Amazon S3 User Guide.
   *
   * @schema AccessPointSpecForProvider#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicy;

  /**
   * The PublicAccessBlock configuration that you want to apply to the access point.
   *
   * @schema AccessPointSpecForProvider#publicAccessBlockConfiguration
   */
  readonly publicAccessBlockConfiguration?: AccessPointSpecForProviderPublicAccessBlockConfiguration;

  /**
   * Region is which region the AccessPoint will be created.
   *
   * @schema AccessPointSpecForProvider#region
   */
  readonly region: string;

  /**
   * If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC).
   * This is required for creating an access point for Amazon S3 on Outposts buckets.
   *
   * @schema AccessPointSpecForProvider#vpcConfiguration
   */
  readonly vpcConfiguration?: AccessPointSpecForProviderVpcConfiguration;

}

/**
 * Converts an object of type 'AccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProvider(obj: AccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountID': obj.accountId,
    'bucketAccountID': obj.bucketAccountId,
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_AccessPointSpecForProviderBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_AccessPointSpecForProviderBucketNameSelector(obj.bucketNameSelector),
    'policy': toJson_AccessPointSpecForProviderPolicy(obj.policy),
    'publicAccessBlockConfiguration': toJson_AccessPointSpecForProviderPublicAccessBlockConfiguration(obj.publicAccessBlockConfiguration),
    'region': obj.region,
    'vpcConfiguration': toJson_AccessPointSpecForProviderVpcConfiguration(obj.vpcConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessPointSpecManagementPolicies
 */
export enum AccessPointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPointSpecProviderConfigRef
 */
export interface AccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: AccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRef(obj: AccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPointSpecPublishConnectionDetailsTo
 */
export interface AccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsTo(obj: AccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPointSpecWriteConnectionSecretToRef
 */
export interface AccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecWriteConnectionSecretToRef(obj: AccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketNameRef is a reference to a Bucket used to set the BucketName
 *
 * @schema AccessPointSpecForProviderBucketNameRef
 */
export interface AccessPointSpecForProviderBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderBucketNameRef#policy
   */
  readonly policy?: AccessPointSpecForProviderBucketNameRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketNameRef(obj: AccessPointSpecForProviderBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketNameSelector selects a references to used to set the BucketName
 *
 * @schema AccessPointSpecForProviderBucketNameSelector
 */
export interface AccessPointSpecForProviderBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderBucketNameSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketNameSelector(obj: AccessPointSpecForProviderBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy that you want to apply to the specified access point. For more information about access point policies, see Managing data access with Amazon S3 access points (https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html) in the Amazon S3 User Guide.
 *
 * @schema AccessPointSpecForProviderPolicy
 */
export interface AccessPointSpecForProviderPolicy {
  /**
   * ID is the policy's optional identifier
   *
   * @schema AccessPointSpecForProviderPolicy#id
   */
  readonly id?: string;

  /**
   * Statements is the list of statement this policy applies either jsonStatements or statements must be specified in the policy
   *
   * @schema AccessPointSpecForProviderPolicy#statements
   */
  readonly statements?: AccessPointSpecForProviderPolicyStatements[];

  /**
   * Version is the current IAM policy version
   *
   * @schema AccessPointSpecForProviderPolicy#version
   */
  readonly version: AccessPointSpecForProviderPolicyVersion;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicy(obj: AccessPointSpecForProviderPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'statements': obj.statements?.map(y => toJson_AccessPointSpecForProviderPolicyStatements(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The PublicAccessBlock configuration that you want to apply to the access point.
 *
 * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration
 */
export interface AccessPointSpecForProviderPublicAccessBlockConfiguration {
  /**
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#blockPublicACLs
   */
  readonly blockPublicAcLs?: boolean;

  /**
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#ignorePublicACLs
   */
  readonly ignorePublicAcLs?: boolean;

  /**
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPublicAccessBlockConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPublicAccessBlockConfiguration(obj: AccessPointSpecForProviderPublicAccessBlockConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicACLs': obj.blockPublicAcLs,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicACLs': obj.ignorePublicAcLs,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC).
 * This is required for creating an access point for Amazon S3 on Outposts buckets.
 *
 * @schema AccessPointSpecForProviderVpcConfiguration
 */
export interface AccessPointSpecForProviderVpcConfiguration {
  /**
   * @schema AccessPointSpecForProviderVpcConfiguration#vpcID
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfiguration(obj: AccessPointSpecForProviderVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcID': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecProviderConfigRefPolicy
 */
export interface AccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRefPolicy(obj: AccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj: AccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface AccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj: AccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderBucketNameRefPolicy
 */
export interface AccessPointSpecForProviderBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderBucketNameRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderBucketNameRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketNameRefPolicy(obj: AccessPointSpecForProviderBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderBucketNameSelectorPolicy
 */
export interface AccessPointSpecForProviderBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketNameSelectorPolicy(obj: AccessPointSpecForProviderBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketPolicyStatement defines an individual statement within the BucketPolicyBody
 *
 * @schema AccessPointSpecForProviderPolicyStatements
 */
export interface AccessPointSpecForProviderPolicyStatements {
  /**
   * Each element of the PolicyAction array describes the specific action or actions that will be allowed or denied with this PolicyStatement.
   *
   * @schema AccessPointSpecForProviderPolicyStatements#action
   */
  readonly action?: string[];

  /**
   * Condition specifies where conditions for policy are in effect. https://docs.aws.amazon.com/AmazonS3/latest/dev/amazon-s3-policy-keys.html
   *
   * @schema AccessPointSpecForProviderPolicyStatements#condition
   */
  readonly condition?: AccessPointSpecForProviderPolicyStatementsCondition[];

  /**
   * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
   *
   * @schema AccessPointSpecForProviderPolicyStatements#effect
   */
  readonly effect: AccessPointSpecForProviderPolicyStatementsEffect;

  /**
   * Each element of the NotPolicyAction array will allow the property to match all but the listed actions.
   *
   * @schema AccessPointSpecForProviderPolicyStatements#notAction
   */
  readonly notAction?: string[];

  /**
   * Used with the S3 policy to specify the users which are not included in this policy
   *
   * @schema AccessPointSpecForProviderPolicyStatements#notPrincipal
   */
  readonly notPrincipal?: AccessPointSpecForProviderPolicyStatementsNotPrincipal;

  /**
   * This will explicitly match all resource paths except the ones specified in this array
   *
   * @schema AccessPointSpecForProviderPolicyStatements#notResource
   */
  readonly notResource?: string[];

  /**
   * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
   *
   * @schema AccessPointSpecForProviderPolicyStatements#principal
   */
  readonly principal?: AccessPointSpecForProviderPolicyStatementsPrincipal;

  /**
   * The paths on which this resource will apply
   *
   * @schema AccessPointSpecForProviderPolicyStatements#resource
   */
  readonly resource?: string[];

  /**
   * Optional identifier for this statement, must be unique within the policy if provided.
   *
   * @schema AccessPointSpecForProviderPolicyStatements#sid
   */
  readonly sid?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatements(obj: AccessPointSpecForProviderPolicyStatements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => y),
    'condition': obj.condition?.map(y => toJson_AccessPointSpecForProviderPolicyStatementsCondition(y)),
    'effect': obj.effect,
    'notAction': obj.notAction?.map(y => y),
    'notPrincipal': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipal(obj.notPrincipal),
    'notResource': obj.notResource?.map(y => y),
    'principal': toJson_AccessPointSpecForProviderPolicyStatementsPrincipal(obj.principal),
    'resource': obj.resource?.map(y => y),
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the current IAM policy version
 *
 * @schema AccessPointSpecForProviderPolicyVersion
 */
export enum AccessPointSpecForProviderPolicyVersion {
  /** 2012-10-17 */
  VALUE_2012_HYPHEN_10_HYPHEN_17 = "2012-10-17",
  /** 2008-10-17 */
  VALUE_2008_HYPHEN_10_HYPHEN_17 = "2008-10-17",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolution
 */
export enum AccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolve
 */
export enum AccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderBucketNameRefPolicyResolution
 */
export enum AccessPointSpecForProviderBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderBucketNameRefPolicyResolve
 */
export enum AccessPointSpecForProviderBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderBucketNameSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderBucketNameSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Condition represents a set of condition pairs for a bucket policy
 *
 * @schema AccessPointSpecForProviderPolicyStatementsCondition
 */
export interface AccessPointSpecForProviderPolicyStatementsCondition {
  /**
   * Conditions represents each of the key/value pairs for the operator key
   *
   * @schema AccessPointSpecForProviderPolicyStatementsCondition#conditions
   */
  readonly conditions: AccessPointSpecForProviderPolicyStatementsConditionConditions[];

  /**
   * OperatorKey matches the condition key and value in the policy against values in the request context
   *
   * @schema AccessPointSpecForProviderPolicyStatementsCondition#operatorKey
   */
  readonly operatorKey: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsCondition(obj: AccessPointSpecForProviderPolicyStatementsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_AccessPointSpecForProviderPolicyStatementsConditionConditions(y)),
    'operatorKey': obj.operatorKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The effect is required and specifies whether the statement results in an allow or an explicit deny. Valid values for Effect are Allow and Deny.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsEffect
 */
export enum AccessPointSpecForProviderPolicyStatementsEffect {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Used with the S3 policy to specify the users which are not included in this policy
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipal
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipal(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used with the S3 policy to specify the principal that is allowed or denied access to a resource.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipal
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipal {
  /**
   * This flag indicates if the policy should be made available to all anonymous users.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipal#allowAnon
   */
  readonly allowAnon?: boolean;

  /**
   * This list contains the all of the AWS IAM users which are affected by the policy statement.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipal#awsPrincipals
   */
  readonly awsPrincipals?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals[];

  /**
   * This string contains the identifier for any federated web identity provider.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipal#federated
   */
  readonly federated?: string;

  /**
   * Service define the services which can have access to this bucket
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipal#service
   */
  readonly service?: string[];

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipal(obj: AccessPointSpecForProviderPolicyStatementsPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAnon': obj.allowAnon,
    'awsPrincipals': obj.awsPrincipals?.map(y => toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals(y)),
    'federated': obj.federated,
    'service': obj.service?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * ConditionPair represents one condition inside of the set of conditions for a bucket policy
 *
 * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions
 */
export interface AccessPointSpecForProviderPolicyStatementsConditionConditions {
  /**
   * ConditionBooleanValue is the expected boolean value of the key from the parent condition
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * ConditionDateValue is the expected string value of the key from the parent condition. The date value must be in ISO 8601 format. The time is always midnight UTC.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#dateValue
   */
  readonly dateValue?: Date;

  /**
   * ConditionKey is the key condition being applied to the parent condition
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#key
   */
  readonly key: string;

  /**
   * ConditionListValue is the list value of the key from the parent condition
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#listValue
   */
  readonly listValue?: string[];

  /**
   * ConditionNumericValue is the expected string value of the key from the parent condition
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#numericValue
   */
  readonly numericValue?: number;

  /**
   * ConditionStringValue is the expected string value of the key from the parent condition
   *
   * @schema AccessPointSpecForProviderPolicyStatementsConditionConditions#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsConditionConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsConditionConditions(obj: AccessPointSpecForProviderPolicyStatementsConditionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'key': obj.key,
    'listValue': obj.listValue?.map(y => y),
    'numericValue': obj.numericValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSPrincipal wraps the potential values a policy principal can take. Only one of the values should be set.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals {
  /**
   * AWSAccountID identifies an AWS account as the principal
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#awsAccountId
   */
  readonly awsAccountId?: string;

  /**
   * IAMRoleARN contains the ARN of an IAM role
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * IAMRoleARNRef contains the reference to an IAMRole
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnRef
   */
  readonly iamRoleArnRef?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef;

  /**
   * IAMRoleARNSelector queries for an IAM role to retrieve its userName
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector;

  /**
   * UserARN contains the ARN of an IAM user
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArn
   */
  readonly iamUserArn?: string;

  /**
   * UserARNRef contains the reference to an User
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnRef
   */
  readonly iamUserArnRef?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef;

  /**
   * UserARNSelector queries for an User to retrieve its userName
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals#iamUserArnSelector
   */
  readonly iamUserArnSelector?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj.iamRoleArnSelector),
    'iamUserArn': obj.iamUserArn,
    'iamUserArnRef': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj.iamUserArnRef),
    'iamUserArnSelector': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj.iamUserArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNRef contains the reference to an IAMRole
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleARNSelector queries for an IAM role to retrieve its userName
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNRef contains the reference to an User
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserARNSelector queries for an User to retrieve its userName
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy
 */
export interface AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy(obj: AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsNotPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderPolicyStatementsPrincipalAwsPrincipalsIamUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

