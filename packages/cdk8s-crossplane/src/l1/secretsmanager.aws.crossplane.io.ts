// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Secret is the Schema for the Secrets API
 *
 * @schema Secret
 */
export class Secret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Secret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.crossplane.io/v1alpha1',
    kind: 'Secret',
  }

  /**
   * Renders a Kubernetes manifest for "Secret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretProps): any {
    return {
      ...Secret.GVK,
      ...toJson_SecretProps(props),
    };
  }

  /**
   * Defines a "Secret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretProps) {
    super(scope, id, {
      ...Secret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Secret.GVK,
      ...toJson_SecretProps(resolved),
    };
  }
}

/**
 * Secret is the Schema for the Secrets API
 *
 * @schema Secret
 */
export interface SecretProps {
  /**
   * @schema Secret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretSpec defines the desired state of Secret
   *
   * @schema Secret#spec
   */
  readonly spec: SecretSpec;

}

/**
 * Converts an object of type 'SecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretProps(obj: SecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretSpec defines the desired state of Secret
 *
 * @schema SecretSpec
 */
export interface SecretSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretSpecDeletionPolicy;

  /**
   * SecretParameters defines the desired state of Secret
   *
   * @schema SecretSpec#forProvider
   */
  readonly forProvider: SecretSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecretSpec#managementPolicies
   */
  readonly managementPolicies?: SecretSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpec(obj: SecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecretSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecretSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretSpecDeletionPolicy
 */
export enum SecretSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecretParameters defines the desired state of Secret
 *
 * @schema SecretSpecForProvider
 */
export interface SecretSpecForProvider {
  /**
   * BinarySecretRef points to the Kubernetes Secret whose data will be encoded as binary data to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
   *
   * @schema SecretSpecForProvider#binarySecretRef
   */
  readonly binarySecretRef?: SecretSpecForProviderBinarySecretRef;

  /**
   * (Optional) Specifies a user-provided description of the secret.
   *
   * @schema SecretSpecForProvider#description
   */
  readonly description?: string;

  /**
   * (Optional) Specifies that the secret is to be deleted without any recovery window. You can't use both this parameter and the RecoveryWindowInDays parameter in the same API call.
   * An asynchronous background process performs the actual deletion, so there can be a short delay before the operation completes. If you write code to delete and then immediately recreate a secret with the same name, ensure that your code includes appropriate back off and retry logic.
   * Use this parameter with caution. This parameter causes the operation to skip the normal waiting period before the permanent deletion that AWS would normally impose with the RecoveryWindowInDays parameter. If you delete a secret with the ForceDeleteWithouRecovery parameter, then you have no opportunity to recover the secret. It is permanently lost.
   *
   * @schema SecretSpecForProvider#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * (Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to be used to encrypt the SecretString or SecretBinary values in the versions stored in this secret.
   * You can specify any of the supported ways to identify a AWS KMS key ID. If you need to reference a CMK in a different account, you can use only the key ARN or the alias ARN.
   * If you don't specify this value, then Secrets Manager defaults to using the AWS account's default CMK (the one named aws/secretsmanager). If a AWS KMS CMK with that name doesn't yet exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a version's SecretString or SecretBinary fields.
   * You can use the account default CMK to encrypt and decrypt only if you call this operation using credentials from the same account that owns the secret. If the secret resides in a different account, then you must create a custom CMK and specify the ARN in this field.
   *
   * @schema SecretSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to an kms/v1alpha1.Key used to set the KMSKeyID field.
   *
   * @schema SecretSpecForProvider#kmsKeyIDRef
   */
  readonly kmsKeyIdRef?: SecretSpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects references to kms/v1alpha1.Key used to set the KMSKeyID.
   *
   * @schema SecretSpecForProvider#kmsKeyIDSelector
   */
  readonly kmsKeyIdSelector?: SecretSpecForProviderKmsKeyIdSelector;

  /**
   * (Optional) Specifies the number of days that Secrets Manager waits before it can delete the secret. You can't use both this parameter and the ForceDeleteWithoutRecovery parameter in the same API call.
   * This value can range from 7 to 30 days. The default value is 30.
   *
   * @schema SecretSpecForProvider#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

  /**
   * Region is which region the Secret will be created.
   *
   * @schema SecretSpecForProvider#region
   */
  readonly region: string;

  /**
   * A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services resource-based policy. The policy in the string identifies who can access or manage this secret and its versions. For information on how to format a JSON parameter for the various command line tool environments, see Using JSON for Parameters (http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json) in the CLI User Guide.
   * ResourcePolicy is a required field
   *
   * @schema SecretSpecForProvider#resourcePolicy
   */
  readonly resourcePolicy?: string;

  /**
   * StringSecretRef points to the Kubernetes Secret whose data will be sent as string to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
   *
   * @schema SecretSpecForProvider#stringSecretRef
   */
  readonly stringSecretRef?: SecretSpecForProviderStringSecretRef;

  /**
   * (Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list of tags. To remove tags, you must use UntagResource.
   * * Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag from one with key "abc".
   * * If you check tags in IAM policy Condition elements as part of your security strategy, then adding or removing a tag can change permissions. If the successful completion of this operation would result in you losing your permissions for this secret, then this operation is blocked and returns an Access Denied error.
   * This parameter requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see Using JSON for Parameters (https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json) in the AWS CLI User Guide. For example:
   * [{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]
   * If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text.
   * The following basic restrictions apply to tags:
   * * Maximum number of tags per secret—50
   * * Maximum key length—127 Unicode characters in UTF-8
   * * Maximum value length—255 Unicode characters in UTF-8
   * * Tag keys and values are case sensitive.
   * * Do not use the aws: prefix in your tag names or values because AWS reserves it for AWS use. You can't edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit.
   * * If you use your tagging schema across multiple services and resources, remember other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.
   *
   * @schema SecretSpecForProvider#tags
   */
  readonly tags?: SecretSpecForProviderTags[];

}

/**
 * Converts an object of type 'SecretSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProvider(obj: SecretSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binarySecretRef': toJson_SecretSpecForProviderBinarySecretRef(obj.binarySecretRef),
    'description': obj.description,
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIDRef': toJson_SecretSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIDSelector': toJson_SecretSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'recoveryWindowInDays': obj.recoveryWindowInDays,
    'region': obj.region,
    'resourcePolicy': obj.resourcePolicy,
    'stringSecretRef': toJson_SecretSpecForProviderStringSecretRef(obj.stringSecretRef),
    'tags': obj.tags?.map(y => toJson_SecretSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecretSpecManagementPolicies
 */
export enum SecretSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretSpecProviderConfigRef
 */
export interface SecretSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecProviderConfigRef#policy
   */
  readonly policy?: SecretSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRef(obj: SecretSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretSpecPublishConnectionDetailsTo
 */
export interface SecretSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsTo(obj: SecretSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretSpecWriteConnectionSecretToRef
 */
export interface SecretSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecWriteConnectionSecretToRef(obj: SecretSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BinarySecretRef points to the Kubernetes Secret whose data will be encoded as binary data to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
 *
 * @schema SecretSpecForProviderBinarySecretRef
 */
export interface SecretSpecForProviderBinarySecretRef {
  /**
   * Key whose value will be used. If not given, the whole map in the Secret data will be used.
   *
   * @schema SecretSpecForProviderBinarySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the secret.
   *
   * @schema SecretSpecForProviderBinarySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretSpecForProviderBinarySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderBinarySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderBinarySecretRef(obj: SecretSpecForProviderBinarySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to an kms/v1alpha1.Key used to set the KMSKeyID field.
 *
 * @schema SecretSpecForProviderKmsKeyIdRef
 */
export interface SecretSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: SecretSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdRef(obj: SecretSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects references to kms/v1alpha1.Key used to set the KMSKeyID.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelector
 */
export interface SecretSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: SecretSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdSelector(obj: SecretSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StringSecretRef points to the Kubernetes Secret whose data will be sent as string to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
 *
 * @schema SecretSpecForProviderStringSecretRef
 */
export interface SecretSpecForProviderStringSecretRef {
  /**
   * Key whose value will be used. If not given, the whole map in the Secret data will be used.
   *
   * @schema SecretSpecForProviderStringSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the secret.
   *
   * @schema SecretSpecForProviderStringSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretSpecForProviderStringSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderStringSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderStringSecretRef(obj: SecretSpecForProviderStringSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderTags
 */
export interface SecretSpecForProviderTags {
  /**
   * @schema SecretSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema SecretSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderTags(obj: SecretSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecProviderConfigRefPolicy
 */
export interface SecretSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRefPolicy(obj: SecretSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj: SecretSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretSpecPublishConnectionDetailsToMetadata
 */
export interface SecretSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToMetadata(obj: SecretSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicy
 */
export interface SecretSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: SecretSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: SecretSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdRefPolicy(obj: SecretSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface SecretSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdSelectorPolicy(obj: SecretSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolution
 */
export enum SecretSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolve
 */
export enum SecretSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum SecretSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum SecretSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum SecretSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum SecretSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Secret is the Schema for the Secrets API
 *
 * @schema SecretV1Beta1
 */
export class SecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.crossplane.io/v1beta1',
    kind: 'Secret',
  }

  /**
   * Renders a Kubernetes manifest for "SecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretV1Beta1Props): any {
    return {
      ...SecretV1Beta1.GVK,
      ...toJson_SecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "SecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretV1Beta1Props) {
    super(scope, id, {
      ...SecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretV1Beta1.GVK,
      ...toJson_SecretV1Beta1Props(resolved),
    };
  }
}

/**
 * Secret is the Schema for the Secrets API
 *
 * @schema SecretV1Beta1
 */
export interface SecretV1Beta1Props {
  /**
   * @schema SecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretSpec defines the desired state of Secret
   *
   * @schema SecretV1Beta1#spec
   */
  readonly spec: SecretV1Beta1Spec;

}

/**
 * Converts an object of type 'SecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1Props(obj: SecretV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretSpec defines the desired state of Secret
 *
 * @schema SecretV1Beta1Spec
 */
export interface SecretV1Beta1Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: SecretV1Beta1SpecDeletionPolicy;

  /**
   * SecretParameters defines the desired state of Secret
   *
   * @schema SecretV1Beta1Spec#forProvider
   */
  readonly forProvider: SecretV1Beta1SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecretV1Beta1Spec#managementPolicies
   */
  readonly managementPolicies?: SecretV1Beta1SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: SecretV1Beta1SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1Spec(obj: SecretV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretV1Beta1SpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecretV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecretV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretV1Beta1SpecDeletionPolicy
 */
export enum SecretV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecretParameters defines the desired state of Secret
 *
 * @schema SecretV1Beta1SpecForProvider
 */
export interface SecretV1Beta1SpecForProvider {
  /**
   * A list of Regions and KMS keys to replicate secrets.
   *
   * @schema SecretV1Beta1SpecForProvider#addReplicaRegions
   */
  readonly addReplicaRegions?: SecretV1Beta1SpecForProviderAddReplicaRegions[];

  /**
   * BinarySecretRef points to the Kubernetes Secret whose data will be encoded as binary data to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
   *
   * @schema SecretV1Beta1SpecForProvider#binarySecretRef
   */
  readonly binarySecretRef?: SecretV1Beta1SpecForProviderBinarySecretRef;

  /**
   * The description of the secret.
   *
   * @schema SecretV1Beta1SpecForProvider#description
   */
  readonly description?: string;

  /**
   * (Optional) Specifies that the secret is to be deleted without any recovery window. You can't use both this parameter and the RecoveryWindowInDays parameter in the same API call.
   * An asynchronous background process performs the actual deletion, so there can be a short delay before the operation completes. If you write code to delete and then immediately recreate a secret with the same name, ensure that your code includes appropriate back off and retry logic.
   * Use this parameter with caution. This parameter causes the operation to skip the normal waiting period before the permanent deletion that AWS would normally impose with the RecoveryWindowInDays parameter. If you delete a secret with the ForceDeleteWithouRecovery parameter, then you have no opportunity to recover the secret. It is permanently lost.
   *
   * @schema SecretV1Beta1SpecForProvider#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * Specifies whether to overwrite a secret with the same name in the destination Region. By default, secrets aren't overwritten.
   *
   * @schema SecretV1Beta1SpecForProvider#forceOverwriteReplicaSecret
   */
  readonly forceOverwriteReplicaSecret?: boolean;

  /**
   * The ARN, key ID, or alias of the KMS key that Secrets Manager uses to encrypt the secret value in the secret. An alias is always prefixed by alias/, for example alias/aws/secretsmanager. For more information, see About aliases (https://docs.aws.amazon.com/kms/latest/developerguide/alias-about.html).
   * To use a KMS key in a different account, use the key ARN or the alias ARN.
   * If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If that key doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.
   * If the secret is in a different Amazon Web Services account from the credentials calling the API, then you can't use aws/secretsmanager to encrypt the secret, and you must create and use a customer managed KMS key.
   *
   * @schema SecretV1Beta1SpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to an kms/v1alpha1.Key used to set the KMSKeyID field.
   *
   * @schema SecretV1Beta1SpecForProvider#kmsKeyIDRef
   */
  readonly kmsKeyIdRef?: SecretV1Beta1SpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects references to kms/v1alpha1.Key used to set the KMSKeyID.
   *
   * @schema SecretV1Beta1SpecForProvider#kmsKeyIDSelector
   */
  readonly kmsKeyIdSelector?: SecretV1Beta1SpecForProviderKmsKeyIdSelector;

  /**
   * (Optional) Specifies the number of days that Secrets Manager waits before it can delete the secret. You can't use both this parameter and the ForceDeleteWithoutRecovery parameter in the same API call.
   * This value can range from 7 to 30 days. The default value is 30.
   *
   * @schema SecretV1Beta1SpecForProvider#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

  /**
   * Region is which region the Secret will be created.
   *
   * @schema SecretV1Beta1SpecForProvider#region
   */
  readonly region: string;

  /**
   * A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services resource-based policy. The policy in the string identifies who can access or manage this secret and its versions. For information on how to format a JSON parameter for the various command line tool environments, see Using JSON for Parameters (http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json) in the CLI User Guide.
   * ResourcePolicy is a required field
   *
   * @schema SecretV1Beta1SpecForProvider#resourcePolicy
   */
  readonly resourcePolicy?: string;

  /**
   * StringSecretRef points to the Kubernetes Secret whose data will be sent as string to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
   *
   * @schema SecretV1Beta1SpecForProvider#stringSecretRef
   */
  readonly stringSecretRef?: SecretV1Beta1SpecForProviderStringSecretRef;

  /**
   * A list of tags to attach to the secret. Each tag is a key and value pair of strings in a JSON text string, for example:
   * [{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]
   * Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag from one with key "abc".
   * If you check tags in permissions policies as part of your security strategy, then adding or removing a tag can change permissions. If the completion of this operation would result in you losing your permissions for this secret, then Secrets Manager blocks the operation and returns an Access Denied error. For more information, see Control access to secrets using tags (https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#tag-secrets-abac) and Limit access to identities with tags that match secrets' tags (https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_tags2).
   * For information about how to format a JSON parameter for the various command line tool environments, see Using JSON for Parameters (https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json). If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text.
   * The following restrictions apply to tags:
   * * Maximum number of tags per secret: 50
   * * Maximum key length: 127 Unicode characters in UTF-8
   * * Maximum value length: 255 Unicode characters in UTF-8
   * * Tag keys and values are case sensitive.
   * * Do not use the aws: prefix in your tag names or values because Amazon Web Services reserves it for Amazon Web Services use. You can't edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit.
   * * If you use your tagging schema across multiple services and resources, other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.
   *
   * @schema SecretV1Beta1SpecForProvider#tags
   */
  readonly tags?: SecretV1Beta1SpecForProviderTags[];

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProvider(obj: SecretV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addReplicaRegions': obj.addReplicaRegions?.map(y => toJson_SecretV1Beta1SpecForProviderAddReplicaRegions(y)),
    'binarySecretRef': toJson_SecretV1Beta1SpecForProviderBinarySecretRef(obj.binarySecretRef),
    'description': obj.description,
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'forceOverwriteReplicaSecret': obj.forceOverwriteReplicaSecret,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIDRef': toJson_SecretV1Beta1SpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIDSelector': toJson_SecretV1Beta1SpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'recoveryWindowInDays': obj.recoveryWindowInDays,
    'region': obj.region,
    'resourcePolicy': obj.resourcePolicy,
    'stringSecretRef': toJson_SecretV1Beta1SpecForProviderStringSecretRef(obj.stringSecretRef),
    'tags': obj.tags?.map(y => toJson_SecretV1Beta1SpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecretV1Beta1SpecManagementPolicies
 */
export enum SecretV1Beta1SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretV1Beta1SpecProviderConfigRef
 */
export interface SecretV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: SecretV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecProviderConfigRef(obj: SecretV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsTo
 */
export interface SecretV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecPublishConnectionDetailsTo(obj: SecretV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretV1Beta1SpecWriteConnectionSecretToRef
 */
export interface SecretV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecWriteConnectionSecretToRef(obj: SecretV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretV1Beta1SpecForProviderAddReplicaRegions
 */
export interface SecretV1Beta1SpecForProviderAddReplicaRegions {
  /**
   * @schema SecretV1Beta1SpecForProviderAddReplicaRegions#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * @schema SecretV1Beta1SpecForProviderAddReplicaRegions#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderAddReplicaRegions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderAddReplicaRegions(obj: SecretV1Beta1SpecForProviderAddReplicaRegions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyID': obj.kmsKeyId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BinarySecretRef points to the Kubernetes Secret whose data will be encoded as binary data to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
 *
 * @schema SecretV1Beta1SpecForProviderBinarySecretRef
 */
export interface SecretV1Beta1SpecForProviderBinarySecretRef {
  /**
   * Key whose value will be used. If not given, the whole map in the Secret data will be used.
   *
   * @schema SecretV1Beta1SpecForProviderBinarySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the secret.
   *
   * @schema SecretV1Beta1SpecForProviderBinarySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretV1Beta1SpecForProviderBinarySecretRef#namespace
   */
  readonly namespace: string;

  /**
   * Type of the secret. Used to (re)create k8s secret in case of loss. If not given, the controller will try to fetch the type from the referenced secret.
   *
   * @schema SecretV1Beta1SpecForProviderBinarySecretRef#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderBinarySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderBinarySecretRef(obj: SecretV1Beta1SpecForProviderBinarySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to an kms/v1alpha1.Key used to set the KMSKeyID field.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdRef
 */
export interface SecretV1Beta1SpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderKmsKeyIdRef(obj: SecretV1Beta1SpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects references to kms/v1alpha1.Key used to set the KMSKeyID.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelector
 */
export interface SecretV1Beta1SpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderKmsKeyIdSelector(obj: SecretV1Beta1SpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StringSecretRef points to the Kubernetes Secret whose data will be sent as string to AWS. If key parameter is given, only the value of that key will be used. Otherwise, all data in the Secret will be marshalled into JSON and sent to AWS. Either StringSecretRef or BinarySecretRef must be set, but not both.
 *
 * @schema SecretV1Beta1SpecForProviderStringSecretRef
 */
export interface SecretV1Beta1SpecForProviderStringSecretRef {
  /**
   * Key whose value will be used. If not given, the whole map in the Secret data will be used.
   *
   * @schema SecretV1Beta1SpecForProviderStringSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the secret.
   *
   * @schema SecretV1Beta1SpecForProviderStringSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretV1Beta1SpecForProviderStringSecretRef#namespace
   */
  readonly namespace: string;

  /**
   * Type of the secret. Used to (re)create k8s secret in case of loss. If not given, the controller will try to fetch the type from the referenced secret.
   *
   * @schema SecretV1Beta1SpecForProviderStringSecretRef#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderStringSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderStringSecretRef(obj: SecretV1Beta1SpecForProviderStringSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretV1Beta1SpecForProviderTags
 */
export interface SecretV1Beta1SpecForProviderTags {
  /**
   * @schema SecretV1Beta1SpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema SecretV1Beta1SpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderTags(obj: SecretV1Beta1SpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretV1Beta1SpecProviderConfigRefPolicy
 */
export interface SecretV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecProviderConfigRefPolicy(obj: SecretV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface SecretV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: SecretV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface SecretV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecPublishConnectionDetailsToMetadata(obj: SecretV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy
 */
export interface SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy(obj: SecretV1Beta1SpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy
 */
export interface SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy(obj: SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum SecretV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum SecretV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum SecretV1Beta1SpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum SecretV1Beta1SpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

