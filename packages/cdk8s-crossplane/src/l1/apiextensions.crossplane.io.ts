// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A CompositeResourceDefinition defines a new kind of composite infrastructure
resource. The new resource is composed of other composite or managed
infrastructure resources.
 *
 * @schema CompositeResourceDefinition
 */
export class CompositeResourceDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositeResourceDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'CompositeResourceDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "CompositeResourceDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositeResourceDefinitionProps = {}): any {
    return {
      ...CompositeResourceDefinition.GVK,
      ...toJson_CompositeResourceDefinitionProps(props),
    };
  }

  /**
   * Defines a "CompositeResourceDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositeResourceDefinitionProps = {}) {
    super(scope, id, {
      ...CompositeResourceDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositeResourceDefinition.GVK,
      ...toJson_CompositeResourceDefinitionProps(resolved),
    };
  }
}

/**
 * A CompositeResourceDefinition defines a new kind of composite infrastructure
 * resource. The new resource is composed of other composite or managed
 * infrastructure resources.
 *
 * @schema CompositeResourceDefinition
 */
export interface CompositeResourceDefinitionProps {
  /**
   * @schema CompositeResourceDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositeResourceDefinitionSpec specifies the desired state of the definition.
   *
   * @schema CompositeResourceDefinition#spec
   */
  readonly spec?: CompositeResourceDefinitionSpec;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionProps(obj: CompositeResourceDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositeResourceDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeResourceDefinitionSpec specifies the desired state of the definition.
 *
 * @schema CompositeResourceDefinitionSpec
 */
export interface CompositeResourceDefinitionSpec {
  /**
   * ClaimNames specifies the names of an optional composite resource claim.
   * When claim names are specified Crossplane will create a namespaced
   * 'composite resource claim' CRD that corresponds to the defined composite
   * resource. This composite resource claim acts as a namespaced proxy for
   * the composite resource; creating, updating, or deleting the claim will
   * create, update, or delete a corresponding composite resource. You may add
   * claim names to an existing CompositeResourceDefinition, but they cannot
   * be changed or removed once they have been set.
   *
   * @schema CompositeResourceDefinitionSpec#claimNames
   */
  readonly claimNames?: CompositeResourceDefinitionSpecClaimNames;

  /**
   * ConnectionSecretKeys is the list of keys that will be exposed to the end
   * user of the defined kind.
   * If the list is empty, all keys will be published.
   *
   * @schema CompositeResourceDefinitionSpec#connectionSecretKeys
   */
  readonly connectionSecretKeys?: string[];

  /**
   * Conversion defines all conversion settings for the defined Composite resource.
   *
   * @schema CompositeResourceDefinitionSpec#conversion
   */
  readonly conversion?: CompositeResourceDefinitionSpecConversion;

  /**
   * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
   * that is associated with the Claim if no policy has been specified.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositeDeletePolicy
   */
  readonly defaultCompositeDeletePolicy?: CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy;

  /**
   * DefaultCompositionRef refers to the Composition resource that will be used
   * in case no composition selector is given.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositionRef
   */
  readonly defaultCompositionRef?: CompositeResourceDefinitionSpecDefaultCompositionRef;

  /**
   * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
   * Composition Revision has been created if no policy has been specified on the composite.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositionUpdatePolicy
   */
  readonly defaultCompositionUpdatePolicy?: CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy;

  /**
   * EnforcedCompositionRef refers to the Composition resource that will be used
   * by all composite instances whose schema is defined by this definition.
   *
   * @schema CompositeResourceDefinitionSpec#enforcedCompositionRef
   */
  readonly enforcedCompositionRef?: CompositeResourceDefinitionSpecEnforcedCompositionRef;

  /**
   * Group specifies the API group of the defined composite resource.
   * Composite resources are served under `/apis/<group>/...`. Must match the
   * name of the XRD (in the form `<names.plural>.<group>`).
   *
   * @schema CompositeResourceDefinitionSpec#group
   */
  readonly group: string;

  /**
   * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
   *
   * @schema CompositeResourceDefinitionSpec#metadata
   */
  readonly metadata?: CompositeResourceDefinitionSpecMetadata;

  /**
   * Names specifies the resource and kind names of the defined composite
   * resource.
   *
   * @schema CompositeResourceDefinitionSpec#names
   */
  readonly names: CompositeResourceDefinitionSpecNames;

  /**
   * Versions is the list of all API versions of the defined composite
   * resource. Version names are used to compute the order in which served
   * versions are listed in API discovery. If the version string is
   * "kube-like", it will sort above non "kube-like" version strings, which
   * are ordered lexicographically. "Kube-like" versions start with a "v",
   * then are followed by a number (the major version), then optionally the
   * string "alpha" or "beta" and another number (the minor version). These
   * are sorted first by GA > beta > alpha (where GA is a version with no
   * suffix such as beta or alpha), and then by comparing major version, then
   * minor version. An example sorted list of versions: v10, v2, v1, v11beta2,
   * v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
   *
   * @schema CompositeResourceDefinitionSpec#versions
   */
  readonly versions: CompositeResourceDefinitionSpecVersions[];

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpec(obj: CompositeResourceDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimNames': toJson_CompositeResourceDefinitionSpecClaimNames(obj.claimNames),
    'connectionSecretKeys': obj.connectionSecretKeys?.map(y => y),
    'conversion': toJson_CompositeResourceDefinitionSpecConversion(obj.conversion),
    'defaultCompositeDeletePolicy': obj.defaultCompositeDeletePolicy,
    'defaultCompositionRef': toJson_CompositeResourceDefinitionSpecDefaultCompositionRef(obj.defaultCompositionRef),
    'defaultCompositionUpdatePolicy': obj.defaultCompositionUpdatePolicy,
    'enforcedCompositionRef': toJson_CompositeResourceDefinitionSpecEnforcedCompositionRef(obj.enforcedCompositionRef),
    'group': obj.group,
    'metadata': toJson_CompositeResourceDefinitionSpecMetadata(obj.metadata),
    'names': toJson_CompositeResourceDefinitionSpecNames(obj.names),
    'versions': obj.versions?.map(y => toJson_CompositeResourceDefinitionSpecVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClaimNames specifies the names of an optional composite resource claim.
 * When claim names are specified Crossplane will create a namespaced
 * 'composite resource claim' CRD that corresponds to the defined composite
 * resource. This composite resource claim acts as a namespaced proxy for
 * the composite resource; creating, updating, or deleting the claim will
 * create, update, or delete a corresponding composite resource. You may add
 * claim names to an existing CompositeResourceDefinition, but they cannot
 * be changed or removed once they have been set.
 *
 * @schema CompositeResourceDefinitionSpecClaimNames
 */
export interface CompositeResourceDefinitionSpecClaimNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionSpecClaimNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionSpecClaimNames#singular
   */
  readonly singular?: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecClaimNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecClaimNames(obj: CompositeResourceDefinitionSpecClaimNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Conversion defines all conversion settings for the defined Composite resource.
 *
 * @schema CompositeResourceDefinitionSpecConversion
 */
export interface CompositeResourceDefinitionSpecConversion {
  /**
   * strategy specifies how custom resources are converted between versions. Allowed values are:
   * - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource.
   * - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
   * is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
   *
   * @schema CompositeResourceDefinitionSpecConversion#strategy
   */
  readonly strategy: string;

  /**
   * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
   *
   * @schema CompositeResourceDefinitionSpecConversion#webhook
   */
  readonly webhook?: CompositeResourceDefinitionSpecConversionWebhook;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecConversion(obj: CompositeResourceDefinitionSpecConversion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'webhook': toJson_CompositeResourceDefinitionSpecConversionWebhook(obj.webhook),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
 * that is associated with the Claim if no policy has been specified.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy
 */
export enum CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy {
  /** Background */
  BACKGROUND = "Background",
  /** Foreground */
  FOREGROUND = "Foreground",
}

/**
 * DefaultCompositionRef refers to the Composition resource that will be used
 * in case no composition selector is given.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositionRef
 */
export interface CompositeResourceDefinitionSpecDefaultCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionSpecDefaultCompositionRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecDefaultCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecDefaultCompositionRef(obj: CompositeResourceDefinitionSpecDefaultCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
 * Composition Revision has been created if no policy has been specified on the composite.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy
 */
export enum CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy {
  /** Automatic */
  AUTOMATIC = "Automatic",
  /** Manual */
  MANUAL = "Manual",
}

/**
 * EnforcedCompositionRef refers to the Composition resource that will be used
 * by all composite instances whose schema is defined by this definition.
 *
 * @schema CompositeResourceDefinitionSpecEnforcedCompositionRef
 */
export interface CompositeResourceDefinitionSpecEnforcedCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionSpecEnforcedCompositionRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecEnforcedCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecEnforcedCompositionRef(obj: CompositeResourceDefinitionSpecEnforcedCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
 *
 * @schema CompositeResourceDefinitionSpecMetadata
 */
export interface CompositeResourceDefinitionSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema CompositeResourceDefinitionSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   * and services.
   * These labels are added to the composite resource and claim CRD's in addition
   * to any labels defined by `CompositionResourceDefinition` `metadata.labels`.
   *
   * @schema CompositeResourceDefinitionSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecMetadata(obj: CompositeResourceDefinitionSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Names specifies the resource and kind names of the defined composite
 * resource.
 *
 * @schema CompositeResourceDefinitionSpecNames
 */
export interface CompositeResourceDefinitionSpecNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionSpecNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionSpecNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionSpecNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionSpecNames#singular
   */
  readonly singular?: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecNames(obj: CompositeResourceDefinitionSpecNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeResourceDefinitionVersion describes a version of an XR.
 *
 * @schema CompositeResourceDefinitionSpecVersions
 */
export interface CompositeResourceDefinitionSpecVersions {
  /**
   * AdditionalPrinterColumns specifies additional columns returned in Table
   * output. If no columns are specified, a single column displaying the age
   * of the custom resource is used. See the following link for details:
   * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
   *
   * @schema CompositeResourceDefinitionSpecVersions#additionalPrinterColumns
   */
  readonly additionalPrinterColumns?: CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns[];

  /**
   * The deprecated field specifies that this version is deprecated and should
   * not be used.
   *
   * @schema CompositeResourceDefinitionSpecVersions#deprecated
   */
  readonly deprecated?: boolean;

  /**
   * DeprecationWarning specifies the message that should be shown to the user
   * when using this version.
   *
   * @schema CompositeResourceDefinitionSpecVersions#deprecationWarning
   */
  readonly deprecationWarning?: string;

  /**
   * Name of this version, e.g. “v1”, “v2beta1”, etc. Composite resources are
   * served under this version at `/apis/<group>/<version>/...` if `served` is
   * true.
   *
   * @schema CompositeResourceDefinitionSpecVersions#name
   */
  readonly name: string;

  /**
   * Referenceable specifies that this version may be referenced by a
   * Composition in order to configure which resources an XR may be composed
   * of. Exactly one version must be marked as referenceable; all Compositions
   * must target only the referenceable version. The referenceable version
   * must be served. It's mapped to the CRD's `spec.versions[*].storage` field.
   *
   * @schema CompositeResourceDefinitionSpecVersions#referenceable
   */
  readonly referenceable: boolean;

  /**
   * Schema describes the schema used for validation, pruning, and defaulting
   * of this version of the defined composite resource. Fields required by all
   * composite resources will be injected into this schema automatically, and
   * will override equivalently named fields in this schema. Omitting this
   * schema results in a schema that contains only the fields required by all
   * composite resources.
   *
   * @schema CompositeResourceDefinitionSpecVersions#schema
   */
  readonly schema?: CompositeResourceDefinitionSpecVersionsSchema;

  /**
   * Served specifies that this version should be served via REST APIs.
   *
   * @schema CompositeResourceDefinitionSpecVersions#served
   */
  readonly served: boolean;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecVersions(obj: CompositeResourceDefinitionSpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPrinterColumns': obj.additionalPrinterColumns?.map(y => toJson_CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns(y)),
    'deprecated': obj.deprecated,
    'deprecationWarning': obj.deprecationWarning,
    'name': obj.name,
    'referenceable': obj.referenceable,
    'schema': toJson_CompositeResourceDefinitionSpecVersionsSchema(obj.schema),
    'served': obj.served,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhook
 */
export interface CompositeResourceDefinitionSpecConversionWebhook {
  /**
   * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhook#clientConfig
   */
  readonly clientConfig?: CompositeResourceDefinitionSpecConversionWebhookClientConfig;

  /**
   * conversionReviewVersions is an ordered list of preferred `ConversionReview`
   * versions the Webhook expects. The API server will use the first version in
   * the list which it supports. If none of the versions specified in this list
   * are supported by API server, conversion will fail for the custom resource.
   * If a persisted Webhook configuration specifies allowed versions and does not
   * include any versions known to the API Server, calls to the webhook will fail.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhook#conversionReviewVersions
   */
  readonly conversionReviewVersions: string[];

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhook(obj: CompositeResourceDefinitionSpecConversionWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientConfig': toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfig(obj.clientConfig),
    'conversionReviewVersions': obj.conversionReviewVersions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomResourceColumnDefinition specifies a column for server side printing.
 *
 * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns
 */
export interface CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns {
  /**
   * description is a human readable description of this column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#description
   */
  readonly description?: string;

  /**
   * format is an optional OpenAPI type definition for this column. The 'name' format is applied
   * to the primary identifier column to assist in clients identifying column is the resource name.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#format
   */
  readonly format?: string;

  /**
   * jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
   * each custom resource to produce the value for this column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#jsonPath
   */
  readonly jsonPath: string;

  /**
   * name is a human readable name for the column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#name
   */
  readonly name: string;

  /**
   * priority is an integer defining the relative importance of this column compared to others. Lower
   * numbers are considered higher priority. Columns that may be omitted in limited space scenarios
   * should be given a priority greater than 0.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#priority
   */
  readonly priority?: number;

  /**
   * type is an OpenAPI type definition for this column.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns(obj: CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'format': obj.format,
    'jsonPath': obj.jsonPath,
    'name': obj.name,
    'priority': obj.priority,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Schema describes the schema used for validation, pruning, and defaulting
 * of this version of the defined composite resource. Fields required by all
 * composite resources will be injected into this schema automatically, and
 * will override equivalently named fields in this schema. Omitting this
 * schema results in a schema that contains only the fields required by all
 * composite resources.
 *
 * @schema CompositeResourceDefinitionSpecVersionsSchema
 */
export interface CompositeResourceDefinitionSpecVersionsSchema {
  /**
   * OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and
   * pruning.
   *
   * @schema CompositeResourceDefinitionSpecVersionsSchema#openAPIV3Schema
   */
  readonly openApiv3Schema?: any;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersionsSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecVersionsSchema(obj: CompositeResourceDefinitionSpecVersionsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openAPIV3Schema': obj.openApiv3Schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig
 */
export interface CompositeResourceDefinitionSpecConversionWebhookClientConfig {
  /**
   * caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
   * If unspecified, system trust roots on the apiserver are used.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#caBundle
   */
  readonly caBundle?: string;

  /**
   * service is a reference to the service for this webhook. Either
   * service or url must be specified.
   *
   *
   * If the webhook is running within the cluster, then you should use `service`.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#service
   */
  readonly service?: CompositeResourceDefinitionSpecConversionWebhookClientConfigService;

  /**
   * url gives the location of the webhook, in standard URL form
   * (`scheme://host:port/path`). Exactly one of `url` or `service`
   * must be specified.
   *
   *
   * The `host` should not refer to a service running in the cluster; use
   * the `service` field instead. The host might be resolved via external
   * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
   * in-cluster DNS as that would be a layering violation). `host` may
   * also be an IP address.
   *
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is
   * risky unless you take great care to run this webhook on all hosts
   * which run an apiserver which might need to make calls to this
   * webhook. Such installs are likely to be non-portable, i.e., not easy
   * to turn up in a new cluster.
   *
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   *
   * A path is optional, and if present may be any string permissible in
   * a URL. You may use the path to pass an arbitrary string to the
   * webhook, for example, a cluster identifier.
   *
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not
   * allowed. Fragments ("#...") and query parameters ("?...") are not
   * allowed, either.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhookClientConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfig(obj: CompositeResourceDefinitionSpecConversionWebhookClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'service': toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfigService(obj.service),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * service is a reference to the service for this webhook. Either
 * service or url must be specified.
 *
 *
 * If the webhook is running within the cluster, then you should use `service`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService
 */
export interface CompositeResourceDefinitionSpecConversionWebhookClientConfigService {
  /**
   * name is the name of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#namespace
   */
  readonly namespace: string;

  /**
   * path is an optional URL path at which the webhook will be contacted.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#path
   */
  readonly path?: string;

  /**
   * port is an optional service port at which the webhook will be contacted.
   * `port` should be a valid port number (1-65535, inclusive).
   * Defaults to 443 for backward compatibility.
   *
   * @default 443 for backward compatibility.
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhookClientConfigService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfigService(obj: CompositeResourceDefinitionSpecConversionWebhookClientConfigService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Composition specifies how a composite resource should be composed.
 *
 * @schema Composition
 */
export class Composition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Composition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'Composition',
  }

  /**
   * Renders a Kubernetes manifest for "Composition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionProps = {}): any {
    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(props),
    };
  }

  /**
   * Defines a "Composition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionProps = {}) {
    super(scope, id, {
      ...Composition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(resolved),
    };
  }
}

/**
 * A Composition specifies how a composite resource should be composed.
 *
 * @schema Composition
 */
export interface CompositionProps {
  /**
   * @schema Composition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionSpec specifies desired state of a composition.
   *
   * @schema Composition#spec
   */
  readonly spec?: CompositionSpec;

}

/**
 * Converts an object of type 'CompositionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionProps(obj: CompositionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositionSpec specifies desired state of a composition.
 *
 * @schema CompositionSpec
 */
export interface CompositionSpec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionSpec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionSpecCompositeTypeRef;

  /**
   * Environment configures the environment in which resources are rendered.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionSpec#environment
   */
  readonly environment?: CompositionSpecEnvironment;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   *
   * "Resources" (the default) indicates that a Composition uses what is
   * commonly referred to as "Patch & Transform" or P&T composition. This mode
   * of Composition uses an array of resources, each a template for a composed
   * resource.
   *
   *
   * "Pipeline" indicates that a Composition specifies a pipeline
   * of Composition Functions, each of which is responsible for producing
   * composed resources that Crossplane should create or update. THE PIPELINE
   * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionSpec#mode
   */
  readonly mode?: CompositionSpecMode;

  /**
   * PatchSets define a named set of patches that may be included by any
   * resource in this Composition. PatchSets cannot themselves refer to other
   * PatchSets.
   *
   *
   * PatchSets are only used by the "Resources" mode of Composition. They
   * are ignored by other modes.
   *
   * @schema CompositionSpec#patchSets
   */
  readonly patchSets?: CompositionSpecPatchSets[];

  /**
   * Pipeline is a list of composition function steps that will be used when a
   * composite resource referring to this composition is created. One of
   * resources and pipeline must be specified - you cannot specify both.
   *
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   *
   * THIS IS A BETA FIELD. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionSpec#pipeline
   */
  readonly pipeline?: CompositionSpecPipeline[];

  /**
   * PublishConnectionDetailsWithStoreConfig specifies the secret store config
   * with which the connection details of composite resources dynamically
   * provisioned using this composition will be published.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionSpec#publishConnectionDetailsWithStoreConfigRef
   */
  readonly publishConnectionDetailsWithStoreConfigRef?: CompositionSpecPublishConnectionDetailsWithStoreConfigRef;

  /**
   * Resources is a list of resource templates that will be used when a
   * composite resource referring to this composition is created.
   *
   *
   * Resources are only used by the "Resources" mode of Composition. They are
   * ignored by other modes.
   *
   * @schema CompositionSpec#resources
   */
  readonly resources?: CompositionSpecResources[];

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
   * set independently and connection details would be published to both
   * without affecting each other as long as related fields at MR level
   * specified.
   *
   * @schema CompositionSpec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;

}

/**
 * Converts an object of type 'CompositionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpec(obj: CompositionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionSpecCompositeTypeRef(obj.compositeTypeRef),
    'environment': toJson_CompositionSpecEnvironment(obj.environment),
    'mode': obj.mode,
    'patchSets': obj.patchSets?.map(y => toJson_CompositionSpecPatchSets(y)),
    'pipeline': obj.pipeline?.map(y => toJson_CompositionSpecPipeline(y)),
    'publishConnectionDetailsWithStoreConfigRef': toJson_CompositionSpecPublishConnectionDetailsWithStoreConfigRef(obj.publishConnectionDetailsWithStoreConfigRef),
    'resources': obj.resources?.map(y => toJson_CompositionSpecResources(y)),
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionSpecCompositeTypeRef
 */
export interface CompositionSpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'CompositionSpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecCompositeTypeRef(obj: CompositionSpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment configures the environment in which resources are rendered.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionSpecEnvironment
 */
export interface CompositionSpecEnvironment {
  /**
   * DefaultData statically defines the initial state of the environment.
   * It has the same schema-less structure as the data field in
   * environment configs.
   * It is overwritten by the selected environment configs.
   *
   * @schema CompositionSpecEnvironment#defaultData
   */
  readonly defaultData?: { [key: string]: any };

  /**
   * EnvironmentConfigs selects a list of `EnvironmentConfig`s. The resolved
   * resources are stored in the composite resource at
   * `spec.environmentConfigRefs` and is only updated if it is null.
   *
   *
   * The list of references is used to compute an in-memory environment at
   * compose time. The data of all object is merged in the order they are
   * listed, meaning the values of EnvironmentConfigs with a larger index take
   * priority over ones with smaller indices.
   *
   *
   * The computed environment can be accessed in a composition using
   * `FromEnvironmentFieldPath` and `CombineFromEnvironment` patches.
   *
   * @schema CompositionSpecEnvironment#environmentConfigs
   */
  readonly environmentConfigs?: CompositionSpecEnvironmentEnvironmentConfigs[];

  /**
   * Patches is a list of environment patches that are executed before a
   * composition's resources are composed.
   *
   * @schema CompositionSpecEnvironment#patches
   */
  readonly patches?: CompositionSpecEnvironmentPatches[];

  /**
   * Policy represents the Resolve and Resolution policies which apply to
   * all EnvironmentSourceReferences in EnvironmentConfigs list.
   *
   * @schema CompositionSpecEnvironment#policy
   */
  readonly policy?: CompositionSpecEnvironmentPolicy;

}

/**
 * Converts an object of type 'CompositionSpecEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironment(obj: CompositionSpecEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultData': ((obj.defaultData) === undefined) ? undefined : (Object.entries(obj.defaultData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'environmentConfigs': obj.environmentConfigs?.map(y => toJson_CompositionSpecEnvironmentEnvironmentConfigs(y)),
    'patches': obj.patches?.map(y => toJson_CompositionSpecEnvironmentPatches(y)),
    'policy': toJson_CompositionSpecEnvironmentPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 *
 * "Resources" (the default) indicates that a Composition uses what is
 * commonly referred to as "Patch & Transform" or P&T composition. This mode
 * of Composition uses an array of resources, each a template for a composed
 * resource.
 *
 *
 * "Pipeline" indicates that a Composition specifies a pipeline
 * of Composition Functions, each of which is responsible for producing
 * composed resources that Crossplane should create or update. THE PIPELINE
 * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
 * feature flag is disabled.
 *
 * @schema CompositionSpecMode
 */
export enum CompositionSpecMode {
  /** Resources */
  RESOURCES = "Resources",
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PatchSet is a set of patches that can be reused from all resources within
 * a Composition.
 *
 * @schema CompositionSpecPatchSets
 */
export interface CompositionSpecPatchSets {
  /**
   * Name of this PatchSet.
   *
   * @schema CompositionSpecPatchSets#name
   */
  readonly name: string;

  /**
   * Patches will be applied as an overlay to the base resource.
   *
   * @schema CompositionSpecPatchSets#patches
   */
  readonly patches: CompositionSpecPatchSetsPatches[];

}

/**
 * Converts an object of type 'CompositionSpecPatchSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSets(obj: CompositionSpecPatchSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionSpecPatchSetsPatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A PipelineStep in a Composition Function pipeline.
 *
 * @schema CompositionSpecPipeline
 */
export interface CompositionSpecPipeline {
  /**
   * FunctionRef is a reference to the Composition Function this step should
   * execute.
   *
   * @schema CompositionSpecPipeline#functionRef
   */
  readonly functionRef: CompositionSpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the Composition
   * Function as the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionSpecPipeline#input
   */
  readonly input?: any;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionSpecPipeline#step
   */
  readonly step: string;

}

/**
 * Converts an object of type 'CompositionSpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPipeline(obj: CompositionSpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionRef': toJson_CompositionSpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsWithStoreConfig specifies the secret store config
 * with which the connection details of composite resources dynamically
 * provisioned using this composition will be published.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionSpecPublishConnectionDetailsWithStoreConfigRef
 */
export interface CompositionSpecPublishConnectionDetailsWithStoreConfigRef {
  /**
   * Name of the referenced StoreConfig.
   *
   * @schema CompositionSpecPublishConnectionDetailsWithStoreConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionSpecPublishConnectionDetailsWithStoreConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPublishConnectionDetailsWithStoreConfigRef(obj: CompositionSpecPublishConnectionDetailsWithStoreConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ComposedTemplate is used to provide information about how the composed resource
 * should be processed.
 *
 * @schema CompositionSpecResources
 */
export interface CompositionSpecResources {
  /**
   * Base is the target resource that the patches will be applied on.
   *
   * @schema CompositionSpecResources#base
   */
  readonly base: any;

  /**
   * ConnectionDetails lists the propagation secret keys from this target
   * resource to the composition instance connection secret.
   *
   * @schema CompositionSpecResources#connectionDetails
   */
  readonly connectionDetails?: CompositionSpecResourcesConnectionDetails[];

  /**
   * A Name uniquely identifies this entry within its Composition's resources
   * array. Names are optional but *strongly* recommended. When all entries in
   * the resources array are named entries may added, deleted, and reordered
   * as long as their names do not change. When entries are not named the
   * length and order of the resources array should be treated as immutable.
   * Either all or no entries must be named.
   *
   * @schema CompositionSpecResources#name
   */
  readonly name?: string;

  /**
   * Patches will be applied as overlay to the base resource.
   *
   * @schema CompositionSpecResources#patches
   */
  readonly patches?: CompositionSpecResourcesPatches[];

  /**
   * ReadinessChecks allows users to define custom readiness checks. All checks
   * have to return true in order for resource to be considered ready. The
   * default readiness check is to have the "Ready" condition to be "True".
   *
   * @schema CompositionSpecResources#readinessChecks
   */
  readonly readinessChecks?: CompositionSpecResourcesReadinessChecks[];

}

/**
 * Converts an object of type 'CompositionSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResources(obj: CompositionSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'connectionDetails': obj.connectionDetails?.map(y => toJson_CompositionSpecResourcesConnectionDetails(y)),
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionSpecResourcesPatches(y)),
    'readinessChecks': obj.readinessChecks?.map(y => toJson_CompositionSpecResourcesReadinessChecks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSource selects a EnvironmentConfig resource.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigs
 */
export interface CompositionSpecEnvironmentEnvironmentConfigs {
  /**
   * Ref is a named reference to a single EnvironmentConfig.
   * Either Ref or Selector is required.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigs#ref
   */
  readonly ref?: CompositionSpecEnvironmentEnvironmentConfigsRef;

  /**
   * Selector selects EnvironmentConfig(s) via labels.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigs#selector
   */
  readonly selector?: CompositionSpecEnvironmentEnvironmentConfigsSelector;

  /**
   * Type specifies the way the EnvironmentConfig is selected.
   * Default is `Reference`
   *
   * @default Reference`
   * @schema CompositionSpecEnvironmentEnvironmentConfigs#type
   */
  readonly type?: CompositionSpecEnvironmentEnvironmentConfigsType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentEnvironmentConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentEnvironmentConfigs(obj: CompositionSpecEnvironmentEnvironmentConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_CompositionSpecEnvironmentEnvironmentConfigsRef(obj.ref),
    'selector': toJson_CompositionSpecEnvironmentEnvironmentConfigsSelector(obj.selector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentPatch is a patch for a Composition environment.
 *
 * @schema CompositionSpecEnvironmentPatches
 */
export interface CompositionSpecEnvironmentPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite or
   * CombineToComposite patch.
   *
   * @schema CompositionSpecEnvironmentPatches#combine
   */
  readonly combine?: CompositionSpecEnvironmentPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath or
   * ToCompositeFieldPath.
   *
   * @schema CompositionSpecEnvironmentPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionSpecEnvironmentPatches#policy
   */
  readonly policy?: CompositionSpecEnvironmentPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionSpecEnvironmentPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionSpecEnvironmentPatches#transforms
   */
  readonly transforms?: CompositionSpecEnvironmentPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionSpecEnvironmentPatches#type
   */
  readonly type?: CompositionSpecEnvironmentPatchesType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatches(obj: CompositionSpecEnvironmentPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionSpecEnvironmentPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'policy': toJson_CompositionSpecEnvironmentPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionSpecEnvironmentPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy represents the Resolve and Resolution policies which apply to
 * all EnvironmentSourceReferences in EnvironmentConfigs list.
 *
 * @schema CompositionSpecEnvironmentPolicy
 */
export interface CompositionSpecEnvironmentPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CompositionSpecEnvironmentPolicy#resolution
   */
  readonly resolution?: CompositionSpecEnvironmentPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CompositionSpecEnvironmentPolicy#resolve
   */
  readonly resolve?: CompositionSpecEnvironmentPolicyResolve;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPolicy(obj: CompositionSpecEnvironmentPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionSpecPatchSetsPatches
 */
export interface CompositionSpecPatchSetsPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionSpecPatchSetsPatches#combine
   */
  readonly combine?: CompositionSpecPatchSetsPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionSpecPatchSetsPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionSpecPatchSetsPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionSpecPatchSetsPatches#policy
   */
  readonly policy?: CompositionSpecPatchSetsPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionSpecPatchSetsPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionSpecPatchSetsPatches#transforms
   */
  readonly transforms?: CompositionSpecPatchSetsPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionSpecPatchSetsPatches#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatches(obj: CompositionSpecPatchSetsPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionSpecPatchSetsPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionSpecPatchSetsPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionSpecPatchSetsPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionRef is a reference to the Composition Function this step should
 * execute.
 *
 * @schema CompositionSpecPipelineFunctionRef
 */
export interface CompositionSpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionSpecPipelineFunctionRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionSpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPipelineFunctionRef(obj: CompositionSpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionDetail includes the information about the propagation of the connection
 * information from one secret to another.
 *
 * @schema CompositionSpecResourcesConnectionDetails
 */
export interface CompositionSpecResourcesConnectionDetails {
  /**
   * FromConnectionSecretKey is the key that will be used to fetch the value
   * from the composed resource's connection secret.
   *
   * @schema CompositionSpecResourcesConnectionDetails#fromConnectionSecretKey
   */
  readonly fromConnectionSecretKey?: string;

  /**
   * FromFieldPath is the path of the field on the composed resource whose
   * value to be used as input. Name must be specified if the type is
   * FromFieldPath.
   *
   * @schema CompositionSpecResourcesConnectionDetails#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Name of the connection secret key that will be propagated to the
   * connection secret of the composition instance. Leave empty if you'd like
   * to use the same key name.
   *
   * @schema CompositionSpecResourcesConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Type sets the connection detail fetching behaviour to be used. Each
   * connection detail type may require its own fields to be set on the
   * ConnectionDetail object. If the type is omitted Crossplane will attempt
   * to infer it based on which other fields were specified. If multiple
   * fields are specified the order of precedence is:
   * 1. FromValue
   * 2. FromConnectionSecretKey
   * 3. FromFieldPath
   *
   * @schema CompositionSpecResourcesConnectionDetails#type
   */
  readonly type?: CompositionSpecResourcesConnectionDetailsType;

  /**
   * Value that will be propagated to the connection secret of the composite
   * resource. May be set to inject a fixed, non-sensitive connection secret
   * value, for example a well-known port.
   *
   * @schema CompositionSpecResourcesConnectionDetails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesConnectionDetails(obj: CompositionSpecResourcesConnectionDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromConnectionSecretKey': obj.fromConnectionSecretKey,
    'fromFieldPath': obj.fromFieldPath,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionSpecResourcesPatches
 */
export interface CompositionSpecResourcesPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionSpecResourcesPatches#combine
   */
  readonly combine?: CompositionSpecResourcesPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionSpecResourcesPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionSpecResourcesPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionSpecResourcesPatches#policy
   */
  readonly policy?: CompositionSpecResourcesPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionSpecResourcesPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionSpecResourcesPatches#transforms
   */
  readonly transforms?: CompositionSpecResourcesPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionSpecResourcesPatches#type
   */
  readonly type?: CompositionSpecResourcesPatchesType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatches(obj: CompositionSpecResourcesPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionSpecResourcesPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionSpecResourcesPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionSpecResourcesPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReadinessCheck is used to indicate how to tell whether a resource is ready
 * for consumption
 *
 * @schema CompositionSpecResourcesReadinessChecks
 */
export interface CompositionSpecResourcesReadinessChecks {
  /**
   * FieldPath shows the path of the field whose value will be used.
   *
   * @schema CompositionSpecResourcesReadinessChecks#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchCondition
   */
  readonly matchCondition?: CompositionSpecResourcesReadinessChecksMatchCondition;

  /**
   * MatchInt is the value you'd like to match if you're using "MatchInt" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchInteger
   */
  readonly matchInteger?: number;

  /**
   * MatchString is the value you'd like to match if you're using "MatchString" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchString
   */
  readonly matchString?: string;

  /**
   * Type indicates the type of probe you'd like to use.
   *
   * @schema CompositionSpecResourcesReadinessChecks#type
   */
  readonly type: CompositionSpecResourcesReadinessChecksType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesReadinessChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesReadinessChecks(obj: CompositionSpecResourcesReadinessChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'matchCondition': toJson_CompositionSpecResourcesReadinessChecksMatchCondition(obj.matchCondition),
    'matchInteger': obj.matchInteger,
    'matchString': obj.matchString,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ref is a named reference to a single EnvironmentConfig.
 * Either Ref or Selector is required.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsRef
 */
export interface CompositionSpecEnvironmentEnvironmentConfigsRef {
  /**
   * The name of the object.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentEnvironmentConfigsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentEnvironmentConfigsRef(obj: CompositionSpecEnvironmentEnvironmentConfigsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector selects EnvironmentConfig(s) via labels.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector
 */
export interface CompositionSpecEnvironmentEnvironmentConfigsSelector {
  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector#matchLabels
   */
  readonly matchLabels?: CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels[];

  /**
   * MaxMatch specifies the number of extracted EnvironmentConfigs in Multiple mode, extracts all if nil.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector#maxMatch
   */
  readonly maxMatch?: number;

  /**
   * MinMatch specifies the required minimum of extracted EnvironmentConfigs in Multiple mode.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector#minMatch
   */
  readonly minMatch?: number;

  /**
   * Mode specifies retrieval strategy: "Single" or "Multiple".
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector#mode
   */
  readonly mode?: CompositionSpecEnvironmentEnvironmentConfigsSelectorMode;

  /**
   * SortByFieldPath is the path to the field based on which list of EnvironmentConfigs is alphabetically sorted.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelector#sortByFieldPath
   */
  readonly sortByFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentEnvironmentConfigsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentEnvironmentConfigsSelector(obj: CompositionSpecEnvironmentEnvironmentConfigsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': obj.matchLabels?.map(y => toJson_CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels(y)),
    'maxMatch': obj.maxMatch,
    'minMatch': obj.minMatch,
    'mode': obj.mode,
    'sortByFieldPath': obj.sortByFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies the way the EnvironmentConfig is selected.
 * Default is `Reference`
 *
 * @default Reference`
 * @schema CompositionSpecEnvironmentEnvironmentConfigsType
 */
export enum CompositionSpecEnvironmentEnvironmentConfigsType {
  /** Reference */
  REFERENCE = "Reference",
  /** Selector */
  SELECTOR = "Selector",
}

/**
 * Combine is the patch configuration for a CombineFromComposite or
 * CombineToComposite patch.
 *
 * @schema CompositionSpecEnvironmentPatchesCombine
 */
export interface CompositionSpecEnvironmentPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionSpecEnvironmentPatchesCombine#strategy
   */
  readonly strategy: CompositionSpecEnvironmentPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionSpecEnvironmentPatchesCombine#string
   */
  readonly string?: CompositionSpecEnvironmentPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionSpecEnvironmentPatchesCombine#variables
   */
  readonly variables: CompositionSpecEnvironmentPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesCombine(obj: CompositionSpecEnvironmentPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionSpecEnvironmentPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionSpecEnvironmentPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionSpecEnvironmentPatchesPolicy
 */
export interface CompositionSpecEnvironmentPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionSpecEnvironmentPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionSpecEnvironmentPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionSpecEnvironmentPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionSpecEnvironmentPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesPolicy(obj: CompositionSpecEnvironmentPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionSpecEnvironmentPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionSpecEnvironmentPatchesTransforms
 */
export interface CompositionSpecEnvironmentPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#convert
   */
  readonly convert?: CompositionSpecEnvironmentPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#match
   */
  readonly match?: CompositionSpecEnvironmentPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#math
   */
  readonly math?: CompositionSpecEnvironmentPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#string
   */
  readonly string?: CompositionSpecEnvironmentPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionSpecEnvironmentPatchesTransforms#type
   */
  readonly type: CompositionSpecEnvironmentPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransforms(obj: CompositionSpecEnvironmentPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionSpecEnvironmentPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionSpecEnvironmentPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionSpecEnvironmentPatchesTransformsMath(obj.math),
    'string': toJson_CompositionSpecEnvironmentPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionSpecEnvironmentPatchesType
 */
export enum CompositionSpecEnvironmentPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CompositionSpecEnvironmentPolicyResolution
 */
export enum CompositionSpecEnvironmentPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CompositionSpecEnvironmentPolicyResolve
 */
export enum CompositionSpecEnvironmentPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionSpecPatchSetsPatchesCombine
 */
export interface CompositionSpecPatchSetsPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#strategy
   */
  readonly strategy: CompositionSpecPatchSetsPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#string
   */
  readonly string?: CompositionSpecPatchSetsPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#variables
   */
  readonly variables: CompositionSpecPatchSetsPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombine(obj: CompositionSpecPatchSetsPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionSpecPatchSetsPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionSpecPatchSetsPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionSpecPatchSetsPatchesPolicy
 */
export interface CompositionSpecPatchSetsPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionSpecPatchSetsPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionSpecPatchSetsPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionSpecPatchSetsPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionSpecPatchSetsPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesPolicy(obj: CompositionSpecPatchSetsPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionSpecPatchSetsPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionSpecPatchSetsPatchesTransforms
 */
export interface CompositionSpecPatchSetsPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#convert
   */
  readonly convert?: CompositionSpecPatchSetsPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#match
   */
  readonly match?: CompositionSpecPatchSetsPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#math
   */
  readonly math?: CompositionSpecPatchSetsPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#string
   */
  readonly string?: CompositionSpecPatchSetsPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#type
   */
  readonly type: CompositionSpecPatchSetsPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransforms(obj: CompositionSpecPatchSetsPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionSpecPatchSetsPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionSpecPatchSetsPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionSpecPatchSetsPatchesTransformsMath(obj.math),
    'string': toJson_CompositionSpecPatchSetsPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionSpecPatchSetsPatchesType
 */
export enum CompositionSpecPatchSetsPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * Type sets the connection detail fetching behaviour to be used. Each
 * connection detail type may require its own fields to be set on the
 * ConnectionDetail object. If the type is omitted Crossplane will attempt
 * to infer it based on which other fields were specified. If multiple
 * fields are specified the order of precedence is:
 * 1. FromValue
 * 2. FromConnectionSecretKey
 * 3. FromFieldPath
 *
 * @schema CompositionSpecResourcesConnectionDetailsType
 */
export enum CompositionSpecResourcesConnectionDetailsType {
  /** FromConnectionSecretKey */
  FROM_CONNECTION_SECRET_KEY = "FromConnectionSecretKey",
  /** FromFieldPath */
  FROM_FIELD_PATH = "FromFieldPath",
  /** FromValue */
  FROM_VALUE = "FromValue",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionSpecResourcesPatchesCombine
 */
export interface CompositionSpecResourcesPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionSpecResourcesPatchesCombine#strategy
   */
  readonly strategy: CompositionSpecResourcesPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionSpecResourcesPatchesCombine#string
   */
  readonly string?: CompositionSpecResourcesPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionSpecResourcesPatchesCombine#variables
   */
  readonly variables: CompositionSpecResourcesPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesCombine(obj: CompositionSpecResourcesPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionSpecResourcesPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionSpecResourcesPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionSpecResourcesPatchesPolicy
 */
export interface CompositionSpecResourcesPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionSpecResourcesPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionSpecResourcesPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionSpecResourcesPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionSpecResourcesPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesPolicy(obj: CompositionSpecResourcesPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionSpecResourcesPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionSpecResourcesPatchesTransforms
 */
export interface CompositionSpecResourcesPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#convert
   */
  readonly convert?: CompositionSpecResourcesPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#match
   */
  readonly match?: CompositionSpecResourcesPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#math
   */
  readonly math?: CompositionSpecResourcesPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#string
   */
  readonly string?: CompositionSpecResourcesPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#type
   */
  readonly type: CompositionSpecResourcesPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransforms(obj: CompositionSpecResourcesPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionSpecResourcesPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionSpecResourcesPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionSpecResourcesPatchesTransformsMath(obj.math),
    'string': toJson_CompositionSpecResourcesPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionSpecResourcesPatchesType
 */
export enum CompositionSpecResourcesPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
 *
 * @schema CompositionSpecResourcesReadinessChecksMatchCondition
 */
export interface CompositionSpecResourcesReadinessChecksMatchCondition {
  /**
   * Status is the status of the condition you'd like to match.
   *
   * @schema CompositionSpecResourcesReadinessChecksMatchCondition#status
   */
  readonly status: string;

  /**
   * Type indicates the type of condition you'd like to use.
   *
   * @schema CompositionSpecResourcesReadinessChecksMatchCondition#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesReadinessChecksMatchCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesReadinessChecksMatchCondition(obj: CompositionSpecResourcesReadinessChecksMatchCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type indicates the type of probe you'd like to use.
 *
 * @schema CompositionSpecResourcesReadinessChecksType
 */
export enum CompositionSpecResourcesReadinessChecksType {
  /** MatchString */
  MATCH_STRING = "MatchString",
  /** MatchInteger */
  MATCH_INTEGER = "MatchInteger",
  /** NonEmpty */
  NON_EMPTY = "NonEmpty",
  /** MatchCondition */
  MATCH_CONDITION = "MatchCondition",
  /** MatchTrue */
  MATCH_TRUE = "MatchTrue",
  /** MatchFalse */
  MATCH_FALSE = "MatchFalse",
  /** None */
  NONE = "None",
}

/**
 * An EnvironmentSourceSelectorLabelMatcher acts like a k8s label selector but
 * can draw the label value from a different path.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels
 */
export interface CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels {
  /**
   * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
   * The default is Required, meaning that an error will be returned if the
   * field is not found in the composite resource.
   * Optional means that if the field is not found in the composite resource,
   * that label pair will just be skipped. N.B. other specified label
   * matchers will still be used to retrieve the desired
   * environment config, if any.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#fromFieldPathPolicy
   */
  readonly fromFieldPathPolicy?: CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy;

  /**
   * Key of the label to match.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#key
   */
  readonly key: string;

  /**
   * Type specifies where the value for a label comes from.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#type
   */
  readonly type?: CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType;

  /**
   * Value specifies a literal label value.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#value
   */
  readonly value?: string;

  /**
   * ValueFromFieldPath specifies the field path to look for the label value.
   *
   * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#valueFromFieldPath
   */
  readonly valueFromFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels(obj: CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPathPolicy': obj.fromFieldPathPolicy,
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
    'valueFromFieldPath': obj.valueFromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode specifies retrieval strategy: "Single" or "Multiple".
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMode
 */
export enum CompositionSpecEnvironmentEnvironmentConfigsSelectorMode {
  /** Single */
  SINGLE = "Single",
  /** Multiple */
  MULTIPLE = "Multiple",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionSpecEnvironmentPatchesCombineStrategy
 */
export enum CompositionSpecEnvironmentPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionSpecEnvironmentPatchesCombineString
 */
export interface CompositionSpecEnvironmentPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecEnvironmentPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesCombineString(obj: CompositionSpecEnvironmentPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionSpecEnvironmentPatchesCombineVariables
 */
export interface CompositionSpecEnvironmentPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionSpecEnvironmentPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesCombineVariables(obj: CompositionSpecEnvironmentPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionSpecEnvironmentPatchesPolicyFromFieldPath
 */
export enum CompositionSpecEnvironmentPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionSpecEnvironmentPatchesPolicyMergeOptions
 */
export interface CompositionSpecEnvironmentPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionSpecEnvironmentPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionSpecEnvironmentPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesPolicyMergeOptions(obj: CompositionSpecEnvironmentPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsConvert
 */
export interface CompositionSpecEnvironmentPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsConvert#format
   */
  readonly format?: CompositionSpecEnvironmentPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsConvert#toType
   */
  readonly toType: CompositionSpecEnvironmentPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsConvert(obj: CompositionSpecEnvironmentPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMatch
 */
export interface CompositionSpecEnvironmentPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionSpecEnvironmentPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionSpecEnvironmentPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsMatch(obj: CompositionSpecEnvironmentPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionSpecEnvironmentPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMath
 */
export interface CompositionSpecEnvironmentPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMath#type
   */
  readonly type?: CompositionSpecEnvironmentPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsMath(obj: CompositionSpecEnvironmentPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsString
 */
export interface CompositionSpecEnvironmentPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#convert
   */
  readonly convert?: CompositionSpecEnvironmentPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#join
   */
  readonly join?: CompositionSpecEnvironmentPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionSpecEnvironmentPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsString#type
   */
  readonly type?: CompositionSpecEnvironmentPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsString(obj: CompositionSpecEnvironmentPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionSpecEnvironmentPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionSpecEnvironmentPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsType
 */
export enum CompositionSpecEnvironmentPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineStrategy
 */
export enum CompositionSpecPatchSetsPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineString
 */
export interface CompositionSpecPatchSetsPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombineString(obj: CompositionSpecPatchSetsPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineVariables
 */
export interface CompositionSpecPatchSetsPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionSpecPatchSetsPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombineVariables(obj: CompositionSpecPatchSetsPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionSpecPatchSetsPatchesPolicyFromFieldPath
 */
export enum CompositionSpecPatchSetsPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions
 */
export interface CompositionSpecPatchSetsPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesPolicyMergeOptions(obj: CompositionSpecPatchSetsPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvert
 */
export interface CompositionSpecPatchSetsPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsConvert#format
   */
  readonly format?: CompositionSpecPatchSetsPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsConvert#toType
   */
  readonly toType: CompositionSpecPatchSetsPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsConvert(obj: CompositionSpecPatchSetsPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatch
 */
export interface CompositionSpecPatchSetsPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionSpecPatchSetsPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMatch(obj: CompositionSpecPatchSetsPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionSpecPatchSetsPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMath
 */
export interface CompositionSpecPatchSetsPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMath(obj: CompositionSpecPatchSetsPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsString
 */
export interface CompositionSpecPatchSetsPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#convert
   */
  readonly convert?: CompositionSpecPatchSetsPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#join
   */
  readonly join?: CompositionSpecPatchSetsPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionSpecPatchSetsPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsString(obj: CompositionSpecPatchSetsPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionSpecPatchSetsPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionSpecPatchSetsPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsType
 */
export enum CompositionSpecPatchSetsPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionSpecResourcesPatchesCombineStrategy
 */
export enum CompositionSpecResourcesPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionSpecResourcesPatchesCombineString
 */
export interface CompositionSpecResourcesPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecResourcesPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesCombineString(obj: CompositionSpecResourcesPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionSpecResourcesPatchesCombineVariables
 */
export interface CompositionSpecResourcesPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionSpecResourcesPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesCombineVariables(obj: CompositionSpecResourcesPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionSpecResourcesPatchesPolicyFromFieldPath
 */
export enum CompositionSpecResourcesPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionSpecResourcesPatchesPolicyMergeOptions
 */
export interface CompositionSpecResourcesPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionSpecResourcesPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionSpecResourcesPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesPolicyMergeOptions(obj: CompositionSpecResourcesPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvert
 */
export interface CompositionSpecResourcesPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionSpecResourcesPatchesTransformsConvert#format
   */
  readonly format?: CompositionSpecResourcesPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionSpecResourcesPatchesTransformsConvert#toType
   */
  readonly toType: CompositionSpecResourcesPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsConvert(obj: CompositionSpecResourcesPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatch
 */
export interface CompositionSpecResourcesPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionSpecResourcesPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionSpecResourcesPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMatch(obj: CompositionSpecResourcesPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionSpecResourcesPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMath
 */
export interface CompositionSpecResourcesPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#type
   */
  readonly type?: CompositionSpecResourcesPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMath(obj: CompositionSpecResourcesPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionSpecResourcesPatchesTransformsString
 */
export interface CompositionSpecResourcesPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#convert
   */
  readonly convert?: CompositionSpecResourcesPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#join
   */
  readonly join?: CompositionSpecResourcesPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionSpecResourcesPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#type
   */
  readonly type?: CompositionSpecResourcesPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsString(obj: CompositionSpecResourcesPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionSpecResourcesPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionSpecResourcesPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsType
 */
export enum CompositionSpecResourcesPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
 * The default is Required, meaning that an error will be returned if the
 * field is not found in the composite resource.
 * Optional means that if the field is not found in the composite resource,
 * that label pair will just be skipped. N.B. other specified label
 * matchers will still be used to retrieve the desired
 * environment config, if any.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy
 */
export enum CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * Type specifies where the value for a label comes from.
 *
 * @schema CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType
 */
export enum CompositionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** Value */
  VALUE = "Value",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsConvertFormat
 */
export enum CompositionSpecEnvironmentPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsConvertToType
 */
export enum CompositionSpecEnvironmentPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMatchFallbackTo
 */
export enum CompositionSpecEnvironmentPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatterns
 */
export interface CompositionSpecEnvironmentPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionSpecEnvironmentPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsMatchPatterns(obj: CompositionSpecEnvironmentPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMathType
 */
export enum CompositionSpecEnvironmentPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsStringConvert
 */
export enum CompositionSpecEnvironmentPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsStringJoin
 */
export interface CompositionSpecEnvironmentPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsStringJoin(obj: CompositionSpecEnvironmentPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsStringRegexp
 */
export interface CompositionSpecEnvironmentPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionSpecEnvironmentPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionSpecEnvironmentPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecEnvironmentPatchesTransformsStringRegexp(obj: CompositionSpecEnvironmentPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsStringType
 */
export enum CompositionSpecEnvironmentPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvertFormat
 */
export enum CompositionSpecPatchSetsPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvertToType
 */
export enum CompositionSpecPatchSetsPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo
 */
export enum CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns
 */
export interface CompositionSpecPatchSetsPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionSpecPatchSetsPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMatchPatterns(obj: CompositionSpecPatchSetsPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMathType
 */
export enum CompositionSpecPatchSetsPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringConvert
 */
export enum CompositionSpecPatchSetsPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringJoin
 */
export interface CompositionSpecPatchSetsPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsStringJoin(obj: CompositionSpecPatchSetsPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp
 */
export interface CompositionSpecPatchSetsPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsStringRegexp(obj: CompositionSpecPatchSetsPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringType
 */
export enum CompositionSpecPatchSetsPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvertFormat
 */
export enum CompositionSpecResourcesPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvertToType
 */
export enum CompositionSpecResourcesPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchFallbackTo
 */
export enum CompositionSpecResourcesPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns
 */
export interface CompositionSpecResourcesPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionSpecResourcesPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMatchPatterns(obj: CompositionSpecResourcesPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMathType
 */
export enum CompositionSpecResourcesPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringConvert
 */
export enum CompositionSpecResourcesPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringJoin
 */
export interface CompositionSpecResourcesPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsStringJoin(obj: CompositionSpecResourcesPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringRegexp
 */
export interface CompositionSpecResourcesPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsStringRegexp(obj: CompositionSpecResourcesPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringType
 */
export enum CompositionSpecResourcesPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionSpecEnvironmentPatchesTransformsMatchPatternsType
 */
export enum CompositionSpecEnvironmentPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatternsType
 */
export enum CompositionSpecPatchSetsPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchPatternsType
 */
export enum CompositionSpecResourcesPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}


/**
 * A CompositionRevision represents a revision in time of a Composition.
Revisions are created by Crossplane; they should be treated as immutable.
 *
 * @schema CompositionRevision
 */
export class CompositionRevision extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositionRevision"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'CompositionRevision',
  }

  /**
   * Renders a Kubernetes manifest for "CompositionRevision".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionRevisionProps = {}): any {
    return {
      ...CompositionRevision.GVK,
      ...toJson_CompositionRevisionProps(props),
    };
  }

  /**
   * Defines a "CompositionRevision" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionRevisionProps = {}) {
    super(scope, id, {
      ...CompositionRevision.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositionRevision.GVK,
      ...toJson_CompositionRevisionProps(resolved),
    };
  }
}

/**
 * A CompositionRevision represents a revision in time of a Composition.
 * Revisions are created by Crossplane; they should be treated as immutable.
 *
 * @schema CompositionRevision
 */
export interface CompositionRevisionProps {
  /**
   * @schema CompositionRevision#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionRevisionSpec specifies the desired state of the composition
   * revision.
   *
   * @schema CompositionRevision#spec
   */
  readonly spec?: CompositionRevisionSpec;

}

/**
 * Converts an object of type 'CompositionRevisionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionProps(obj: CompositionRevisionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionRevisionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositionRevisionSpec specifies the desired state of the composition
 * revision.
 *
 * @schema CompositionRevisionSpec
 */
export interface CompositionRevisionSpec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionRevisionSpec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionRevisionSpecCompositeTypeRef;

  /**
   * Environment configures the environment in which resources are rendered.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionRevisionSpec#environment
   */
  readonly environment?: CompositionRevisionSpecEnvironment;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   *
   * "Resources" (the default) indicates that a Composition uses what is
   * commonly referred to as "Patch & Transform" or P&T composition. This mode
   * of Composition uses an array of resources, each a template for a composed
   * resource.
   *
   *
   * "Pipeline" indicates that a Composition specifies a pipeline
   * of Composition Functions, each of which is responsible for producing
   * composed resources that Crossplane should create or update. THE PIPELINE
   * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionRevisionSpec#mode
   */
  readonly mode?: CompositionRevisionSpecMode;

  /**
   * PatchSets define a named set of patches that may be included by any
   * resource in this Composition. PatchSets cannot themselves refer to other
   * PatchSets.
   *
   *
   * PatchSets are only used by the "Resources" mode of Composition. They
   * are ignored by other modes.
   *
   * @schema CompositionRevisionSpec#patchSets
   */
  readonly patchSets?: CompositionRevisionSpecPatchSets[];

  /**
   * Pipeline is a list of composition function steps that will be used when a
   * composite resource referring to this composition is created. One of
   * resources and pipeline must be specified - you cannot specify both.
   *
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   *
   * THIS IS A BETA FIELD. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionRevisionSpec#pipeline
   */
  readonly pipeline?: CompositionRevisionSpecPipeline[];

  /**
   * PublishConnectionDetailsWithStoreConfig specifies the secret store config
   * with which the connection details of composite resources dynamically
   * provisioned using this composition will be published.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionRevisionSpec#publishConnectionDetailsWithStoreConfigRef
   */
  readonly publishConnectionDetailsWithStoreConfigRef?: CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef;

  /**
   * Resources is a list of resource templates that will be used when a
   * composite resource referring to this composition is created.
   *
   *
   * Resources are only used by the "Resources" mode of Composition. They are
   * ignored by other modes.
   *
   * @schema CompositionRevisionSpec#resources
   */
  readonly resources?: CompositionRevisionSpecResources[];

  /**
   * Revision number. Newer revisions have larger numbers.
   *
   * @schema CompositionRevisionSpec#revision
   */
  readonly revision: number;

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
   * set independently and connection details would be published to both
   * without affecting each other as long as related fields at MR level
   * specified.
   *
   * @schema CompositionRevisionSpec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpec(obj: CompositionRevisionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionRevisionSpecCompositeTypeRef(obj.compositeTypeRef),
    'environment': toJson_CompositionRevisionSpecEnvironment(obj.environment),
    'mode': obj.mode,
    'patchSets': obj.patchSets?.map(y => toJson_CompositionRevisionSpecPatchSets(y)),
    'pipeline': obj.pipeline?.map(y => toJson_CompositionRevisionSpecPipeline(y)),
    'publishConnectionDetailsWithStoreConfigRef': toJson_CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef(obj.publishConnectionDetailsWithStoreConfigRef),
    'resources': obj.resources?.map(y => toJson_CompositionRevisionSpecResources(y)),
    'revision': obj.revision,
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionRevisionSpecCompositeTypeRef
 */
export interface CompositionRevisionSpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionRevisionSpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionRevisionSpecCompositeTypeRef#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecCompositeTypeRef(obj: CompositionRevisionSpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment configures the environment in which resources are rendered.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionRevisionSpecEnvironment
 */
export interface CompositionRevisionSpecEnvironment {
  /**
   * DefaultData statically defines the initial state of the environment.
   * It has the same schema-less structure as the data field in
   * environment configs.
   * It is overwritten by the selected environment configs.
   *
   * @schema CompositionRevisionSpecEnvironment#defaultData
   */
  readonly defaultData?: { [key: string]: any };

  /**
   * EnvironmentConfigs selects a list of `EnvironmentConfig`s. The resolved
   * resources are stored in the composite resource at
   * `spec.environmentConfigRefs` and is only updated if it is null.
   *
   *
   * The list of references is used to compute an in-memory environment at
   * compose time. The data of all object is merged in the order they are
   * listed, meaning the values of EnvironmentConfigs with a larger index take
   * priority over ones with smaller indices.
   *
   *
   * The computed environment can be accessed in a composition using
   * `FromEnvironmentFieldPath` and `CombineFromEnvironment` patches.
   *
   * @schema CompositionRevisionSpecEnvironment#environmentConfigs
   */
  readonly environmentConfigs?: CompositionRevisionSpecEnvironmentEnvironmentConfigs[];

  /**
   * Patches is a list of environment patches that are executed before a
   * composition's resources are composed.
   *
   * @schema CompositionRevisionSpecEnvironment#patches
   */
  readonly patches?: CompositionRevisionSpecEnvironmentPatches[];

  /**
   * Policy represents the Resolve and Resolution policies which apply to
   * all EnvironmentSourceReferences in EnvironmentConfigs list.
   *
   * @schema CompositionRevisionSpecEnvironment#policy
   */
  readonly policy?: CompositionRevisionSpecEnvironmentPolicy;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironment(obj: CompositionRevisionSpecEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultData': ((obj.defaultData) === undefined) ? undefined : (Object.entries(obj.defaultData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'environmentConfigs': obj.environmentConfigs?.map(y => toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigs(y)),
    'patches': obj.patches?.map(y => toJson_CompositionRevisionSpecEnvironmentPatches(y)),
    'policy': toJson_CompositionRevisionSpecEnvironmentPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 *
 * "Resources" (the default) indicates that a Composition uses what is
 * commonly referred to as "Patch & Transform" or P&T composition. This mode
 * of Composition uses an array of resources, each a template for a composed
 * resource.
 *
 *
 * "Pipeline" indicates that a Composition specifies a pipeline
 * of Composition Functions, each of which is responsible for producing
 * composed resources that Crossplane should create or update. THE PIPELINE
 * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
 * feature flag is disabled.
 *
 * @schema CompositionRevisionSpecMode
 */
export enum CompositionRevisionSpecMode {
  /** Resources */
  RESOURCES = "Resources",
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PatchSet is a set of patches that can be reused from all resources within
 * a Composition.
 *
 * @schema CompositionRevisionSpecPatchSets
 */
export interface CompositionRevisionSpecPatchSets {
  /**
   * Name of this PatchSet.
   *
   * @schema CompositionRevisionSpecPatchSets#name
   */
  readonly name: string;

  /**
   * Patches will be applied as an overlay to the base resource.
   *
   * @schema CompositionRevisionSpecPatchSets#patches
   */
  readonly patches: CompositionRevisionSpecPatchSetsPatches[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSets(obj: CompositionRevisionSpecPatchSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionRevisionSpecPatchSetsPatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A PipelineStep in a Composition Function pipeline.
 *
 * @schema CompositionRevisionSpecPipeline
 */
export interface CompositionRevisionSpecPipeline {
  /**
   * FunctionRef is a reference to the Composition Function this step should
   * execute.
   *
   * @schema CompositionRevisionSpecPipeline#functionRef
   */
  readonly functionRef: CompositionRevisionSpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the Composition
   * Function as the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionRevisionSpecPipeline#input
   */
  readonly input?: any;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionRevisionSpecPipeline#step
   */
  readonly step: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPipeline(obj: CompositionRevisionSpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionRef': toJson_CompositionRevisionSpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsWithStoreConfig specifies the secret store config
 * with which the connection details of composite resources dynamically
 * provisioned using this composition will be published.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef
 */
export interface CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef {
  /**
   * Name of the referenced StoreConfig.
   *
   * @schema CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef(obj: CompositionRevisionSpecPublishConnectionDetailsWithStoreConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ComposedTemplate is used to provide information about how the composed resource
 * should be processed.
 *
 * @schema CompositionRevisionSpecResources
 */
export interface CompositionRevisionSpecResources {
  /**
   * Base is the target resource that the patches will be applied on.
   *
   * @schema CompositionRevisionSpecResources#base
   */
  readonly base: any;

  /**
   * ConnectionDetails lists the propagation secret keys from this target
   * resource to the composition instance connection secret.
   *
   * @schema CompositionRevisionSpecResources#connectionDetails
   */
  readonly connectionDetails?: CompositionRevisionSpecResourcesConnectionDetails[];

  /**
   * A Name uniquely identifies this entry within its Composition's resources
   * array. Names are optional but *strongly* recommended. When all entries in
   * the resources array are named entries may added, deleted, and reordered
   * as long as their names do not change. When entries are not named the
   * length and order of the resources array should be treated as immutable.
   * Either all or no entries must be named.
   *
   * @schema CompositionRevisionSpecResources#name
   */
  readonly name?: string;

  /**
   * Patches will be applied as overlay to the base resource.
   *
   * @schema CompositionRevisionSpecResources#patches
   */
  readonly patches?: CompositionRevisionSpecResourcesPatches[];

  /**
   * ReadinessChecks allows users to define custom readiness checks. All checks
   * have to return true in order for resource to be considered ready. The
   * default readiness check is to have the "Ready" condition to be "True".
   *
   * @schema CompositionRevisionSpecResources#readinessChecks
   */
  readonly readinessChecks?: CompositionRevisionSpecResourcesReadinessChecks[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResources(obj: CompositionRevisionSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'connectionDetails': obj.connectionDetails?.map(y => toJson_CompositionRevisionSpecResourcesConnectionDetails(y)),
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionRevisionSpecResourcesPatches(y)),
    'readinessChecks': obj.readinessChecks?.map(y => toJson_CompositionRevisionSpecResourcesReadinessChecks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSource selects a EnvironmentConfig resource.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigs
 */
export interface CompositionRevisionSpecEnvironmentEnvironmentConfigs {
  /**
   * Ref is a named reference to a single EnvironmentConfig.
   * Either Ref or Selector is required.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigs#ref
   */
  readonly ref?: CompositionRevisionSpecEnvironmentEnvironmentConfigsRef;

  /**
   * Selector selects EnvironmentConfig(s) via labels.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigs#selector
   */
  readonly selector?: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector;

  /**
   * Type specifies the way the EnvironmentConfig is selected.
   * Default is `Reference`
   *
   * @default Reference`
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigs#type
   */
  readonly type?: CompositionRevisionSpecEnvironmentEnvironmentConfigsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentEnvironmentConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigs(obj: CompositionRevisionSpecEnvironmentEnvironmentConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsRef(obj.ref),
    'selector': toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector(obj.selector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentPatch is a patch for a Composition environment.
 *
 * @schema CompositionRevisionSpecEnvironmentPatches
 */
export interface CompositionRevisionSpecEnvironmentPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite or
   * CombineToComposite patch.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#combine
   */
  readonly combine?: CompositionRevisionSpecEnvironmentPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath or
   * ToCompositeFieldPath.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#policy
   */
  readonly policy?: CompositionRevisionSpecEnvironmentPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#transforms
   */
  readonly transforms?: CompositionRevisionSpecEnvironmentPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionSpecEnvironmentPatches#type
   */
  readonly type?: CompositionRevisionSpecEnvironmentPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatches(obj: CompositionRevisionSpecEnvironmentPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionSpecEnvironmentPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'policy': toJson_CompositionRevisionSpecEnvironmentPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionSpecEnvironmentPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy represents the Resolve and Resolution policies which apply to
 * all EnvironmentSourceReferences in EnvironmentConfigs list.
 *
 * @schema CompositionRevisionSpecEnvironmentPolicy
 */
export interface CompositionRevisionSpecEnvironmentPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CompositionRevisionSpecEnvironmentPolicy#resolution
   */
  readonly resolution?: CompositionRevisionSpecEnvironmentPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CompositionRevisionSpecEnvironmentPolicy#resolve
   */
  readonly resolve?: CompositionRevisionSpecEnvironmentPolicyResolve;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPolicy(obj: CompositionRevisionSpecEnvironmentPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionRevisionSpecPatchSetsPatches
 */
export interface CompositionRevisionSpecPatchSetsPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#combine
   */
  readonly combine?: CompositionRevisionSpecPatchSetsPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#policy
   */
  readonly policy?: CompositionRevisionSpecPatchSetsPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#transforms
   */
  readonly transforms?: CompositionRevisionSpecPatchSetsPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionSpecPatchSetsPatches#type
   */
  readonly type?: CompositionRevisionSpecPatchSetsPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatches(obj: CompositionRevisionSpecPatchSetsPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionSpecPatchSetsPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionRevisionSpecPatchSetsPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionSpecPatchSetsPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionRef is a reference to the Composition Function this step should
 * execute.
 *
 * @schema CompositionRevisionSpecPipelineFunctionRef
 */
export interface CompositionRevisionSpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionRevisionSpecPipelineFunctionRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPipelineFunctionRef(obj: CompositionRevisionSpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionDetail includes the information about the propagation of the connection
 * information from one secret to another.
 *
 * @schema CompositionRevisionSpecResourcesConnectionDetails
 */
export interface CompositionRevisionSpecResourcesConnectionDetails {
  /**
   * FromConnectionSecretKey is the key that will be used to fetch the value
   * from the composed resource's connection secret.
   *
   * @schema CompositionRevisionSpecResourcesConnectionDetails#fromConnectionSecretKey
   */
  readonly fromConnectionSecretKey?: string;

  /**
   * FromFieldPath is the path of the field on the composed resource whose
   * value to be used as input. Name must be specified if the type is
   * FromFieldPath.
   *
   * @schema CompositionRevisionSpecResourcesConnectionDetails#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Name of the connection secret key that will be propagated to the
   * connection secret of the composition instance. Leave empty if you'd like
   * to use the same key name.
   *
   * @schema CompositionRevisionSpecResourcesConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Type sets the connection detail fetching behaviour to be used. Each
   * connection detail type may require its own fields to be set on the
   * ConnectionDetail object. If the type is omitted Crossplane will attempt
   * to infer it based on which other fields were specified. If multiple
   * fields are specified the order of precedence is:
   * 1. FromValue
   * 2. FromConnectionSecretKey
   * 3. FromFieldPath
   *
   * @schema CompositionRevisionSpecResourcesConnectionDetails#type
   */
  readonly type?: CompositionRevisionSpecResourcesConnectionDetailsType;

  /**
   * Value that will be propagated to the connection secret of the composite
   * resource. May be set to inject a fixed, non-sensitive connection secret
   * value, for example a well-known port.
   *
   * @schema CompositionRevisionSpecResourcesConnectionDetails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesConnectionDetails(obj: CompositionRevisionSpecResourcesConnectionDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromConnectionSecretKey': obj.fromConnectionSecretKey,
    'fromFieldPath': obj.fromFieldPath,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionRevisionSpecResourcesPatches
 */
export interface CompositionRevisionSpecResourcesPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionRevisionSpecResourcesPatches#combine
   */
  readonly combine?: CompositionRevisionSpecResourcesPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionRevisionSpecResourcesPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionRevisionSpecResourcesPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionSpecResourcesPatches#policy
   */
  readonly policy?: CompositionRevisionSpecResourcesPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionSpecResourcesPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionSpecResourcesPatches#transforms
   */
  readonly transforms?: CompositionRevisionSpecResourcesPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionSpecResourcesPatches#type
   */
  readonly type?: CompositionRevisionSpecResourcesPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatches(obj: CompositionRevisionSpecResourcesPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionSpecResourcesPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionRevisionSpecResourcesPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionSpecResourcesPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReadinessCheck is used to indicate how to tell whether a resource is ready
 * for consumption
 *
 * @schema CompositionRevisionSpecResourcesReadinessChecks
 */
export interface CompositionRevisionSpecResourcesReadinessChecks {
  /**
   * FieldPath shows the path of the field whose value will be used.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecks#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecks#matchCondition
   */
  readonly matchCondition?: CompositionRevisionSpecResourcesReadinessChecksMatchCondition;

  /**
   * MatchInt is the value you'd like to match if you're using "MatchInt" type.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecks#matchInteger
   */
  readonly matchInteger?: number;

  /**
   * MatchString is the value you'd like to match if you're using "MatchString" type.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecks#matchString
   */
  readonly matchString?: string;

  /**
   * Type indicates the type of probe you'd like to use.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecks#type
   */
  readonly type: CompositionRevisionSpecResourcesReadinessChecksType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesReadinessChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesReadinessChecks(obj: CompositionRevisionSpecResourcesReadinessChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'matchCondition': toJson_CompositionRevisionSpecResourcesReadinessChecksMatchCondition(obj.matchCondition),
    'matchInteger': obj.matchInteger,
    'matchString': obj.matchString,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ref is a named reference to a single EnvironmentConfig.
 * Either Ref or Selector is required.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsRef
 */
export interface CompositionRevisionSpecEnvironmentEnvironmentConfigsRef {
  /**
   * The name of the object.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentEnvironmentConfigsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsRef(obj: CompositionRevisionSpecEnvironmentEnvironmentConfigsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector selects EnvironmentConfig(s) via labels.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector
 */
export interface CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector {
  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector#matchLabels
   */
  readonly matchLabels?: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels[];

  /**
   * MaxMatch specifies the number of extracted EnvironmentConfigs in Multiple mode, extracts all if nil.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector#maxMatch
   */
  readonly maxMatch?: number;

  /**
   * MinMatch specifies the required minimum of extracted EnvironmentConfigs in Multiple mode.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector#minMatch
   */
  readonly minMatch?: number;

  /**
   * Mode specifies retrieval strategy: "Single" or "Multiple".
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector#mode
   */
  readonly mode?: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMode;

  /**
   * SortByFieldPath is the path to the field based on which list of EnvironmentConfigs is alphabetically sorted.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector#sortByFieldPath
   */
  readonly sortByFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector(obj: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': obj.matchLabels?.map(y => toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels(y)),
    'maxMatch': obj.maxMatch,
    'minMatch': obj.minMatch,
    'mode': obj.mode,
    'sortByFieldPath': obj.sortByFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies the way the EnvironmentConfig is selected.
 * Default is `Reference`
 *
 * @default Reference`
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsType
 */
export enum CompositionRevisionSpecEnvironmentEnvironmentConfigsType {
  /** Reference */
  REFERENCE = "Reference",
  /** Selector */
  SELECTOR = "Selector",
}

/**
 * Combine is the patch configuration for a CombineFromComposite or
 * CombineToComposite patch.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesCombine
 */
export interface CompositionRevisionSpecEnvironmentPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionSpecEnvironmentPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesCombine#string
   */
  readonly string?: CompositionRevisionSpecEnvironmentPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesCombine#variables
   */
  readonly variables: CompositionRevisionSpecEnvironmentPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesCombine(obj: CompositionRevisionSpecEnvironmentPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionSpecEnvironmentPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionSpecEnvironmentPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesPolicy
 */
export interface CompositionRevisionSpecEnvironmentPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionSpecEnvironmentPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesPolicy(obj: CompositionRevisionSpecEnvironmentPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransforms
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionSpecEnvironmentPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#match
   */
  readonly match?: CompositionRevisionSpecEnvironmentPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#math
   */
  readonly math?: CompositionRevisionSpecEnvironmentPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#string
   */
  readonly string?: CompositionRevisionSpecEnvironmentPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransforms#type
   */
  readonly type: CompositionRevisionSpecEnvironmentPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransforms(obj: CompositionRevisionSpecEnvironmentPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesType
 */
export enum CompositionRevisionSpecEnvironmentPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CompositionRevisionSpecEnvironmentPolicyResolution
 */
export enum CompositionRevisionSpecEnvironmentPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CompositionRevisionSpecEnvironmentPolicyResolve
 */
export enum CompositionRevisionSpecEnvironmentPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesCombine
 */
export interface CompositionRevisionSpecPatchSetsPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionSpecPatchSetsPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesCombine#string
   */
  readonly string?: CompositionRevisionSpecPatchSetsPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesCombine#variables
   */
  readonly variables: CompositionRevisionSpecPatchSetsPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesCombine(obj: CompositionRevisionSpecPatchSetsPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionSpecPatchSetsPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionSpecPatchSetsPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesPolicy
 */
export interface CompositionRevisionSpecPatchSetsPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionSpecPatchSetsPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesPolicy(obj: CompositionRevisionSpecPatchSetsPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransforms
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionSpecPatchSetsPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#match
   */
  readonly match?: CompositionRevisionSpecPatchSetsPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#math
   */
  readonly math?: CompositionRevisionSpecPatchSetsPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#string
   */
  readonly string?: CompositionRevisionSpecPatchSetsPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransforms#type
   */
  readonly type: CompositionRevisionSpecPatchSetsPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransforms(obj: CompositionRevisionSpecPatchSetsPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesType
 */
export enum CompositionRevisionSpecPatchSetsPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * Type sets the connection detail fetching behaviour to be used. Each
 * connection detail type may require its own fields to be set on the
 * ConnectionDetail object. If the type is omitted Crossplane will attempt
 * to infer it based on which other fields were specified. If multiple
 * fields are specified the order of precedence is:
 * 1. FromValue
 * 2. FromConnectionSecretKey
 * 3. FromFieldPath
 *
 * @schema CompositionRevisionSpecResourcesConnectionDetailsType
 */
export enum CompositionRevisionSpecResourcesConnectionDetailsType {
  /** FromConnectionSecretKey */
  FROM_CONNECTION_SECRET_KEY = "FromConnectionSecretKey",
  /** FromFieldPath */
  FROM_FIELD_PATH = "FromFieldPath",
  /** FromValue */
  FROM_VALUE = "FromValue",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionRevisionSpecResourcesPatchesCombine
 */
export interface CompositionRevisionSpecResourcesPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionSpecResourcesPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionSpecResourcesPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionSpecResourcesPatchesCombine#string
   */
  readonly string?: CompositionRevisionSpecResourcesPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionSpecResourcesPatchesCombine#variables
   */
  readonly variables: CompositionRevisionSpecResourcesPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesCombine(obj: CompositionRevisionSpecResourcesPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionSpecResourcesPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionSpecResourcesPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionSpecResourcesPatchesPolicy
 */
export interface CompositionRevisionSpecResourcesPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionSpecResourcesPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionSpecResourcesPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionSpecResourcesPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionSpecResourcesPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesPolicy(obj: CompositionRevisionSpecResourcesPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionSpecResourcesPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransforms
 */
export interface CompositionRevisionSpecResourcesPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionSpecResourcesPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#match
   */
  readonly match?: CompositionRevisionSpecResourcesPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#math
   */
  readonly math?: CompositionRevisionSpecResourcesPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#string
   */
  readonly string?: CompositionRevisionSpecResourcesPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransforms#type
   */
  readonly type: CompositionRevisionSpecResourcesPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransforms(obj: CompositionRevisionSpecResourcesPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionSpecResourcesPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionSpecResourcesPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionSpecResourcesPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionSpecResourcesPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionSpecResourcesPatchesType
 */
export enum CompositionRevisionSpecResourcesPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
 *
 * @schema CompositionRevisionSpecResourcesReadinessChecksMatchCondition
 */
export interface CompositionRevisionSpecResourcesReadinessChecksMatchCondition {
  /**
   * Status is the status of the condition you'd like to match.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecksMatchCondition#status
   */
  readonly status: string;

  /**
   * Type indicates the type of condition you'd like to use.
   *
   * @schema CompositionRevisionSpecResourcesReadinessChecksMatchCondition#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesReadinessChecksMatchCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesReadinessChecksMatchCondition(obj: CompositionRevisionSpecResourcesReadinessChecksMatchCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type indicates the type of probe you'd like to use.
 *
 * @schema CompositionRevisionSpecResourcesReadinessChecksType
 */
export enum CompositionRevisionSpecResourcesReadinessChecksType {
  /** MatchString */
  MATCH_STRING = "MatchString",
  /** MatchInteger */
  MATCH_INTEGER = "MatchInteger",
  /** NonEmpty */
  NON_EMPTY = "NonEmpty",
  /** MatchCondition */
  MATCH_CONDITION = "MatchCondition",
  /** MatchTrue */
  MATCH_TRUE = "MatchTrue",
  /** MatchFalse */
  MATCH_FALSE = "MatchFalse",
  /** None */
  NONE = "None",
}

/**
 * An EnvironmentSourceSelectorLabelMatcher acts like a k8s label selector but
 * can draw the label value from a different path.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels
 */
export interface CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels {
  /**
   * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
   * The default is Required, meaning that an error will be returned if the
   * field is not found in the composite resource.
   * Optional means that if the field is not found in the composite resource,
   * that label pair will just be skipped. N.B. other specified label
   * matchers will still be used to retrieve the desired
   * environment config, if any.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#fromFieldPathPolicy
   */
  readonly fromFieldPathPolicy?: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy;

  /**
   * Key of the label to match.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#key
   */
  readonly key: string;

  /**
   * Type specifies where the value for a label comes from.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#type
   */
  readonly type?: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType;

  /**
   * Value specifies a literal label value.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#value
   */
  readonly value?: string;

  /**
   * ValueFromFieldPath specifies the field path to look for the label value.
   *
   * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels#valueFromFieldPath
   */
  readonly valueFromFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels(obj: CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPathPolicy': obj.fromFieldPathPolicy,
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
    'valueFromFieldPath': obj.valueFromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode specifies retrieval strategy: "Single" or "Multiple".
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMode
 */
export enum CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMode {
  /** Single */
  SINGLE = "Single",
  /** Multiple */
  MULTIPLE = "Multiple",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesCombineStrategy
 */
export enum CompositionRevisionSpecEnvironmentPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesCombineString
 */
export interface CompositionRevisionSpecEnvironmentPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesCombineString(obj: CompositionRevisionSpecEnvironmentPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesCombineVariables
 */
export interface CompositionRevisionSpecEnvironmentPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesCombineVariables(obj: CompositionRevisionSpecEnvironmentPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionSpecEnvironmentPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions
 */
export interface CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions(obj: CompositionRevisionSpecEnvironmentPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsConvert
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionSpecEnvironmentPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionSpecEnvironmentPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsConvert(obj: CompositionRevisionSpecEnvironmentPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatch
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionSpecEnvironmentPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMatch(obj: CompositionRevisionSpecEnvironmentPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMath
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionSpecEnvironmentPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMath(obj: CompositionRevisionSpecEnvironmentPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionSpecEnvironmentPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionSpecEnvironmentPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsString(obj: CompositionRevisionSpecEnvironmentPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsType
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesCombineStrategy
 */
export enum CompositionRevisionSpecPatchSetsPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesCombineString
 */
export interface CompositionRevisionSpecPatchSetsPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesCombineString(obj: CompositionRevisionSpecPatchSetsPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesCombineVariables
 */
export interface CompositionRevisionSpecPatchSetsPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesCombineVariables(obj: CompositionRevisionSpecPatchSetsPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionSpecPatchSetsPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions
 */
export interface CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions(obj: CompositionRevisionSpecPatchSetsPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsConvert
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionSpecPatchSetsPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionSpecPatchSetsPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsConvert(obj: CompositionRevisionSpecPatchSetsPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatch
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionSpecPatchSetsPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMatch(obj: CompositionRevisionSpecPatchSetsPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMath
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionSpecPatchSetsPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMath(obj: CompositionRevisionSpecPatchSetsPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionSpecPatchSetsPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionSpecPatchSetsPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsString(obj: CompositionRevisionSpecPatchSetsPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsType
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionSpecResourcesPatchesCombineStrategy
 */
export enum CompositionRevisionSpecResourcesPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionSpecResourcesPatchesCombineString
 */
export interface CompositionRevisionSpecResourcesPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecResourcesPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesCombineString(obj: CompositionRevisionSpecResourcesPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionSpecResourcesPatchesCombineVariables
 */
export interface CompositionRevisionSpecResourcesPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionSpecResourcesPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesCombineVariables(obj: CompositionRevisionSpecResourcesPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionSpecResourcesPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionSpecResourcesPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionSpecResourcesPatchesPolicyMergeOptions
 */
export interface CompositionRevisionSpecResourcesPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionSpecResourcesPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionSpecResourcesPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesPolicyMergeOptions(obj: CompositionRevisionSpecResourcesPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsConvert
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionSpecResourcesPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionSpecResourcesPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsConvert(obj: CompositionRevisionSpecResourcesPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMatch
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionSpecResourcesPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsMatch(obj: CompositionRevisionSpecResourcesPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMath
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionSpecResourcesPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsMath(obj: CompositionRevisionSpecResourcesPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsString
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionSpecResourcesPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionSpecResourcesPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionSpecResourcesPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionSpecResourcesPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsString(obj: CompositionRevisionSpecResourcesPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionSpecResourcesPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionSpecResourcesPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsType
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
 * The default is Required, meaning that an error will be returned if the
 * field is not found in the composite resource.
 * Optional means that if the field is not found in the composite resource,
 * that label pair will just be skipped. N.B. other specified label
 * matchers will still be used to retrieve the desired
 * environment config, if any.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy
 */
export enum CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * Type specifies where the value for a label comes from.
 *
 * @schema CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType
 */
export enum CompositionRevisionSpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** Value */
  VALUE = "Value",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsConvertFormat
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsConvertToType
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns(obj: CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMathType
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringConvert
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin(obj: CompositionRevisionSpecEnvironmentPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp
 */
export interface CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp(obj: CompositionRevisionSpecEnvironmentPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsStringType
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsConvertFormat
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsConvertToType
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns(obj: CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMathType
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringConvert
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin(obj: CompositionRevisionSpecPatchSetsPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp
 */
export interface CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp(obj: CompositionRevisionSpecPatchSetsPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsStringType
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsConvertFormat
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsConvertToType
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionSpecResourcesPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns(obj: CompositionRevisionSpecResourcesPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMathType
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsStringConvert
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsStringJoin
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsStringJoin(obj: CompositionRevisionSpecResourcesPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsStringRegexp
 */
export interface CompositionRevisionSpecResourcesPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionSpecResourcesPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionSpecResourcesPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionSpecResourcesPatchesTransformsStringRegexp(obj: CompositionRevisionSpecResourcesPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsStringType
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionSpecEnvironmentPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionSpecPatchSetsPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionSpecResourcesPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionSpecResourcesPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}


/**
 * A CompositionRevision represents a revision in time of a Composition.
Revisions are created by Crossplane; they should be treated as immutable.
 *
 * @schema CompositionRevisionV1Beta1
 */
export class CompositionRevisionV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositionRevisionV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1beta1',
    kind: 'CompositionRevision',
  }

  /**
   * Renders a Kubernetes manifest for "CompositionRevisionV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionRevisionV1Beta1Props = {}): any {
    return {
      ...CompositionRevisionV1Beta1.GVK,
      ...toJson_CompositionRevisionV1Beta1Props(props),
    };
  }

  /**
   * Defines a "CompositionRevisionV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionRevisionV1Beta1Props = {}) {
    super(scope, id, {
      ...CompositionRevisionV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositionRevisionV1Beta1.GVK,
      ...toJson_CompositionRevisionV1Beta1Props(resolved),
    };
  }
}

/**
 * A CompositionRevision represents a revision in time of a Composition.
 * Revisions are created by Crossplane; they should be treated as immutable.
 *
 * @schema CompositionRevisionV1Beta1
 */
export interface CompositionRevisionV1Beta1Props {
  /**
   * @schema CompositionRevisionV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionRevisionSpec specifies the desired state of the composition
   * revision.
   *
   * @schema CompositionRevisionV1Beta1#spec
   */
  readonly spec?: CompositionRevisionV1Beta1Spec;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1Props(obj: CompositionRevisionV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionRevisionV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositionRevisionSpec specifies the desired state of the composition
 * revision.
 *
 * @schema CompositionRevisionV1Beta1Spec
 */
export interface CompositionRevisionV1Beta1Spec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionRevisionV1Beta1Spec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionRevisionV1Beta1SpecCompositeTypeRef;

  /**
   * Environment configures the environment in which resources are rendered.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionRevisionV1Beta1Spec#environment
   */
  readonly environment?: CompositionRevisionV1Beta1SpecEnvironment;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   *
   * "Resources" (the default) indicates that a Composition uses what is
   * commonly referred to as "Patch & Transform" or P&T composition. This mode
   * of Composition uses an array of resources, each a template for a composed
   * resource.
   *
   *
   * "Pipeline" indicates that a Composition specifies a pipeline
   * of Composition Functions, each of which is responsible for producing
   * composed resources that Crossplane should create or update. THE PIPELINE
   * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionRevisionV1Beta1Spec#mode
   */
  readonly mode?: CompositionRevisionV1Beta1SpecMode;

  /**
   * PatchSets define a named set of patches that may be included by any
   * resource in this Composition. PatchSets cannot themselves refer to other
   * PatchSets.
   *
   *
   * PatchSets are only used by the "Resources" mode of Composition. They
   * are ignored by other modes.
   *
   * @schema CompositionRevisionV1Beta1Spec#patchSets
   */
  readonly patchSets?: CompositionRevisionV1Beta1SpecPatchSets[];

  /**
   * Pipeline is a list of composition function steps that will be used when a
   * composite resource referring to this composition is created. One of
   * resources and pipeline must be specified - you cannot specify both.
   *
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   *
   * THIS IS A BETA FIELD. It is not honored if the relevant Crossplane
   * feature flag is disabled.
   *
   * @schema CompositionRevisionV1Beta1Spec#pipeline
   */
  readonly pipeline?: CompositionRevisionV1Beta1SpecPipeline[];

  /**
   * PublishConnectionDetailsWithStoreConfig specifies the secret store config
   * with which the connection details of composite resources dynamically
   * provisioned using this composition will be published.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionRevisionV1Beta1Spec#publishConnectionDetailsWithStoreConfigRef
   */
  readonly publishConnectionDetailsWithStoreConfigRef?: CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef;

  /**
   * Resources is a list of resource templates that will be used when a
   * composite resource referring to this composition is created.
   *
   *
   * Resources are only used by the "Resources" mode of Composition. They are
   * ignored by other modes.
   *
   * @schema CompositionRevisionV1Beta1Spec#resources
   */
  readonly resources?: CompositionRevisionV1Beta1SpecResources[];

  /**
   * Revision number. Newer revisions have larger numbers.
   *
   * @schema CompositionRevisionV1Beta1Spec#revision
   */
  readonly revision: number;

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
   * set independently and connection details would be published to both
   * without affecting each other as long as related fields at MR level
   * specified.
   *
   * @schema CompositionRevisionV1Beta1Spec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1Spec(obj: CompositionRevisionV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionRevisionV1Beta1SpecCompositeTypeRef(obj.compositeTypeRef),
    'environment': toJson_CompositionRevisionV1Beta1SpecEnvironment(obj.environment),
    'mode': obj.mode,
    'patchSets': obj.patchSets?.map(y => toJson_CompositionRevisionV1Beta1SpecPatchSets(y)),
    'pipeline': obj.pipeline?.map(y => toJson_CompositionRevisionV1Beta1SpecPipeline(y)),
    'publishConnectionDetailsWithStoreConfigRef': toJson_CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef(obj.publishConnectionDetailsWithStoreConfigRef),
    'resources': obj.resources?.map(y => toJson_CompositionRevisionV1Beta1SpecResources(y)),
    'revision': obj.revision,
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionRevisionV1Beta1SpecCompositeTypeRef
 */
export interface CompositionRevisionV1Beta1SpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionRevisionV1Beta1SpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionRevisionV1Beta1SpecCompositeTypeRef#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecCompositeTypeRef(obj: CompositionRevisionV1Beta1SpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment configures the environment in which resources are rendered.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironment
 */
export interface CompositionRevisionV1Beta1SpecEnvironment {
  /**
   * DefaultData statically defines the initial state of the environment.
   * It has the same schema-less structure as the data field in
   * environment configs.
   * It is overwritten by the selected environment configs.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironment#defaultData
   */
  readonly defaultData?: { [key: string]: any };

  /**
   * EnvironmentConfigs selects a list of `EnvironmentConfig`s. The resolved
   * resources are stored in the composite resource at
   * `spec.environmentConfigRefs` and is only updated if it is null.
   *
   *
   * The list of references is used to compute an in-memory environment at
   * compose time. The data of all object is merged in the order they are
   * listed, meaning the values of EnvironmentConfigs with a larger index take
   * priority over ones with smaller indices.
   *
   *
   * The computed environment can be accessed in a composition using
   * `FromEnvironmentFieldPath` and `CombineFromEnvironment` patches.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironment#environmentConfigs
   */
  readonly environmentConfigs?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs[];

  /**
   * Patches is a list of environment patches that are executed before a
   * composition's resources are composed.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironment#patches
   */
  readonly patches?: CompositionRevisionV1Beta1SpecEnvironmentPatches[];

  /**
   * Policy represents the Resolve and Resolution policies which apply to
   * all EnvironmentSourceReferences in EnvironmentConfigs list.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironment#policy
   */
  readonly policy?: CompositionRevisionV1Beta1SpecEnvironmentPolicy;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironment(obj: CompositionRevisionV1Beta1SpecEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultData': ((obj.defaultData) === undefined) ? undefined : (Object.entries(obj.defaultData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'environmentConfigs': obj.environmentConfigs?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs(y)),
    'patches': obj.patches?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentPatches(y)),
    'policy': toJson_CompositionRevisionV1Beta1SpecEnvironmentPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 *
 * "Resources" (the default) indicates that a Composition uses what is
 * commonly referred to as "Patch & Transform" or P&T composition. This mode
 * of Composition uses an array of resources, each a template for a composed
 * resource.
 *
 *
 * "Pipeline" indicates that a Composition specifies a pipeline
 * of Composition Functions, each of which is responsible for producing
 * composed resources that Crossplane should create or update. THE PIPELINE
 * MODE IS A BETA FEATURE. It is not honored if the relevant Crossplane
 * feature flag is disabled.
 *
 * @schema CompositionRevisionV1Beta1SpecMode
 */
export enum CompositionRevisionV1Beta1SpecMode {
  /** Resources */
  RESOURCES = "Resources",
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PatchSet is a set of patches that can be reused from all resources within
 * a Composition.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSets
 */
export interface CompositionRevisionV1Beta1SpecPatchSets {
  /**
   * Name of this PatchSet.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSets#name
   */
  readonly name: string;

  /**
   * Patches will be applied as an overlay to the base resource.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSets#patches
   */
  readonly patches: CompositionRevisionV1Beta1SpecPatchSetsPatches[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSets(obj: CompositionRevisionV1Beta1SpecPatchSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionRevisionV1Beta1SpecPatchSetsPatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A PipelineStep in a Composition Function pipeline.
 *
 * @schema CompositionRevisionV1Beta1SpecPipeline
 */
export interface CompositionRevisionV1Beta1SpecPipeline {
  /**
   * FunctionRef is a reference to the Composition Function this step should
   * execute.
   *
   * @schema CompositionRevisionV1Beta1SpecPipeline#functionRef
   */
  readonly functionRef: CompositionRevisionV1Beta1SpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the Composition
   * Function as the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionRevisionV1Beta1SpecPipeline#input
   */
  readonly input?: any;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionRevisionV1Beta1SpecPipeline#step
   */
  readonly step: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPipeline(obj: CompositionRevisionV1Beta1SpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionRef': toJson_CompositionRevisionV1Beta1SpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsWithStoreConfig specifies the secret store config
 * with which the connection details of composite resources dynamically
 * provisioned using this composition will be published.
 *
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef
 */
export interface CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef {
  /**
   * Name of the referenced StoreConfig.
   *
   * @schema CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef(obj: CompositionRevisionV1Beta1SpecPublishConnectionDetailsWithStoreConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ComposedTemplate is used to provide information about how the composed resource
 * should be processed.
 *
 * @schema CompositionRevisionV1Beta1SpecResources
 */
export interface CompositionRevisionV1Beta1SpecResources {
  /**
   * Base is the target resource that the patches will be applied on.
   *
   * @schema CompositionRevisionV1Beta1SpecResources#base
   */
  readonly base: any;

  /**
   * ConnectionDetails lists the propagation secret keys from this target
   * resource to the composition instance connection secret.
   *
   * @schema CompositionRevisionV1Beta1SpecResources#connectionDetails
   */
  readonly connectionDetails?: CompositionRevisionV1Beta1SpecResourcesConnectionDetails[];

  /**
   * A Name uniquely identifies this entry within its Composition's resources
   * array. Names are optional but *strongly* recommended. When all entries in
   * the resources array are named entries may added, deleted, and reordered
   * as long as their names do not change. When entries are not named the
   * length and order of the resources array should be treated as immutable.
   * Either all or no entries must be named.
   *
   * @schema CompositionRevisionV1Beta1SpecResources#name
   */
  readonly name?: string;

  /**
   * Patches will be applied as overlay to the base resource.
   *
   * @schema CompositionRevisionV1Beta1SpecResources#patches
   */
  readonly patches?: CompositionRevisionV1Beta1SpecResourcesPatches[];

  /**
   * ReadinessChecks allows users to define custom readiness checks. All checks
   * have to return true in order for resource to be considered ready. The
   * default readiness check is to have the "Ready" condition to be "True".
   *
   * @schema CompositionRevisionV1Beta1SpecResources#readinessChecks
   */
  readonly readinessChecks?: CompositionRevisionV1Beta1SpecResourcesReadinessChecks[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResources(obj: CompositionRevisionV1Beta1SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'connectionDetails': obj.connectionDetails?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesConnectionDetails(y)),
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesPatches(y)),
    'readinessChecks': obj.readinessChecks?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesReadinessChecks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSource selects a EnvironmentConfig resource.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs {
  /**
   * Ref is a named reference to a single EnvironmentConfig.
   * Either Ref or Selector is required.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs#ref
   */
  readonly ref?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef;

  /**
   * Selector selects EnvironmentConfig(s) via labels.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs#selector
   */
  readonly selector?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector;

  /**
   * Type specifies the way the EnvironmentConfig is selected.
   * Default is `Reference`
   *
   * @default Reference`
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs(obj: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef(obj.ref),
    'selector': toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector(obj.selector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentPatch is a patch for a Composition environment.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite or
   * CombineToComposite patch.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#combine
   */
  readonly combine?: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath or
   * ToCompositeFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#policy
   */
  readonly policy?: CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#transforms
   */
  readonly transforms?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatches#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecEnvironmentPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatches(obj: CompositionRevisionV1Beta1SpecEnvironmentPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'policy': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy represents the Resolve and Resolution policies which apply to
 * all EnvironmentSourceReferences in EnvironmentConfigs list.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPolicy
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPolicy#resolution
   */
  readonly resolution?: CompositionRevisionV1Beta1SpecEnvironmentPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPolicy#resolve
   */
  readonly resolve?: CompositionRevisionV1Beta1SpecEnvironmentPolicyResolve;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPolicy(obj: CompositionRevisionV1Beta1SpecEnvironmentPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#combine
   */
  readonly combine?: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#policy
   */
  readonly policy?: CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#transforms
   */
  readonly transforms?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatches#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecPatchSetsPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatches(obj: CompositionRevisionV1Beta1SpecPatchSetsPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionRef is a reference to the Composition Function this step should
 * execute.
 *
 * @schema CompositionRevisionV1Beta1SpecPipelineFunctionRef
 */
export interface CompositionRevisionV1Beta1SpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionRevisionV1Beta1SpecPipelineFunctionRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPipelineFunctionRef(obj: CompositionRevisionV1Beta1SpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionDetail includes the information about the propagation of the connection
 * information from one secret to another.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails
 */
export interface CompositionRevisionV1Beta1SpecResourcesConnectionDetails {
  /**
   * FromConnectionSecretKey is the key that will be used to fetch the value
   * from the composed resource's connection secret.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails#fromConnectionSecretKey
   */
  readonly fromConnectionSecretKey?: string;

  /**
   * FromFieldPath is the path of the field on the composed resource whose
   * value to be used as input. Name must be specified if the type is
   * FromFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Name of the connection secret key that will be propagated to the
   * connection secret of the composition instance. Leave empty if you'd like
   * to use the same key name.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Type sets the connection detail fetching behaviour to be used. Each
   * connection detail type may require its own fields to be set on the
   * ConnectionDetail object. If the type is omitted Crossplane will attempt
   * to infer it based on which other fields were specified. If multiple
   * fields are specified the order of precedence is:
   * 1. FromValue
   * 2. FromConnectionSecretKey
   * 3. FromFieldPath
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecResourcesConnectionDetailsType;

  /**
   * Value that will be propagated to the connection secret of the composite
   * resource. May be set to inject a fixed, non-sensitive connection secret
   * value, for example a well-known port.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesConnectionDetails(obj: CompositionRevisionV1Beta1SpecResourcesConnectionDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromConnectionSecretKey': obj.fromConnectionSecretKey,
    'fromFieldPath': obj.fromFieldPath,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatches
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite,
   * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#combine
   */
  readonly combine?: CompositionRevisionV1Beta1SpecResourcesPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath,
   * FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#policy
   */
  readonly policy?: CompositionRevisionV1Beta1SpecResourcesPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#transforms
   */
  readonly transforms?: CompositionRevisionV1Beta1SpecResourcesPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatches#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecResourcesPatchesType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatches(obj: CompositionRevisionV1Beta1SpecResourcesPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReadinessCheck is used to indicate how to tell whether a resource is ready
 * for consumption
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks
 */
export interface CompositionRevisionV1Beta1SpecResourcesReadinessChecks {
  /**
   * FieldPath shows the path of the field whose value will be used.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks#matchCondition
   */
  readonly matchCondition?: CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition;

  /**
   * MatchInt is the value you'd like to match if you're using "MatchInt" type.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks#matchInteger
   */
  readonly matchInteger?: number;

  /**
   * MatchString is the value you'd like to match if you're using "MatchString" type.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks#matchString
   */
  readonly matchString?: string;

  /**
   * Type indicates the type of probe you'd like to use.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecks#type
   */
  readonly type: CompositionRevisionV1Beta1SpecResourcesReadinessChecksType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesReadinessChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesReadinessChecks(obj: CompositionRevisionV1Beta1SpecResourcesReadinessChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'matchCondition': toJson_CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition(obj.matchCondition),
    'matchInteger': obj.matchInteger,
    'matchString': obj.matchString,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ref is a named reference to a single EnvironmentConfig.
 * Either Ref or Selector is required.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef {
  /**
   * The name of the object.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef(obj: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector selects EnvironmentConfig(s) via labels.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector {
  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector#matchLabels
   */
  readonly matchLabels?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels[];

  /**
   * MaxMatch specifies the number of extracted EnvironmentConfigs in Multiple mode, extracts all if nil.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector#maxMatch
   */
  readonly maxMatch?: number;

  /**
   * MinMatch specifies the required minimum of extracted EnvironmentConfigs in Multiple mode.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector#minMatch
   */
  readonly minMatch?: number;

  /**
   * Mode specifies retrieval strategy: "Single" or "Multiple".
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector#mode
   */
  readonly mode?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMode;

  /**
   * SortByFieldPath is the path to the field based on which list of EnvironmentConfigs is alphabetically sorted.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector#sortByFieldPath
   */
  readonly sortByFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector(obj: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': obj.matchLabels?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels(y)),
    'maxMatch': obj.maxMatch,
    'minMatch': obj.minMatch,
    'mode': obj.mode,
    'sortByFieldPath': obj.sortByFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies the way the EnvironmentConfig is selected.
 * Default is `Reference`
 *
 * @default Reference`
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsType {
  /** Reference */
  REFERENCE = "Reference",
  /** Selector */
  SELECTOR = "Selector",
}

/**
 * Combine is the patch configuration for a CombineFromComposite or
 * CombineToComposite patch.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine#variables
   */
  readonly variables: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#match
   */
  readonly match?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#math
   */
  readonly math?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms#type
   */
  readonly type: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPolicyResolution
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPolicyResolve
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine#variables
   */
  readonly variables: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#match
   */
  readonly match?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#math
   */
  readonly math?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms#type
   */
  readonly type: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * Type sets the connection detail fetching behaviour to be used. Each
 * connection detail type may require its own fields to be set on the
 * ConnectionDetail object. If the type is omitted Crossplane will attempt
 * to infer it based on which other fields were specified. If multiple
 * fields are specified the order of precedence is:
 * 1. FromValue
 * 2. FromConnectionSecretKey
 * 3. FromFieldPath
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesConnectionDetailsType
 */
export enum CompositionRevisionV1Beta1SpecResourcesConnectionDetailsType {
  /** FromConnectionSecretKey */
  FROM_CONNECTION_SECRET_KEY = "FromConnectionSecretKey",
  /** FromFieldPath */
  FROM_FIELD_PATH = "FromFieldPath",
  /** FromValue */
  FROM_VALUE = "FromValue",
}

/**
 * Combine is the patch configuration for a CombineFromComposite,
 * CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombine
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombine#strategy
   */
  readonly strategy: CompositionRevisionV1Beta1SpecResourcesPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombine#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecResourcesPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombine#variables
   */
  readonly variables: CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombine(obj: CompositionRevisionV1Beta1SpecResourcesPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicy
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionRevisionV1Beta1SpecResourcesPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesPolicy(obj: CompositionRevisionV1Beta1SpecResourcesPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#match
   */
  readonly match?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#math
   */
  readonly math?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#string
   */
  readonly string?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransforms#type
   */
  readonly type: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransforms(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath(obj.math),
    'string': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** FromEnvironmentFieldPath */
  FROM_ENVIRONMENT_FIELD_PATH = "FromEnvironmentFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** ToEnvironmentFieldPath */
  TO_ENVIRONMENT_FIELD_PATH = "ToEnvironmentFieldPath",
  /** CombineFromEnvironment */
  COMBINE_FROM_ENVIRONMENT = "CombineFromEnvironment",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
  /** CombineToEnvironment */
  COMBINE_TO_ENVIRONMENT = "CombineToEnvironment",
}

/**
 * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition
 */
export interface CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition {
  /**
   * Status is the status of the condition you'd like to match.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition#status
   */
  readonly status: string;

  /**
   * Type indicates the type of condition you'd like to use.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition(obj: CompositionRevisionV1Beta1SpecResourcesReadinessChecksMatchCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type indicates the type of probe you'd like to use.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesReadinessChecksType
 */
export enum CompositionRevisionV1Beta1SpecResourcesReadinessChecksType {
  /** MatchString */
  MATCH_STRING = "MatchString",
  /** MatchInteger */
  MATCH_INTEGER = "MatchInteger",
  /** NonEmpty */
  NON_EMPTY = "NonEmpty",
  /** MatchCondition */
  MATCH_CONDITION = "MatchCondition",
  /** MatchTrue */
  MATCH_TRUE = "MatchTrue",
  /** MatchFalse */
  MATCH_FALSE = "MatchFalse",
  /** None */
  NONE = "None",
}

/**
 * An EnvironmentSourceSelectorLabelMatcher acts like a k8s label selector but
 * can draw the label value from a different path.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels {
  /**
   * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
   * The default is Required, meaning that an error will be returned if the
   * field is not found in the composite resource.
   * Optional means that if the field is not found in the composite resource,
   * that label pair will just be skipped. N.B. other specified label
   * matchers will still be used to retrieve the desired
   * environment config, if any.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels#fromFieldPathPolicy
   */
  readonly fromFieldPathPolicy?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy;

  /**
   * Key of the label to match.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels#key
   */
  readonly key: string;

  /**
   * Type specifies where the value for a label comes from.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType;

  /**
   * Value specifies a literal label value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels#value
   */
  readonly value?: string;

  /**
   * ValueFromFieldPath specifies the field path to look for the label value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels#valueFromFieldPath
   */
  readonly valueFromFieldPath?: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels(obj: CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPathPolicy': obj.fromFieldPathPolicy,
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
    'valueFromFieldPath': obj.valueFromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode specifies retrieval strategy: "Single" or "Multiple".
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMode
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMode {
  /** Single */
  SINGLE = "Single",
  /** Multiple */
  MULTIPLE = "Multiple",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineStrategy
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineStrategy
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombineStrategy
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombineString
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombineString#fmt
   */
  readonly fmt: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombineString(obj: CompositionRevisionV1Beta1SpecResourcesPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables(obj: CompositionRevisionV1Beta1SpecResourcesPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicyFromFieldPath
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions(obj: CompositionRevisionV1Beta1SpecResourcesPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert#format
   */
  readonly format?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert#toType
   */
  readonly toType: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertToType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns[];

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMathType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#convert
   */
  readonly convert?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#join
   */
  readonly join?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString#type
   */
  readonly type?: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
 * The default is Required, meaning that an error will be returned if the
 * field is not found in the composite resource.
 * Optional means that if the field is not found in the composite resource,
 * that label pair will just be skipped. N.B. other specified label
 * matchers will still be used to retrieve the desired
 * environment config, if any.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsFromFieldPathPolicy {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * Type specifies where the value for a label comes from.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentEnvironmentConfigsSelectorMatchLabelsType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** Value */
  VALUE = "Value",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertFormat
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertToType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMathType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringConvert
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp
 */
export interface CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp(obj: CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertFormat
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertToType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMathType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringConvert
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp
 */
export interface CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp(obj: CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertFormat
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertToType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchFallbackTo
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatternsType;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMathType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringConvert
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin#separator
   */
  readonly separator: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp
 */
export interface CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp#match
   */
  readonly match: string;

}

/**
 * Converts an object of type 'CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp(obj: CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionV1Beta1SpecEnvironmentPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionV1Beta1SpecPatchSetsPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatternsType
 */
export enum CompositionRevisionV1Beta1SpecResourcesPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}


/**
 * A EnvironmentConfig contains a set of arbitrary, unstructured values.
 *
 * @schema EnvironmentConfig
 */
export class EnvironmentConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvironmentConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1alpha1',
    kind: 'EnvironmentConfig',
  }

  /**
   * Renders a Kubernetes manifest for "EnvironmentConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentConfigProps = {}): any {
    return {
      ...EnvironmentConfig.GVK,
      ...toJson_EnvironmentConfigProps(props),
    };
  }

  /**
   * Defines a "EnvironmentConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentConfigProps = {}) {
    super(scope, id, {
      ...EnvironmentConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvironmentConfig.GVK,
      ...toJson_EnvironmentConfigProps(resolved),
    };
  }
}

/**
 * A EnvironmentConfig contains a set of arbitrary, unstructured values.
 *
 * @schema EnvironmentConfig
 */
export interface EnvironmentConfigProps {
  /**
   * @schema EnvironmentConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The data of this EnvironmentConfig.
   * This may contain any kind of structure that can be serialized into JSON.
   *
   * @schema EnvironmentConfig#data
   */
  readonly data?: { [key: string]: any };

}

/**
 * Converts an object of type 'EnvironmentConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentConfigProps(obj: EnvironmentConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * A Usage defines a deletion blocking relationship between two resources.
 *
 * @schema Usage
 */
export class Usage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Usage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1alpha1',
    kind: 'Usage',
  }

  /**
   * Renders a Kubernetes manifest for "Usage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsageProps): any {
    return {
      ...Usage.GVK,
      ...toJson_UsageProps(props),
    };
  }

  /**
   * Defines a "Usage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsageProps) {
    super(scope, id, {
      ...Usage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Usage.GVK,
      ...toJson_UsageProps(resolved),
    };
  }
}

/**
 * A Usage defines a deletion blocking relationship between two resources.
 *
 * @schema Usage
 */
export interface UsageProps {
  /**
   * @schema Usage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsageSpec defines the desired state of Usage.
   *
   * @schema Usage#spec
   */
  readonly spec: UsageSpec;

}

/**
 * Converts an object of type 'UsageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageProps(obj: UsageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsageSpec defines the desired state of Usage.
 *
 * @schema UsageSpec
 */
export interface UsageSpec {
  /**
   * By is the resource that is "using the other resource".
   *
   * @schema UsageSpec#by
   */
  readonly by?: UsageSpecBy;

  /**
   * Of is the resource that is "being used".
   *
   * @schema UsageSpec#of
   */
  readonly of: UsageSpecOf;

  /**
   * Reason is the reason for blocking deletion of the resource.
   *
   * @schema UsageSpec#reason
   */
  readonly reason?: string;

}

/**
 * Converts an object of type 'UsageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpec(obj: UsageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'by': toJson_UsageSpecBy(obj.by),
    'of': toJson_UsageSpecOf(obj.of),
    'reason': obj.reason,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By is the resource that is "using the other resource".
 *
 * @schema UsageSpecBy
 */
export interface UsageSpecBy {
  /**
   * API version of the referent.
   *
   * @schema UsageSpecBy#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema UsageSpecBy#kind
   */
  readonly kind?: string;

  /**
   * Reference to the resource.
   *
   * @schema UsageSpecBy#resourceRef
   */
  readonly resourceRef?: UsageSpecByResourceRef;

  /**
   * Selector to the resource.
   * This field will be ignored if ResourceRef is set.
   *
   * @schema UsageSpecBy#resourceSelector
   */
  readonly resourceSelector?: UsageSpecByResourceSelector;

}

/**
 * Converts an object of type 'UsageSpecBy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecBy(obj: UsageSpecBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'resourceRef': toJson_UsageSpecByResourceRef(obj.resourceRef),
    'resourceSelector': toJson_UsageSpecByResourceSelector(obj.resourceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Of is the resource that is "being used".
 *
 * @schema UsageSpecOf
 */
export interface UsageSpecOf {
  /**
   * API version of the referent.
   *
   * @schema UsageSpecOf#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema UsageSpecOf#kind
   */
  readonly kind?: string;

  /**
   * Reference to the resource.
   *
   * @schema UsageSpecOf#resourceRef
   */
  readonly resourceRef?: UsageSpecOfResourceRef;

  /**
   * Selector to the resource.
   * This field will be ignored if ResourceRef is set.
   *
   * @schema UsageSpecOf#resourceSelector
   */
  readonly resourceSelector?: UsageSpecOfResourceSelector;

}

/**
 * Converts an object of type 'UsageSpecOf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecOf(obj: UsageSpecOf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'resourceRef': toJson_UsageSpecOfResourceRef(obj.resourceRef),
    'resourceSelector': toJson_UsageSpecOfResourceSelector(obj.resourceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the resource.
 *
 * @schema UsageSpecByResourceRef
 */
export interface UsageSpecByResourceRef {
  /**
   * Name of the referent.
   *
   * @schema UsageSpecByResourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsageSpecByResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecByResourceRef(obj: UsageSpecByResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to the resource.
 * This field will be ignored if ResourceRef is set.
 *
 * @schema UsageSpecByResourceSelector
 */
export interface UsageSpecByResourceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema UsageSpecByResourceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsageSpecByResourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'UsageSpecByResourceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecByResourceSelector(obj: UsageSpecByResourceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the resource.
 *
 * @schema UsageSpecOfResourceRef
 */
export interface UsageSpecOfResourceRef {
  /**
   * Name of the referent.
   *
   * @schema UsageSpecOfResourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsageSpecOfResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecOfResourceRef(obj: UsageSpecOfResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to the resource.
 * This field will be ignored if ResourceRef is set.
 *
 * @schema UsageSpecOfResourceSelector
 */
export interface UsageSpecOfResourceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema UsageSpecOfResourceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsageSpecOfResourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'UsageSpecOfResourceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageSpecOfResourceSelector(obj: UsageSpecOfResourceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

