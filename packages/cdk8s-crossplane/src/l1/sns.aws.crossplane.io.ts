// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Subscription defines a managed resource that represents state of a AWS SNS Subscription
 *
 * @schema Subscription
 */
export class Subscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.crossplane.io/v1beta1',
    kind: 'Subscription',
  }

  /**
   * Renders a Kubernetes manifest for "Subscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubscriptionProps): any {
    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(props),
    };
  }

  /**
   * Defines a "Subscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubscriptionProps) {
    super(scope, id, {
      ...Subscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(resolved),
    };
  }
}

/**
 * Subscription defines a managed resource that represents state of a AWS SNS Subscription
 *
 * @schema Subscription
 */
export interface SubscriptionProps {
  /**
   * @schema Subscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubscriptionSpec defined the desired state of a AWS SNS Topic
   *
   * @schema Subscription#spec
   */
  readonly spec: SubscriptionSpec;

}

/**
 * Converts an object of type 'SubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionProps(obj: SubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubscriptionSpec defined the desired state of a AWS SNS Topic
 *
 * @schema SubscriptionSpec
 */
export interface SubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubscriptionSpecDeletionPolicy;

  /**
   * SubscriptionParameters define the desired state of a AWS SNS Topic
   *
   * @schema SubscriptionSpec#forProvider
   */
  readonly forProvider: SubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: SubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpec(obj: SubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubscriptionSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubscriptionSpecDeletionPolicy
 */
export enum SubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SubscriptionParameters define the desired state of a AWS SNS Topic
 *
 * @schema SubscriptionSpecForProvider
 */
export interface SubscriptionSpecForProvider {
  /**
   * DeliveryPolicy defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
   *
   * @schema SubscriptionSpecForProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * The subscription's endpoint
   *
   * @schema SubscriptionSpecForProvider#endpoint
   */
  readonly endpoint: string;

  /**
   * The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
   *
   * @schema SubscriptionSpecForProvider#filterPolicy
   */
  readonly filterPolicy?: string;

  /**
   * FilterPolicyScope can be MessageAttributes or MessageBody
   *
   * @schema SubscriptionSpecForProvider#filterPolicyScope
   */
  readonly filterPolicyScope?: string;

  /**
   * The subscription's protocol.
   *
   * @schema SubscriptionSpecForProvider#protocol
   */
  readonly protocol: string;

  /**
   * When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
   *
   * @schema SubscriptionSpecForProvider#rawMessageDelivery
   */
  readonly rawMessageDelivery?: string;

  /**
   * When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
   *
   * @schema SubscriptionSpecForProvider#redrivePolicy
   */
  readonly redrivePolicy?: string;

  /**
   * Region is the region you'd like your Subscription to be in.
   *
   * @schema SubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * TopicArn is the Arn of the SNS Topic
   *
   * @schema SubscriptionSpecForProvider#topicArn
   */
  readonly topicArn?: string;

  /**
   * TopicArnRef references a SNS Topic and retrieves its TopicArn
   *
   * @schema SubscriptionSpecForProvider#topicArnRef
   */
  readonly topicArnRef?: SubscriptionSpecForProviderTopicArnRef;

  /**
   * TopicArnSelector selects a reference to a SNS Topic and retrieves its TopicArn
   *
   * @schema SubscriptionSpecForProvider#topicArnSelector
   */
  readonly topicArnSelector?: SubscriptionSpecForProviderTopicArnSelector;

}

/**
 * Converts an object of type 'SubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProvider(obj: SubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryPolicy': obj.deliveryPolicy,
    'endpoint': obj.endpoint,
    'filterPolicy': obj.filterPolicy,
    'filterPolicyScope': obj.filterPolicyScope,
    'protocol': obj.protocol,
    'rawMessageDelivery': obj.rawMessageDelivery,
    'redrivePolicy': obj.redrivePolicy,
    'region': obj.region,
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_SubscriptionSpecForProviderTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_SubscriptionSpecForProviderTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SubscriptionSpecManagementPolicies
 */
export enum SubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubscriptionSpecProviderConfigRef
 */
export interface SubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: SubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderConfigRef(obj: SubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsTo
 */
export interface SubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsTo(obj: SubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubscriptionSpecWriteConnectionSecretToRef
 */
export interface SubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecWriteConnectionSecretToRef(obj: SubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicArnRef references a SNS Topic and retrieves its TopicArn
 *
 * @schema SubscriptionSpecForProviderTopicArnRef
 */
export interface SubscriptionSpecForProviderTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecForProviderTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecForProviderTopicArnRef#policy
   */
  readonly policy?: SubscriptionSpecForProviderTopicArnRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicArnRef(obj: SubscriptionSpecForProviderTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecForProviderTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicArnSelector selects a reference to a SNS Topic and retrieves its TopicArn
 *
 * @schema SubscriptionSpecForProviderTopicArnSelector
 */
export interface SubscriptionSpecForProviderTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubscriptionSpecForProviderTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubscriptionSpecForProviderTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubscriptionSpecForProviderTopicArnSelector#policy
   */
  readonly policy?: SubscriptionSpecForProviderTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicArnSelector(obj: SubscriptionSpecForProviderTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubscriptionSpecForProviderTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicy
 */
export interface SubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderConfigRefPolicy(obj: SubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface SubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToConfigRef(obj: SubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface SubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToMetadata(obj: SubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecForProviderTopicArnRefPolicy
 */
export interface SubscriptionSpecForProviderTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderTopicArnRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderTopicArnRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicArnRefPolicy(obj: SubscriptionSpecForProviderTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubscriptionSpecForProviderTopicArnSelectorPolicy
 */
export interface SubscriptionSpecForProviderTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicArnSelectorPolicy(obj: SubscriptionSpecForProviderTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum SubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum SubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderTopicArnRefPolicyResolution
 */
export enum SubscriptionSpecForProviderTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderTopicArnRefPolicyResolve
 */
export enum SubscriptionSpecForProviderTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderTopicArnSelectorPolicyResolution
 */
export enum SubscriptionSpecForProviderTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderTopicArnSelectorPolicyResolve
 */
export enum SubscriptionSpecForProviderTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Topic defines a managed resource that represents state of a AWS Topic
 *
 * @schema Topic
 */
export class Topic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Topic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.crossplane.io/v1beta1',
    kind: 'Topic',
  }

  /**
   * Renders a Kubernetes manifest for "Topic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicProps): any {
    return {
      ...Topic.GVK,
      ...toJson_TopicProps(props),
    };
  }

  /**
   * Defines a "Topic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicProps) {
    super(scope, id, {
      ...Topic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Topic.GVK,
      ...toJson_TopicProps(resolved),
    };
  }
}

/**
 * Topic defines a managed resource that represents state of a AWS Topic
 *
 * @schema Topic
 */
export interface TopicProps {
  /**
   * @schema Topic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicSpec defined the desired state of a AWS SNS Topic
   *
   * @schema Topic#spec
   */
  readonly spec: TopicSpec;

}

/**
 * Converts an object of type 'TopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicProps(obj: TopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicSpec defined the desired state of a AWS SNS Topic
 *
 * @schema TopicSpec
 */
export interface TopicSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TopicSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicSpecDeletionPolicy;

  /**
   * TopicParameters define the desired state of a AWS SNS Topic
   *
   * @schema TopicSpec#forProvider
   */
  readonly forProvider: TopicSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TopicSpec#managementPolicies
   */
  readonly managementPolicies?: TopicSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpec(obj: TopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TopicSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TopicSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TopicSpecDeletionPolicy
 */
export enum TopicSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TopicParameters define the desired state of a AWS SNS Topic
 *
 * @schema TopicSpecForProvider
 */
export interface TopicSpecForProvider {
  /**
   * DeliveryRetryPolicy - the JSON serialization of the effective delivery policy, taking system defaults into account
   *
   * @schema TopicSpecForProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * The display name to use for a topic with SNS subscriptions.
   *
   * @schema TopicSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Whether or not this should be a fifo-topic
   *
   * @schema TopicSpecForProvider#fifoTopic
   */
  readonly fifoTopic?: boolean;

  /**
   * Setting this enables server side encryption at-rest to your topic. The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK
   * For more examples, see KeyId (https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the AWS Key Management Service API Reference.
   *
   * @schema TopicSpecForProvider#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * Name refers to the name of the AWS SNS Topic
   *
   * @schema TopicSpecForProvider#name
   */
  readonly name: string;

  /**
   * The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
   *
   * @schema TopicSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your Topic to be created in.
   *
   * @schema TopicSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tags represetnt a list of user-provided metadata that can be associated with a SNS Topic. For more information about tagging, see Tagging SNS Topics (https://docs.aws.amazon.com/sns/latest/dg/sns-tags.html) in the SNS User Guide.
   *
   * @schema TopicSpecForProvider#tags
   */
  readonly tags?: TopicSpecForProviderTags[];

}

/**
 * Converts an object of type 'TopicSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProvider(obj: TopicSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryPolicy': obj.deliveryPolicy,
    'displayName': obj.displayName,
    'fifoTopic': obj.fifoTopic,
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'name': obj.name,
    'policy': obj.policy,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_TopicSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TopicSpecManagementPolicies
 */
export enum TopicSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicSpecProviderConfigRef
 */
export interface TopicSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecProviderConfigRef#policy
   */
  readonly policy?: TopicSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRef(obj: TopicSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicSpecPublishConnectionDetailsTo
 */
export interface TopicSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsTo(obj: TopicSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicSpecWriteConnectionSecretToRef
 */
export interface TopicSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecWriteConnectionSecretToRef(obj: TopicSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag represent a user-provided metadata that can be associated with a SNS Topic. For more information about tagging, see Tagging SNS Topics (https://docs.aws.amazon.com/sns/latest/dg/sns-tags.html) in the SNS User Guide.
 *
 * @schema TopicSpecForProviderTags
 */
export interface TopicSpecForProviderTags {
  /**
   * The key name that can be used to look up or retrieve the associated value. For example, Department or Cost Center are common choices.
   *
   * @schema TopicSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * The value associated with this tag. For example, tags with a key name of Department could have values such as Human Resources, Accounting, and Support. Tags with a key name of Cost Center might have values that consist of the number associated with the different cost centers in your company. Typically, many resources have tags with the same key name but with different values.
   * AWS always interprets the tag Value as a single string. If you need to store an array, you can store comma-separated values in the string. However, you must interpret the value in your code.
   *
   * @schema TopicSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderTags(obj: TopicSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecProviderConfigRefPolicy
 */
export interface TopicSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRefPolicy(obj: TopicSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj: TopicSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicSpecPublishConnectionDetailsToMetadata
 */
export interface TopicSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToMetadata(obj: TopicSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolution
 */
export enum TopicSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolve
 */
export enum TopicSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

