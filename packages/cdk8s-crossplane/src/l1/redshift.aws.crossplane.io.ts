// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Cluster is a managed resource that represents an AWS Redshift cluster.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.crossplane.io/v1alpha1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * A Cluster is a managed resource that represents an AWS Redshift cluster.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of an AWS Redshift Cluster.
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of an AWS Redshift Cluster.
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * ClusterParameters define the parameters available for an AWS Redshift cluster
   *
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClusterParameters define the parameters available for an AWS Redshift cluster
 *
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * AllowVersionUpgrade indicates that major engine upgrades are applied automatically to the cluster during the maintenance window. default=true
   *
   * @schema ClusterSpecForProvider#allowVersionUpgrade
   */
  readonly allowVersionUpgrade?: boolean;

  /**
   * AutomatedSnapshotRetentionPeriod is the number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to  0 disables automated backups. default=1
   *
   * @schema ClusterSpecForProvider#automatedSnapshotRetentionPeriod
   */
  readonly automatedSnapshotRetentionPeriod?: number;

  /**
   * AvailabilityZone is the EC2 Availability Zone in which you want Amazon Redshift to provision the cluster. Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint. Example: us-east-2d Constraint: The specified Availability Zone must be in the same region as the current endpoint. The Availability Zone parameter can't be specified if the MultiAZ parameter is set to true. The specified Availability Zone must be in the same AWS Region as the current endpoint.
   *
   * @schema ClusterSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * ClusterParameterGroupName is the name of the cluster parameter group to use for the cluster. Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to Working with Amazon Redshift Parameter Groups (https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)
   *
   * @schema ClusterSpecForProvider#clusterParameterGroupName
   */
  readonly clusterParameterGroupName?: string;

  /**
   * ClusterSecurityGroupRefs are references to ClusterSecurityGroups used to set the ClusterSecurityGroups.
   *
   * @schema ClusterSpecForProvider#clusterSecurityGroupRefs
   */
  readonly clusterSecurityGroupRefs?: ClusterSpecForProviderClusterSecurityGroupRefs[];

  /**
   * ClusterSecurityGroupSelector selects references to ClusterSecurityGroups used to set the ClusterSecurityGroups.
   *
   * @schema ClusterSpecForProvider#clusterSecurityGroupSelector
   */
  readonly clusterSecurityGroupSelector?: ClusterSpecForProviderClusterSecurityGroupSelector;

  /**
   * SecurityGroups is a list of security groups to associate with this cluster. Default: The default cluster security group for Amazon Redshift.
   *
   * @schema ClusterSpecForProvider#clusterSecurityGroups
   */
  readonly clusterSecurityGroups?: string[];

  /**
   * ClusterSubnetGroupName is the name of a cluster subnet group to be associated with this cluster. If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).
   *
   * @schema ClusterSpecForProvider#clusterSubnetGroupName
   */
  readonly clusterSubnetGroupName?: string;

  /**
   * ClusterType is the type of the cluster you want. When cluster type is specified as * single-node, the NumberOfNodes parameter is not required. * multi-node, the NumberOfNodes parameter is required. default=multi-node
   *
   * @schema ClusterSpecForProvider#clusterType
   */
  readonly clusterType?: ClusterSpecForProviderClusterType;

  /**
   * ClusterVersion is the version of the Amazon Redshift engine software that you want to deploy on the cluster. The version selected runs on all the nodes in the cluster. Constraints: Only version 1.0 is currently available.
   *
   * @schema ClusterSpecForProvider#clusterVersion
   */
  readonly clusterVersion?: string;

  /**
   * DBName is the name of the first database to be created when the cluster is created. To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to Create a Database (https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html) in the Amazon Redshift Database Developer Guide. Constraints: * Must contain 1 to 64 alphanumeric characters. * Must contain only lowercase letters. * Cannot be a word that is reserved by the service. A list of reserved words can be found in Reserved Words (https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide. default=dev
   *
   * @schema ClusterSpecForProvider#dbName
   */
  readonly dbName?: string;

  /**
   * The Elastic IP (EIP) address for the cluster. Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to Supported Platforms to Launch Your Cluster (https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms) in the Amazon Redshift Cluster Management Guide.
   *
   * @schema ClusterSpecForProvider#elasticIP
   */
  readonly elasticIp?: string;

  /**
   * Encrypted defines whether your data in the cluster will be encrypted at rest or not. default=false
   *
   * @schema ClusterSpecForProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * EnhancedVPCRouting specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing (https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html) in the Amazon Redshift Cluster Management Guide. If this option is true, enhanced VPC routing is enabled. default=false
   *
   * @schema ClusterSpecForProvider#enhancedVPCRouting
   */
  readonly enhancedVpcRouting?: boolean;

  /**
   * FinalClusterSnapshotIdentifier is the identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, SkipFinalClusterSnapshot must be false. Constraints: * Must be 1 to 255 alphanumeric characters. * First character must be a letter. * Cannot end with a hyphen or contain two consecutive hyphens.
   *
   * @schema ClusterSpecForProvider#finalClusterSnapshotIdentifier
   */
  readonly finalClusterSnapshotIdentifier?: string;

  /**
   * FinalClusterSnapshotRetentionPeriod is the number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. The value must be either -1 or an integer between 1 and 3,653. default -1
   *
   * @schema ClusterSpecForProvider#finalClusterSnapshotRetentionPeriod
   */
  readonly finalClusterSnapshotRetentionPeriod?: number;

  /**
   * HSMClientCertificateIdentifier specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
   *
   * @schema ClusterSpecForProvider#hsmClientCertificateIdentifier
   */
  readonly hsmClientCertificateIdentifier?: string;

  /**
   * HSMConfigurationIdentifier specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
   *
   * @schema ClusterSpecForProvider#hsmConfigurationIdentifier
   */
  readonly hsmConfigurationIdentifier?: string;

  /**
   * IAMRoleRefs are references to IAMRoles used to set the IAMRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleRefs
   */
  readonly iamRoleRefs?: ClusterSpecForProviderIamRoleRefs[];

  /**
   * IAMRoleSelector selects references to IAMRoles used to set the IAMRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ClusterSpecForProviderIamRoleSelector;

  /**
   * IAMRoles is a list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request. A cluster can have up to 10 IAM roles associated with it at any time. kubebuilder:validation:MaxItems=10
   *
   * @schema ClusterSpecForProvider#iamRoles
   */
  readonly iamRoles?: string[];

  /**
   * KMSKeyID is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a cluster with the same AWS account that owns the KMS encryption key used to encrypt the new cluster, then you can use the KMS key alias instead of the ARN for the KM encryption key.
   *
   * @schema ClusterSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * MaintenanceTrackName an optional parameter for the name of the maintenance track for the cluster.
   *
   * @schema ClusterSpecForProvider#maintenanceTrackName
   */
  readonly maintenanceTrackName?: string;

  /**
   * ManualSnapshotRetentionPeriod is the default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. default=1
   *
   * @schema ClusterSpecForProvider#manualSnapshotRetentionPeriod
   */
  readonly manualSnapshotRetentionPeriod?: number;

  /**
   * MasterUsername is the user name associated with the master user account for the cluster that is being created. Constraints: * Must be 1 - 128 alphanumeric characters. The user name can't be PUBLIC. * First character must be a letter. * Cannot be a reserved word. A list of reserved words can be found in Reserved Words (https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide.
   *
   * @schema ClusterSpecForProvider#masterUsername
   */
  readonly masterUsername: string;

  /**
   * NewClusterIdentifier is the new identifier you want to use for the cluster.
   *
   * @schema ClusterSpecForProvider#newClusterIdentifier
   */
  readonly newClusterIdentifier?: string;

  /**
   * NewMasterUserPassword is the new password to be associated with the master user account for the cluster that has being created. Set this value if you want to change the existing password of the cluster. Constraints: * Must be between 8 and 64 characters in length. * Must contain at least one uppercase letter. * Must contain at least one lowercase letter. * Must contain one number. * Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.
   *
   * @schema ClusterSpecForProvider#newMasterUserPassword
   */
  readonly newMasterUserPassword?: string;

  /**
   * NodeType is the node type defining its size and compute capacity to be provisioned for the cluster. For information about node types, go to Working with Clusters (https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes) in the Amazon Redshift Cluster Management Guide.
   *
   * @schema ClusterSpecForProvider#nodeType
   */
  readonly nodeType: string;

  /**
   * NumberOfNodes defines the number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node. For information about determining how many nodes you need, go to Working with Clusters (https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes) in the Amazon Redshift Cluster Management Guide. If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster. default=1
   *
   * @schema ClusterSpecForProvider#numberOfNodes
   */
  readonly numberOfNodes?: number;

  /**
   * Port specifies the port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections. default=5439
   *
   * @schema ClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * PreferredMaintenanceWindow is the weekly time range (in UTC) during which automated cluster maintenance can occur. Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see Maintenance Windows (https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows) in Amazon Redshift Cluster Management Guide. Constraints: Minimum 30-minute window.
   *
   * @schema ClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * PubliclyAccessible is to specify if the cluster can be accessed from a public network.
   *
   * @schema ClusterSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like the Cluster to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * SkipFinalClusterSnapshot determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If true, a final cluster snapshot is not created. If false, a final cluster snapshot is created before the cluster is deleted. The FinalClusterSnapshotIdentifier parameter must be specified if SkipFinalClusterSnapshot is false. Default: false
   *
   * @schema ClusterSpecForProvider#skipFinalClusterSnapshot
   */
  readonly skipFinalClusterSnapshot?: boolean;

  /**
   * SnapshotScheduleIdentifier is a unique identifier for the snapshot schedule.
   *
   * @schema ClusterSpecForProvider#snapshotScheduleIdentifier
   */
  readonly snapshotScheduleIdentifier?: string;

  /**
   * Tags indicates a list of tags for the clusters.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: ClusterSpecForProviderTags[];

  /**
   * VPCSecurityGroupIDRefs are references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIDRefs
   */
  readonly vpcSecurityGroupIdRefs?: ClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIDSelector
   */
  readonly vpcSecurityGroupIdSelector?: ClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * VPCSecurityGroupIDs a list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowVersionUpgrade': obj.allowVersionUpgrade,
    'automatedSnapshotRetentionPeriod': obj.automatedSnapshotRetentionPeriod,
    'availabilityZone': obj.availabilityZone,
    'clusterParameterGroupName': obj.clusterParameterGroupName,
    'clusterSecurityGroupRefs': obj.clusterSecurityGroupRefs?.map(y => toJson_ClusterSpecForProviderClusterSecurityGroupRefs(y)),
    'clusterSecurityGroupSelector': toJson_ClusterSpecForProviderClusterSecurityGroupSelector(obj.clusterSecurityGroupSelector),
    'clusterSecurityGroups': obj.clusterSecurityGroups?.map(y => y),
    'clusterSubnetGroupName': obj.clusterSubnetGroupName,
    'clusterType': obj.clusterType,
    'clusterVersion': obj.clusterVersion,
    'dbName': obj.dbName,
    'elasticIP': obj.elasticIp,
    'encrypted': obj.encrypted,
    'enhancedVPCRouting': obj.enhancedVpcRouting,
    'finalClusterSnapshotIdentifier': obj.finalClusterSnapshotIdentifier,
    'finalClusterSnapshotRetentionPeriod': obj.finalClusterSnapshotRetentionPeriod,
    'hsmClientCertificateIdentifier': obj.hsmClientCertificateIdentifier,
    'hsmConfigurationIdentifier': obj.hsmConfigurationIdentifier,
    'iamRoleRefs': obj.iamRoleRefs?.map(y => toJson_ClusterSpecForProviderIamRoleRefs(y)),
    'iamRoleSelector': toJson_ClusterSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'iamRoles': obj.iamRoles?.map(y => y),
    'kmsKeyID': obj.kmsKeyId,
    'maintenanceTrackName': obj.maintenanceTrackName,
    'manualSnapshotRetentionPeriod': obj.manualSnapshotRetentionPeriod,
    'masterUsername': obj.masterUsername,
    'newClusterIdentifier': obj.newClusterIdentifier,
    'newMasterUserPassword': obj.newMasterUserPassword,
    'nodeType': obj.nodeType,
    'numberOfNodes': obj.numberOfNodes,
    'port': obj.port,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'skipFinalClusterSnapshot': obj.skipFinalClusterSnapshot,
    'snapshotScheduleIdentifier': obj.snapshotScheduleIdentifier,
    'tags': obj.tags?.map(y => toJson_ClusterSpecForProviderTags(y)),
    'vpcSecurityGroupIDRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIDSelector': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupRefs
 */
export interface ClusterSpecForProviderClusterSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupRefs#policy
   */
  readonly policy?: ClusterSpecForProviderClusterSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterSecurityGroupRefs(obj: ClusterSpecForProviderClusterSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderClusterSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSecurityGroupSelector selects references to ClusterSecurityGroups used to set the ClusterSecurityGroups.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupSelector
 */
export interface ClusterSpecForProviderClusterSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupSelector#policy
   */
  readonly policy?: ClusterSpecForProviderClusterSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterSecurityGroupSelector(obj: ClusterSpecForProviderClusterSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderClusterSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterType is the type of the cluster you want. When cluster type is specified as * single-node, the NumberOfNodes parameter is not required. * multi-node, the NumberOfNodes parameter is required. default=multi-node
 *
 * @schema ClusterSpecForProviderClusterType
 */
export enum ClusterSpecForProviderClusterType {
  /** multi-node */
  MULTI_HYPHEN_NODE = "multi-node",
  /** single-node */
  SINGLE_HYPHEN_NODE = "single-node",
}

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderIamRoleRefs
 */
export interface ClusterSpecForProviderIamRoleRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefs(obj: ClusterSpecForProviderIamRoleRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IAMRoleSelector selects references to IAMRoles used to set the IAMRoles.
 *
 * @schema ClusterSpecForProviderIamRoleSelector
 */
export interface ClusterSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelector(obj: ClusterSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag represetnt a key-pair metadata assigned to a Redshift Cluster
 *
 * @schema ClusterSpecForProviderTags
 */
export interface ClusterSpecForProviderTags {
  /**
   * The key of the tag.
   *
   * @schema ClusterSpecForProviderTags#tag
   */
  readonly tag: string;

  /**
   * The value of the tag.
   *
   * @schema ClusterSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderTags(obj: ClusterSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tag': obj.tag,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCSecurityGroupIDSelector selects references to VPCSecurityGroups used to set the VPCSecurityGroupIDs.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupRefsPolicy
 */
export interface ClusterSpecForProviderClusterSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterSecurityGroupRefsPolicy(obj: ClusterSpecForProviderClusterSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupSelectorPolicy
 */
export interface ClusterSpecForProviderClusterSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderClusterSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClusterSecurityGroupSelectorPolicy(obj: ClusterSpecForProviderClusterSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicy
 */
export interface ClusterSpecForProviderIamRoleRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj: ClusterSpecForProviderIamRoleRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicy
 */
export interface ClusterSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj: ClusterSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolution
 */
export enum ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolve
 */
export enum ClusterSpecForProviderClusterSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolution
 */
export enum ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolve
 */
export enum ClusterSpecForProviderClusterSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

