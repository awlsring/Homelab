// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ResolverEndpoint is the Schema for the ResolverEndpoints API
 *
 * @schema ResolverEndpoint
 */
export class ResolverEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResolverEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.crossplane.io/v1alpha1',
    kind: 'ResolverEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "ResolverEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResolverEndpointProps): any {
    return {
      ...ResolverEndpoint.GVK,
      ...toJson_ResolverEndpointProps(props),
    };
  }

  /**
   * Defines a "ResolverEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResolverEndpointProps) {
    super(scope, id, {
      ...ResolverEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResolverEndpoint.GVK,
      ...toJson_ResolverEndpointProps(resolved),
    };
  }
}

/**
 * ResolverEndpoint is the Schema for the ResolverEndpoints API
 *
 * @schema ResolverEndpoint
 */
export interface ResolverEndpointProps {
  /**
   * @schema ResolverEndpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverEndpointSpec defines the desired state of ResolverEndpoint
   *
   * @schema ResolverEndpoint#spec
   */
  readonly spec: ResolverEndpointSpec;

}

/**
 * Converts an object of type 'ResolverEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointProps(obj: ResolverEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverEndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverEndpointSpec defines the desired state of ResolverEndpoint
 *
 * @schema ResolverEndpointSpec
 */
export interface ResolverEndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverEndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverEndpointSpecDeletionPolicy;

  /**
   * ResolverEndpointParameters defines the desired state of ResolverEndpoint
   *
   * @schema ResolverEndpointSpec#forProvider
   */
  readonly forProvider: ResolverEndpointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResolverEndpointSpec#managementPolicies
   */
  readonly managementPolicies?: ResolverEndpointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResolverEndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverEndpointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResolverEndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverEndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResolverEndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverEndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverEndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpec(obj: ResolverEndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverEndpointSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResolverEndpointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResolverEndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverEndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverEndpointSpecDeletionPolicy
 */
export enum ResolverEndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ResolverEndpointParameters defines the desired state of ResolverEndpoint
 *
 * @schema ResolverEndpointSpecForProvider
 */
export interface ResolverEndpointSpecForProvider {
  /**
   * Specify the applicable value:
   * * INBOUND: Resolver forwards DNS queries to the DNS service for a VPC from your network
   * * OUTBOUND: Resolver forwards DNS queries from the DNS service for a VPC to your network
   *
   * @schema ResolverEndpointSpecForProvider#direction
   */
  readonly direction: string;

  /**
   * IPAddresses are the subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC.
   *
   * @schema ResolverEndpointSpecForProvider#ipAddresses
   */
  readonly ipAddresses: ResolverEndpointSpecForProviderIpAddresses[];

  /**
   * A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
   *
   * @schema ResolverEndpointSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
   *
   * @schema ResolverEndpointSpecForProvider#outpostARN
   */
  readonly outpostArn?: string;

  /**
   * The instance type. If you specify this, you must also specify a value for the OutpostArn.
   *
   * @schema ResolverEndpointSpecForProvider#preferredInstanceType
   */
  readonly preferredInstanceType?: string;

  /**
   * Region is which region the ResolverEndpoint will be created.
   *
   * @schema ResolverEndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * For the endpoint type you can choose either IPv4, IPv6, or dual-stack. A dual-stack endpoint means that it will resolve via both IPv4 and IPv6. This endpoint type is applied to all IP addresses.
   *
   * @schema ResolverEndpointSpecForProvider#resolverEndpointType
   */
  readonly resolverEndpointType?: string;

  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema ResolverEndpointSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: ResolverEndpointSpecForProviderSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema ResolverEndpointSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: ResolverEndpointSpecForProviderSecurityGroupIdSelector;

  /**
   * The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
   *
   * @schema ResolverEndpointSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of the tag keys and values that you want to associate with the endpoint.
   *
   * @schema ResolverEndpointSpecForProvider#tags
   */
  readonly tags?: ResolverEndpointSpecForProviderTags[];

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProvider(obj: ResolverEndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'ipAddresses': obj.ipAddresses?.map(y => toJson_ResolverEndpointSpecForProviderIpAddresses(y)),
    'name': obj.name,
    'outpostARN': obj.outpostArn,
    'preferredInstanceType': obj.preferredInstanceType,
    'region': obj.region,
    'resolverEndpointType': obj.resolverEndpointType,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_ResolverEndpointSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_ResolverEndpointSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'tags': obj.tags?.map(y => toJson_ResolverEndpointSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResolverEndpointSpecManagementPolicies
 */
export enum ResolverEndpointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResolverEndpointSpecProviderConfigRef
 */
export interface ResolverEndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverEndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverEndpointSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverEndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecProviderConfigRef(obj: ResolverEndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverEndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsTo
 */
export interface ResolverEndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverEndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverEndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverEndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecPublishConnectionDetailsTo(obj: ResolverEndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverEndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverEndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResolverEndpointSpecWriteConnectionSecretToRef
 */
export interface ResolverEndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverEndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverEndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverEndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecWriteConnectionSecretToRef(obj: ResolverEndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPAddressRequest is used by ResolverEndpoint
 *
 * @schema ResolverEndpointSpecForProviderIpAddresses
 */
export interface ResolverEndpointSpecForProviderIpAddresses {
  /**
   * IP address that you want to use for DNS queries.
   *
   * @schema ResolverEndpointSpecForProviderIpAddresses#ip
   */
  readonly ip?: string;

  /**
   * SubnetId is the ID of the subnet that contains the IP address.
   *
   * @schema ResolverEndpointSpecForProviderIpAddresses#subnetId
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema ResolverEndpointSpecForProviderIpAddresses#subnetIdRef
   */
  readonly subnetIdRef?: ResolverEndpointSpecForProviderIpAddressesSubnetIdRef;

  /**
   * SubnetIDSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema ResolverEndpointSpecForProviderIpAddresses#subnetIdSelector
   */
  readonly subnetIdSelector?: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderIpAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderIpAddresses(obj: ResolverEndpointSpecForProviderIpAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ip': obj.ip,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefs
 */
export interface ResolverEndpointSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderSecurityGroupIdRefs(obj: ResolverEndpointSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelector
 */
export interface ResolverEndpointSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderSecurityGroupIdSelector(obj: ResolverEndpointSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverEndpointSpecForProviderTags
 */
export interface ResolverEndpointSpecForProviderTags {
  /**
   * @schema ResolverEndpointSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ResolverEndpointSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderTags(obj: ResolverEndpointSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverEndpointSpecProviderConfigRefPolicy
 */
export interface ResolverEndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecProviderConfigRefPolicy(obj: ResolverEndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverEndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecPublishConnectionDetailsToConfigRef(obj: ResolverEndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverEndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverEndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecPublishConnectionDetailsToMetadata(obj: ResolverEndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRef
 */
export interface ResolverEndpointSpecForProviderIpAddressesSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRef#policy
   */
  readonly policy?: ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderIpAddressesSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdRef(obj: ResolverEndpointSpecForProviderIpAddressesSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector
 */
export interface ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector#policy
   */
  readonly policy?: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector(obj: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy(obj: ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj: ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecProviderConfigRefPolicyResolution
 */
export enum ResolverEndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecProviderConfigRefPolicyResolve
 */
export enum ResolverEndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy
 */
export interface ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy(obj: ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy
 */
export interface ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy(obj: ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum ResolverEndpointSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum ResolverEndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolution
 */
export enum ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolve
 */
export enum ResolverEndpointSpecForProviderIpAddressesSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolution
 */
export enum ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolve
 */
export enum ResolverEndpointSpecForProviderIpAddressesSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResolverRule is the Schema for the ResolverRules API
 *
 * @schema ResolverRule
 */
export class ResolverRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResolverRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.crossplane.io/v1alpha1',
    kind: 'ResolverRule',
  }

  /**
   * Renders a Kubernetes manifest for "ResolverRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResolverRuleProps): any {
    return {
      ...ResolverRule.GVK,
      ...toJson_ResolverRuleProps(props),
    };
  }

  /**
   * Defines a "ResolverRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResolverRuleProps) {
    super(scope, id, {
      ...ResolverRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResolverRule.GVK,
      ...toJson_ResolverRuleProps(resolved),
    };
  }
}

/**
 * ResolverRule is the Schema for the ResolverRules API
 *
 * @schema ResolverRule
 */
export interface ResolverRuleProps {
  /**
   * @schema ResolverRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverRuleSpec defines the desired state of ResolverRule
   *
   * @schema ResolverRule#spec
   */
  readonly spec: ResolverRuleSpec;

}

/**
 * Converts an object of type 'ResolverRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleProps(obj: ResolverRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverRuleSpec defines the desired state of ResolverRule
 *
 * @schema ResolverRuleSpec
 */
export interface ResolverRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverRuleSpecDeletionPolicy;

  /**
   * ResolverRuleParameters defines the desired state of ResolverRule
   *
   * @schema ResolverRuleSpec#forProvider
   */
  readonly forProvider: ResolverRuleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResolverRuleSpec#managementPolicies
   */
  readonly managementPolicies?: ResolverRuleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResolverRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverRuleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResolverRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResolverRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpec(obj: ResolverRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverRuleSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResolverRuleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResolverRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverRuleSpecDeletionPolicy
 */
export enum ResolverRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ResolverRuleParameters defines the desired state of ResolverRule
 *
 * @schema ResolverRuleSpecForProvider
 */
export interface ResolverRuleSpecForProvider {
  /**
   * DNS queries for this domain name are forwarded to the IP addresses that you specify in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains the most specific domain name (www.example.com).
   *
   * @schema ResolverRuleSpecForProvider#domainName
   */
  readonly domainName: string;

  /**
   * A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
   *
   * @schema ResolverRuleSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is which region the ResolverRule will be created.
   *
   * @schema ResolverRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
   *
   * @schema ResolverRuleSpecForProvider#resolverEndpointID
   */
  readonly resolverEndpointId?: string;

  /**
   * ResolverEndpointIDRef is the reference to the ResolverEndpoint used to set the ResolverEndpointID
   *
   * @schema ResolverRuleSpecForProvider#resolverEndpointIdRefs
   */
  readonly resolverEndpointIdRefs?: ResolverRuleSpecForProviderResolverEndpointIdRefs;

  /**
   * ResolverEndpointIDSelector selects references to ResolverEndpoint used to set the ResolverEndpointID
   *
   * @schema ResolverRuleSpecForProvider#resolverEndpointIdSelector
   */
  readonly resolverEndpointIdSelector?: ResolverRuleSpecForProviderResolverEndpointIdSelector;

  /**
   * When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD.
   * When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM.
   * For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType.
   * Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
   *
   * @schema ResolverRuleSpecForProvider#ruleType
   */
  readonly ruleType: string;

  /**
   * A list of the tag keys and values that you want to associate with the endpoint.
   *
   * @schema ResolverRuleSpecForProvider#tags
   */
  readonly tags?: ResolverRuleSpecForProviderTags[];

  /**
   * The IPs that you want Resolver to forward DNS queries to. You can specify either Ipv4 or Ipv6 addresses but not both in the same rule. Separate IP addresses with a space.
   * TargetIps is available only when the value of Rule type is FORWARD.
   *
   * @schema ResolverRuleSpecForProvider#targetIPs
   */
  readonly targetIPs?: ResolverRuleSpecForProviderTargetIPs[];

}

/**
 * Converts an object of type 'ResolverRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProvider(obj: ResolverRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'name': obj.name,
    'region': obj.region,
    'resolverEndpointID': obj.resolverEndpointId,
    'resolverEndpointIdRefs': toJson_ResolverRuleSpecForProviderResolverEndpointIdRefs(obj.resolverEndpointIdRefs),
    'resolverEndpointIdSelector': toJson_ResolverRuleSpecForProviderResolverEndpointIdSelector(obj.resolverEndpointIdSelector),
    'ruleType': obj.ruleType,
    'tags': obj.tags?.map(y => toJson_ResolverRuleSpecForProviderTags(y)),
    'targetIPs': obj.targetIPs?.map(y => toJson_ResolverRuleSpecForProviderTargetIPs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResolverRuleSpecManagementPolicies
 */
export enum ResolverRuleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResolverRuleSpecProviderConfigRef
 */
export interface ResolverRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecProviderConfigRef(obj: ResolverRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsTo
 */
export interface ResolverRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecPublishConnectionDetailsTo(obj: ResolverRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResolverRuleSpecWriteConnectionSecretToRef
 */
export interface ResolverRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecWriteConnectionSecretToRef(obj: ResolverRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverEndpointIDRef is the reference to the ResolverEndpoint used to set the ResolverEndpointID
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdRefs
 */
export interface ResolverRuleSpecForProviderResolverEndpointIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdRefs#policy
   */
  readonly policy?: ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderResolverEndpointIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderResolverEndpointIdRefs(obj: ResolverRuleSpecForProviderResolverEndpointIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverEndpointIDSelector selects references to ResolverEndpoint used to set the ResolverEndpointID
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdSelector
 */
export interface ResolverRuleSpecForProviderResolverEndpointIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdSelector#policy
   */
  readonly policy?: ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderResolverEndpointIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderResolverEndpointIdSelector(obj: ResolverRuleSpecForProviderResolverEndpointIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverRuleSpecForProviderTags
 */
export interface ResolverRuleSpecForProviderTags {
  /**
   * @schema ResolverRuleSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ResolverRuleSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderTags(obj: ResolverRuleSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverRuleSpecForProviderTargetIPs
 */
export interface ResolverRuleSpecForProviderTargetIPs {
  /**
   * @schema ResolverRuleSpecForProviderTargetIPs#ip
   */
  readonly ip?: string;

  /**
   * @schema ResolverRuleSpecForProviderTargetIPs#ipv6
   */
  readonly ipv6?: string;

  /**
   * @schema ResolverRuleSpecForProviderTargetIPs#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderTargetIPs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderTargetIPs(obj: ResolverRuleSpecForProviderTargetIPs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ip': obj.ip,
    'ipv6': obj.ipv6,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleSpecProviderConfigRefPolicy
 */
export interface ResolverRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecProviderConfigRefPolicy(obj: ResolverRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecPublishConnectionDetailsToConfigRef(obj: ResolverRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecPublishConnectionDetailsToMetadata(obj: ResolverRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy
 */
export interface ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy#resolution
   */
  readonly resolution?: ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy#resolve
   */
  readonly resolve?: ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy(obj: ResolverRuleSpecForProviderResolverEndpointIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy
 */
export interface ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy(obj: ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleSpecProviderConfigRefPolicyResolution
 */
export enum ResolverRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleSpecProviderConfigRefPolicyResolve
 */
export enum ResolverRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolution
 */
export enum ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolve
 */
export enum ResolverRuleSpecForProviderResolverEndpointIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolution
 */
export enum ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolve
 */
export enum ResolverRuleSpecForProviderResolverEndpointIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResolverRuleAssociation is a managed resource that represents an AWS Route53 ResolverRuleAssociation.
 *
 * @schema ResolverRuleAssociation
 */
export class ResolverRuleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResolverRuleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.crossplane.io/v1alpha1',
    kind: 'ResolverRuleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ResolverRuleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResolverRuleAssociationProps): any {
    return {
      ...ResolverRuleAssociation.GVK,
      ...toJson_ResolverRuleAssociationProps(props),
    };
  }

  /**
   * Defines a "ResolverRuleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResolverRuleAssociationProps) {
    super(scope, id, {
      ...ResolverRuleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResolverRuleAssociation.GVK,
      ...toJson_ResolverRuleAssociationProps(resolved),
    };
  }
}

/**
 * ResolverRuleAssociation is a managed resource that represents an AWS Route53 ResolverRuleAssociation.
 *
 * @schema ResolverRuleAssociation
 */
export interface ResolverRuleAssociationProps {
  /**
   * @schema ResolverRuleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverRuleAssociationSpec defines the desired state of an AWS Route53 Hosted ResolverRuleAssociation.
   *
   * @schema ResolverRuleAssociation#spec
   */
  readonly spec: ResolverRuleAssociationSpec;

}

/**
 * Converts an object of type 'ResolverRuleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationProps(obj: ResolverRuleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverRuleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverRuleAssociationSpec defines the desired state of an AWS Route53 Hosted ResolverRuleAssociation.
 *
 * @schema ResolverRuleAssociationSpec
 */
export interface ResolverRuleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverRuleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverRuleAssociationSpecDeletionPolicy;

  /**
   * ResolverRuleAssociationParameters define the desired state of an AWS Route53 Hosted ResolverRuleAssociation.
   *
   * @schema ResolverRuleAssociationSpec#forProvider
   */
  readonly forProvider: ResolverRuleAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResolverRuleAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: ResolverRuleAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResolverRuleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverRuleAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResolverRuleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverRuleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResolverRuleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverRuleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpec(obj: ResolverRuleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverRuleAssociationSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResolverRuleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResolverRuleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverRuleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverRuleAssociationSpecDeletionPolicy
 */
export enum ResolverRuleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ResolverRuleAssociationParameters define the desired state of an AWS Route53 Hosted ResolverRuleAssociation.
 *
 * @schema ResolverRuleAssociationSpecForProvider
 */
export interface ResolverRuleAssociationSpecForProvider {
  /**
   * Region is which region the Addon will be created.
   *
   * @schema ResolverRuleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use ListResolverRules (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html).
   *
   * @schema ResolverRuleAssociationSpecForProvider#resolverRuleId
   */
  readonly resolverRuleId?: string;

  /**
   * ResolverRuleIDRef is a reference to a ResolverRule used to set the ResolverRuleID.
   *
   * @schema ResolverRuleAssociationSpecForProvider#resolverRuleIdRef
   */
  readonly resolverRuleIdRef?: ResolverRuleAssociationSpecForProviderResolverRuleIdRef;

  /**
   * ResolverRuleIDSelector selects references to a ResolverRule used to set the ResolverRuleID.
   *
   * @schema ResolverRuleAssociationSpecForProvider#resolverRuleIdSelector
   */
  readonly resolverRuleIdSelector?: ResolverRuleAssociationSpecForProviderResolverRuleIdSelector;

  /**
   * The ID of the VPC that you want to associate the Resolver rule with.
   *
   * @schema ResolverRuleAssociationSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIdRef is a reference to a VPC used to set the VPCId.
   *
   * @schema ResolverRuleAssociationSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: ResolverRuleAssociationSpecForProviderVpcIdRef;

  /**
   * VPCIdSelector selects references to a VPC used to set the VPCId.
   *
   * @schema ResolverRuleAssociationSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: ResolverRuleAssociationSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProvider(obj: ResolverRuleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'resolverRuleId': obj.resolverRuleId,
    'resolverRuleIdRef': toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdRef(obj.resolverRuleIdRef),
    'resolverRuleIdSelector': toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdSelector(obj.resolverRuleIdSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ResolverRuleAssociationSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ResolverRuleAssociationSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResolverRuleAssociationSpecManagementPolicies
 */
export enum ResolverRuleAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResolverRuleAssociationSpecProviderConfigRef
 */
export interface ResolverRuleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverRuleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecProviderConfigRef(obj: ResolverRuleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsTo
 */
export interface ResolverRuleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecPublishConnectionDetailsTo(obj: ResolverRuleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResolverRuleAssociationSpecWriteConnectionSecretToRef
 */
export interface ResolverRuleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverRuleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverRuleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecWriteConnectionSecretToRef(obj: ResolverRuleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverRuleIDRef is a reference to a ResolverRule used to set the ResolverRuleID.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRef
 */
export interface ResolverRuleAssociationSpecForProviderResolverRuleIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRef#policy
   */
  readonly policy?: ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderResolverRuleIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdRef(obj: ResolverRuleAssociationSpecForProviderResolverRuleIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverRuleIDSelector selects references to a ResolverRule used to set the ResolverRuleID.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelector
 */
export interface ResolverRuleAssociationSpecForProviderResolverRuleIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelector#policy
   */
  readonly policy?: ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderResolverRuleIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdSelector(obj: ResolverRuleAssociationSpecForProviderResolverRuleIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIdRef is a reference to a VPC used to set the VPCId.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdRef
 */
export interface ResolverRuleAssociationSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdRef#policy
   */
  readonly policy?: ResolverRuleAssociationSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderVpcIdRef(obj: ResolverRuleAssociationSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleAssociationSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIdSelector selects references to a VPC used to set the VPCId.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdSelector
 */
export interface ResolverRuleAssociationSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderVpcIdSelector(obj: ResolverRuleAssociationSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleAssociationSpecProviderConfigRefPolicy
 */
export interface ResolverRuleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecProviderConfigRefPolicy(obj: ResolverRuleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef(obj: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata(obj: ResolverRuleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy
 */
export interface ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy(obj: ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy
 */
export interface ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy(obj: ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdRefPolicy
 */
export interface ResolverRuleAssociationSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderVpcIdRefPolicy(obj: ResolverRuleAssociationSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy
 */
export interface ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy(obj: ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ResolverRuleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ResolverRuleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution
 */
export enum ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve
 */
export enum ResolverRuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution
 */
export enum ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve
 */
export enum ResolverRuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolution
 */
export enum ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolve
 */
export enum ResolverRuleAssociationSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum ResolverRuleAssociationSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverRuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

